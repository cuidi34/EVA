(lp0
(iArchitecture
Architecture
p1
(dp2
S'clusters'
p3
(lp4
(iArchitecture
Cluster
p5
(dp6
S'entities'
p7
(lp8
(iArchitecture
Entity
p9
(dp10
S'issue_ids'
p11
(lp12
sS'name'
p13
S'com.google.common.annotations.GwtIncompatible'
p14
sS'descs'
p15
(lp16
sS'labels'
p17
(lp18
sS'titles'
p19
(lp20
sS'change'
p21
I0
sba(iArchitecture
Entity
p22
(dp23
g11
(lp24
V339
p25
aV2037
p26
asg13
S'com.google.common.base.Absent'
p27
sg15
(lp28
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p29
aVUncorrect hashCode() implementation at com.google.common.base.Absent and com.google.common.base.Present - for example if hashCode() of reference at Present return 0 then it hashCode() equal Absent.\u000a\u000aexample: Optional.absent() has same hash code as Optional.of(0.0) or Optional.of(0)\u000a
p30
asg17
(lp31
(lp32
I1
aa(lp33
I0
aasg19
(lp34
VConcurrency bug in AbstractMultimap
p35
aVOptional.hashCode()
p36
asg21
I0
sba(iArchitecture
Entity
p37
(dp38
g11
(lp39
sg13
S'com.google.common.base.AbstractIterator'
p40
sg15
(lp41
sg17
(lp42
sg19
(lp43
sg21
I0
sba(iArchitecture
Entity
p44
(dp45
g11
(lp46
sg13
S'com.google.common.base.AbstractIterator$1'
p47
sg15
(lp48
sg17
(lp49
sg19
(lp50
sg21
I0
sba(iArchitecture
Entity
p51
(dp52
g11
(lp53
sg13
S'com.google.common.base.AbstractIterator$State'
p54
sg15
(lp55
sg17
(lp56
sg19
(lp57
sg21
I0
sba(iArchitecture
Entity
p58
(dp59
g11
(lp60
sg13
S'com.google.common.base.Ascii'
p61
sg15
(lp62
sg17
(lp63
sg19
(lp64
sg21
I0
sba(iArchitecture
Entity
p65
(dp66
g11
(lp67
sg13
S'com.google.common.base.CaseFormat'
p68
sg15
(lp69
sg17
(lp70
sg19
(lp71
sg21
I0
sba(iArchitecture
Entity
p72
(dp73
g11
(lp74
sg13
S'com.google.common.base.CaseFormat$1'
p75
sg15
(lp76
sg17
(lp77
sg19
(lp78
sg21
I0
sba(iArchitecture
Entity
p79
(dp80
g11
(lp81
sg13
S'com.google.common.base.CaseFormat$2'
p82
sg15
(lp83
sg17
(lp84
sg19
(lp85
sg21
I0
sba(iArchitecture
Entity
p86
(dp87
g11
(lp88
sg13
S'com.google.common.base.CaseFormat$3'
p89
sg15
(lp90
sg17
(lp91
sg19
(lp92
sg21
I0
sba(iArchitecture
Entity
p93
(dp94
g11
(lp95
sg13
S'com.google.common.base.CaseFormat$4'
p96
sg15
(lp97
sg17
(lp98
sg19
(lp99
sg21
I0
sba(iArchitecture
Entity
p100
(dp101
g11
(lp102
sg13
S'com.google.common.base.CaseFormat$5'
p103
sg15
(lp104
sg17
(lp105
sg19
(lp106
sg21
I0
sba(iArchitecture
Entity
p107
(dp108
g11
(lp109
sg13
S'com.google.common.base.CaseFormat$StringConverter'
p110
sg15
(lp111
sg17
(lp112
sg19
(lp113
sg21
I0
sba(iArchitecture
Entity
p114
(dp115
g11
(lp116
g25
aV2410
p117
asg13
S'com.google.common.base.CharMatcher'
p118
sg15
(lp119
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p120
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p121
asg17
(lp122
g32
a(lp123
I2
aasg19
(lp124
g35
aVCharMatcher.matchesNoneOf JavaDoc is incorrect
p125
asg21
I0
sba(iArchitecture
Entity
p126
(dp127
g11
(lp128
g25
ag117
asg13
S'com.google.common.base.CharMatcher$1'
p129
sg15
(lp130
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p131
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p132
asg17
(lp133
g32
ag123
asg19
(lp134
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p135
(dp136
g11
(lp137
g25
ag117
asg13
S'com.google.common.base.CharMatcher$10'
p138
sg15
(lp139
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p140
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p141
asg17
(lp142
g32
ag123
asg19
(lp143
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p144
(dp145
g11
(lp146
g25
ag117
asg13
S'com.google.common.base.CharMatcher$11'
p147
sg15
(lp148
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p149
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p150
asg17
(lp151
g32
ag123
asg19
(lp152
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p153
(dp154
g11
(lp155
g25
ag117
asg13
S'com.google.common.base.CharMatcher$12'
p156
sg15
(lp157
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p158
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p159
asg17
(lp160
g32
ag123
asg19
(lp161
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p162
(dp163
g11
(lp164
g25
ag117
asg13
S'com.google.common.base.CharMatcher$13'
p165
sg15
(lp166
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p167
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p168
asg17
(lp169
g32
ag123
asg19
(lp170
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p171
(dp172
g11
(lp173
g25
ag117
asg13
S'com.google.common.base.CharMatcher$14'
p174
sg15
(lp175
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p176
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p177
asg17
(lp178
g32
ag123
asg19
(lp179
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p180
(dp181
g11
(lp182
g25
ag117
asg13
S'com.google.common.base.CharMatcher$15'
p183
sg15
(lp184
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p185
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p186
asg17
(lp187
g32
ag123
asg19
(lp188
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p189
(dp190
g11
(lp191
g25
ag117
asg13
S'com.google.common.base.CharMatcher$2'
p192
sg15
(lp193
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p194
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p195
asg17
(lp196
g32
ag123
asg19
(lp197
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p198
(dp199
g11
(lp200
g25
ag117
asg13
S'com.google.common.base.CharMatcher$3'
p201
sg15
(lp202
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p203
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p204
asg17
(lp205
g32
ag123
asg19
(lp206
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p207
(dp208
g11
(lp209
g25
ag117
asg13
S'com.google.common.base.CharMatcher$4'
p210
sg15
(lp211
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p212
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p213
asg17
(lp214
g32
ag123
asg19
(lp215
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p216
(dp217
g11
(lp218
g25
ag117
asg13
S'com.google.common.base.CharMatcher$5'
p219
sg15
(lp220
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p221
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p222
asg17
(lp223
g32
ag123
asg19
(lp224
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p225
(dp226
g11
(lp227
g25
ag117
asg13
S'com.google.common.base.CharMatcher$6'
p228
sg15
(lp229
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p230
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p231
asg17
(lp232
g32
ag123
asg19
(lp233
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p234
(dp235
g11
(lp236
g25
ag117
asg13
S'com.google.common.base.CharMatcher$7'
p237
sg15
(lp238
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p239
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p240
asg17
(lp241
g32
ag123
asg19
(lp242
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p243
(dp244
g11
(lp245
g25
ag117
asg13
S'com.google.common.base.CharMatcher$8'
p246
sg15
(lp247
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p248
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p249
asg17
(lp250
g32
ag123
asg19
(lp251
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p252
(dp253
g11
(lp254
g25
ag117
asg13
S'com.google.common.base.CharMatcher$9'
p255
sg15
(lp256
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p257
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p258
asg17
(lp259
g32
ag123
asg19
(lp260
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p261
(dp262
g11
(lp263
g25
ag117
asg13
S'com.google.common.base.CharMatcher$And'
p264
sg15
(lp265
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p266
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p267
asg17
(lp268
g32
ag123
asg19
(lp269
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p270
(dp271
g11
(lp272
g25
ag117
asg13
S'com.google.common.base.CharMatcher$BitSetMatcher'
p273
sg15
(lp274
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p275
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p276
asg17
(lp277
g32
ag123
asg19
(lp278
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p279
(dp280
g11
(lp281
g25
ag117
asg13
S'com.google.common.base.CharMatcher$FastMatcher'
p282
sg15
(lp283
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p284
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p285
asg17
(lp286
g32
ag123
asg19
(lp287
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p288
(dp289
g11
(lp290
g25
ag117
asg13
S'com.google.common.base.CharMatcher$NegatedFastMatcher'
p291
sg15
(lp292
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p293
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p294
asg17
(lp295
g32
ag123
asg19
(lp296
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p297
(dp298
g11
(lp299
g25
ag117
asg13
S'com.google.common.base.CharMatcher$NegatedMatcher'
p300
sg15
(lp301
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p302
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p303
asg17
(lp304
g32
ag123
asg19
(lp305
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p306
(dp307
g11
(lp308
g25
ag117
asg13
S'com.google.common.base.CharMatcher$Or'
p309
sg15
(lp310
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p311
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p312
asg17
(lp313
g32
ag123
asg19
(lp314
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p315
(dp316
g11
(lp317
g25
ag117
asg13
S'com.google.common.base.CharMatcher$RangesMatcher'
p318
sg15
(lp319
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p320
aVThe second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: "The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached."  This should be "until this returns true or the end is reached".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\u000a\u000aSimilarly, the "returns" section currently says: "true if this matcher matches every character in the sequence, including when the sequence is empty" (same as `matchesAllOf`). It should say something like "true if this matches matches no character in the sequence, including when the sequence is empty".\u000a
p321
asg17
(lp322
g32
ag123
asg19
(lp323
g35
ag125
asg21
I0
sba(iArchitecture
Entity
p324
(dp325
g11
(lp326
g25
asg13
S'com.google.common.base.Converter'
p327
sg15
(lp328
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p329
asg17
(lp330
g32
asg19
(lp331
g35
asg21
I0
sba(iArchitecture
Entity
p332
(dp333
g11
(lp334
g25
asg13
S'com.google.common.base.Converter$1'
p335
sg15
(lp336
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p337
asg17
(lp338
g32
asg19
(lp339
g35
asg21
I0
sba(iArchitecture
Entity
p340
(dp341
g11
(lp342
g25
asg13
S'com.google.common.base.Converter$1$1'
p343
sg15
(lp344
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p345
asg17
(lp346
g32
asg19
(lp347
g35
asg21
I0
sba(iArchitecture
Entity
p348
(dp349
g11
(lp350
g25
asg13
S'com.google.common.base.Converter$ConverterComposition'
p351
sg15
(lp352
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p353
asg17
(lp354
g32
asg19
(lp355
g35
asg21
I0
sba(iArchitecture
Entity
p356
(dp357
g11
(lp358
g25
asg13
S'com.google.common.base.Converter$FunctionBasedConverter'
p359
sg15
(lp360
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p361
asg17
(lp362
g32
asg19
(lp363
g35
asg21
I0
sba(iArchitecture
Entity
p364
(dp365
g11
(lp366
g25
asg13
S'com.google.common.base.Converter$IdentityConverter'
p367
sg15
(lp368
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p369
asg17
(lp370
g32
asg19
(lp371
g35
asg21
I0
sba(iArchitecture
Entity
p372
(dp373
g11
(lp374
g25
asg13
S'com.google.common.base.Converter$ReverseConverter'
p375
sg15
(lp376
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p377
asg17
(lp378
g32
asg19
(lp379
g35
asg21
I0
sba(iArchitecture
Entity
p380
(dp381
g11
(lp382
sg13
S'com.google.common.base.Enums'
p383
sg15
(lp384
sg17
(lp385
sg19
(lp386
sg21
I0
sba(iArchitecture
Entity
p387
(dp388
g11
(lp389
sg13
S'com.google.common.base.Enums$StringConverter'
p390
sg15
(lp391
sg17
(lp392
sg19
(lp393
sg21
I0
sba(iArchitecture
Entity
p394
(dp395
g11
(lp396
g25
asg13
S'com.google.common.base.Equivalence'
p397
sg15
(lp398
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p399
asg17
(lp400
g32
asg19
(lp401
g35
asg21
I0
sba(iArchitecture
Entity
p402
(dp403
g11
(lp404
g25
asg13
S'com.google.common.base.Equivalence$1'
p405
sg15
(lp406
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p407
asg17
(lp408
g32
asg19
(lp409
g35
asg21
I0
sba(iArchitecture
Entity
p410
(dp411
g11
(lp412
g25
asg13
S'com.google.common.base.Equivalence$Equals'
p413
sg15
(lp414
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p415
asg17
(lp416
g32
asg19
(lp417
g35
asg21
I0
sba(iArchitecture
Entity
p418
(dp419
g11
(lp420
g25
asg13
S'com.google.common.base.Equivalence$EquivalentToPredicate'
p421
sg15
(lp422
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p423
asg17
(lp424
g32
asg19
(lp425
g35
asg21
I0
sba(iArchitecture
Entity
p426
(dp427
g11
(lp428
g25
asg13
S'com.google.common.base.Equivalence$Identity'
p429
sg15
(lp430
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p431
asg17
(lp432
g32
asg19
(lp433
g35
asg21
I0
sba(iArchitecture
Entity
p434
(dp435
g11
(lp436
g25
asg13
S'com.google.common.base.Equivalence$Wrapper'
p437
sg15
(lp438
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p439
asg17
(lp440
g32
asg19
(lp441
g35
asg21
I0
sba(iArchitecture
Entity
p442
(dp443
g11
(lp444
sg13
S'com.google.common.base.FinalizablePhantomReference'
p445
sg15
(lp446
sg17
(lp447
sg19
(lp448
sg21
I0
sba(iArchitecture
Entity
p449
(dp450
g11
(lp451
sg13
S'com.google.common.base.FinalizableReference'
p452
sg15
(lp453
sg17
(lp454
sg19
(lp455
sg21
I0
sba(iArchitecture
Entity
p456
(dp457
g11
(lp458
sg13
S'com.google.common.base.FinalizableReferenceQueue'
p459
sg15
(lp460
sg17
(lp461
sg19
(lp462
sg21
I0
sba(iArchitecture
Entity
p463
(dp464
g11
(lp465
sg13
S'com.google.common.base.FinalizableReferenceQueue$DecoupledLoader'
p466
sg15
(lp467
sg17
(lp468
sg19
(lp469
sg21
I0
sba(iArchitecture
Entity
p470
(dp471
g11
(lp472
sg13
S'com.google.common.base.FinalizableReferenceQueue$DirectLoader'
p473
sg15
(lp474
sg17
(lp475
sg19
(lp476
sg21
I0
sba(iArchitecture
Entity
p477
(dp478
g11
(lp479
sg13
S'com.google.common.base.FinalizableReferenceQueue$FinalizerLoader'
p480
sg15
(lp481
sg17
(lp482
sg19
(lp483
sg21
I0
sba(iArchitecture
Entity
p484
(dp485
g11
(lp486
sg13
S'com.google.common.base.FinalizableReferenceQueue$SystemLoader'
p487
sg15
(lp488
sg17
(lp489
sg19
(lp490
sg21
I0
sba(iArchitecture
Entity
p491
(dp492
g11
(lp493
sg13
S'com.google.common.base.FinalizableSoftReference'
p494
sg15
(lp495
sg17
(lp496
sg19
(lp497
sg21
I0
sba(iArchitecture
Entity
p498
(dp499
g11
(lp500
sg13
S'com.google.common.base.FinalizableWeakReference'
p501
sg15
(lp502
sg17
(lp503
sg19
(lp504
sg21
I0
sba(iArchitecture
Entity
p505
(dp506
g11
(lp507
sg13
S'com.google.common.base.Function'
p508
sg15
(lp509
sg17
(lp510
sg19
(lp511
sg21
I0
sba(iArchitecture
Entity
p512
(dp513
g11
(lp514
sg13
S'com.google.common.base.FunctionalEquivalence'
p515
sg15
(lp516
sg17
(lp517
sg19
(lp518
sg21
I0
sba(iArchitecture
Entity
p519
(dp520
g11
(lp521
sg13
S'com.google.common.base.Functions'
p522
sg15
(lp523
sg17
(lp524
sg19
(lp525
sg21
I0
sba(iArchitecture
Entity
p526
(dp527
g11
(lp528
sg13
S'com.google.common.base.Functions$1'
p529
sg15
(lp530
sg17
(lp531
sg19
(lp532
sg21
I0
sba(iArchitecture
Entity
p533
(dp534
g11
(lp535
sg13
S'com.google.common.base.Functions$ConstantFunction'
p536
sg15
(lp537
sg17
(lp538
sg19
(lp539
sg21
I0
sba(iArchitecture
Entity
p540
(dp541
g11
(lp542
sg13
S'com.google.common.base.Functions$ForMapWithDefault'
p543
sg15
(lp544
sg17
(lp545
sg19
(lp546
sg21
I0
sba(iArchitecture
Entity
p547
(dp548
g11
(lp549
sg13
S'com.google.common.base.Functions$FunctionComposition'
p550
sg15
(lp551
sg17
(lp552
sg19
(lp553
sg21
I0
sba(iArchitecture
Entity
p554
(dp555
g11
(lp556
sg13
S'com.google.common.base.Functions$FunctionForMapNoDefault'
p557
sg15
(lp558
sg17
(lp559
sg19
(lp560
sg21
I0
sba(iArchitecture
Entity
p561
(dp562
g11
(lp563
sg13
S'com.google.common.base.Functions$IdentityFunction'
p564
sg15
(lp565
sg17
(lp566
sg19
(lp567
sg21
I0
sba(iArchitecture
Entity
p568
(dp569
g11
(lp570
sg13
S'com.google.common.base.Functions$PredicateFunction'
p571
sg15
(lp572
sg17
(lp573
sg19
(lp574
sg21
I0
sba(iArchitecture
Entity
p575
(dp576
g11
(lp577
sg13
S'com.google.common.base.Functions$SupplierFunction'
p578
sg15
(lp579
sg17
(lp580
sg19
(lp581
sg21
I0
sba(iArchitecture
Entity
p582
(dp583
g11
(lp584
sg13
S'com.google.common.base.Functions$ToStringFunction'
p585
sg15
(lp586
sg17
(lp587
sg19
(lp588
sg21
I0
sba(iArchitecture
Entity
p589
(dp590
g11
(lp591
sg13
S'com.google.common.base.Joiner'
p592
sg15
(lp593
sg17
(lp594
sg19
(lp595
sg21
I0
sba(iArchitecture
Entity
p596
(dp597
g11
(lp598
sg13
S'com.google.common.base.Joiner$1'
p599
sg15
(lp600
sg17
(lp601
sg19
(lp602
sg21
I0
sba(iArchitecture
Entity
p603
(dp604
g11
(lp605
sg13
S'com.google.common.base.Joiner$2'
p606
sg15
(lp607
sg17
(lp608
sg19
(lp609
sg21
I0
sba(iArchitecture
Entity
p610
(dp611
g11
(lp612
sg13
S'com.google.common.base.Joiner$3'
p613
sg15
(lp614
sg17
(lp615
sg19
(lp616
sg21
I0
sba(iArchitecture
Entity
p617
(dp618
g11
(lp619
sg13
S'com.google.common.base.Joiner$MapJoiner'
p620
sg15
(lp621
sg17
(lp622
sg19
(lp623
sg21
I0
sba(iArchitecture
Entity
p624
(dp625
g11
(lp626
V1125
p627
asg13
S'com.google.common.base.MoreObjects'
p628
sg15
(lp629
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1125) created by **adrianshum** on 2012-08-29 at 03:06 AM_\u000a\u000a---\u000a\u000aCurrently there is no handling for arrays in helpers in Objects, e.g. toStringHelper and Object.equal.\u000a\u000aThat means, I cannot do\u000aObjects.toStringHelper(getClass())\u000a&nbsp;&nbsp;&nbsp;&nbsp;.add("foo", this.foo)\u000a&nbsp;&nbsp;&nbsp;&nbsp;.add("anArray", this.anArray)\u000a&nbsp;&nbsp;&nbsp;&nbsp;.toString();\u000a\u000a(I know I can change it to add("anArray", Arrays.toString(this.anArray)) but it looks bad)\u000a\u000aSame for Objects.equal, when I am overriding equals(), I cannot do:\u000areturn Objects.equal("foo", other.foo) \u000a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&& Objects.equals("anArray", other.anArray);\u000a\u000aI believe adding corresponding overloads should not be difficult, and it makes the API much easier to use.\u000a
p630
asg17
(lp631
(lp632
I0
aasg19
(lp633
VArray handling in Objects#toStringHelper
p634
asg21
I0
sba(iArchitecture
Entity
p635
(dp636
g11
(lp637
g627
asg13
S'com.google.common.base.MoreObjects$1'
p638
sg15
(lp639
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1125) created by **adrianshum** on 2012-08-29 at 03:06 AM_\u000a\u000a---\u000a\u000aCurrently there is no handling for arrays in helpers in Objects, e.g. toStringHelper and Object.equal.\u000a\u000aThat means, I cannot do\u000aObjects.toStringHelper(getClass())\u000a&nbsp;&nbsp;&nbsp;&nbsp;.add("foo", this.foo)\u000a&nbsp;&nbsp;&nbsp;&nbsp;.add("anArray", this.anArray)\u000a&nbsp;&nbsp;&nbsp;&nbsp;.toString();\u000a\u000a(I know I can change it to add("anArray", Arrays.toString(this.anArray)) but it looks bad)\u000a\u000aSame for Objects.equal, when I am overriding equals(), I cannot do:\u000areturn Objects.equal("foo", other.foo) \u000a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&& Objects.equals("anArray", other.anArray);\u000a\u000aI believe adding corresponding overloads should not be difficult, and it makes the API much easier to use.\u000a
p640
asg17
(lp641
g632
asg19
(lp642
g634
asg21
I0
sba(iArchitecture
Entity
p643
(dp644
g11
(lp645
g627
asg13
S'com.google.common.base.MoreObjects$ToStringHelper'
p646
sg15
(lp647
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1125) created by **adrianshum** on 2012-08-29 at 03:06 AM_\u000a\u000a---\u000a\u000aCurrently there is no handling for arrays in helpers in Objects, e.g. toStringHelper and Object.equal.\u000a\u000aThat means, I cannot do\u000aObjects.toStringHelper(getClass())\u000a&nbsp;&nbsp;&nbsp;&nbsp;.add("foo", this.foo)\u000a&nbsp;&nbsp;&nbsp;&nbsp;.add("anArray", this.anArray)\u000a&nbsp;&nbsp;&nbsp;&nbsp;.toString();\u000a\u000a(I know I can change it to add("anArray", Arrays.toString(this.anArray)) but it looks bad)\u000a\u000aSame for Objects.equal, when I am overriding equals(), I cannot do:\u000areturn Objects.equal("foo", other.foo) \u000a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&& Objects.equals("anArray", other.anArray);\u000a\u000aI believe adding corresponding overloads should not be difficult, and it makes the API much easier to use.\u000a
p648
asg17
(lp649
g632
asg19
(lp650
g634
asg21
I0
sba(iArchitecture
Entity
p651
(dp652
g11
(lp653
g627
asg13
S'com.google.common.base.MoreObjects$ToStringHelper$ValueHolder'
p654
sg15
(lp655
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1125) created by **adrianshum** on 2012-08-29 at 03:06 AM_\u000a\u000a---\u000a\u000aCurrently there is no handling for arrays in helpers in Objects, e.g. toStringHelper and Object.equal.\u000a\u000aThat means, I cannot do\u000aObjects.toStringHelper(getClass())\u000a&nbsp;&nbsp;&nbsp;&nbsp;.add("foo", this.foo)\u000a&nbsp;&nbsp;&nbsp;&nbsp;.add("anArray", this.anArray)\u000a&nbsp;&nbsp;&nbsp;&nbsp;.toString();\u000a\u000a(I know I can change it to add("anArray", Arrays.toString(this.anArray)) but it looks bad)\u000a\u000aSame for Objects.equal, when I am overriding equals(), I cannot do:\u000areturn Objects.equal("foo", other.foo) \u000a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&& Objects.equals("anArray", other.anArray);\u000a\u000aI believe adding corresponding overloads should not be difficult, and it makes the API much easier to use.\u000a
p656
asg17
(lp657
g632
asg19
(lp658
g634
asg21
I0
sba(iArchitecture
Entity
p659
(dp660
g11
(lp661
sg13
S'com.google.common.base.Objects'
p662
sg15
(lp663
sg17
(lp664
sg19
(lp665
sg21
I0
sba(iArchitecture
Entity
p666
(dp667
g11
(lp668
sg13
S'com.google.common.base.Objects$1'
p669
sg15
(lp670
sg17
(lp671
sg19
(lp672
sg21
I0
sba(iArchitecture
Entity
p673
(dp674
g11
(lp675
sg13
S'com.google.common.base.Objects$ToStringHelper'
p676
sg15
(lp677
sg17
(lp678
sg19
(lp679
sg21
I0
sba(iArchitecture
Entity
p680
(dp681
g11
(lp682
sg13
S'com.google.common.base.Objects$ToStringHelper$ValueHolder'
p683
sg15
(lp684
sg17
(lp685
sg19
(lp686
sg21
I0
sba(iArchitecture
Entity
p687
(dp688
g11
(lp689
g26
ag26
asg13
S'com.google.common.base.Optional'
p690
sg15
(lp691
VUncorrect hashCode() implementation at com.google.common.base.Absent and com.google.common.base.Present - for example if hashCode() of reference at Present return 0 then it hashCode() equal Absent.\u000a\u000aexample: Optional.absent() has same hash code as Optional.of(0.0) or Optional.of(0)\u000a
p692
aVUncorrect hashCode() implementation at com.google.common.base.Absent and com.google.common.base.Present - for example if hashCode() of reference at Present return 0 then it hashCode() equal Absent.\u000a\u000aexample: Optional.absent() has same hash code as Optional.of(0.0) or Optional.of(0)\u000a
p693
asg17
(lp694
g33
ag33
asg19
(lp695
g36
ag36
asg21
I0
sba(iArchitecture
Entity
p696
(dp697
g11
(lp698
g26
ag26
asg13
S'com.google.common.base.Optional$1'
p699
sg15
(lp700
VUncorrect hashCode() implementation at com.google.common.base.Absent and com.google.common.base.Present - for example if hashCode() of reference at Present return 0 then it hashCode() equal Absent.\u000a\u000aexample: Optional.absent() has same hash code as Optional.of(0.0) or Optional.of(0)\u000a
p701
aVUncorrect hashCode() implementation at com.google.common.base.Absent and com.google.common.base.Present - for example if hashCode() of reference at Present return 0 then it hashCode() equal Absent.\u000a\u000aexample: Optional.absent() has same hash code as Optional.of(0.0) or Optional.of(0)\u000a
p702
asg17
(lp703
g33
ag33
asg19
(lp704
g36
ag36
asg21
I0
sba(iArchitecture
Entity
p705
(dp706
g11
(lp707
g26
ag26
asg13
S'com.google.common.base.Optional$1$1'
p708
sg15
(lp709
VUncorrect hashCode() implementation at com.google.common.base.Absent and com.google.common.base.Present - for example if hashCode() of reference at Present return 0 then it hashCode() equal Absent.\u000a\u000aexample: Optional.absent() has same hash code as Optional.of(0.0) or Optional.of(0)\u000a
p710
aVUncorrect hashCode() implementation at com.google.common.base.Absent and com.google.common.base.Present - for example if hashCode() of reference at Present return 0 then it hashCode() equal Absent.\u000a\u000aexample: Optional.absent() has same hash code as Optional.of(0.0) or Optional.of(0)\u000a
p711
asg17
(lp712
g33
ag33
asg19
(lp713
g36
ag36
asg21
I0
sba(iArchitecture
Entity
p714
(dp715
g11
(lp716
sg13
S'com.google.common.base.PairwiseEquivalence'
p717
sg15
(lp718
sg17
(lp719
sg19
(lp720
sg21
I0
sba(iArchitecture
Entity
p721
(dp722
g11
(lp723
V2365
p724
ag724
asg13
S'com.google.common.base.Platform'
p725
sg15
(lp726
VNot a high priority. I just feel a little bad that users there would get something like "com.google.common.base.Stopwatch@0xdeadbeef".\u000a
p727
aVNot a high priority. I just feel a little bad that users there would get something like "com.google.common.base.Stopwatch@0xdeadbeef".\u000a
p728
asg17
(lp729
(lp730
I1
aag730
asg19
(lp731
VImplement Stopwatch.toString() under GWT
p732
ag732
asg21
I0
sba(iArchitecture
Entity
p733
(dp734
g11
(lp735
V1444
p736
ag736
asg13
S'com.google.common.base.Predicate'
p737
sg15
(lp738
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p739
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p740
asg17
(lp741
(lp742
I1
aag742
asg19
(lp743
VPredicates.assignableFrom is named backward, and its doc is backward, too
p744
ag744
asg21
I0
sba(iArchitecture
Entity
p745
(dp746
g11
(lp747
g736
ag736
asg13
S'com.google.common.base.Predicates'
p748
sg15
(lp749
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p750
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p751
asg17
(lp752
g742
ag742
asg19
(lp753
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p754
(dp755
g11
(lp756
g736
ag736
asg13
S'com.google.common.base.Predicates$1'
p757
sg15
(lp758
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p759
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p760
asg17
(lp761
g742
ag742
asg19
(lp762
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p763
(dp764
g11
(lp765
g736
ag736
asg13
S'com.google.common.base.Predicates$AndPredicate'
p766
sg15
(lp767
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p768
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p769
asg17
(lp770
g742
ag742
asg19
(lp771
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p772
(dp773
g11
(lp774
g736
ag736
asg13
S'com.google.common.base.Predicates$AssignableFromPredicate'
p775
sg15
(lp776
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p777
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p778
asg17
(lp779
g742
ag742
asg19
(lp780
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p781
(dp782
g11
(lp783
g736
ag736
asg13
S'com.google.common.base.Predicates$CompositionPredicate'
p784
sg15
(lp785
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p786
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p787
asg17
(lp788
g742
ag742
asg19
(lp789
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p790
(dp791
g11
(lp792
g736
ag736
asg13
S'com.google.common.base.Predicates$ContainsPatternFromStringPredicate'
p793
sg15
(lp794
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p795
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p796
asg17
(lp797
g742
ag742
asg19
(lp798
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p799
(dp800
g11
(lp801
g736
ag736
asg13
S'com.google.common.base.Predicates$ContainsPatternPredicate'
p802
sg15
(lp803
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p804
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p805
asg17
(lp806
g742
ag742
asg19
(lp807
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p808
(dp809
g11
(lp810
g736
ag736
asg13
S'com.google.common.base.Predicates$InPredicate'
p811
sg15
(lp812
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p813
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p814
asg17
(lp815
g742
ag742
asg19
(lp816
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p817
(dp818
g11
(lp819
g736
ag736
asg13
S'com.google.common.base.Predicates$InstanceOfPredicate'
p820
sg15
(lp821
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p822
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p823
asg17
(lp824
g742
ag742
asg19
(lp825
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p826
(dp827
g11
(lp828
g736
ag736
asg13
S'com.google.common.base.Predicates$IsEqualToPredicate'
p829
sg15
(lp830
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p831
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p832
asg17
(lp833
g742
ag742
asg19
(lp834
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p835
(dp836
g11
(lp837
g736
ag736
asg13
S'com.google.common.base.Predicates$NotPredicate'
p838
sg15
(lp839
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p840
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p841
asg17
(lp842
g742
ag742
asg19
(lp843
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p844
(dp845
g11
(lp846
g736
ag736
asg13
S'com.google.common.base.Predicates$ObjectPredicate'
p847
sg15
(lp848
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p849
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p850
asg17
(lp851
g742
ag742
asg19
(lp852
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p853
(dp854
g11
(lp855
g736
ag736
asg13
S'com.google.common.base.Predicates$ObjectPredicate$1'
p856
sg15
(lp857
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p858
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p859
asg17
(lp860
g742
ag742
asg19
(lp861
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p862
(dp863
g11
(lp864
g736
ag736
asg13
S'com.google.common.base.Predicates$ObjectPredicate$2'
p865
sg15
(lp866
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p867
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p868
asg17
(lp869
g742
ag742
asg19
(lp870
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p871
(dp872
g11
(lp873
g736
ag736
asg13
S'com.google.common.base.Predicates$ObjectPredicate$3'
p874
sg15
(lp875
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p876
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p877
asg17
(lp878
g742
ag742
asg19
(lp879
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p880
(dp881
g11
(lp882
g736
ag736
asg13
S'com.google.common.base.Predicates$ObjectPredicate$4'
p883
sg15
(lp884
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p885
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p886
asg17
(lp887
g742
ag742
asg19
(lp888
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p889
(dp890
g11
(lp891
g736
ag736
asg13
S'com.google.common.base.Predicates$OrPredicate'
p892
sg15
(lp893
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p894
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1444) created by **cpovirk@google.com** on 2013-06-11 at 09:49 PM_\u000a\u000a---\u000a\u000aJust as we've inverted Class.isInstance to Predicates.instanceOf, we ought to have inverted Class.isAssignableFrom to Predicates.assignableTo.\u000a\u000aAnd the doc says: "true if the class being tested is assignable from the given class"\ufeff\u000ahttps://google.github.io/guava/apidocs/com/google/common/base/Predicates.html#assignableFrom(java.lang.Class)\u000a\u000aBut it's the other way around.\u000a
p895
asg17
(lp896
g742
ag742
asg19
(lp897
g744
ag744
asg21
I0
sba(iArchitecture
Entity
p898
(dp899
g11
(lp900
sg13
S'com.google.common.base.Present'
p901
sg15
(lp902
sg17
(lp903
sg19
(lp904
sg21
I0
sba(iArchitecture
Entity
p905
(dp906
g11
(lp907
sg13
S'com.google.common.base.SmallCharMatcher'
p908
sg15
(lp909
sg17
(lp910
sg19
(lp911
sg21
I0
sba(iArchitecture
Entity
p912
(dp913
g11
(lp914
sg13
S'com.google.common.base.Splitter'
p915
sg15
(lp916
sg17
(lp917
sg19
(lp918
sg21
I0
sba(iArchitecture
Entity
p919
(dp920
g11
(lp921
sg13
S'com.google.common.base.Splitter$1'
p922
sg15
(lp923
sg17
(lp924
sg19
(lp925
sg21
I0
sba(iArchitecture
Entity
p926
(dp927
g11
(lp928
sg13
S'com.google.common.base.Splitter$1$1'
p929
sg15
(lp930
sg17
(lp931
sg19
(lp932
sg21
I0
sba(iArchitecture
Entity
p933
(dp934
g11
(lp935
sg13
S'com.google.common.base.Splitter$2'
p936
sg15
(lp937
sg17
(lp938
sg19
(lp939
sg21
I0
sba(iArchitecture
Entity
p940
(dp941
g11
(lp942
sg13
S'com.google.common.base.Splitter$2$1'
p943
sg15
(lp944
sg17
(lp945
sg19
(lp946
sg21
I0
sba(iArchitecture
Entity
p947
(dp948
g11
(lp949
sg13
S'com.google.common.base.Splitter$3'
p950
sg15
(lp951
sg17
(lp952
sg19
(lp953
sg21
I0
sba(iArchitecture
Entity
p954
(dp955
g11
(lp956
sg13
S'com.google.common.base.Splitter$3$1'
p957
sg15
(lp958
sg17
(lp959
sg19
(lp960
sg21
I0
sba(iArchitecture
Entity
p961
(dp962
g11
(lp963
sg13
S'com.google.common.base.Splitter$4'
p964
sg15
(lp965
sg17
(lp966
sg19
(lp967
sg21
I0
sba(iArchitecture
Entity
p968
(dp969
g11
(lp970
sg13
S'com.google.common.base.Splitter$4$1'
p971
sg15
(lp972
sg17
(lp973
sg19
(lp974
sg21
I0
sba(iArchitecture
Entity
p975
(dp976
g11
(lp977
sg13
S'com.google.common.base.Splitter$5'
p978
sg15
(lp979
sg17
(lp980
sg19
(lp981
sg21
I0
sba(iArchitecture
Entity
p982
(dp983
g11
(lp984
sg13
S'com.google.common.base.Splitter$MapSplitter'
p985
sg15
(lp986
sg17
(lp987
sg19
(lp988
sg21
I0
sba(iArchitecture
Entity
p989
(dp990
g11
(lp991
sg13
S'com.google.common.base.Splitter$SplittingIterator'
p992
sg15
(lp993
sg17
(lp994
sg19
(lp995
sg21
I0
sba(iArchitecture
Entity
p996
(dp997
g11
(lp998
sg13
S'com.google.common.base.Splitter$Strategy'
p999
sg15
(lp1000
sg17
(lp1001
sg19
(lp1002
sg21
I0
sba(iArchitecture
Entity
p1003
(dp1004
g11
(lp1005
sg13
S'com.google.common.base.StandardSystemProperty'
p1006
sg15
(lp1007
sg17
(lp1008
sg19
(lp1009
sg21
I0
sba(iArchitecture
Entity
p1010
(dp1011
g11
(lp1012
g724
ag724
ag724
aV2039
p1013
ag1013
ag1013
aV1567
p1014
aV1312
p1015
ag1015
asg13
S'com.google.common.base.Stopwatch'
p1016
sg15
(lp1017
VNot a high priority. I just feel a little bad that users there would get something like "com.google.common.base.Stopwatch@0xdeadbeef".\u000a
p1018
aVNot a high priority. I just feel a little bad that users there would get something like "com.google.common.base.Stopwatch@0xdeadbeef".\u000a
p1019
aVNot a high priority. I just feel a little bad that users there would get something like "com.google.common.base.Stopwatch@0xdeadbeef".\u000a
p1020
aVHello, I was reading through the set of tests at https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java , and I noticed there are two tests that appear to do the same thing - testElapsed_millis() and testElapsedMillis(). Is this expected? Could one test perhaps be an old test under a different naming convention? From the history it looks like they were added independently.\u000a\u000aThe contribution guide recommends creating an issue as the first step, so I thought I would ask.\u000a\u000aGitHub suggests that both functions are only called from guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java . Would it be appropriate to create a pull request to remove one of the tests? (Or of course, feel free to simply remove one yourself if the workflow is easier; I just wanted to ask)\u000a\u000aCheers!\u000a
p1021
aVHello, I was reading through the set of tests at https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java , and I noticed there are two tests that appear to do the same thing - testElapsed_millis() and testElapsedMillis(). Is this expected? Could one test perhaps be an old test under a different naming convention? From the history it looks like they were added independently.\u000a\u000aThe contribution guide recommends creating an issue as the first step, so I thought I would ask.\u000a\u000aGitHub suggests that both functions are only called from guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java . Would it be appropriate to create a pull request to remove one of the tests? (Or of course, feel free to simply remove one yourself if the workflow is easier; I just wanted to ask)\u000a\u000aCheers!\u000a
p1022
aVHello, I was reading through the set of tests at https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java , and I noticed there are two tests that appear to do the same thing - testElapsed_millis() and testElapsedMillis(). Is this expected? Could one test perhaps be an old test under a different naming convention? From the history it looks like they were added independently.\u000a\u000aThe contribution guide recommends creating an issue as the first step, so I thought I would ask.\u000a\u000aGitHub suggests that both functions are only called from guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java . Would it be appropriate to create a pull request to remove one of the tests? (Or of course, feel free to simply remove one yourself if the workflow is easier; I just wanted to ask)\u000a\u000aCheers!\u000a
p1023
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1024
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1312) created by **vgal...@tennaxia.com** on 2013-02-28 at 01:05 PM_\u000a\u000a---\u000a\u000aHello,\u000a\u000aIt would be great if Stopwatch could be promoted in next release.\u000a\u000aThank you\u000a\u000avictor\u000a
p1025
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1312) created by **vgal...@tennaxia.com** on 2013-02-28 at 01:05 PM_\u000a\u000a---\u000a\u000aHello,\u000a\u000aIt would be great if Stopwatch could be promoted in next release.\u000a\u000aThank you\u000a\u000avictor\u000a
p1026
asg17
(lp1027
g730
ag730
ag730
a(lp1028
I6
aag1028
ag1028
a(lp1029
I1
aa(lp1030
I7
aag1030
asg19
(lp1031
g732
ag732
ag732
aVPossible duplicate tests? - testElapsed_millis() and testElapsedMillis()
p1032
ag1032
ag1032
aVRunning tests in a non-US locale might fail
p1033
aVDe-@Beta Stopwatch
p1034
ag1034
asg21
I0
sba(iArchitecture
Entity
p1035
(dp1036
g11
(lp1037
g724
ag724
ag724
ag1013
ag1013
ag1013
ag1014
ag1015
ag1015
asg13
S'com.google.common.base.Stopwatch$1'
p1038
sg15
(lp1039
VNot a high priority. I just feel a little bad that users there would get something like "com.google.common.base.Stopwatch@0xdeadbeef".\u000a
p1040
aVNot a high priority. I just feel a little bad that users there would get something like "com.google.common.base.Stopwatch@0xdeadbeef".\u000a
p1041
aVNot a high priority. I just feel a little bad that users there would get something like "com.google.common.base.Stopwatch@0xdeadbeef".\u000a
p1042
aVHello, I was reading through the set of tests at https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java , and I noticed there are two tests that appear to do the same thing - testElapsed_millis() and testElapsedMillis(). Is this expected? Could one test perhaps be an old test under a different naming convention? From the history it looks like they were added independently.\u000a\u000aThe contribution guide recommends creating an issue as the first step, so I thought I would ask.\u000a\u000aGitHub suggests that both functions are only called from guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java . Would it be appropriate to create a pull request to remove one of the tests? (Or of course, feel free to simply remove one yourself if the workflow is easier; I just wanted to ask)\u000a\u000aCheers!\u000a
p1043
aVHello, I was reading through the set of tests at https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java , and I noticed there are two tests that appear to do the same thing - testElapsed_millis() and testElapsedMillis(). Is this expected? Could one test perhaps be an old test under a different naming convention? From the history it looks like they were added independently.\u000a\u000aThe contribution guide recommends creating an issue as the first step, so I thought I would ask.\u000a\u000aGitHub suggests that both functions are only called from guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java . Would it be appropriate to create a pull request to remove one of the tests? (Or of course, feel free to simply remove one yourself if the workflow is easier; I just wanted to ask)\u000a\u000aCheers!\u000a
p1044
aVHello, I was reading through the set of tests at https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java , and I noticed there are two tests that appear to do the same thing - testElapsed_millis() and testElapsedMillis(). Is this expected? Could one test perhaps be an old test under a different naming convention? From the history it looks like they were added independently.\u000a\u000aThe contribution guide recommends creating an issue as the first step, so I thought I would ask.\u000a\u000aGitHub suggests that both functions are only called from guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java . Would it be appropriate to create a pull request to remove one of the tests? (Or of course, feel free to simply remove one yourself if the workflow is easier; I just wanted to ask)\u000a\u000aCheers!\u000a
p1045
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1046
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1312) created by **vgal...@tennaxia.com** on 2013-02-28 at 01:05 PM_\u000a\u000a---\u000a\u000aHello,\u000a\u000aIt would be great if Stopwatch could be promoted in next release.\u000a\u000aThank you\u000a\u000avictor\u000a
p1047
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1312) created by **vgal...@tennaxia.com** on 2013-02-28 at 01:05 PM_\u000a\u000a---\u000a\u000aHello,\u000a\u000aIt would be great if Stopwatch could be promoted in next release.\u000a\u000aThank you\u000a\u000avictor\u000a
p1048
asg17
(lp1049
g730
ag730
ag730
ag1028
ag1028
ag1028
ag1029
ag1030
ag1030
asg19
(lp1050
g732
ag732
ag732
ag1032
ag1032
ag1032
ag1033
ag1034
ag1034
asg21
I0
sba(iArchitecture
Entity
p1051
(dp1052
g11
(lp1053
sg13
S'com.google.common.base.Suppliers'
p1054
sg15
(lp1055
sg17
(lp1056
sg19
(lp1057
sg21
I0
sba(iArchitecture
Entity
p1058
(dp1059
g11
(lp1060
sg13
S'com.google.common.base.Suppliers$ExpiringMemoizingSupplier'
p1061
sg15
(lp1062
sg17
(lp1063
sg19
(lp1064
sg21
I0
sba(iArchitecture
Entity
p1065
(dp1066
g11
(lp1067
sg13
S'com.google.common.base.Suppliers$MemoizingSupplier'
p1068
sg15
(lp1069
sg17
(lp1070
sg19
(lp1071
sg21
I0
sba(iArchitecture
Entity
p1072
(dp1073
g11
(lp1074
sg13
S'com.google.common.base.Suppliers$SupplierComposition'
p1075
sg15
(lp1076
sg17
(lp1077
sg19
(lp1078
sg21
I0
sba(iArchitecture
Entity
p1079
(dp1080
g11
(lp1081
sg13
S'com.google.common.base.Suppliers$SupplierFunction'
p1082
sg15
(lp1083
sg17
(lp1084
sg19
(lp1085
sg21
I0
sba(iArchitecture
Entity
p1086
(dp1087
g11
(lp1088
sg13
S'com.google.common.base.Suppliers$SupplierFunctionImpl'
p1089
sg15
(lp1090
sg17
(lp1091
sg19
(lp1092
sg21
I0
sba(iArchitecture
Entity
p1093
(dp1094
g11
(lp1095
sg13
S'com.google.common.base.Suppliers$SupplierOfInstance'
p1096
sg15
(lp1097
sg17
(lp1098
sg19
(lp1099
sg21
I0
sba(iArchitecture
Entity
p1100
(dp1101
g11
(lp1102
sg13
S'com.google.common.base.Suppliers$ThreadSafeSupplier'
p1103
sg15
(lp1104
sg17
(lp1105
sg19
(lp1106
sg21
I0
sba(iArchitecture
Entity
p1107
(dp1108
g11
(lp1109
sg13
S'com.google.common.base.Ticker'
p1110
sg15
(lp1111
sg17
(lp1112
sg19
(lp1113
sg21
I0
sba(iArchitecture
Entity
p1114
(dp1115
g11
(lp1116
sg13
S'com.google.common.base.Ticker$1'
p1117
sg15
(lp1118
sg17
(lp1119
sg19
(lp1120
sg21
I0
sba(iArchitecture
Entity
p1121
(dp1122
g11
(lp1123
sg13
S'com.google.common.base.Verify'
p1124
sg15
(lp1125
sg17
(lp1126
sg19
(lp1127
sg21
I0
sba(iArchitecture
Entity
p1128
(dp1129
g11
(lp1130
sg13
S'com.google.common.base.VerifyException'
p1131
sg15
(lp1132
sg17
(lp1133
sg19
(lp1134
sg21
I0
sbasS'classes'
p1135
(lp1136
g14
ag27
ag40
ag47
ag54
ag61
ag68
ag75
ag82
ag89
ag96
ag103
ag110
ag118
ag129
ag138
ag147
ag156
ag165
ag174
ag183
ag192
ag201
ag210
ag219
ag228
ag237
ag246
ag255
ag264
ag273
ag282
ag291
ag300
ag309
ag318
ag327
ag335
ag343
ag351
ag359
ag367
ag375
ag383
ag390
ag397
ag405
ag413
ag421
ag429
ag437
ag445
ag452
ag459
ag466
ag473
ag480
ag487
ag494
ag501
ag508
ag515
ag522
ag529
ag536
ag543
ag550
ag557
ag564
ag571
ag578
ag585
ag592
ag599
ag606
ag613
ag620
ag628
ag638
ag646
ag654
ag662
ag669
ag676
ag683
ag690
ag699
ag708
ag717
ag725
ag737
ag748
ag757
ag766
ag775
ag784
ag793
ag802
ag811
ag820
ag829
ag838
ag847
ag856
ag865
ag874
ag883
ag892
ag901
ag908
ag915
ag922
ag929
ag936
ag943
ag950
ag957
ag964
ag971
ag978
ag985
ag992
ag999
ag1006
ag1016
ag1038
ag1054
ag1061
ag1068
ag1075
ag1082
ag1089
ag1096
ag1103
ag1110
ag1117
ag1124
ag1131
asS'sorting_num'
p1137
I0
sg21
I0
sS'label'
p1138
S'com.google.common.base.ss'
p1139
sba(iArchitecture
Cluster
p1140
(dp1141
g7
(lp1142
(iArchitecture
Entity
p1143
(dp1144
g11
(lp1145
sg13
S'com.google.common.base.Defaults'
p1146
sg15
(lp1147
sg17
(lp1148
sg19
(lp1149
sg21
I0
sba(iArchitecture
Entity
p1150
(dp1151
g11
(lp1152
sg13
S'com.google.common.base.Preconditions'
p1153
sg15
(lp1154
sg17
(lp1155
sg19
(lp1156
sg21
I0
sba(iArchitecture
Entity
p1157
(dp1158
g11
(lp1159
sg13
S'com.google.common.base.Utf8'
p1160
sg15
(lp1161
sg17
(lp1162
sg19
(lp1163
sg21
I0
sba(iArchitecture
Entity
p1164
(dp1165
g11
(lp1166
sg13
S'com.google.common.cache.AbstractCache'
p1167
sg15
(lp1168
sg17
(lp1169
sg19
(lp1170
sg21
I0
sba(iArchitecture
Entity
p1171
(dp1172
g11
(lp1173
sg13
S'com.google.common.cache.AbstractCache$SimpleStatsCounter'
p1174
sg15
(lp1175
sg17
(lp1176
sg19
(lp1177
sg21
I0
sba(iArchitecture
Entity
p1178
(dp1179
g11
(lp1180
sg13
S'com.google.common.cache.AbstractCache$StatsCounter'
p1181
sg15
(lp1182
sg17
(lp1183
sg19
(lp1184
sg21
I0
sba(iArchitecture
Entity
p1185
(dp1186
g11
(lp1187
g25
ag25
ag1014
aV2178
p1188
aV2101
p1189
asg13
S'com.google.common.cache.Cache'
p1190
sg15
(lp1191
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p1192
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p1193
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1194
aVAs a novice of using Cache I think its statistic activation should be documented in the API of stats().\u000a\u000aFirst: recordStats() is to be isssued.\u000aSecond: stats() can not be instantiated because it is a factory for a final statistic.\u000a
p1195
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1196
asg17
(lp1197
g32
ag32
ag1029
a(lp1198
I2
aa(lp1199
I1
aasg19
(lp1200
g35
ag35
ag1033
aVCache.stats usage should be documented better
p1201
aVWrong RemovalCause published on cache.invaldateAll()
p1202
asg21
I0
sba(iArchitecture
Entity
p1203
(dp1204
g11
(lp1205
g1014
asg13
S'com.google.common.cache.CacheBuilder'
p1206
sg15
(lp1207
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1208
asg17
(lp1209
g1029
asg19
(lp1210
g1033
asg21
I0
sba(iArchitecture
Entity
p1211
(dp1212
g11
(lp1213
g1014
asg13
S'com.google.common.cache.CacheBuilder$1'
p1214
sg15
(lp1215
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1216
asg17
(lp1217
g1029
asg19
(lp1218
g1033
asg21
I0
sba(iArchitecture
Entity
p1219
(dp1220
g11
(lp1221
g1014
asg13
S'com.google.common.cache.CacheBuilder$2'
p1222
sg15
(lp1223
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1224
asg17
(lp1225
g1029
asg19
(lp1226
g1033
asg21
I0
sba(iArchitecture
Entity
p1227
(dp1228
g11
(lp1229
g1014
asg13
S'com.google.common.cache.CacheBuilder$3'
p1230
sg15
(lp1231
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1232
asg17
(lp1233
g1029
asg19
(lp1234
g1033
asg21
I0
sba(iArchitecture
Entity
p1235
(dp1236
g11
(lp1237
g1014
asg13
S'com.google.common.cache.CacheBuilder$NullListener'
p1238
sg15
(lp1239
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1240
asg17
(lp1241
g1029
asg19
(lp1242
g1033
asg21
I0
sba(iArchitecture
Entity
p1243
(dp1244
g11
(lp1245
g1014
asg13
S'com.google.common.cache.CacheBuilder$OneWeigher'
p1246
sg15
(lp1247
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1248
asg17
(lp1249
g1029
asg19
(lp1250
g1033
asg21
I0
sba(iArchitecture
Entity
p1251
(dp1252
g11
(lp1253
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec'
p1254
sg15
(lp1255
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1256
asg17
(lp1257
g1029
asg19
(lp1258
g1033
asg21
I0
sba(iArchitecture
Entity
p1259
(dp1260
g11
(lp1261
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$1'
p1262
sg15
(lp1263
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1264
asg17
(lp1265
g1029
asg19
(lp1266
g1033
asg21
I0
sba(iArchitecture
Entity
p1267
(dp1268
g11
(lp1269
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$AccessDurationParser'
p1270
sg15
(lp1271
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1272
asg17
(lp1273
g1029
asg19
(lp1274
g1033
asg21
I0
sba(iArchitecture
Entity
p1275
(dp1276
g11
(lp1277
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$ConcurrencyLevelParser'
p1278
sg15
(lp1279
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1280
asg17
(lp1281
g1029
asg19
(lp1282
g1033
asg21
I0
sba(iArchitecture
Entity
p1283
(dp1284
g11
(lp1285
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$DurationParser'
p1286
sg15
(lp1287
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1288
asg17
(lp1289
g1029
asg19
(lp1290
g1033
asg21
I0
sba(iArchitecture
Entity
p1291
(dp1292
g11
(lp1293
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$InitialCapacityParser'
p1294
sg15
(lp1295
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1296
asg17
(lp1297
g1029
asg19
(lp1298
g1033
asg21
I0
sba(iArchitecture
Entity
p1299
(dp1300
g11
(lp1301
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$IntegerParser'
p1302
sg15
(lp1303
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1304
asg17
(lp1305
g1029
asg19
(lp1306
g1033
asg21
I0
sba(iArchitecture
Entity
p1307
(dp1308
g11
(lp1309
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$KeyStrengthParser'
p1310
sg15
(lp1311
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1312
asg17
(lp1313
g1029
asg19
(lp1314
g1033
asg21
I0
sba(iArchitecture
Entity
p1315
(dp1316
g11
(lp1317
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$LongParser'
p1318
sg15
(lp1319
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1320
asg17
(lp1321
g1029
asg19
(lp1322
g1033
asg21
I0
sba(iArchitecture
Entity
p1323
(dp1324
g11
(lp1325
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$MaximumSizeParser'
p1326
sg15
(lp1327
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1328
asg17
(lp1329
g1029
asg19
(lp1330
g1033
asg21
I0
sba(iArchitecture
Entity
p1331
(dp1332
g11
(lp1333
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$MaximumWeightParser'
p1334
sg15
(lp1335
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1336
asg17
(lp1337
g1029
asg19
(lp1338
g1033
asg21
I0
sba(iArchitecture
Entity
p1339
(dp1340
g11
(lp1341
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$RecordStatsParser'
p1342
sg15
(lp1343
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1344
asg17
(lp1345
g1029
asg19
(lp1346
g1033
asg21
I0
sba(iArchitecture
Entity
p1347
(dp1348
g11
(lp1349
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$RefreshDurationParser'
p1350
sg15
(lp1351
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1352
asg17
(lp1353
g1029
asg19
(lp1354
g1033
asg21
I0
sba(iArchitecture
Entity
p1355
(dp1356
g11
(lp1357
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$ValueParser'
p1358
sg15
(lp1359
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1360
asg17
(lp1361
g1029
asg19
(lp1362
g1033
asg21
I0
sba(iArchitecture
Entity
p1363
(dp1364
g11
(lp1365
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$ValueStrengthParser'
p1366
sg15
(lp1367
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1368
asg17
(lp1369
g1029
asg19
(lp1370
g1033
asg21
I0
sba(iArchitecture
Entity
p1371
(dp1372
g11
(lp1373
g1014
asg13
S'com.google.common.cache.CacheBuilderSpec$WriteDurationParser'
p1374
sg15
(lp1375
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p1376
asg17
(lp1377
g1029
asg19
(lp1378
g1033
asg21
I0
sba(iArchitecture
Entity
p1379
(dp1380
g11
(lp1381
sg13
S'com.google.common.cache.CacheLoader'
p1382
sg15
(lp1383
sg17
(lp1384
sg19
(lp1385
sg21
I0
sba(iArchitecture
Entity
p1386
(dp1387
g11
(lp1388
sg13
S'com.google.common.cache.CacheLoader$1'
p1389
sg15
(lp1390
sg17
(lp1391
sg19
(lp1392
sg21
I0
sba(iArchitecture
Entity
p1393
(dp1394
g11
(lp1395
sg13
S'com.google.common.cache.CacheLoader$1$1'
p1396
sg15
(lp1397
sg17
(lp1398
sg19
(lp1399
sg21
I0
sba(iArchitecture
Entity
p1400
(dp1401
g11
(lp1402
sg13
S'com.google.common.cache.CacheLoader$FunctionToCacheLoader'
p1403
sg15
(lp1404
sg17
(lp1405
sg19
(lp1406
sg21
I0
sba(iArchitecture
Entity
p1407
(dp1408
g11
(lp1409
sg13
S'com.google.common.cache.CacheLoader$InvalidCacheLoadException'
p1410
sg15
(lp1411
sg17
(lp1412
sg19
(lp1413
sg21
I0
sba(iArchitecture
Entity
p1414
(dp1415
g11
(lp1416
sg13
S'com.google.common.cache.CacheLoader$SupplierToCacheLoader'
p1417
sg15
(lp1418
sg17
(lp1419
sg19
(lp1420
sg21
I0
sba(iArchitecture
Entity
p1421
(dp1422
g11
(lp1423
sg13
S'com.google.common.cache.CacheLoader$UnsupportedLoadingOperationException'
p1424
sg15
(lp1425
sg17
(lp1426
sg19
(lp1427
sg21
I0
sba(iArchitecture
Entity
p1428
(dp1429
g11
(lp1430
sg13
S'com.google.common.cache.CacheStats'
p1431
sg15
(lp1432
sg17
(lp1433
sg19
(lp1434
sg21
I0
sba(iArchitecture
Entity
p1435
(dp1436
g11
(lp1437
sg13
S'com.google.common.cache.ForwardingCache'
p1438
sg15
(lp1439
sg17
(lp1440
sg19
(lp1441
sg21
I0
sba(iArchitecture
Entity
p1442
(dp1443
g11
(lp1444
sg13
S'com.google.common.cache.ForwardingCache$SimpleForwardingCache'
p1445
sg15
(lp1446
sg17
(lp1447
sg19
(lp1448
sg21
I0
sba(iArchitecture
Entity
p1449
(dp1450
g11
(lp1451
sg13
S'com.google.common.cache.ForwardingLoadingCache'
p1452
sg15
(lp1453
sg17
(lp1454
sg19
(lp1455
sg21
I0
sba(iArchitecture
Entity
p1456
(dp1457
g11
(lp1458
sg13
S'com.google.common.cache.ForwardingLoadingCache$SimpleForwardingLoadingCache'
p1459
sg15
(lp1460
sg17
(lp1461
sg19
(lp1462
sg21
I0
sba(iArchitecture
Entity
p1463
(dp1464
g11
(lp1465
sg13
S'com.google.common.cache.LoadingCache'
p1466
sg15
(lp1467
sg17
(lp1468
sg19
(lp1469
sg21
I0
sba(iArchitecture
Entity
p1470
(dp1471
g11
(lp1472
V2108
p1473
ag1189
asg13
S'com.google.common.cache.LocalCache'
p1474
sg15
(lp1475
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1476
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1477
asg17
(lp1478
(lp1479
I1
aag1199
asg19
(lp1480
VCache.asMap().size() may return a negative value
p1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1482
(dp1483
g11
(lp1484
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$1'
p1485
sg15
(lp1486
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1487
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1488
asg17
(lp1489
g1479
ag1199
asg19
(lp1490
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1491
(dp1492
g11
(lp1493
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$2'
p1494
sg15
(lp1495
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1496
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1497
asg17
(lp1498
g1479
ag1199
asg19
(lp1499
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1500
(dp1501
g11
(lp1502
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$AbstractCacheSet'
p1503
sg15
(lp1504
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1505
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1506
asg17
(lp1507
g1479
ag1199
asg19
(lp1508
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1509
(dp1510
g11
(lp1511
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$AbstractReferenceEntry'
p1512
sg15
(lp1513
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1514
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1515
asg17
(lp1516
g1479
ag1199
asg19
(lp1517
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1518
(dp1519
g11
(lp1520
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$AccessQueue'
p1521
sg15
(lp1522
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1523
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1524
asg17
(lp1525
g1479
ag1199
asg19
(lp1526
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1527
(dp1528
g11
(lp1529
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$AccessQueue$1'
p1530
sg15
(lp1531
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1532
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1533
asg17
(lp1534
g1479
ag1199
asg19
(lp1535
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1536
(dp1537
g11
(lp1538
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$AccessQueue$2'
p1539
sg15
(lp1540
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1541
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1542
asg17
(lp1543
g1479
ag1199
asg19
(lp1544
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1545
(dp1546
g11
(lp1547
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntryFactory'
p1548
sg15
(lp1549
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1550
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1551
asg17
(lp1552
g1479
ag1199
asg19
(lp1553
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1554
(dp1555
g11
(lp1556
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntryFactory$1'
p1557
sg15
(lp1558
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1559
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1560
asg17
(lp1561
g1479
ag1199
asg19
(lp1562
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1563
(dp1564
g11
(lp1565
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntryFactory$2'
p1566
sg15
(lp1567
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1568
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1569
asg17
(lp1570
g1479
ag1199
asg19
(lp1571
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1572
(dp1573
g11
(lp1574
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntryFactory$3'
p1575
sg15
(lp1576
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1577
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1578
asg17
(lp1579
g1479
ag1199
asg19
(lp1580
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1581
(dp1582
g11
(lp1583
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntryFactory$4'
p1584
sg15
(lp1585
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1586
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1587
asg17
(lp1588
g1479
ag1199
asg19
(lp1589
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1590
(dp1591
g11
(lp1592
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntryFactory$5'
p1593
sg15
(lp1594
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1595
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1596
asg17
(lp1597
g1479
ag1199
asg19
(lp1598
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1599
(dp1600
g11
(lp1601
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntryFactory$6'
p1602
sg15
(lp1603
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1604
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1605
asg17
(lp1606
g1479
ag1199
asg19
(lp1607
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1608
(dp1609
g11
(lp1610
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntryFactory$7'
p1611
sg15
(lp1612
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1613
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1614
asg17
(lp1615
g1479
ag1199
asg19
(lp1616
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1617
(dp1618
g11
(lp1619
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntryFactory$8'
p1620
sg15
(lp1621
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1622
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1623
asg17
(lp1624
g1479
ag1199
asg19
(lp1625
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1626
(dp1627
g11
(lp1628
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntryIterator'
p1629
sg15
(lp1630
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1631
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1632
asg17
(lp1633
g1479
ag1199
asg19
(lp1634
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1635
(dp1636
g11
(lp1637
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$EntrySet'
p1638
sg15
(lp1639
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1640
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1641
asg17
(lp1642
g1479
ag1199
asg19
(lp1643
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1644
(dp1645
g11
(lp1646
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$HashIterator'
p1647
sg15
(lp1648
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1649
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1650
asg17
(lp1651
g1479
ag1199
asg19
(lp1652
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1653
(dp1654
g11
(lp1655
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$KeyIterator'
p1656
sg15
(lp1657
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1658
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1659
asg17
(lp1660
g1479
ag1199
asg19
(lp1661
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1662
(dp1663
g11
(lp1664
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$KeySet'
p1665
sg15
(lp1666
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1667
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1668
asg17
(lp1669
g1479
ag1199
asg19
(lp1670
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1671
(dp1672
g11
(lp1673
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$LoadingSerializationProxy'
p1674
sg15
(lp1675
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1676
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1677
asg17
(lp1678
g1479
ag1199
asg19
(lp1679
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1680
(dp1681
g11
(lp1682
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$LoadingValueReference'
p1683
sg15
(lp1684
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1685
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1686
asg17
(lp1687
g1479
ag1199
asg19
(lp1688
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1689
(dp1690
g11
(lp1691
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$LoadingValueReference$1'
p1692
sg15
(lp1693
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1694
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1695
asg17
(lp1696
g1479
ag1199
asg19
(lp1697
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1698
(dp1699
g11
(lp1700
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$LocalLoadingCache'
p1701
sg15
(lp1702
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1703
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1704
asg17
(lp1705
g1479
ag1199
asg19
(lp1706
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1707
(dp1708
g11
(lp1709
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$LocalManualCache'
p1710
sg15
(lp1711
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1712
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1713
asg17
(lp1714
g1479
ag1199
asg19
(lp1715
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1716
(dp1717
g11
(lp1718
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$LocalManualCache$1'
p1719
sg15
(lp1720
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1721
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1722
asg17
(lp1723
g1479
ag1199
asg19
(lp1724
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1725
(dp1726
g11
(lp1727
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$ManualSerializationProxy'
p1728
sg15
(lp1729
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1730
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1731
asg17
(lp1732
g1479
ag1199
asg19
(lp1733
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1734
(dp1735
g11
(lp1736
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$NullEntry'
p1737
sg15
(lp1738
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1739
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1740
asg17
(lp1741
g1479
ag1199
asg19
(lp1742
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1743
(dp1744
g11
(lp1745
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$ReferenceEntry'
p1746
sg15
(lp1747
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1748
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1749
asg17
(lp1750
g1479
ag1199
asg19
(lp1751
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1752
(dp1753
g11
(lp1754
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$Segment'
p1755
sg15
(lp1756
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1757
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1758
asg17
(lp1759
g1479
ag1199
asg19
(lp1760
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1761
(dp1762
g11
(lp1763
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$Segment$1'
p1764
sg15
(lp1765
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1766
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1767
asg17
(lp1768
g1479
ag1199
asg19
(lp1769
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1770
(dp1771
g11
(lp1772
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$SoftValueReference'
p1773
sg15
(lp1774
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1775
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1776
asg17
(lp1777
g1479
ag1199
asg19
(lp1778
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1779
(dp1780
g11
(lp1781
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$Strength'
p1782
sg15
(lp1783
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1784
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1785
asg17
(lp1786
g1479
ag1199
asg19
(lp1787
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1788
(dp1789
g11
(lp1790
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$Strength$1'
p1791
sg15
(lp1792
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1793
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1794
asg17
(lp1795
g1479
ag1199
asg19
(lp1796
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1797
(dp1798
g11
(lp1799
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$Strength$2'
p1800
sg15
(lp1801
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1802
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1803
asg17
(lp1804
g1479
ag1199
asg19
(lp1805
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1806
(dp1807
g11
(lp1808
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$Strength$3'
p1809
sg15
(lp1810
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1811
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1812
asg17
(lp1813
g1479
ag1199
asg19
(lp1814
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1815
(dp1816
g11
(lp1817
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$StrongAccessEntry'
p1818
sg15
(lp1819
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1820
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1821
asg17
(lp1822
g1479
ag1199
asg19
(lp1823
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1824
(dp1825
g11
(lp1826
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$StrongAccessWriteEntry'
p1827
sg15
(lp1828
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1829
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1830
asg17
(lp1831
g1479
ag1199
asg19
(lp1832
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1833
(dp1834
g11
(lp1835
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$StrongEntry'
p1836
sg15
(lp1837
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1838
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1839
asg17
(lp1840
g1479
ag1199
asg19
(lp1841
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1842
(dp1843
g11
(lp1844
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$StrongValueReference'
p1845
sg15
(lp1846
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1847
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1848
asg17
(lp1849
g1479
ag1199
asg19
(lp1850
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1851
(dp1852
g11
(lp1853
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$StrongWriteEntry'
p1854
sg15
(lp1855
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1856
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1857
asg17
(lp1858
g1479
ag1199
asg19
(lp1859
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1860
(dp1861
g11
(lp1862
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$ValueIterator'
p1863
sg15
(lp1864
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1865
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1866
asg17
(lp1867
g1479
ag1199
asg19
(lp1868
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1869
(dp1870
g11
(lp1871
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$ValueReference'
p1872
sg15
(lp1873
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1874
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1875
asg17
(lp1876
g1479
ag1199
asg19
(lp1877
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1878
(dp1879
g11
(lp1880
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$Values'
p1881
sg15
(lp1882
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1883
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1884
asg17
(lp1885
g1479
ag1199
asg19
(lp1886
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1887
(dp1888
g11
(lp1889
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WeakAccessEntry'
p1890
sg15
(lp1891
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1892
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1893
asg17
(lp1894
g1479
ag1199
asg19
(lp1895
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1896
(dp1897
g11
(lp1898
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WeakAccessWriteEntry'
p1899
sg15
(lp1900
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1901
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1902
asg17
(lp1903
g1479
ag1199
asg19
(lp1904
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1905
(dp1906
g11
(lp1907
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WeakEntry'
p1908
sg15
(lp1909
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1910
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1911
asg17
(lp1912
g1479
ag1199
asg19
(lp1913
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1914
(dp1915
g11
(lp1916
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WeakValueReference'
p1917
sg15
(lp1918
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1919
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1920
asg17
(lp1921
g1479
ag1199
asg19
(lp1922
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1923
(dp1924
g11
(lp1925
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WeakWriteEntry'
p1926
sg15
(lp1927
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1928
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1929
asg17
(lp1930
g1479
ag1199
asg19
(lp1931
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1932
(dp1933
g11
(lp1934
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WeightedSoftValueReference'
p1935
sg15
(lp1936
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1937
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1938
asg17
(lp1939
g1479
ag1199
asg19
(lp1940
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1941
(dp1942
g11
(lp1943
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WeightedStrongValueReference'
p1944
sg15
(lp1945
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1946
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1947
asg17
(lp1948
g1479
ag1199
asg19
(lp1949
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1950
(dp1951
g11
(lp1952
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WeightedWeakValueReference'
p1953
sg15
(lp1954
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1955
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1956
asg17
(lp1957
g1479
ag1199
asg19
(lp1958
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1959
(dp1960
g11
(lp1961
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WriteQueue'
p1962
sg15
(lp1963
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1964
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1965
asg17
(lp1966
g1479
ag1199
asg19
(lp1967
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1968
(dp1969
g11
(lp1970
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WriteQueue$1'
p1971
sg15
(lp1972
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1973
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1974
asg17
(lp1975
g1479
ag1199
asg19
(lp1976
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1977
(dp1978
g11
(lp1979
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WriteQueue$2'
p1980
sg15
(lp1981
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1982
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1983
asg17
(lp1984
g1479
ag1199
asg19
(lp1985
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1986
(dp1987
g11
(lp1988
g1473
ag1189
asg13
S'com.google.common.cache.LocalCache$WriteThroughEntry'
p1989
sg15
(lp1990
VMy multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\u000a\u000a``` java\u000a(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\u000a(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\u000a```\u000a\u000aThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\u000a\u000a```\u000ajava.lang.NegativeArraySizeException\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\u000aat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\u000aat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\u000aat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\u000aat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\u000aat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\u000aat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\u000aat java.lang.Thread.run(Thread.java:745)\u000a```\u000a
p1991
aVWhen the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\u000a\u000aDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\u000a\u000a> The key and/or value may be null if they were already garbage collected.\u000a\u000aTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\u000a\u000a``` java\u000a@Test\u000apublic void clear_expireAfterAccess() {\u000a  FakeTicker ticker = new FakeTicker();\u000a  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\u000a  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\u000a      ArgumentCaptor.forClass(RemovalNotification.class);\u000a  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\u000a      .expireAfterAccess(1, TimeUnit.MINUTES)\u000a      .removalListener(listener)\u000a      .ticker(ticker)\u000a      .build();\u000a  cache.put(1, 1);\u000a  ticker.advance(10, TimeUnit.MINUTES);\u000a  cache.invalidateAll();\u000a\u000a  verify(listener).onRemoval(captor.capture());\u000a  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\u000a}\u000a```\u000a\u000aThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \u000a\u000aUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\u000a
p1992
asg17
(lp1993
g1479
ag1199
asg19
(lp1994
g1481
ag1202
asg21
I0
sba(iArchitecture
Entity
p1995
(dp1996
g11
(lp1997
sg13
S'com.google.common.cache.LongAddable'
p1998
sg15
(lp1999
sg17
(lp2000
sg19
(lp2001
sg21
I0
sba(iArchitecture
Entity
p2002
(dp2003
g11
(lp2004
sg13
S'com.google.common.cache.LongAddables'
p2005
sg15
(lp2006
sg17
(lp2007
sg19
(lp2008
sg21
I0
sba(iArchitecture
Entity
p2009
(dp2010
g11
(lp2011
sg13
S'com.google.common.cache.LongAddables$1'
p2012
sg15
(lp2013
sg17
(lp2014
sg19
(lp2015
sg21
I0
sba(iArchitecture
Entity
p2016
(dp2017
g11
(lp2018
sg13
S'com.google.common.cache.LongAddables$2'
p2019
sg15
(lp2020
sg17
(lp2021
sg19
(lp2022
sg21
I0
sba(iArchitecture
Entity
p2023
(dp2024
g11
(lp2025
sg13
S'com.google.common.cache.LongAddables$PureJavaLongAddable'
p2026
sg15
(lp2027
sg17
(lp2028
sg19
(lp2029
sg21
I0
sba(iArchitecture
Entity
p2030
(dp2031
g11
(lp2032
sg13
S'com.google.common.cache.LongAdder'
p2033
sg15
(lp2034
sg17
(lp2035
sg19
(lp2036
sg21
I0
sba(iArchitecture
Entity
p2037
(dp2038
g11
(lp2039
sg13
S'com.google.common.cache.RemovalCause'
p2040
sg15
(lp2041
sg17
(lp2042
sg19
(lp2043
sg21
I0
sba(iArchitecture
Entity
p2044
(dp2045
g11
(lp2046
sg13
S'com.google.common.cache.RemovalCause$1'
p2047
sg15
(lp2048
sg17
(lp2049
sg19
(lp2050
sg21
I0
sba(iArchitecture
Entity
p2051
(dp2052
g11
(lp2053
sg13
S'com.google.common.cache.RemovalCause$2'
p2054
sg15
(lp2055
sg17
(lp2056
sg19
(lp2057
sg21
I0
sba(iArchitecture
Entity
p2058
(dp2059
g11
(lp2060
sg13
S'com.google.common.cache.RemovalCause$3'
p2061
sg15
(lp2062
sg17
(lp2063
sg19
(lp2064
sg21
I0
sba(iArchitecture
Entity
p2065
(dp2066
g11
(lp2067
sg13
S'com.google.common.cache.RemovalCause$4'
p2068
sg15
(lp2069
sg17
(lp2070
sg19
(lp2071
sg21
I0
sba(iArchitecture
Entity
p2072
(dp2073
g11
(lp2074
sg13
S'com.google.common.cache.RemovalCause$5'
p2075
sg15
(lp2076
sg17
(lp2077
sg19
(lp2078
sg21
I0
sba(iArchitecture
Entity
p2079
(dp2080
g11
(lp2081
sg13
S'com.google.common.cache.RemovalListener'
p2082
sg15
(lp2083
sg17
(lp2084
sg19
(lp2085
sg21
I0
sba(iArchitecture
Entity
p2086
(dp2087
g11
(lp2088
sg13
S'com.google.common.cache.RemovalListeners'
p2089
sg15
(lp2090
sg17
(lp2091
sg19
(lp2092
sg21
I0
sba(iArchitecture
Entity
p2093
(dp2094
g11
(lp2095
sg13
S'com.google.common.cache.RemovalListeners$1'
p2096
sg15
(lp2097
sg17
(lp2098
sg19
(lp2099
sg21
I0
sba(iArchitecture
Entity
p2100
(dp2101
g11
(lp2102
sg13
S'com.google.common.cache.RemovalListeners$1$1'
p2103
sg15
(lp2104
sg17
(lp2105
sg19
(lp2106
sg21
I0
sba(iArchitecture
Entity
p2107
(dp2108
g11
(lp2109
sg13
S'com.google.common.cache.RemovalNotification'
p2110
sg15
(lp2111
sg17
(lp2112
sg19
(lp2113
sg21
I0
sba(iArchitecture
Entity
p2114
(dp2115
g11
(lp2116
sg13
S'com.google.common.cache.Striped64'
p2117
sg15
(lp2118
sg17
(lp2119
sg19
(lp2120
sg21
I0
sba(iArchitecture
Entity
p2121
(dp2122
g11
(lp2123
sg13
S'com.google.common.cache.Striped64$1'
p2124
sg15
(lp2125
sg17
(lp2126
sg19
(lp2127
sg21
I0
sba(iArchitecture
Entity
p2128
(dp2129
g11
(lp2130
sg13
S'com.google.common.cache.Striped64$Cell'
p2131
sg15
(lp2132
sg17
(lp2133
sg19
(lp2134
sg21
I0
sba(iArchitecture
Entity
p2135
(dp2136
g11
(lp2137
sg13
S'com.google.common.cache.Weigher'
p2138
sg15
(lp2139
sg17
(lp2140
sg19
(lp2141
sg21
I0
sba(iArchitecture
Entity
p2142
(dp2143
g11
(lp2144
sg13
S'com.google.common.collect.EvictingQueue'
p2145
sg15
(lp2146
sg17
(lp2147
sg19
(lp2148
sg21
I0
sba(iArchitecture
Entity
p2149
(dp2150
g11
(lp2151
sg13
S'com.google.common.escape.ArrayBasedUnicodeEscaper'
p2152
sg15
(lp2153
sg17
(lp2154
sg19
(lp2155
sg21
I0
sba(iArchitecture
Entity
p2156
(dp2157
g11
(lp2158
sg13
S'com.google.common.hash.HashingInputStream'
p2159
sg15
(lp2160
sg17
(lp2161
sg19
(lp2162
sg21
I0
sba(iArchitecture
Entity
p2163
(dp2164
g11
(lp2165
sg13
S'com.google.common.hash.HashingOutputStream'
p2166
sg15
(lp2167
sg17
(lp2168
sg19
(lp2169
sg21
I0
sba(iArchitecture
Entity
p2170
(dp2171
g11
(lp2172
sg13
S'com.google.common.io.PatternFilenameFilter'
p2173
sg15
(lp2174
sg17
(lp2175
sg19
(lp2176
sg21
I0
sba(iArchitecture
Entity
p2177
(dp2178
g11
(lp2179
sg13
S'com.google.common.primitives.UnsignedInteger'
p2180
sg15
(lp2181
sg17
(lp2182
sg19
(lp2183
sg21
I0
sba(iArchitecture
Entity
p2184
(dp2185
g11
(lp2186
sg13
S'com.google.common.util.concurrent.FakeTimeLimiter'
p2187
sg15
(lp2188
sg17
(lp2189
sg19
(lp2190
sg21
I0
sba(iArchitecture
Entity
p2191
(dp2192
g11
(lp2193
sg13
S'com.google.common.util.concurrent.SettableFuture'
p2194
sg15
(lp2195
sg17
(lp2196
sg19
(lp2197
sg21
I0
sba(iArchitecture
Entity
p2198
(dp2199
g11
(lp2200
sg13
S'sun.misc.Unsafe'
p2201
sg15
(lp2202
sg17
(lp2203
sg19
(lp2204
sg21
I0
sbasg1135
(lp2205
g1146
ag1153
ag1160
ag1167
ag1174
ag1181
ag1190
ag1206
ag1214
ag1222
ag1230
ag1238
ag1246
ag1254
ag1262
ag1270
ag1278
ag1286
ag1294
ag1302
ag1310
ag1318
ag1326
ag1334
ag1342
ag1350
ag1358
ag1366
ag1374
ag1382
ag1389
ag1396
ag1403
ag1410
ag1417
ag1424
ag1431
ag1438
ag1445
ag1452
ag1459
ag1466
ag1474
ag1485
ag1494
ag1503
ag1512
ag1521
ag1530
ag1539
ag1548
ag1557
ag1566
ag1575
ag1584
ag1593
ag1602
ag1611
ag1620
ag1629
ag1638
ag1647
ag1656
ag1665
ag1674
ag1683
ag1692
ag1701
ag1710
ag1719
ag1728
ag1737
ag1746
ag1755
ag1764
ag1773
ag1782
ag1791
ag1800
ag1809
ag1818
ag1827
ag1836
ag1845
ag1854
ag1863
ag1872
ag1881
ag1890
ag1899
ag1908
ag1917
ag1926
ag1935
ag1944
ag1953
ag1962
ag1971
ag1980
ag1989
ag1998
ag2005
ag2012
ag2019
ag2026
ag2033
ag2040
ag2047
ag2054
ag2061
ag2068
ag2075
ag2082
ag2089
ag2096
ag2103
ag2110
ag2117
ag2124
ag2131
ag2138
ag2145
ag2152
ag2159
ag2166
ag2173
ag2180
ag2187
ag2194
ag2201
asg1137
I0
sg21
I0
sg1138
S'com.google.common.cache.ss'
p2206
sba(iArchitecture
Cluster
p2207
(dp2208
g7
(lp2209
(iArchitecture
Entity
p2210
(dp2211
g11
(lp2212
sg13
S'com.google.common.annotations.Beta'
p2213
sg15
(lp2214
sg17
(lp2215
sg19
(lp2216
sg21
I0
sba(iArchitecture
Entity
p2217
(dp2218
g11
(lp2219
sg13
S'com.google.common.annotations.GwtCompatible'
p2220
sg15
(lp2221
sg17
(lp2222
sg19
(lp2223
sg21
I0
sba(iArchitecture
Entity
p2224
(dp2225
g11
(lp2226
sg13
S'com.google.common.annotations.VisibleForTesting'
p2227
sg15
(lp2228
sg17
(lp2229
sg19
(lp2230
sg21
I0
sba(iArchitecture
Entity
p2231
(dp2232
g11
(lp2233
sg13
S'com.google.common.cache.AbstractLoadingCache'
p2234
sg15
(lp2235
sg17
(lp2236
sg19
(lp2237
sg21
I0
sba(iArchitecture
Entity
p2238
(dp2239
g11
(lp2240
sg13
S'com.google.common.collect.AbstractBiMap'
p2241
sg15
(lp2242
sg17
(lp2243
sg19
(lp2244
sg21
I0
sba(iArchitecture
Entity
p2245
(dp2246
g11
(lp2247
sg13
S'com.google.common.collect.AbstractBiMap$1'
p2248
sg15
(lp2249
sg17
(lp2250
sg19
(lp2251
sg21
I0
sba(iArchitecture
Entity
p2252
(dp2253
g11
(lp2254
sg13
S'com.google.common.collect.AbstractBiMap$EntrySet'
p2255
sg15
(lp2256
sg17
(lp2257
sg19
(lp2258
sg21
I0
sba(iArchitecture
Entity
p2259
(dp2260
g11
(lp2261
sg13
S'com.google.common.collect.AbstractBiMap$EntrySet$1'
p2262
sg15
(lp2263
sg17
(lp2264
sg19
(lp2265
sg21
I0
sba(iArchitecture
Entity
p2266
(dp2267
g11
(lp2268
sg13
S'com.google.common.collect.AbstractBiMap$EntrySet$1$1'
p2269
sg15
(lp2270
sg17
(lp2271
sg19
(lp2272
sg21
I0
sba(iArchitecture
Entity
p2273
(dp2274
g11
(lp2275
sg13
S'com.google.common.collect.AbstractBiMap$Inverse'
p2276
sg15
(lp2277
sg17
(lp2278
sg19
(lp2279
sg21
I0
sba(iArchitecture
Entity
p2280
(dp2281
g11
(lp2282
sg13
S'com.google.common.collect.AbstractBiMap$KeySet'
p2283
sg15
(lp2284
sg17
(lp2285
sg19
(lp2286
sg21
I0
sba(iArchitecture
Entity
p2287
(dp2288
g11
(lp2289
sg13
S'com.google.common.collect.AbstractBiMap$ValueSet'
p2290
sg15
(lp2291
sg17
(lp2292
sg19
(lp2293
sg21
I0
sba(iArchitecture
Entity
p2294
(dp2295
g11
(lp2296
sg13
S'com.google.common.collect.AbstractIndexedListIterator'
p2297
sg15
(lp2298
sg17
(lp2299
sg19
(lp2300
sg21
I0
sba(iArchitecture
Entity
p2301
(dp2302
g11
(lp2303
sg13
S'com.google.common.collect.AbstractIterator'
p2304
sg15
(lp2305
sg17
(lp2306
sg19
(lp2307
sg21
I0
sba(iArchitecture
Entity
p2308
(dp2309
g11
(lp2310
sg13
S'com.google.common.collect.AbstractIterator$1'
p2311
sg15
(lp2312
sg17
(lp2313
sg19
(lp2314
sg21
I0
sba(iArchitecture
Entity
p2315
(dp2316
g11
(lp2317
sg13
S'com.google.common.collect.AbstractIterator$State'
p2318
sg15
(lp2319
sg17
(lp2320
sg19
(lp2321
sg21
I0
sba(iArchitecture
Entity
p2322
(dp2323
g11
(lp2324
sg13
S'com.google.common.collect.AbstractListMultimap'
p2325
sg15
(lp2326
sg17
(lp2327
sg19
(lp2328
sg21
I0
sba(iArchitecture
Entity
p2329
(dp2330
g11
(lp2331
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap'
p2332
sg15
(lp2333
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2334
asg17
(lp2335
g32
asg19
(lp2336
g35
asg21
I0
sba(iArchitecture
Entity
p2337
(dp2338
g11
(lp2339
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$1'
p2340
sg15
(lp2341
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2342
asg17
(lp2343
g32
asg19
(lp2344
g35
asg21
I0
sba(iArchitecture
Entity
p2345
(dp2346
g11
(lp2347
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$2'
p2348
sg15
(lp2349
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2350
asg17
(lp2351
g32
asg19
(lp2352
g35
asg21
I0
sba(iArchitecture
Entity
p2353
(dp2354
g11
(lp2355
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$AsMap'
p2356
sg15
(lp2357
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2358
asg17
(lp2359
g32
asg19
(lp2360
g35
asg21
I0
sba(iArchitecture
Entity
p2361
(dp2362
g11
(lp2363
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapEntries'
p2364
sg15
(lp2365
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2366
asg17
(lp2367
g32
asg19
(lp2368
g35
asg21
I0
sba(iArchitecture
Entity
p2369
(dp2370
g11
(lp2371
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapIterator'
p2372
sg15
(lp2373
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2374
asg17
(lp2375
g32
asg19
(lp2376
g35
asg21
I0
sba(iArchitecture
Entity
p2377
(dp2378
g11
(lp2379
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$Itr'
p2380
sg15
(lp2381
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2382
asg17
(lp2383
g32
asg19
(lp2384
g35
asg21
I0
sba(iArchitecture
Entity
p2385
(dp2386
g11
(lp2387
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$KeySet'
p2388
sg15
(lp2389
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2390
asg17
(lp2391
g32
asg19
(lp2392
g35
asg21
I0
sba(iArchitecture
Entity
p2393
(dp2394
g11
(lp2395
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$KeySet$1'
p2396
sg15
(lp2397
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2398
asg17
(lp2399
g32
asg19
(lp2400
g35
asg21
I0
sba(iArchitecture
Entity
p2401
(dp2402
g11
(lp2403
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$NavigableAsMap'
p2404
sg15
(lp2405
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2406
asg17
(lp2407
g32
asg19
(lp2408
g35
asg21
I0
sba(iArchitecture
Entity
p2409
(dp2410
g11
(lp2411
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$NavigableKeySet'
p2412
sg15
(lp2413
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2414
asg17
(lp2415
g32
asg19
(lp2416
g35
asg21
I0
sba(iArchitecture
Entity
p2417
(dp2418
g11
(lp2419
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$RandomAccessWrappedList'
p2420
sg15
(lp2421
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2422
asg17
(lp2423
g32
asg19
(lp2424
g35
asg21
I0
sba(iArchitecture
Entity
p2425
(dp2426
g11
(lp2427
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$SortedAsMap'
p2428
sg15
(lp2429
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2430
asg17
(lp2431
g32
asg19
(lp2432
g35
asg21
I0
sba(iArchitecture
Entity
p2433
(dp2434
g11
(lp2435
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$SortedKeySet'
p2436
sg15
(lp2437
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2438
asg17
(lp2439
g32
asg19
(lp2440
g35
asg21
I0
sba(iArchitecture
Entity
p2441
(dp2442
g11
(lp2443
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection'
p2444
sg15
(lp2445
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2446
asg17
(lp2447
g32
asg19
(lp2448
g35
asg21
I0
sba(iArchitecture
Entity
p2449
(dp2450
g11
(lp2451
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection$WrappedIterator'
p2452
sg15
(lp2453
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2454
asg17
(lp2455
g32
asg19
(lp2456
g35
asg21
I0
sba(iArchitecture
Entity
p2457
(dp2458
g11
(lp2459
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedList'
p2460
sg15
(lp2461
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2462
asg17
(lp2463
g32
asg19
(lp2464
g35
asg21
I0
sba(iArchitecture
Entity
p2465
(dp2466
g11
(lp2467
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedList$WrappedListIterator'
p2468
sg15
(lp2469
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2470
asg17
(lp2471
g32
asg19
(lp2472
g35
asg21
I0
sba(iArchitecture
Entity
p2473
(dp2474
g11
(lp2475
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedNavigableSet'
p2476
sg15
(lp2477
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2478
asg17
(lp2479
g32
asg19
(lp2480
g35
asg21
I0
sba(iArchitecture
Entity
p2481
(dp2482
g11
(lp2483
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedSet'
p2484
sg15
(lp2485
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2486
asg17
(lp2487
g32
asg19
(lp2488
g35
asg21
I0
sba(iArchitecture
Entity
p2489
(dp2490
g11
(lp2491
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedSortedSet'
p2492
sg15
(lp2493
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2494
asg17
(lp2495
g32
asg19
(lp2496
g35
asg21
I0
sba(iArchitecture
Entity
p2497
(dp2498
g11
(lp2499
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultiset'
p2500
sg15
(lp2501
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2502
asg17
(lp2503
g32
asg19
(lp2504
g35
asg21
I0
sba(iArchitecture
Entity
p2505
(dp2506
g11
(lp2507
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultiset$1'
p2508
sg15
(lp2509
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2510
asg17
(lp2511
g32
asg19
(lp2512
g35
asg21
I0
sba(iArchitecture
Entity
p2513
(dp2514
g11
(lp2515
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultiset$1$1'
p2516
sg15
(lp2517
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2518
asg17
(lp2519
g32
asg19
(lp2520
g35
asg21
I0
sba(iArchitecture
Entity
p2521
(dp2522
g11
(lp2523
g25
asg13
S'com.google.common.collect.AbstractMapBasedMultiset$MapBasedMultisetIterator'
p2524
sg15
(lp2525
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2526
asg17
(lp2527
g32
asg19
(lp2528
g35
asg21
I0
sba(iArchitecture
Entity
p2529
(dp2530
g11
(lp2531
sg13
S'com.google.common.collect.AbstractMapEntry'
p2532
sg15
(lp2533
sg17
(lp2534
sg19
(lp2535
sg21
I0
sba(iArchitecture
Entity
p2536
(dp2537
g11
(lp2538
sg13
S'com.google.common.collect.AbstractMultimap'
p2539
sg15
(lp2540
sg17
(lp2541
sg19
(lp2542
sg21
I0
sba(iArchitecture
Entity
p2543
(dp2544
g11
(lp2545
sg13
S'com.google.common.collect.AbstractMultimap$1'
p2546
sg15
(lp2547
sg17
(lp2548
sg19
(lp2549
sg21
I0
sba(iArchitecture
Entity
p2550
(dp2551
g11
(lp2552
sg13
S'com.google.common.collect.AbstractMultimap$Entries'
p2553
sg15
(lp2554
sg17
(lp2555
sg19
(lp2556
sg21
I0
sba(iArchitecture
Entity
p2557
(dp2558
g11
(lp2559
sg13
S'com.google.common.collect.AbstractMultimap$EntrySet'
p2560
sg15
(lp2561
sg17
(lp2562
sg19
(lp2563
sg21
I0
sba(iArchitecture
Entity
p2564
(dp2565
g11
(lp2566
sg13
S'com.google.common.collect.AbstractMultimap$Values'
p2567
sg15
(lp2568
sg17
(lp2569
sg19
(lp2570
sg21
I0
sba(iArchitecture
Entity
p2571
(dp2572
g11
(lp2573
sg13
S'com.google.common.collect.AbstractMultiset'
p2574
sg15
(lp2575
sg17
(lp2576
sg19
(lp2577
sg21
I0
sba(iArchitecture
Entity
p2578
(dp2579
g11
(lp2580
sg13
S'com.google.common.collect.AbstractMultiset$ElementSet'
p2581
sg15
(lp2582
sg17
(lp2583
sg19
(lp2584
sg21
I0
sba(iArchitecture
Entity
p2585
(dp2586
g11
(lp2587
sg13
S'com.google.common.collect.AbstractMultiset$EntrySet'
p2588
sg15
(lp2589
sg17
(lp2590
sg19
(lp2591
sg21
I0
sba(iArchitecture
Entity
p2592
(dp2593
g11
(lp2594
sg13
S'com.google.common.collect.AbstractNavigableMap'
p2595
sg15
(lp2596
sg17
(lp2597
sg19
(lp2598
sg21
I0
sba(iArchitecture
Entity
p2599
(dp2600
g11
(lp2601
sg13
S'com.google.common.collect.AbstractNavigableMap$1'
p2602
sg15
(lp2603
sg17
(lp2604
sg19
(lp2605
sg21
I0
sba(iArchitecture
Entity
p2606
(dp2607
g11
(lp2608
sg13
S'com.google.common.collect.AbstractNavigableMap$DescendingMap'
p2609
sg15
(lp2610
sg17
(lp2611
sg19
(lp2612
sg21
I0
sba(iArchitecture
Entity
p2613
(dp2614
g11
(lp2615
sg13
S'com.google.common.collect.AbstractRangeSet'
p2616
sg15
(lp2617
sg17
(lp2618
sg19
(lp2619
sg21
I0
sba(iArchitecture
Entity
p2620
(dp2621
g11
(lp2622
sg13
S'com.google.common.collect.AbstractSequentialIterator'
p2623
sg15
(lp2624
sg17
(lp2625
sg19
(lp2626
sg21
I0
sba(iArchitecture
Entity
p2627
(dp2628
g11
(lp2629
sg13
S'com.google.common.collect.AbstractSetMultimap'
p2630
sg15
(lp2631
sg17
(lp2632
sg19
(lp2633
sg21
I0
sba(iArchitecture
Entity
p2634
(dp2635
g11
(lp2636
sg13
S'com.google.common.collect.AbstractSortedKeySortedSetMultimap'
p2637
sg15
(lp2638
sg17
(lp2639
sg19
(lp2640
sg21
I0
sba(iArchitecture
Entity
p2641
(dp2642
g11
(lp2643
sg13
S'com.google.common.collect.AbstractSortedMultiset'
p2644
sg15
(lp2645
sg17
(lp2646
sg19
(lp2647
sg21
I0
sba(iArchitecture
Entity
p2648
(dp2649
g11
(lp2650
sg13
S'com.google.common.collect.AbstractSortedMultiset$1'
p2651
sg15
(lp2652
sg17
(lp2653
sg19
(lp2654
sg21
I0
sba(iArchitecture
Entity
p2655
(dp2656
g11
(lp2657
sg13
S'com.google.common.collect.AbstractSortedSetMultimap'
p2658
sg15
(lp2659
sg17
(lp2660
sg19
(lp2661
sg21
I0
sba(iArchitecture
Entity
p2662
(dp2663
g11
(lp2664
sg13
S'com.google.common.collect.AbstractTable'
p2665
sg15
(lp2666
sg17
(lp2667
sg19
(lp2668
sg21
I0
sba(iArchitecture
Entity
p2669
(dp2670
g11
(lp2671
sg13
S'com.google.common.collect.AbstractTable$1'
p2672
sg15
(lp2673
sg17
(lp2674
sg19
(lp2675
sg21
I0
sba(iArchitecture
Entity
p2676
(dp2677
g11
(lp2678
sg13
S'com.google.common.collect.AbstractTable$CellSet'
p2679
sg15
(lp2680
sg17
(lp2681
sg19
(lp2682
sg21
I0
sba(iArchitecture
Entity
p2683
(dp2684
g11
(lp2685
sg13
S'com.google.common.collect.AbstractTable$Values'
p2686
sg15
(lp2687
sg17
(lp2688
sg19
(lp2689
sg21
I0
sba(iArchitecture
Entity
p2690
(dp2691
g11
(lp2692
g25
asg13
S'com.google.common.collect.AllEqualOrdering'
p2693
sg15
(lp2694
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2695
asg17
(lp2696
g32
asg19
(lp2697
g35
asg21
I0
sba(iArchitecture
Entity
p2698
(dp2699
g11
(lp2700
sg13
S'com.google.common.collect.ArrayListMultimap'
p2701
sg15
(lp2702
sg17
(lp2703
sg19
(lp2704
sg21
I0
sba(iArchitecture
Entity
p2705
(dp2706
g11
(lp2707
sg13
S'com.google.common.collect.ArrayTable'
p2708
sg15
(lp2709
sg17
(lp2710
sg19
(lp2711
sg21
I0
sba(iArchitecture
Entity
p2712
(dp2713
g11
(lp2714
sg13
S'com.google.common.collect.ArrayTable$1'
p2715
sg15
(lp2716
sg17
(lp2717
sg19
(lp2718
sg21
I0
sba(iArchitecture
Entity
p2719
(dp2720
g11
(lp2721
sg13
S'com.google.common.collect.ArrayTable$1$1'
p2722
sg15
(lp2723
sg17
(lp2724
sg19
(lp2725
sg21
I0
sba(iArchitecture
Entity
p2726
(dp2727
g11
(lp2728
sg13
S'com.google.common.collect.ArrayTable$ArrayMap'
p2729
sg15
(lp2730
sg17
(lp2731
sg19
(lp2732
sg21
I0
sba(iArchitecture
Entity
p2733
(dp2734
g11
(lp2735
sg13
S'com.google.common.collect.ArrayTable$ArrayMap$1'
p2736
sg15
(lp2737
sg17
(lp2738
sg19
(lp2739
sg21
I0
sba(iArchitecture
Entity
p2740
(dp2741
g11
(lp2742
sg13
S'com.google.common.collect.ArrayTable$ArrayMap$1$1'
p2743
sg15
(lp2744
sg17
(lp2745
sg19
(lp2746
sg21
I0
sba(iArchitecture
Entity
p2747
(dp2748
g11
(lp2749
sg13
S'com.google.common.collect.ArrayTable$ArrayMap$1$1$1'
p2750
sg15
(lp2751
sg17
(lp2752
sg19
(lp2753
sg21
I0
sba(iArchitecture
Entity
p2754
(dp2755
g11
(lp2756
sg13
S'com.google.common.collect.ArrayTable$Column'
p2757
sg15
(lp2758
sg17
(lp2759
sg19
(lp2760
sg21
I0
sba(iArchitecture
Entity
p2761
(dp2762
g11
(lp2763
sg13
S'com.google.common.collect.ArrayTable$ColumnMap'
p2764
sg15
(lp2765
sg17
(lp2766
sg19
(lp2767
sg21
I0
sba(iArchitecture
Entity
p2768
(dp2769
g11
(lp2770
sg13
S'com.google.common.collect.ArrayTable$Row'
p2771
sg15
(lp2772
sg17
(lp2773
sg19
(lp2774
sg21
I0
sba(iArchitecture
Entity
p2775
(dp2776
g11
(lp2777
sg13
S'com.google.common.collect.ArrayTable$RowMap'
p2778
sg15
(lp2779
sg17
(lp2780
sg19
(lp2781
sg21
I0
sba(iArchitecture
Entity
p2782
(dp2783
g11
(lp2784
sg13
S'com.google.common.collect.BiMap'
p2785
sg15
(lp2786
sg17
(lp2787
sg19
(lp2788
sg21
I0
sba(iArchitecture
Entity
p2789
(dp2790
g11
(lp2791
sg13
S'com.google.common.collect.BinaryTreeTraverser'
p2792
sg15
(lp2793
sg17
(lp2794
sg19
(lp2795
sg21
I0
sba(iArchitecture
Entity
p2796
(dp2797
g11
(lp2798
sg13
S'com.google.common.collect.BinaryTreeTraverser$1'
p2799
sg15
(lp2800
sg17
(lp2801
sg19
(lp2802
sg21
I0
sba(iArchitecture
Entity
p2803
(dp2804
g11
(lp2805
sg13
S'com.google.common.collect.BinaryTreeTraverser$1$1'
p2806
sg15
(lp2807
sg17
(lp2808
sg19
(lp2809
sg21
I0
sba(iArchitecture
Entity
p2810
(dp2811
g11
(lp2812
sg13
S'com.google.common.collect.BinaryTreeTraverser$2'
p2813
sg15
(lp2814
sg17
(lp2815
sg19
(lp2816
sg21
I0
sba(iArchitecture
Entity
p2817
(dp2818
g11
(lp2819
sg13
S'com.google.common.collect.BinaryTreeTraverser$InOrderIterator'
p2820
sg15
(lp2821
sg17
(lp2822
sg19
(lp2823
sg21
I0
sba(iArchitecture
Entity
p2824
(dp2825
g11
(lp2826
sg13
S'com.google.common.collect.BinaryTreeTraverser$PostOrderIterator'
p2827
sg15
(lp2828
sg17
(lp2829
sg19
(lp2830
sg21
I0
sba(iArchitecture
Entity
p2831
(dp2832
g11
(lp2833
sg13
S'com.google.common.collect.BinaryTreeTraverser$PreOrderIterator'
p2834
sg15
(lp2835
sg17
(lp2836
sg19
(lp2837
sg21
I0
sba(iArchitecture
Entity
p2838
(dp2839
g11
(lp2840
sg13
S'com.google.common.collect.BoundType'
p2841
sg15
(lp2842
sg17
(lp2843
sg19
(lp2844
sg21
I0
sba(iArchitecture
Entity
p2845
(dp2846
g11
(lp2847
sg13
S'com.google.common.collect.BoundType$1'
p2848
sg15
(lp2849
sg17
(lp2850
sg19
(lp2851
sg21
I0
sba(iArchitecture
Entity
p2852
(dp2853
g11
(lp2854
sg13
S'com.google.common.collect.BoundType$2'
p2855
sg15
(lp2856
sg17
(lp2857
sg19
(lp2858
sg21
I0
sba(iArchitecture
Entity
p2859
(dp2860
g11
(lp2861
sg13
S'com.google.common.collect.ByFunctionOrdering'
p2862
sg15
(lp2863
sg17
(lp2864
sg19
(lp2865
sg21
I0
sba(iArchitecture
Entity
p2866
(dp2867
g11
(lp2868
sg13
S'com.google.common.collect.CartesianList'
p2869
sg15
(lp2870
sg17
(lp2871
sg19
(lp2872
sg21
I0
sba(iArchitecture
Entity
p2873
(dp2874
g11
(lp2875
sg13
S'com.google.common.collect.CartesianList$1'
p2876
sg15
(lp2877
sg17
(lp2878
sg19
(lp2879
sg21
I0
sba(iArchitecture
Entity
p2880
(dp2881
g11
(lp2882
sg13
S'com.google.common.collect.ClassToInstanceMap'
p2883
sg15
(lp2884
sg17
(lp2885
sg19
(lp2886
sg21
I0
sba(iArchitecture
Entity
p2887
(dp2888
g11
(lp2889
sg13
S'com.google.common.collect.CollectPreconditions'
p2890
sg15
(lp2891
sg17
(lp2892
sg19
(lp2893
sg21
I0
sba(iArchitecture
Entity
p2894
(dp2895
g11
(lp2896
sg13
S'com.google.common.collect.Collections2'
p2897
sg15
(lp2898
sg17
(lp2899
sg19
(lp2900
sg21
I0
sba(iArchitecture
Entity
p2901
(dp2902
g11
(lp2903
sg13
S'com.google.common.collect.Collections2$1'
p2904
sg15
(lp2905
sg17
(lp2906
sg19
(lp2907
sg21
I0
sba(iArchitecture
Entity
p2908
(dp2909
g11
(lp2910
sg13
S'com.google.common.collect.Collections2$FilteredCollection'
p2911
sg15
(lp2912
sg17
(lp2913
sg19
(lp2914
sg21
I0
sba(iArchitecture
Entity
p2915
(dp2916
g11
(lp2917
sg13
S'com.google.common.collect.Collections2$OrderedPermutationCollection'
p2918
sg15
(lp2919
sg17
(lp2920
sg19
(lp2921
sg21
I0
sba(iArchitecture
Entity
p2922
(dp2923
g11
(lp2924
sg13
S'com.google.common.collect.Collections2$OrderedPermutationIterator'
p2925
sg15
(lp2926
sg17
(lp2927
sg19
(lp2928
sg21
I0
sba(iArchitecture
Entity
p2929
(dp2930
g11
(lp2931
sg13
S'com.google.common.collect.Collections2$PermutationCollection'
p2932
sg15
(lp2933
sg17
(lp2934
sg19
(lp2935
sg21
I0
sba(iArchitecture
Entity
p2936
(dp2937
g11
(lp2938
sg13
S'com.google.common.collect.Collections2$PermutationIterator'
p2939
sg15
(lp2940
sg17
(lp2941
sg19
(lp2942
sg21
I0
sba(iArchitecture
Entity
p2943
(dp2944
g11
(lp2945
sg13
S'com.google.common.collect.Collections2$TransformedCollection'
p2946
sg15
(lp2947
sg17
(lp2948
sg19
(lp2949
sg21
I0
sba(iArchitecture
Entity
p2950
(dp2951
g11
(lp2952
sg13
S'com.google.common.collect.ComparatorOrdering'
p2953
sg15
(lp2954
sg17
(lp2955
sg19
(lp2956
sg21
I0
sba(iArchitecture
Entity
p2957
(dp2958
g11
(lp2959
sg13
S'com.google.common.collect.ComparisonChain'
p2960
sg15
(lp2961
sg17
(lp2962
sg19
(lp2963
sg21
I0
sba(iArchitecture
Entity
p2964
(dp2965
g11
(lp2966
sg13
S'com.google.common.collect.ComparisonChain$1'
p2967
sg15
(lp2968
sg17
(lp2969
sg19
(lp2970
sg21
I0
sba(iArchitecture
Entity
p2971
(dp2972
g11
(lp2973
sg13
S'com.google.common.collect.ComparisonChain$InactiveComparisonChain'
p2974
sg15
(lp2975
sg17
(lp2976
sg19
(lp2977
sg21
I0
sba(iArchitecture
Entity
p2978
(dp2979
g11
(lp2980
sg13
S'com.google.common.collect.CompoundOrdering'
p2981
sg15
(lp2982
sg17
(lp2983
sg19
(lp2984
sg21
I0
sba(iArchitecture
Entity
p2985
(dp2986
g11
(lp2987
sg13
S'com.google.common.collect.ComputationException'
p2988
sg15
(lp2989
sg17
(lp2990
sg19
(lp2991
sg21
I0
sba(iArchitecture
Entity
p2992
(dp2993
g11
(lp2994
g25
asg13
S'com.google.common.collect.ComputingConcurrentHashMap'
p2995
sg15
(lp2996
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p2997
asg17
(lp2998
g32
asg19
(lp2999
g35
asg21
I0
sba(iArchitecture
Entity
p3000
(dp3001
g11
(lp3002
g25
asg13
S'com.google.common.collect.ComputingConcurrentHashMap$ComputationExceptionReference'
p3003
sg15
(lp3004
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3005
asg17
(lp3006
g32
asg19
(lp3007
g35
asg21
I0
sba(iArchitecture
Entity
p3008
(dp3009
g11
(lp3010
g25
asg13
S'com.google.common.collect.ComputingConcurrentHashMap$ComputedReference'
p3011
sg15
(lp3012
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3013
asg17
(lp3014
g32
asg19
(lp3015
g35
asg21
I0
sba(iArchitecture
Entity
p3016
(dp3017
g11
(lp3018
g25
asg13
S'com.google.common.collect.ComputingConcurrentHashMap$ComputingSegment'
p3019
sg15
(lp3020
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3021
asg17
(lp3022
g32
asg19
(lp3023
g35
asg21
I0
sba(iArchitecture
Entity
p3024
(dp3025
g11
(lp3026
g25
asg13
S'com.google.common.collect.ComputingConcurrentHashMap$ComputingSerializationProxy'
p3027
sg15
(lp3028
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3029
asg17
(lp3030
g32
asg19
(lp3031
g35
asg21
I0
sba(iArchitecture
Entity
p3032
(dp3033
g11
(lp3034
g25
asg13
S'com.google.common.collect.ComputingConcurrentHashMap$ComputingValueReference'
p3035
sg15
(lp3036
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3037
asg17
(lp3038
g32
asg19
(lp3039
g35
asg21
I0
sba(iArchitecture
Entity
p3040
(dp3041
g11
(lp3042
sg13
S'com.google.common.collect.ConcurrentHashMultiset'
p3043
sg15
(lp3044
sg17
(lp3045
sg19
(lp3046
sg21
I0
sba(iArchitecture
Entity
p3047
(dp3048
g11
(lp3049
sg13
S'com.google.common.collect.ConcurrentHashMultiset$1'
p3050
sg15
(lp3051
sg17
(lp3052
sg19
(lp3053
sg21
I0
sba(iArchitecture
Entity
p3054
(dp3055
g11
(lp3056
sg13
S'com.google.common.collect.ConcurrentHashMultiset$2'
p3057
sg15
(lp3058
sg17
(lp3059
sg19
(lp3060
sg21
I0
sba(iArchitecture
Entity
p3061
(dp3062
g11
(lp3063
sg13
S'com.google.common.collect.ConcurrentHashMultiset$3'
p3064
sg15
(lp3065
sg17
(lp3066
sg19
(lp3067
sg21
I0
sba(iArchitecture
Entity
p3068
(dp3069
g11
(lp3070
sg13
S'com.google.common.collect.ConcurrentHashMultiset$EntrySet'
p3071
sg15
(lp3072
sg17
(lp3073
sg19
(lp3074
sg21
I0
sba(iArchitecture
Entity
p3075
(dp3076
g11
(lp3077
sg13
S'com.google.common.collect.ConcurrentHashMultiset$FieldSettersHolder'
p3078
sg15
(lp3079
sg17
(lp3080
sg19
(lp3081
sg21
I0
sba(iArchitecture
Entity
p3082
(dp3083
g11
(lp3084
sg13
S'com.google.common.collect.Constraint'
p3085
sg15
(lp3086
sg17
(lp3087
sg19
(lp3088
sg21
I0
sba(iArchitecture
Entity
p3089
(dp3090
g11
(lp3091
sg13
S'com.google.common.collect.Constraints'
p3092
sg15
(lp3093
sg17
(lp3094
sg19
(lp3095
sg21
I0
sba(iArchitecture
Entity
p3096
(dp3097
g11
(lp3098
sg13
S'com.google.common.collect.Constraints$ConstrainedCollection'
p3099
sg15
(lp3100
sg17
(lp3101
sg19
(lp3102
sg21
I0
sba(iArchitecture
Entity
p3103
(dp3104
g11
(lp3105
sg13
S'com.google.common.collect.Constraints$ConstrainedList'
p3106
sg15
(lp3107
sg17
(lp3108
sg19
(lp3109
sg21
I0
sba(iArchitecture
Entity
p3110
(dp3111
g11
(lp3112
sg13
S'com.google.common.collect.Constraints$ConstrainedListIterator'
p3113
sg15
(lp3114
sg17
(lp3115
sg19
(lp3116
sg21
I0
sba(iArchitecture
Entity
p3117
(dp3118
g11
(lp3119
sg13
S'com.google.common.collect.Constraints$ConstrainedRandomAccessList'
p3120
sg15
(lp3121
sg17
(lp3122
sg19
(lp3123
sg21
I0
sba(iArchitecture
Entity
p3124
(dp3125
g11
(lp3126
sg13
S'com.google.common.collect.Constraints$ConstrainedSet'
p3127
sg15
(lp3128
sg17
(lp3129
sg19
(lp3130
sg21
I0
sba(iArchitecture
Entity
p3131
(dp3132
g11
(lp3133
sg13
S'com.google.common.collect.Constraints$ConstrainedSortedSet'
p3134
sg15
(lp3135
sg17
(lp3136
sg19
(lp3137
sg21
I0
sba(iArchitecture
Entity
p3138
(dp3139
g11
(lp3140
V2196
p3141
asg13
S'com.google.common.collect.ContiguousSet'
p3142
sg15
(lp3143
VLet a < x < b:\u000a- [x].intersection([x]) should return [x], returns [],\u000a- [x].intersection([a..b]) should return [x], returns [],\u000a- [a..b].intersection([x]) should return [x], returns [],\u000a- [a..x].intersection([x..b]) should return [x], returns [].\u000a\u000aI'll create a PR in a minute.\u000a
p3144
asg17
(lp3145
(lp3146
I1
aasg19
(lp3147
VContiguousSet.intersection doesn't handle singleton results.
p3148
asg21
I0
sba(iArchitecture
Entity
p3149
(dp3150
g11
(lp3151
sg13
S'com.google.common.collect.Count'
p3152
sg15
(lp3153
sg17
(lp3154
sg19
(lp3155
sg21
I0
sba(iArchitecture
Entity
p3156
(dp3157
g11
(lp3158
g25
asg13
S'com.google.common.collect.Cut'
p3159
sg15
(lp3160
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3161
asg17
(lp3162
g32
asg19
(lp3163
g35
asg21
I0
sba(iArchitecture
Entity
p3164
(dp3165
g11
(lp3166
g25
asg13
S'com.google.common.collect.Cut$1'
p3167
sg15
(lp3168
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3169
asg17
(lp3170
g32
asg19
(lp3171
g35
asg21
I0
sba(iArchitecture
Entity
p3172
(dp3173
g11
(lp3174
g25
asg13
S'com.google.common.collect.Cut$AboveAll'
p3175
sg15
(lp3176
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3177
asg17
(lp3178
g32
asg19
(lp3179
g35
asg21
I0
sba(iArchitecture
Entity
p3180
(dp3181
g11
(lp3182
g25
asg13
S'com.google.common.collect.Cut$AboveValue'
p3183
sg15
(lp3184
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3185
asg17
(lp3186
g32
asg19
(lp3187
g35
asg21
I0
sba(iArchitecture
Entity
p3188
(dp3189
g11
(lp3190
g25
asg13
S'com.google.common.collect.Cut$BelowAll'
p3191
sg15
(lp3192
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3193
asg17
(lp3194
g32
asg19
(lp3195
g35
asg21
I0
sba(iArchitecture
Entity
p3196
(dp3197
g11
(lp3198
g25
asg13
S'com.google.common.collect.Cut$BelowValue'
p3199
sg15
(lp3200
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3201
asg17
(lp3202
g32
asg19
(lp3203
g35
asg21
I0
sba(iArchitecture
Entity
p3204
(dp3205
g11
(lp3206
sg13
S'com.google.common.collect.DenseImmutableTable'
p3207
sg15
(lp3208
sg17
(lp3209
sg19
(lp3210
sg21
I0
sba(iArchitecture
Entity
p3211
(dp3212
g11
(lp3213
sg13
S'com.google.common.collect.DenseImmutableTable$1'
p3214
sg15
(lp3215
sg17
(lp3216
sg19
(lp3217
sg21
I0
sba(iArchitecture
Entity
p3218
(dp3219
g11
(lp3220
sg13
S'com.google.common.collect.DenseImmutableTable$Column'
p3221
sg15
(lp3222
sg17
(lp3223
sg19
(lp3224
sg21
I0
sba(iArchitecture
Entity
p3225
(dp3226
g11
(lp3227
sg13
S'com.google.common.collect.DenseImmutableTable$ColumnMap'
p3228
sg15
(lp3229
sg17
(lp3230
sg19
(lp3231
sg21
I0
sba(iArchitecture
Entity
p3232
(dp3233
g11
(lp3234
sg13
S'com.google.common.collect.DenseImmutableTable$ImmutableArrayMap'
p3235
sg15
(lp3236
sg17
(lp3237
sg19
(lp3238
sg21
I0
sba(iArchitecture
Entity
p3239
(dp3240
g11
(lp3241
sg13
S'com.google.common.collect.DenseImmutableTable$ImmutableArrayMap$1'
p3242
sg15
(lp3243
sg17
(lp3244
sg19
(lp3245
sg21
I0
sba(iArchitecture
Entity
p3246
(dp3247
g11
(lp3248
sg13
S'com.google.common.collect.DenseImmutableTable$ImmutableArrayMap$1$1'
p3249
sg15
(lp3250
sg17
(lp3251
sg19
(lp3252
sg21
I0
sba(iArchitecture
Entity
p3253
(dp3254
g11
(lp3255
sg13
S'com.google.common.collect.DenseImmutableTable$Row'
p3256
sg15
(lp3257
sg17
(lp3258
sg19
(lp3259
sg21
I0
sba(iArchitecture
Entity
p3260
(dp3261
g11
(lp3262
sg13
S'com.google.common.collect.DenseImmutableTable$RowMap'
p3263
sg15
(lp3264
sg17
(lp3265
sg19
(lp3266
sg21
I0
sba(iArchitecture
Entity
p3267
(dp3268
g11
(lp3269
sg13
S'com.google.common.collect.DescendingImmutableSortedMultiset'
p3270
sg15
(lp3271
sg17
(lp3272
sg19
(lp3273
sg21
I0
sba(iArchitecture
Entity
p3274
(dp3275
g11
(lp3276
sg13
S'com.google.common.collect.DescendingImmutableSortedSet'
p3277
sg15
(lp3278
sg17
(lp3279
sg19
(lp3280
sg21
I0
sba(iArchitecture
Entity
p3281
(dp3282
g11
(lp3283
sg13
S'com.google.common.collect.DescendingMultiset'
p3284
sg15
(lp3285
sg17
(lp3286
sg19
(lp3287
sg21
I0
sba(iArchitecture
Entity
p3288
(dp3289
g11
(lp3290
sg13
S'com.google.common.collect.DescendingMultiset$1'
p3291
sg15
(lp3292
sg17
(lp3293
sg19
(lp3294
sg21
I0
sba(iArchitecture
Entity
p3295
(dp3296
g11
(lp3297
g25
asg13
S'com.google.common.collect.DiscreteDomain'
p3298
sg15
(lp3299
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3300
asg17
(lp3301
g32
asg19
(lp3302
g35
asg21
I0
sba(iArchitecture
Entity
p3303
(dp3304
g11
(lp3305
g25
asg13
S'com.google.common.collect.DiscreteDomain$BigIntegerDomain'
p3306
sg15
(lp3307
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3308
asg17
(lp3309
g32
asg19
(lp3310
g35
asg21
I0
sba(iArchitecture
Entity
p3311
(dp3312
g11
(lp3313
g25
asg13
S'com.google.common.collect.DiscreteDomain$IntegerDomain'
p3314
sg15
(lp3315
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3316
asg17
(lp3317
g32
asg19
(lp3318
g35
asg21
I0
sba(iArchitecture
Entity
p3319
(dp3320
g11
(lp3321
g25
asg13
S'com.google.common.collect.DiscreteDomain$LongDomain'
p3322
sg15
(lp3323
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3324
asg17
(lp3325
g32
asg19
(lp3326
g35
asg21
I0
sba(iArchitecture
Entity
p3327
(dp3328
g11
(lp3329
sg13
S'com.google.common.collect.EmptyContiguousSet'
p3330
sg15
(lp3331
sg17
(lp3332
sg19
(lp3333
sg21
I0
sba(iArchitecture
Entity
p3334
(dp3335
g11
(lp3336
sg13
S'com.google.common.collect.EmptyContiguousSet$1'
p3337
sg15
(lp3338
sg17
(lp3339
sg19
(lp3340
sg21
I0
sba(iArchitecture
Entity
p3341
(dp3342
g11
(lp3343
sg13
S'com.google.common.collect.EmptyContiguousSet$SerializedForm'
p3344
sg15
(lp3345
sg17
(lp3346
sg19
(lp3347
sg21
I0
sba(iArchitecture
Entity
p3348
(dp3349
g11
(lp3350
sg13
S'com.google.common.collect.EmptyImmutableBiMap'
p3351
sg15
(lp3352
sg17
(lp3353
sg19
(lp3354
sg21
I0
sba(iArchitecture
Entity
p3355
(dp3356
g11
(lp3357
g25
asg13
S'com.google.common.collect.EmptyImmutableListMultimap'
p3358
sg15
(lp3359
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3360
asg17
(lp3361
g32
asg19
(lp3362
g35
asg21
I0
sba(iArchitecture
Entity
p3363
(dp3364
g11
(lp3365
g25
asg13
S'com.google.common.collect.EmptyImmutableSet'
p3366
sg15
(lp3367
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3368
asg17
(lp3369
g32
asg19
(lp3370
g35
asg21
I0
sba(iArchitecture
Entity
p3371
(dp3372
g11
(lp3373
g25
asg13
S'com.google.common.collect.EmptyImmutableSetMultimap'
p3374
sg15
(lp3375
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p3376
asg17
(lp3377
g32
asg19
(lp3378
g35
asg21
I0
sba(iArchitecture
Entity
p3379
(dp3380
g11
(lp3381
sg13
S'com.google.common.collect.EmptyImmutableSortedMap'
p3382
sg15
(lp3383
sg17
(lp3384
sg19
(lp3385
sg21
I0
sba(iArchitecture
Entity
p3386
(dp3387
g11
(lp3388
sg13
S'com.google.common.collect.EmptyImmutableSortedMultiset'
p3389
sg15
(lp3390
sg17
(lp3391
sg19
(lp3392
sg21
I0
sba(iArchitecture
Entity
p3393
(dp3394
g11
(lp3395
sg13
S'com.google.common.collect.EmptyImmutableSortedSet'
p3396
sg15
(lp3397
sg17
(lp3398
sg19
(lp3399
sg21
I0
sba(iArchitecture
Entity
p3400
(dp3401
g11
(lp3402
sg13
S'com.google.common.collect.EnumBiMap'
p3403
sg15
(lp3404
sg17
(lp3405
sg19
(lp3406
sg21
I0
sba(iArchitecture
Entity
p3407
(dp3408
g11
(lp3409
sg13
S'com.google.common.collect.EnumHashBiMap'
p3410
sg15
(lp3411
sg17
(lp3412
sg19
(lp3413
sg21
I0
sba(iArchitecture
Entity
p3414
(dp3415
g11
(lp3416
sg13
S'com.google.common.collect.EnumMultiset'
p3417
sg15
(lp3418
sg17
(lp3419
sg19
(lp3420
sg21
I0
sba(iArchitecture
Entity
p3421
(dp3422
g11
(lp3423
sg13
S'com.google.common.collect.ExplicitOrdering'
p3424
sg15
(lp3425
sg17
(lp3426
sg19
(lp3427
sg21
I0
sba(iArchitecture
Entity
p3428
(dp3429
g11
(lp3430
sg13
S'com.google.common.collect.FilteredEntryMultimap'
p3431
sg15
(lp3432
sg17
(lp3433
sg19
(lp3434
sg21
I0
sba(iArchitecture
Entity
p3435
(dp3436
g11
(lp3437
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap'
p3438
sg15
(lp3439
sg17
(lp3440
sg19
(lp3441
sg21
I0
sba(iArchitecture
Entity
p3442
(dp3443
g11
(lp3444
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$1'
p3445
sg15
(lp3446
sg17
(lp3447
sg19
(lp3448
sg21
I0
sba(iArchitecture
Entity
p3449
(dp3450
g11
(lp3451
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$2'
p3452
sg15
(lp3453
sg17
(lp3454
sg19
(lp3455
sg21
I0
sba(iArchitecture
Entity
p3456
(dp3457
g11
(lp3458
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$2$1'
p3459
sg15
(lp3460
sg17
(lp3461
sg19
(lp3462
sg21
I0
sba(iArchitecture
Entity
p3463
(dp3464
g11
(lp3465
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$3'
p3466
sg15
(lp3467
sg17
(lp3468
sg19
(lp3469
sg21
I0
sba(iArchitecture
Entity
p3470
(dp3471
g11
(lp3472
sg13
S'com.google.common.collect.FilteredEntryMultimap$Keys'
p3473
sg15
(lp3474
sg17
(lp3475
sg19
(lp3476
sg21
I0
sba(iArchitecture
Entity
p3477
(dp3478
g11
(lp3479
sg13
S'com.google.common.collect.FilteredEntryMultimap$Keys$1'
p3480
sg15
(lp3481
sg17
(lp3482
sg19
(lp3483
sg21
I0
sba(iArchitecture
Entity
p3484
(dp3485
g11
(lp3486
sg13
S'com.google.common.collect.FilteredEntryMultimap$Keys$1$1'
p3487
sg15
(lp3488
sg17
(lp3489
sg19
(lp3490
sg21
I0
sba(iArchitecture
Entity
p3491
(dp3492
g11
(lp3493
sg13
S'com.google.common.collect.FilteredEntryMultimap$ValuePredicate'
p3494
sg15
(lp3495
sg17
(lp3496
sg19
(lp3497
sg21
I0
sba(iArchitecture
Entity
p3498
(dp3499
g11
(lp3500
sg13
S'com.google.common.collect.FilteredEntrySetMultimap'
p3501
sg15
(lp3502
sg17
(lp3503
sg19
(lp3504
sg21
I0
sba(iArchitecture
Entity
p3505
(dp3506
g11
(lp3507
sg13
S'com.google.common.collect.FilteredKeyListMultimap'
p3508
sg15
(lp3509
sg17
(lp3510
sg19
(lp3511
sg21
I0
sba(iArchitecture
Entity
p3512
(dp3513
g11
(lp3514
sg13
S'com.google.common.collect.FilteredKeyMultimap'
p3515
sg15
(lp3516
sg17
(lp3517
sg19
(lp3518
sg21
I0
sba(iArchitecture
Entity
p3519
(dp3520
g11
(lp3521
sg13
S'com.google.common.collect.FilteredKeyMultimap$AddRejectingList'
p3522
sg15
(lp3523
sg17
(lp3524
sg19
(lp3525
sg21
I0
sba(iArchitecture
Entity
p3526
(dp3527
g11
(lp3528
sg13
S'com.google.common.collect.FilteredKeyMultimap$AddRejectingSet'
p3529
sg15
(lp3530
sg17
(lp3531
sg19
(lp3532
sg21
I0
sba(iArchitecture
Entity
p3533
(dp3534
g11
(lp3535
sg13
S'com.google.common.collect.FilteredKeyMultimap$Entries'
p3536
sg15
(lp3537
sg17
(lp3538
sg19
(lp3539
sg21
I0
sba(iArchitecture
Entity
p3540
(dp3541
g11
(lp3542
sg13
S'com.google.common.collect.FilteredKeySetMultimap'
p3543
sg15
(lp3544
sg17
(lp3545
sg19
(lp3546
sg21
I0
sba(iArchitecture
Entity
p3547
(dp3548
g11
(lp3549
sg13
S'com.google.common.collect.FilteredKeySetMultimap$EntrySet'
p3550
sg15
(lp3551
sg17
(lp3552
sg19
(lp3553
sg21
I0
sba(iArchitecture
Entity
p3554
(dp3555
g11
(lp3556
sg13
S'com.google.common.collect.FilteredMultimap'
p3557
sg15
(lp3558
sg17
(lp3559
sg19
(lp3560
sg21
I0
sba(iArchitecture
Entity
p3561
(dp3562
g11
(lp3563
sg13
S'com.google.common.collect.FilteredMultimapValues'
p3564
sg15
(lp3565
sg17
(lp3566
sg19
(lp3567
sg21
I0
sba(iArchitecture
Entity
p3568
(dp3569
g11
(lp3570
sg13
S'com.google.common.collect.FilteredSetMultimap'
p3571
sg15
(lp3572
sg17
(lp3573
sg19
(lp3574
sg21
I0
sba(iArchitecture
Entity
p3575
(dp3576
g11
(lp3577
V1963
p3578
ag3578
asg13
S'com.google.common.collect.FluentIterable'
p3579
sg15
(lp3580
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p3581
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p3582
asg17
(lp3583
(lp3584
I0
aag3584
asg19
(lp3585
VDe-@Beta Maps.asMap and toMap
p3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p3587
(dp3588
g11
(lp3589
g3578
ag3578
asg13
S'com.google.common.collect.FluentIterable$1'
p3590
sg15
(lp3591
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p3592
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p3593
asg17
(lp3594
g3584
ag3584
asg19
(lp3595
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p3596
(dp3597
g11
(lp3598
g3578
ag3578
asg13
S'com.google.common.collect.FluentIterable$FromIterableFunction'
p3599
sg15
(lp3600
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p3601
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p3602
asg17
(lp3603
g3584
ag3584
asg19
(lp3604
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p3605
(dp3606
g11
(lp3607
sg13
S'com.google.common.collect.ForwardingBlockingDeque'
p3608
sg15
(lp3609
sg17
(lp3610
sg19
(lp3611
sg21
I0
sba(iArchitecture
Entity
p3612
(dp3613
g11
(lp3614
sg13
S'com.google.common.collect.ForwardingCollection'
p3615
sg15
(lp3616
sg17
(lp3617
sg19
(lp3618
sg21
I0
sba(iArchitecture
Entity
p3619
(dp3620
g11
(lp3621
sg13
S'com.google.common.collect.ForwardingConcurrentMap'
p3622
sg15
(lp3623
sg17
(lp3624
sg19
(lp3625
sg21
I0
sba(iArchitecture
Entity
p3626
(dp3627
g11
(lp3628
sg13
S'com.google.common.collect.ForwardingDeque'
p3629
sg15
(lp3630
sg17
(lp3631
sg19
(lp3632
sg21
I0
sba(iArchitecture
Entity
p3633
(dp3634
g11
(lp3635
sg13
S'com.google.common.collect.ForwardingImmutableCollection'
p3636
sg15
(lp3637
sg17
(lp3638
sg19
(lp3639
sg21
I0
sba(iArchitecture
Entity
p3640
(dp3641
g11
(lp3642
sg13
S'com.google.common.collect.ForwardingImmutableList'
p3643
sg15
(lp3644
sg17
(lp3645
sg19
(lp3646
sg21
I0
sba(iArchitecture
Entity
p3647
(dp3648
g11
(lp3649
sg13
S'com.google.common.collect.ForwardingImmutableMap'
p3650
sg15
(lp3651
sg17
(lp3652
sg19
(lp3653
sg21
I0
sba(iArchitecture
Entity
p3654
(dp3655
g11
(lp3656
sg13
S'com.google.common.collect.ForwardingImmutableSet'
p3657
sg15
(lp3658
sg17
(lp3659
sg19
(lp3660
sg21
I0
sba(iArchitecture
Entity
p3661
(dp3662
g11
(lp3663
sg13
S'com.google.common.collect.ForwardingIterator'
p3664
sg15
(lp3665
sg17
(lp3666
sg19
(lp3667
sg21
I0
sba(iArchitecture
Entity
p3668
(dp3669
g11
(lp3670
sg13
S'com.google.common.collect.ForwardingList'
p3671
sg15
(lp3672
sg17
(lp3673
sg19
(lp3674
sg21
I0
sba(iArchitecture
Entity
p3675
(dp3676
g11
(lp3677
sg13
S'com.google.common.collect.ForwardingListIterator'
p3678
sg15
(lp3679
sg17
(lp3680
sg19
(lp3681
sg21
I0
sba(iArchitecture
Entity
p3682
(dp3683
g11
(lp3684
sg13
S'com.google.common.collect.ForwardingListMultimap'
p3685
sg15
(lp3686
sg17
(lp3687
sg19
(lp3688
sg21
I0
sba(iArchitecture
Entity
p3689
(dp3690
g11
(lp3691
sg13
S'com.google.common.collect.ForwardingMap'
p3692
sg15
(lp3693
sg17
(lp3694
sg19
(lp3695
sg21
I0
sba(iArchitecture
Entity
p3696
(dp3697
g11
(lp3698
sg13
S'com.google.common.collect.ForwardingMap$StandardEntrySet'
p3699
sg15
(lp3700
sg17
(lp3701
sg19
(lp3702
sg21
I0
sba(iArchitecture
Entity
p3703
(dp3704
g11
(lp3705
sg13
S'com.google.common.collect.ForwardingMap$StandardKeySet'
p3706
sg15
(lp3707
sg17
(lp3708
sg19
(lp3709
sg21
I0
sba(iArchitecture
Entity
p3710
(dp3711
g11
(lp3712
sg13
S'com.google.common.collect.ForwardingMap$StandardValues'
p3713
sg15
(lp3714
sg17
(lp3715
sg19
(lp3716
sg21
I0
sba(iArchitecture
Entity
p3717
(dp3718
g11
(lp3719
sg13
S'com.google.common.collect.ForwardingMultimap'
p3720
sg15
(lp3721
sg17
(lp3722
sg19
(lp3723
sg21
I0
sba(iArchitecture
Entity
p3724
(dp3725
g11
(lp3726
sg13
S'com.google.common.collect.ForwardingMultiset'
p3727
sg15
(lp3728
sg17
(lp3729
sg19
(lp3730
sg21
I0
sba(iArchitecture
Entity
p3731
(dp3732
g11
(lp3733
sg13
S'com.google.common.collect.ForwardingMultiset$StandardElementSet'
p3734
sg15
(lp3735
sg17
(lp3736
sg19
(lp3737
sg21
I0
sba(iArchitecture
Entity
p3738
(dp3739
g11
(lp3740
sg13
S'com.google.common.collect.ForwardingNavigableMap'
p3741
sg15
(lp3742
sg17
(lp3743
sg19
(lp3744
sg21
I0
sba(iArchitecture
Entity
p3745
(dp3746
g11
(lp3747
sg13
S'com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap'
p3748
sg15
(lp3749
sg17
(lp3750
sg19
(lp3751
sg21
I0
sba(iArchitecture
Entity
p3752
(dp3753
g11
(lp3754
sg13
S'com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap$1'
p3755
sg15
(lp3756
sg17
(lp3757
sg19
(lp3758
sg21
I0
sba(iArchitecture
Entity
p3759
(dp3760
g11
(lp3761
sg13
S'com.google.common.collect.ForwardingNavigableMap$StandardNavigableKeySet'
p3762
sg15
(lp3763
sg17
(lp3764
sg19
(lp3765
sg21
I0
sba(iArchitecture
Entity
p3766
(dp3767
g11
(lp3768
sg13
S'com.google.common.collect.ForwardingNavigableSet'
p3769
sg15
(lp3770
sg17
(lp3771
sg19
(lp3772
sg21
I0
sba(iArchitecture
Entity
p3773
(dp3774
g11
(lp3775
sg13
S'com.google.common.collect.ForwardingNavigableSet$StandardDescendingSet'
p3776
sg15
(lp3777
sg17
(lp3778
sg19
(lp3779
sg21
I0
sba(iArchitecture
Entity
p3780
(dp3781
g11
(lp3782
sg13
S'com.google.common.collect.ForwardingQueue'
p3783
sg15
(lp3784
sg17
(lp3785
sg19
(lp3786
sg21
I0
sba(iArchitecture
Entity
p3787
(dp3788
g11
(lp3789
sg13
S'com.google.common.collect.ForwardingSet'
p3790
sg15
(lp3791
sg17
(lp3792
sg19
(lp3793
sg21
I0
sba(iArchitecture
Entity
p3794
(dp3795
g11
(lp3796
sg13
S'com.google.common.collect.ForwardingSetMultimap'
p3797
sg15
(lp3798
sg17
(lp3799
sg19
(lp3800
sg21
I0
sba(iArchitecture
Entity
p3801
(dp3802
g11
(lp3803
sg13
S'com.google.common.collect.ForwardingSortedMap'
p3804
sg15
(lp3805
sg17
(lp3806
sg19
(lp3807
sg21
I0
sba(iArchitecture
Entity
p3808
(dp3809
g11
(lp3810
sg13
S'com.google.common.collect.ForwardingSortedMap$StandardKeySet'
p3811
sg15
(lp3812
sg17
(lp3813
sg19
(lp3814
sg21
I0
sba(iArchitecture
Entity
p3815
(dp3816
g11
(lp3817
sg13
S'com.google.common.collect.ForwardingSortedMultiset'
p3818
sg15
(lp3819
sg17
(lp3820
sg19
(lp3821
sg21
I0
sba(iArchitecture
Entity
p3822
(dp3823
g11
(lp3824
sg13
S'com.google.common.collect.ForwardingSortedMultiset$StandardDescendingMultiset'
p3825
sg15
(lp3826
sg17
(lp3827
sg19
(lp3828
sg21
I0
sba(iArchitecture
Entity
p3829
(dp3830
g11
(lp3831
sg13
S'com.google.common.collect.ForwardingSortedMultiset$StandardElementSet'
p3832
sg15
(lp3833
sg17
(lp3834
sg19
(lp3835
sg21
I0
sba(iArchitecture
Entity
p3836
(dp3837
g11
(lp3838
sg13
S'com.google.common.collect.ForwardingSortedSet'
p3839
sg15
(lp3840
sg17
(lp3841
sg19
(lp3842
sg21
I0
sba(iArchitecture
Entity
p3843
(dp3844
g11
(lp3845
sg13
S'com.google.common.collect.ForwardingSortedSetMultimap'
p3846
sg15
(lp3847
sg17
(lp3848
sg19
(lp3849
sg21
I0
sba(iArchitecture
Entity
p3850
(dp3851
g11
(lp3852
sg13
S'com.google.common.collect.ForwardingTable'
p3853
sg15
(lp3854
sg17
(lp3855
sg19
(lp3856
sg21
I0
sba(iArchitecture
Entity
p3857
(dp3858
g11
(lp3859
sg13
S'com.google.common.collect.GeneralRange'
p3860
sg15
(lp3861
sg17
(lp3862
sg19
(lp3863
sg21
I0
sba(iArchitecture
Entity
p3864
(dp3865
g11
(lp3866
sg13
S'com.google.common.collect.GenericMapMaker'
p3867
sg15
(lp3868
sg17
(lp3869
sg19
(lp3870
sg21
I0
sba(iArchitecture
Entity
p3871
(dp3872
g11
(lp3873
sg13
S'com.google.common.collect.GenericMapMaker$NullListener'
p3874
sg15
(lp3875
sg17
(lp3876
sg19
(lp3877
sg21
I0
sba(iArchitecture
Entity
p3878
(dp3879
g11
(lp3880
sg13
S'com.google.common.collect.GwtTransient'
p3881
sg15
(lp3882
sg17
(lp3883
sg19
(lp3884
sg21
I0
sba(iArchitecture
Entity
p3885
(dp3886
g11
(lp3887
sg13
S'com.google.common.collect.HashBasedTable'
p3888
sg15
(lp3889
sg17
(lp3890
sg19
(lp3891
sg21
I0
sba(iArchitecture
Entity
p3892
(dp3893
g11
(lp3894
sg13
S'com.google.common.collect.HashBasedTable$Factory'
p3895
sg15
(lp3896
sg17
(lp3897
sg19
(lp3898
sg21
I0
sba(iArchitecture
Entity
p3899
(dp3900
g11
(lp3901
sg13
S'com.google.common.collect.HashBiMap'
p3902
sg15
(lp3903
sg17
(lp3904
sg19
(lp3905
sg21
I0
sba(iArchitecture
Entity
p3906
(dp3907
g11
(lp3908
sg13
S'com.google.common.collect.HashBiMap$1'
p3909
sg15
(lp3910
sg17
(lp3911
sg19
(lp3912
sg21
I0
sba(iArchitecture
Entity
p3913
(dp3914
g11
(lp3915
sg13
S'com.google.common.collect.HashBiMap$BiEntry'
p3916
sg15
(lp3917
sg17
(lp3918
sg19
(lp3919
sg21
I0
sba(iArchitecture
Entity
p3920
(dp3921
g11
(lp3922
sg13
S'com.google.common.collect.HashBiMap$EntrySet'
p3923
sg15
(lp3924
sg17
(lp3925
sg19
(lp3926
sg21
I0
sba(iArchitecture
Entity
p3927
(dp3928
g11
(lp3929
sg13
S'com.google.common.collect.HashBiMap$EntrySet$1'
p3930
sg15
(lp3931
sg17
(lp3932
sg19
(lp3933
sg21
I0
sba(iArchitecture
Entity
p3934
(dp3935
g11
(lp3936
sg13
S'com.google.common.collect.HashBiMap$EntrySet$1$MapEntry'
p3937
sg15
(lp3938
sg17
(lp3939
sg19
(lp3940
sg21
I0
sba(iArchitecture
Entity
p3941
(dp3942
g11
(lp3943
sg13
S'com.google.common.collect.HashBiMap$EntrySet$1.MapEntry'
p3944
sg15
(lp3945
sg17
(lp3946
sg19
(lp3947
sg21
I0
sba(iArchitecture
Entity
p3948
(dp3949
g11
(lp3950
sg13
S'com.google.common.collect.HashBiMap$Inverse'
p3951
sg15
(lp3952
sg17
(lp3953
sg19
(lp3954
sg21
I0
sba(iArchitecture
Entity
p3955
(dp3956
g11
(lp3957
sg13
S'com.google.common.collect.HashBiMap$Inverse$1'
p3958
sg15
(lp3959
sg17
(lp3960
sg19
(lp3961
sg21
I0
sba(iArchitecture
Entity
p3962
(dp3963
g11
(lp3964
sg13
S'com.google.common.collect.HashBiMap$Inverse$1$1'
p3965
sg15
(lp3966
sg17
(lp3967
sg19
(lp3968
sg21
I0
sba(iArchitecture
Entity
p3969
(dp3970
g11
(lp3971
sg13
S'com.google.common.collect.HashBiMap$Inverse$1$1$InverseEntry'
p3972
sg15
(lp3973
sg17
(lp3974
sg19
(lp3975
sg21
I0
sba(iArchitecture
Entity
p3976
(dp3977
g11
(lp3978
sg13
S'com.google.common.collect.HashBiMap$Inverse$1$1.InverseEntry'
p3979
sg15
(lp3980
sg17
(lp3981
sg19
(lp3982
sg21
I0
sba(iArchitecture
Entity
p3983
(dp3984
g11
(lp3985
sg13
S'com.google.common.collect.HashBiMap$Inverse$InverseKeySet'
p3986
sg15
(lp3987
sg17
(lp3988
sg19
(lp3989
sg21
I0
sba(iArchitecture
Entity
p3990
(dp3991
g11
(lp3992
sg13
S'com.google.common.collect.HashBiMap$Inverse$InverseKeySet$1'
p3993
sg15
(lp3994
sg17
(lp3995
sg19
(lp3996
sg21
I0
sba(iArchitecture
Entity
p3997
(dp3998
g11
(lp3999
sg13
S'com.google.common.collect.HashBiMap$InverseSerializedForm'
p4000
sg15
(lp4001
sg17
(lp4002
sg19
(lp4003
sg21
I0
sba(iArchitecture
Entity
p4004
(dp4005
g11
(lp4006
sg13
S'com.google.common.collect.HashBiMap$Itr'
p4007
sg15
(lp4008
sg17
(lp4009
sg19
(lp4010
sg21
I0
sba(iArchitecture
Entity
p4011
(dp4012
g11
(lp4013
sg13
S'com.google.common.collect.HashBiMap$KeySet'
p4014
sg15
(lp4015
sg17
(lp4016
sg19
(lp4017
sg21
I0
sba(iArchitecture
Entity
p4018
(dp4019
g11
(lp4020
sg13
S'com.google.common.collect.HashBiMap$KeySet$1'
p4021
sg15
(lp4022
sg17
(lp4023
sg19
(lp4024
sg21
I0
sba(iArchitecture
Entity
p4025
(dp4026
g11
(lp4027
sg13
S'com.google.common.collect.HashMultiset'
p4028
sg15
(lp4029
sg17
(lp4030
sg19
(lp4031
sg21
I0
sba(iArchitecture
Entity
p4032
(dp4033
g11
(lp4034
sg13
S'com.google.common.collect.Hashing'
p4035
sg15
(lp4036
sg17
(lp4037
sg19
(lp4038
sg21
I0
sba(iArchitecture
Entity
p4039
(dp4040
g11
(lp4041
g25
asg13
S'com.google.common.collect.ImmutableAsList'
p4042
sg15
(lp4043
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4044
asg17
(lp4045
g32
asg19
(lp4046
g35
asg21
I0
sba(iArchitecture
Entity
p4047
(dp4048
g11
(lp4049
g25
asg13
S'com.google.common.collect.ImmutableAsList$SerializedForm'
p4050
sg15
(lp4051
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4052
asg17
(lp4053
g32
asg19
(lp4054
g35
asg21
I0
sba(iArchitecture
Entity
p4055
(dp4056
g11
(lp4057
sg13
S'com.google.common.collect.ImmutableBiMap'
p4058
sg15
(lp4059
sg17
(lp4060
sg19
(lp4061
sg21
I0
sba(iArchitecture
Entity
p4062
(dp4063
g11
(lp4064
sg13
S'com.google.common.collect.ImmutableBiMap$Builder'
p4065
sg15
(lp4066
sg17
(lp4067
sg19
(lp4068
sg21
I0
sba(iArchitecture
Entity
p4069
(dp4070
g11
(lp4071
sg13
S'com.google.common.collect.ImmutableBiMap$SerializedForm'
p4072
sg15
(lp4073
sg17
(lp4074
sg19
(lp4075
sg21
I0
sba(iArchitecture
Entity
p4076
(dp4077
g11
(lp4078
sg13
S'com.google.common.collect.ImmutableClassToInstanceMap'
p4079
sg15
(lp4080
sg17
(lp4081
sg19
(lp4082
sg21
I0
sba(iArchitecture
Entity
p4083
(dp4084
g11
(lp4085
sg13
S'com.google.common.collect.ImmutableClassToInstanceMap$1'
p4086
sg15
(lp4087
sg17
(lp4088
sg19
(lp4089
sg21
I0
sba(iArchitecture
Entity
p4090
(dp4091
g11
(lp4092
sg13
S'com.google.common.collect.ImmutableClassToInstanceMap$Builder'
p4093
sg15
(lp4094
sg17
(lp4095
sg19
(lp4096
sg21
I0
sba(iArchitecture
Entity
p4097
(dp4098
g11
(lp4099
sg13
S'com.google.common.collect.ImmutableCollection'
p4100
sg15
(lp4101
sg17
(lp4102
sg19
(lp4103
sg21
I0
sba(iArchitecture
Entity
p4104
(dp4105
g11
(lp4106
sg13
S'com.google.common.collect.ImmutableCollection$ArrayBasedBuilder'
p4107
sg15
(lp4108
sg17
(lp4109
sg19
(lp4110
sg21
I0
sba(iArchitecture
Entity
p4111
(dp4112
g11
(lp4113
sg13
S'com.google.common.collect.ImmutableCollection$Builder'
p4114
sg15
(lp4115
sg17
(lp4116
sg19
(lp4117
sg21
I0
sba(iArchitecture
Entity
p4118
(dp4119
g11
(lp4120
sg13
S'com.google.common.collect.ImmutableEntry'
p4121
sg15
(lp4122
sg17
(lp4123
sg19
(lp4124
sg21
I0
sba(iArchitecture
Entity
p4125
(dp4126
g11
(lp4127
sg13
S'com.google.common.collect.ImmutableEnumMap'
p4128
sg15
(lp4129
sg17
(lp4130
sg19
(lp4131
sg21
I0
sba(iArchitecture
Entity
p4132
(dp4133
g11
(lp4134
sg13
S'com.google.common.collect.ImmutableEnumMap$1'
p4135
sg15
(lp4136
sg17
(lp4137
sg19
(lp4138
sg21
I0
sba(iArchitecture
Entity
p4139
(dp4140
g11
(lp4141
sg13
S'com.google.common.collect.ImmutableEnumMap$2'
p4142
sg15
(lp4143
sg17
(lp4144
sg19
(lp4145
sg21
I0
sba(iArchitecture
Entity
p4146
(dp4147
g11
(lp4148
sg13
S'com.google.common.collect.ImmutableEnumMap$2$1'
p4149
sg15
(lp4150
sg17
(lp4151
sg19
(lp4152
sg21
I0
sba(iArchitecture
Entity
p4153
(dp4154
g11
(lp4155
sg13
S'com.google.common.collect.ImmutableEnumMap$EnumSerializedForm'
p4156
sg15
(lp4157
sg17
(lp4158
sg19
(lp4159
sg21
I0
sba(iArchitecture
Entity
p4160
(dp4161
g11
(lp4162
sg13
S'com.google.common.collect.ImmutableEnumSet'
p4163
sg15
(lp4164
sg17
(lp4165
sg19
(lp4166
sg21
I0
sba(iArchitecture
Entity
p4167
(dp4168
g11
(lp4169
sg13
S'com.google.common.collect.ImmutableEnumSet$1'
p4170
sg15
(lp4171
sg17
(lp4172
sg19
(lp4173
sg21
I0
sba(iArchitecture
Entity
p4174
(dp4175
g11
(lp4176
sg13
S'com.google.common.collect.ImmutableEnumSet$EnumSerializedForm'
p4177
sg15
(lp4178
sg17
(lp4179
sg19
(lp4180
sg21
I0
sba(iArchitecture
Entity
p4181
(dp4182
g11
(lp4183
g25
aV1977
p4184
asg13
S'com.google.common.collect.ImmutableList'
p4185
sg15
(lp4186
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4187
aVImmutableList contains following code since version 15.0\u000a\u000a private static final ImmutableList<Object> EMPTY =\u000a      new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);\u000a
p4188
asg17
(lp4189
g32
a(lp4190
I1
aasg19
(lp4191
g35
aVPossible deadlock in ImmutableList 
p4192
asg21
I0
sba(iArchitecture
Entity
p4193
(dp4194
g11
(lp4195
g25
ag4184
asg13
S'com.google.common.collect.ImmutableList$1'
p4196
sg15
(lp4197
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4198
aVImmutableList contains following code since version 15.0\u000a\u000a private static final ImmutableList<Object> EMPTY =\u000a      new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);\u000a
p4199
asg17
(lp4200
g32
ag4190
asg19
(lp4201
g35
ag4192
asg21
I0
sba(iArchitecture
Entity
p4202
(dp4203
g11
(lp4204
g25
ag4184
asg13
S'com.google.common.collect.ImmutableList$Builder'
p4205
sg15
(lp4206
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4207
aVImmutableList contains following code since version 15.0\u000a\u000a private static final ImmutableList<Object> EMPTY =\u000a      new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);\u000a
p4208
asg17
(lp4209
g32
ag4190
asg19
(lp4210
g35
ag4192
asg21
I0
sba(iArchitecture
Entity
p4211
(dp4212
g11
(lp4213
g25
ag4184
asg13
S'com.google.common.collect.ImmutableList$ReverseImmutableList'
p4214
sg15
(lp4215
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4216
aVImmutableList contains following code since version 15.0\u000a\u000a private static final ImmutableList<Object> EMPTY =\u000a      new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);\u000a
p4217
asg17
(lp4218
g32
ag4190
asg19
(lp4219
g35
ag4192
asg21
I0
sba(iArchitecture
Entity
p4220
(dp4221
g11
(lp4222
g25
ag4184
asg13
S'com.google.common.collect.ImmutableList$SerializedForm'
p4223
sg15
(lp4224
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4225
aVImmutableList contains following code since version 15.0\u000a\u000a private static final ImmutableList<Object> EMPTY =\u000a      new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);\u000a
p4226
asg17
(lp4227
g32
ag4190
asg19
(lp4228
g35
ag4192
asg21
I0
sba(iArchitecture
Entity
p4229
(dp4230
g11
(lp4231
g25
ag4184
asg13
S'com.google.common.collect.ImmutableList$SubList'
p4232
sg15
(lp4233
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4234
aVImmutableList contains following code since version 15.0\u000a\u000a private static final ImmutableList<Object> EMPTY =\u000a      new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);\u000a
p4235
asg17
(lp4236
g32
ag4190
asg19
(lp4237
g35
ag4192
asg21
I0
sba(iArchitecture
Entity
p4238
(dp4239
g11
(lp4240
sg13
S'com.google.common.collect.ImmutableListMultimap'
p4241
sg15
(lp4242
sg17
(lp4243
sg19
(lp4244
sg21
I0
sba(iArchitecture
Entity
p4245
(dp4246
g11
(lp4247
sg13
S'com.google.common.collect.ImmutableListMultimap$Builder'
p4248
sg15
(lp4249
sg17
(lp4250
sg19
(lp4251
sg21
I0
sba(iArchitecture
Entity
p4252
(dp4253
g11
(lp4254
V2082
p4255
asg13
S'com.google.common.collect.ImmutableMap'
p4256
sg15
(lp4257
VI'm a [Spoon](https://github.com/INRIA/spoon) contributor, an open source project to analyse and transform Java source code. This project have a dependency to [JDT](https://eclipse.org/jdt/) to compile target source code. Recently, I tried to analyse Guava with Spoon but JDT can't compile our project.\u000a\u000aWhat is the problem?\u000a\u000aIn [`ImmutableMap`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java) class, we have these methods:\u000a\u000a``` java\u000a// If the map is an EnumMap, it must have key type K for some <K extends Enum<K>>.\u000a@SuppressWarnings({"unchecked", "rawtypes"})\u000aprivate static <K, V> ImmutableMap<K, V> copyOfEnumMapUnsafe(Map<? extends K, ? extends V> map) {\u000a    return copyOfEnumMap((EnumMap) map);\u000a}\u000a\u000aprivate static <K extends Enum<K>, V> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    EnumMap<K, V> copy = new EnumMap<K, V>(original);\u000a    for (Map.Entry<?, ?> entry : copy.entrySet()) {\u000a        checkEntryNotNull(entry.getKey(), entry.getValue());\u000a    }\u000a    return ImmutableEnumMap.asImmutable(copy);\u000a}\u000a```\u000a\u000aThis code is valid but there is an error from JDT:\u000a\u000a> Type mismatch: cannot convert from `<Enum<Enum<K>>>` to `<K>`\u000a\u000aBefore the creation of this issue, I reported the bug in the bugtracker of JDT (issue [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404)). In 2 words, the conclusion was that: "Yes, JDT don't support this usage of Java but there is a better practice". This better practice is explained [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404#c3):\u000a\u000a``` java\u000aprivate static <K extends Enum<K>> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    return copyOfEnumMap((EnumMap<K,?>) map);\u000a}\u000a```\u000a\u000aI tried some tricky solutions but, unfortunately, this solution can't be applied in your project. So I come to notify you that your project can't be compiled by JDT.\u000a
p4258
asg17
(lp4259
(lp4260
asg19
(lp4261
VGuava can't be compiled by JDT
p4262
asg21
I0
sba(iArchitecture
Entity
p4263
(dp4264
g11
(lp4265
g4255
asg13
S'com.google.common.collect.ImmutableMap$Builder'
p4266
sg15
(lp4267
VI'm a [Spoon](https://github.com/INRIA/spoon) contributor, an open source project to analyse and transform Java source code. This project have a dependency to [JDT](https://eclipse.org/jdt/) to compile target source code. Recently, I tried to analyse Guava with Spoon but JDT can't compile our project.\u000a\u000aWhat is the problem?\u000a\u000aIn [`ImmutableMap`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java) class, we have these methods:\u000a\u000a``` java\u000a// If the map is an EnumMap, it must have key type K for some <K extends Enum<K>>.\u000a@SuppressWarnings({"unchecked", "rawtypes"})\u000aprivate static <K, V> ImmutableMap<K, V> copyOfEnumMapUnsafe(Map<? extends K, ? extends V> map) {\u000a    return copyOfEnumMap((EnumMap) map);\u000a}\u000a\u000aprivate static <K extends Enum<K>, V> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    EnumMap<K, V> copy = new EnumMap<K, V>(original);\u000a    for (Map.Entry<?, ?> entry : copy.entrySet()) {\u000a        checkEntryNotNull(entry.getKey(), entry.getValue());\u000a    }\u000a    return ImmutableEnumMap.asImmutable(copy);\u000a}\u000a```\u000a\u000aThis code is valid but there is an error from JDT:\u000a\u000a> Type mismatch: cannot convert from `<Enum<Enum<K>>>` to `<K>`\u000a\u000aBefore the creation of this issue, I reported the bug in the bugtracker of JDT (issue [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404)). In 2 words, the conclusion was that: "Yes, JDT don't support this usage of Java but there is a better practice". This better practice is explained [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404#c3):\u000a\u000a``` java\u000aprivate static <K extends Enum<K>> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    return copyOfEnumMap((EnumMap<K,?>) map);\u000a}\u000a```\u000a\u000aI tried some tricky solutions but, unfortunately, this solution can't be applied in your project. So I come to notify you that your project can't be compiled by JDT.\u000a
p4268
asg17
(lp4269
g4260
asg19
(lp4270
g4262
asg21
I0
sba(iArchitecture
Entity
p4271
(dp4272
g11
(lp4273
g4255
asg13
S'com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets'
p4274
sg15
(lp4275
VI'm a [Spoon](https://github.com/INRIA/spoon) contributor, an open source project to analyse and transform Java source code. This project have a dependency to [JDT](https://eclipse.org/jdt/) to compile target source code. Recently, I tried to analyse Guava with Spoon but JDT can't compile our project.\u000a\u000aWhat is the problem?\u000a\u000aIn [`ImmutableMap`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java) class, we have these methods:\u000a\u000a``` java\u000a// If the map is an EnumMap, it must have key type K for some <K extends Enum<K>>.\u000a@SuppressWarnings({"unchecked", "rawtypes"})\u000aprivate static <K, V> ImmutableMap<K, V> copyOfEnumMapUnsafe(Map<? extends K, ? extends V> map) {\u000a    return copyOfEnumMap((EnumMap) map);\u000a}\u000a\u000aprivate static <K extends Enum<K>, V> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    EnumMap<K, V> copy = new EnumMap<K, V>(original);\u000a    for (Map.Entry<?, ?> entry : copy.entrySet()) {\u000a        checkEntryNotNull(entry.getKey(), entry.getValue());\u000a    }\u000a    return ImmutableEnumMap.asImmutable(copy);\u000a}\u000a```\u000a\u000aThis code is valid but there is an error from JDT:\u000a\u000a> Type mismatch: cannot convert from `<Enum<Enum<K>>>` to `<K>`\u000a\u000aBefore the creation of this issue, I reported the bug in the bugtracker of JDT (issue [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404)). In 2 words, the conclusion was that: "Yes, JDT don't support this usage of Java but there is a better practice". This better practice is explained [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404#c3):\u000a\u000a``` java\u000aprivate static <K extends Enum<K>> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    return copyOfEnumMap((EnumMap<K,?>) map);\u000a}\u000a```\u000a\u000aI tried some tricky solutions but, unfortunately, this solution can't be applied in your project. So I come to notify you that your project can't be compiled by JDT.\u000a
p4276
asg17
(lp4277
g4260
asg19
(lp4278
g4262
asg21
I0
sba(iArchitecture
Entity
p4279
(dp4280
g11
(lp4281
g4255
asg13
S'com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1'
p4282
sg15
(lp4283
VI'm a [Spoon](https://github.com/INRIA/spoon) contributor, an open source project to analyse and transform Java source code. This project have a dependency to [JDT](https://eclipse.org/jdt/) to compile target source code. Recently, I tried to analyse Guava with Spoon but JDT can't compile our project.\u000a\u000aWhat is the problem?\u000a\u000aIn [`ImmutableMap`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java) class, we have these methods:\u000a\u000a``` java\u000a// If the map is an EnumMap, it must have key type K for some <K extends Enum<K>>.\u000a@SuppressWarnings({"unchecked", "rawtypes"})\u000aprivate static <K, V> ImmutableMap<K, V> copyOfEnumMapUnsafe(Map<? extends K, ? extends V> map) {\u000a    return copyOfEnumMap((EnumMap) map);\u000a}\u000a\u000aprivate static <K extends Enum<K>, V> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    EnumMap<K, V> copy = new EnumMap<K, V>(original);\u000a    for (Map.Entry<?, ?> entry : copy.entrySet()) {\u000a        checkEntryNotNull(entry.getKey(), entry.getValue());\u000a    }\u000a    return ImmutableEnumMap.asImmutable(copy);\u000a}\u000a```\u000a\u000aThis code is valid but there is an error from JDT:\u000a\u000a> Type mismatch: cannot convert from `<Enum<Enum<K>>>` to `<K>`\u000a\u000aBefore the creation of this issue, I reported the bug in the bugtracker of JDT (issue [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404)). In 2 words, the conclusion was that: "Yes, JDT don't support this usage of Java but there is a better practice". This better practice is explained [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404#c3):\u000a\u000a``` java\u000aprivate static <K extends Enum<K>> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    return copyOfEnumMap((EnumMap<K,?>) map);\u000a}\u000a```\u000a\u000aI tried some tricky solutions but, unfortunately, this solution can't be applied in your project. So I come to notify you that your project can't be compiled by JDT.\u000a
p4284
asg17
(lp4285
g4260
asg19
(lp4286
g4262
asg21
I0
sba(iArchitecture
Entity
p4287
(dp4288
g11
(lp4289
g4255
asg13
S'com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1$1'
p4290
sg15
(lp4291
VI'm a [Spoon](https://github.com/INRIA/spoon) contributor, an open source project to analyse and transform Java source code. This project have a dependency to [JDT](https://eclipse.org/jdt/) to compile target source code. Recently, I tried to analyse Guava with Spoon but JDT can't compile our project.\u000a\u000aWhat is the problem?\u000a\u000aIn [`ImmutableMap`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java) class, we have these methods:\u000a\u000a``` java\u000a// If the map is an EnumMap, it must have key type K for some <K extends Enum<K>>.\u000a@SuppressWarnings({"unchecked", "rawtypes"})\u000aprivate static <K, V> ImmutableMap<K, V> copyOfEnumMapUnsafe(Map<? extends K, ? extends V> map) {\u000a    return copyOfEnumMap((EnumMap) map);\u000a}\u000a\u000aprivate static <K extends Enum<K>, V> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    EnumMap<K, V> copy = new EnumMap<K, V>(original);\u000a    for (Map.Entry<?, ?> entry : copy.entrySet()) {\u000a        checkEntryNotNull(entry.getKey(), entry.getValue());\u000a    }\u000a    return ImmutableEnumMap.asImmutable(copy);\u000a}\u000a```\u000a\u000aThis code is valid but there is an error from JDT:\u000a\u000a> Type mismatch: cannot convert from `<Enum<Enum<K>>>` to `<K>`\u000a\u000aBefore the creation of this issue, I reported the bug in the bugtracker of JDT (issue [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404)). In 2 words, the conclusion was that: "Yes, JDT don't support this usage of Java but there is a better practice". This better practice is explained [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404#c3):\u000a\u000a``` java\u000aprivate static <K extends Enum<K>> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    return copyOfEnumMap((EnumMap<K,?>) map);\u000a}\u000a```\u000a\u000aI tried some tricky solutions but, unfortunately, this solution can't be applied in your project. So I come to notify you that your project can't be compiled by JDT.\u000a
p4292
asg17
(lp4293
g4260
asg19
(lp4294
g4262
asg21
I0
sba(iArchitecture
Entity
p4295
(dp4296
g11
(lp4297
g4255
asg13
S'com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1$1$1'
p4298
sg15
(lp4299
VI'm a [Spoon](https://github.com/INRIA/spoon) contributor, an open source project to analyse and transform Java source code. This project have a dependency to [JDT](https://eclipse.org/jdt/) to compile target source code. Recently, I tried to analyse Guava with Spoon but JDT can't compile our project.\u000a\u000aWhat is the problem?\u000a\u000aIn [`ImmutableMap`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java) class, we have these methods:\u000a\u000a``` java\u000a// If the map is an EnumMap, it must have key type K for some <K extends Enum<K>>.\u000a@SuppressWarnings({"unchecked", "rawtypes"})\u000aprivate static <K, V> ImmutableMap<K, V> copyOfEnumMapUnsafe(Map<? extends K, ? extends V> map) {\u000a    return copyOfEnumMap((EnumMap) map);\u000a}\u000a\u000aprivate static <K extends Enum<K>, V> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    EnumMap<K, V> copy = new EnumMap<K, V>(original);\u000a    for (Map.Entry<?, ?> entry : copy.entrySet()) {\u000a        checkEntryNotNull(entry.getKey(), entry.getValue());\u000a    }\u000a    return ImmutableEnumMap.asImmutable(copy);\u000a}\u000a```\u000a\u000aThis code is valid but there is an error from JDT:\u000a\u000a> Type mismatch: cannot convert from `<Enum<Enum<K>>>` to `<K>`\u000a\u000aBefore the creation of this issue, I reported the bug in the bugtracker of JDT (issue [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404)). In 2 words, the conclusion was that: "Yes, JDT don't support this usage of Java but there is a better practice". This better practice is explained [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404#c3):\u000a\u000a``` java\u000aprivate static <K extends Enum<K>> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    return copyOfEnumMap((EnumMap<K,?>) map);\u000a}\u000a```\u000a\u000aI tried some tricky solutions but, unfortunately, this solution can't be applied in your project. So I come to notify you that your project can't be compiled by JDT.\u000a
p4300
asg17
(lp4301
g4260
asg19
(lp4302
g4262
asg21
I0
sba(iArchitecture
Entity
p4303
(dp4304
g11
(lp4305
g4255
asg13
S'com.google.common.collect.ImmutableMap$SerializedForm'
p4306
sg15
(lp4307
VI'm a [Spoon](https://github.com/INRIA/spoon) contributor, an open source project to analyse and transform Java source code. This project have a dependency to [JDT](https://eclipse.org/jdt/) to compile target source code. Recently, I tried to analyse Guava with Spoon but JDT can't compile our project.\u000a\u000aWhat is the problem?\u000a\u000aIn [`ImmutableMap`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java) class, we have these methods:\u000a\u000a``` java\u000a// If the map is an EnumMap, it must have key type K for some <K extends Enum<K>>.\u000a@SuppressWarnings({"unchecked", "rawtypes"})\u000aprivate static <K, V> ImmutableMap<K, V> copyOfEnumMapUnsafe(Map<? extends K, ? extends V> map) {\u000a    return copyOfEnumMap((EnumMap) map);\u000a}\u000a\u000aprivate static <K extends Enum<K>, V> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    EnumMap<K, V> copy = new EnumMap<K, V>(original);\u000a    for (Map.Entry<?, ?> entry : copy.entrySet()) {\u000a        checkEntryNotNull(entry.getKey(), entry.getValue());\u000a    }\u000a    return ImmutableEnumMap.asImmutable(copy);\u000a}\u000a```\u000a\u000aThis code is valid but there is an error from JDT:\u000a\u000a> Type mismatch: cannot convert from `<Enum<Enum<K>>>` to `<K>`\u000a\u000aBefore the creation of this issue, I reported the bug in the bugtracker of JDT (issue [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404)). In 2 words, the conclusion was that: "Yes, JDT don't support this usage of Java but there is a better practice". This better practice is explained [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404#c3):\u000a\u000a``` java\u000aprivate static <K extends Enum<K>> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\u000a    return copyOfEnumMap((EnumMap<K,?>) map);\u000a}\u000a```\u000a\u000aI tried some tricky solutions but, unfortunately, this solution can't be applied in your project. So I come to notify you that your project can't be compiled by JDT.\u000a
p4308
asg17
(lp4309
g4260
asg19
(lp4310
g4262
asg21
I0
sba(iArchitecture
Entity
p4311
(dp4312
g11
(lp4313
sg13
S'com.google.common.collect.ImmutableMapEntry'
p4314
sg15
(lp4315
sg17
(lp4316
sg19
(lp4317
sg21
I0
sba(iArchitecture
Entity
p4318
(dp4319
g11
(lp4320
sg13
S'com.google.common.collect.ImmutableMapEntry$TerminalEntry'
p4321
sg15
(lp4322
sg17
(lp4323
sg19
(lp4324
sg21
I0
sba(iArchitecture
Entity
p4325
(dp4326
g11
(lp4327
sg13
S'com.google.common.collect.ImmutableMapEntrySet'
p4328
sg15
(lp4329
sg17
(lp4330
sg19
(lp4331
sg21
I0
sba(iArchitecture
Entity
p4332
(dp4333
g11
(lp4334
sg13
S'com.google.common.collect.ImmutableMapEntrySet$EntrySetSerializedForm'
p4335
sg15
(lp4336
sg17
(lp4337
sg19
(lp4338
sg21
I0
sba(iArchitecture
Entity
p4339
(dp4340
g11
(lp4341
sg13
S'com.google.common.collect.ImmutableMapKeySet'
p4342
sg15
(lp4343
sg17
(lp4344
sg19
(lp4345
sg21
I0
sba(iArchitecture
Entity
p4346
(dp4347
g11
(lp4348
sg13
S'com.google.common.collect.ImmutableMapKeySet$1'
p4349
sg15
(lp4350
sg17
(lp4351
sg19
(lp4352
sg21
I0
sba(iArchitecture
Entity
p4353
(dp4354
g11
(lp4355
sg13
S'com.google.common.collect.ImmutableMapKeySet$KeySetSerializedForm'
p4356
sg15
(lp4357
sg17
(lp4358
sg19
(lp4359
sg21
I0
sba(iArchitecture
Entity
p4360
(dp4361
g11
(lp4362
sg13
S'com.google.common.collect.ImmutableMapValues'
p4363
sg15
(lp4364
sg17
(lp4365
sg19
(lp4366
sg21
I0
sba(iArchitecture
Entity
p4367
(dp4368
g11
(lp4369
sg13
S'com.google.common.collect.ImmutableMapValues$1'
p4370
sg15
(lp4371
sg17
(lp4372
sg19
(lp4373
sg21
I0
sba(iArchitecture
Entity
p4374
(dp4375
g11
(lp4376
sg13
S'com.google.common.collect.ImmutableMapValues$SerializedForm'
p4377
sg15
(lp4378
sg17
(lp4379
sg19
(lp4380
sg21
I0
sba(iArchitecture
Entity
p4381
(dp4382
g11
(lp4383
sg13
S'com.google.common.collect.ImmutableMultimap'
p4384
sg15
(lp4385
sg17
(lp4386
sg19
(lp4387
sg21
I0
sba(iArchitecture
Entity
p4388
(dp4389
g11
(lp4390
sg13
S'com.google.common.collect.ImmutableMultimap$1'
p4391
sg15
(lp4392
sg17
(lp4393
sg19
(lp4394
sg21
I0
sba(iArchitecture
Entity
p4395
(dp4396
g11
(lp4397
sg13
S'com.google.common.collect.ImmutableMultimap$2'
p4398
sg15
(lp4399
sg17
(lp4400
sg19
(lp4401
sg21
I0
sba(iArchitecture
Entity
p4402
(dp4403
g11
(lp4404
sg13
S'com.google.common.collect.ImmutableMultimap$Builder'
p4405
sg15
(lp4406
sg17
(lp4407
sg19
(lp4408
sg21
I0
sba(iArchitecture
Entity
p4409
(dp4410
g11
(lp4411
sg13
S'com.google.common.collect.ImmutableMultimap$BuilderMultimap'
p4412
sg15
(lp4413
sg17
(lp4414
sg19
(lp4415
sg21
I0
sba(iArchitecture
Entity
p4416
(dp4417
g11
(lp4418
sg13
S'com.google.common.collect.ImmutableMultimap$EntryCollection'
p4419
sg15
(lp4420
sg17
(lp4421
sg19
(lp4422
sg21
I0
sba(iArchitecture
Entity
p4423
(dp4424
g11
(lp4425
sg13
S'com.google.common.collect.ImmutableMultimap$FieldSettersHolder'
p4426
sg15
(lp4427
sg17
(lp4428
sg19
(lp4429
sg21
I0
sba(iArchitecture
Entity
p4430
(dp4431
g11
(lp4432
sg13
S'com.google.common.collect.ImmutableMultimap$Itr'
p4433
sg15
(lp4434
sg17
(lp4435
sg19
(lp4436
sg21
I0
sba(iArchitecture
Entity
p4437
(dp4438
g11
(lp4439
sg13
S'com.google.common.collect.ImmutableMultimap$Keys'
p4440
sg15
(lp4441
sg17
(lp4442
sg19
(lp4443
sg21
I0
sba(iArchitecture
Entity
p4444
(dp4445
g11
(lp4446
sg13
S'com.google.common.collect.ImmutableMultimap$Values'
p4447
sg15
(lp4448
sg17
(lp4449
sg19
(lp4450
sg21
I0
sba(iArchitecture
Entity
p4451
(dp4452
g11
(lp4453
sg13
S'com.google.common.collect.ImmutableMultiset'
p4454
sg15
(lp4455
sg17
(lp4456
sg19
(lp4457
sg21
I0
sba(iArchitecture
Entity
p4458
(dp4459
g11
(lp4460
sg13
S'com.google.common.collect.ImmutableMultiset$1'
p4461
sg15
(lp4462
sg17
(lp4463
sg19
(lp4464
sg21
I0
sba(iArchitecture
Entity
p4465
(dp4466
g11
(lp4467
sg13
S'com.google.common.collect.ImmutableMultiset$Builder'
p4468
sg15
(lp4469
sg17
(lp4470
sg19
(lp4471
sg21
I0
sba(iArchitecture
Entity
p4472
(dp4473
g11
(lp4474
sg13
S'com.google.common.collect.ImmutableMultiset$EntrySet'
p4475
sg15
(lp4476
sg17
(lp4477
sg19
(lp4478
sg21
I0
sba(iArchitecture
Entity
p4479
(dp4480
g11
(lp4481
sg13
S'com.google.common.collect.ImmutableMultiset$EntrySet$1'
p4482
sg15
(lp4483
sg17
(lp4484
sg19
(lp4485
sg21
I0
sba(iArchitecture
Entity
p4486
(dp4487
g11
(lp4488
sg13
S'com.google.common.collect.ImmutableMultiset$EntrySetSerializedForm'
p4489
sg15
(lp4490
sg17
(lp4491
sg19
(lp4492
sg21
I0
sba(iArchitecture
Entity
p4493
(dp4494
g11
(lp4495
sg13
S'com.google.common.collect.ImmutableMultiset$SerializedForm'
p4496
sg15
(lp4497
sg17
(lp4498
sg19
(lp4499
sg21
I0
sba(iArchitecture
Entity
p4500
(dp4501
g11
(lp4502
V2258
p4503
asg13
S'com.google.common.collect.ImmutableRangeMap'
p4504
sg15
(lp4505
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4506
asg17
(lp4507
(lp4508
I2
aasg19
(lp4509
VMutable operations on ImmutableRangeSet should be deprecated
p4510
asg21
I0
sba(iArchitecture
Entity
p4511
(dp4512
g11
(lp4513
g4503
asg13
S'com.google.common.collect.ImmutableRangeMap$1'
p4514
sg15
(lp4515
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4516
asg17
(lp4517
g4508
asg19
(lp4518
g4510
asg21
I0
sba(iArchitecture
Entity
p4519
(dp4520
g11
(lp4521
g4503
asg13
S'com.google.common.collect.ImmutableRangeMap$2'
p4522
sg15
(lp4523
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4524
asg17
(lp4525
g4508
asg19
(lp4526
g4510
asg21
I0
sba(iArchitecture
Entity
p4527
(dp4528
g11
(lp4529
g4503
asg13
S'com.google.common.collect.ImmutableRangeMap$Builder'
p4530
sg15
(lp4531
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4532
asg17
(lp4533
g4508
asg19
(lp4534
g4510
asg21
I0
sba(iArchitecture
Entity
p4535
(dp4536
g11
(lp4537
g4503
asg13
S'com.google.common.collect.ImmutableRangeSet'
p4538
sg15
(lp4539
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4540
asg17
(lp4541
g4508
asg19
(lp4542
g4510
asg21
I0
sba(iArchitecture
Entity
p4543
(dp4544
g11
(lp4545
g4503
asg13
S'com.google.common.collect.ImmutableRangeSet$1'
p4546
sg15
(lp4547
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4548
asg17
(lp4549
g4508
asg19
(lp4550
g4510
asg21
I0
sba(iArchitecture
Entity
p4551
(dp4552
g11
(lp4553
g4503
asg13
S'com.google.common.collect.ImmutableRangeSet$AsSet'
p4554
sg15
(lp4555
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4556
asg17
(lp4557
g4508
asg19
(lp4558
g4510
asg21
I0
sba(iArchitecture
Entity
p4559
(dp4560
g11
(lp4561
g4503
asg13
S'com.google.common.collect.ImmutableRangeSet$AsSet$1'
p4562
sg15
(lp4563
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4564
asg17
(lp4565
g4508
asg19
(lp4566
g4510
asg21
I0
sba(iArchitecture
Entity
p4567
(dp4568
g11
(lp4569
g4503
asg13
S'com.google.common.collect.ImmutableRangeSet$AsSet$2'
p4570
sg15
(lp4571
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4572
asg17
(lp4573
g4508
asg19
(lp4574
g4510
asg21
I0
sba(iArchitecture
Entity
p4575
(dp4576
g11
(lp4577
g4503
asg13
S'com.google.common.collect.ImmutableRangeSet$AsSetSerializedForm'
p4578
sg15
(lp4579
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4580
asg17
(lp4581
g4508
asg19
(lp4582
g4510
asg21
I0
sba(iArchitecture
Entity
p4583
(dp4584
g11
(lp4585
g4503
asg13
S'com.google.common.collect.ImmutableRangeSet$Builder'
p4586
sg15
(lp4587
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4588
asg17
(lp4589
g4508
asg19
(lp4590
g4510
asg21
I0
sba(iArchitecture
Entity
p4591
(dp4592
g11
(lp4593
g4503
asg13
S'com.google.common.collect.ImmutableRangeSet$ComplementRanges'
p4594
sg15
(lp4595
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4596
asg17
(lp4597
g4508
asg19
(lp4598
g4510
asg21
I0
sba(iArchitecture
Entity
p4599
(dp4600
g11
(lp4601
g4503
asg13
S'com.google.common.collect.ImmutableRangeSet$SerializedForm'
p4602
sg15
(lp4603
VMutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\u000a
p4604
asg17
(lp4605
g4508
asg19
(lp4606
g4510
asg21
I0
sba(iArchitecture
Entity
p4607
(dp4608
g11
(lp4609
sg13
S'com.google.common.collect.ImmutableSet'
p4610
sg15
(lp4611
sg17
(lp4612
sg19
(lp4613
sg21
I0
sba(iArchitecture
Entity
p4614
(dp4615
g11
(lp4616
sg13
S'com.google.common.collect.ImmutableSet$SerializedForm'
p4617
sg15
(lp4618
sg17
(lp4619
sg19
(lp4620
sg21
I0
sba(iArchitecture
Entity
p4621
(dp4622
g11
(lp4623
sg13
S'com.google.common.collect.ImmutableSetMultimap'
p4624
sg15
(lp4625
sg17
(lp4626
sg19
(lp4627
sg21
I0
sba(iArchitecture
Entity
p4628
(dp4629
g11
(lp4630
sg13
S'com.google.common.collect.ImmutableSetMultimap$Builder'
p4631
sg15
(lp4632
sg17
(lp4633
sg19
(lp4634
sg21
I0
sba(iArchitecture
Entity
p4635
(dp4636
g11
(lp4637
sg13
S'com.google.common.collect.ImmutableSetMultimap$BuilderMultimap'
p4638
sg15
(lp4639
sg17
(lp4640
sg19
(lp4641
sg21
I0
sba(iArchitecture
Entity
p4642
(dp4643
g11
(lp4644
sg13
S'com.google.common.collect.ImmutableSetMultimap$EntrySet'
p4645
sg15
(lp4646
sg17
(lp4647
sg19
(lp4648
sg21
I0
sba(iArchitecture
Entity
p4649
(dp4650
g11
(lp4651
sg13
S'com.google.common.collect.ImmutableSortedAsList'
p4652
sg15
(lp4653
sg17
(lp4654
sg19
(lp4655
sg21
I0
sba(iArchitecture
Entity
p4656
(dp4657
g11
(lp4658
sg13
S'com.google.common.collect.ImmutableSortedMap'
p4659
sg15
(lp4660
sg17
(lp4661
sg19
(lp4662
sg21
I0
sba(iArchitecture
Entity
p4663
(dp4664
g11
(lp4665
sg13
S'com.google.common.collect.ImmutableSortedMap$Builder'
p4666
sg15
(lp4667
sg17
(lp4668
sg19
(lp4669
sg21
I0
sba(iArchitecture
Entity
p4670
(dp4671
g11
(lp4672
sg13
S'com.google.common.collect.ImmutableSortedMap$SerializedForm'
p4673
sg15
(lp4674
sg17
(lp4675
sg19
(lp4676
sg21
I0
sba(iArchitecture
Entity
p4677
(dp4678
g11
(lp4679
sg13
S'com.google.common.collect.ImmutableSortedMapFauxverideShim'
p4680
sg15
(lp4681
sg17
(lp4682
sg19
(lp4683
sg21
I0
sba(iArchitecture
Entity
p4684
(dp4685
g11
(lp4686
sg13
S'com.google.common.collect.ImmutableSortedMultiset'
p4687
sg15
(lp4688
sg17
(lp4689
sg19
(lp4690
sg21
I0
sba(iArchitecture
Entity
p4691
(dp4692
g11
(lp4693
sg13
S'com.google.common.collect.ImmutableSortedMultiset$Builder'
p4694
sg15
(lp4695
sg17
(lp4696
sg19
(lp4697
sg21
I0
sba(iArchitecture
Entity
p4698
(dp4699
g11
(lp4700
sg13
S'com.google.common.collect.ImmutableSortedMultiset$SerializedForm'
p4701
sg15
(lp4702
sg17
(lp4703
sg19
(lp4704
sg21
I0
sba(iArchitecture
Entity
p4705
(dp4706
g11
(lp4707
sg13
S'com.google.common.collect.ImmutableSortedMultisetFauxverideShim'
p4708
sg15
(lp4709
sg17
(lp4710
sg19
(lp4711
sg21
I0
sba(iArchitecture
Entity
p4712
(dp4713
g11
(lp4714
g25
asg13
S'com.google.common.collect.ImmutableSortedSet'
p4715
sg15
(lp4716
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4717
asg17
(lp4718
g32
asg19
(lp4719
g35
asg21
I0
sba(iArchitecture
Entity
p4720
(dp4721
g11
(lp4722
g25
asg13
S'com.google.common.collect.ImmutableSortedSet$Builder'
p4723
sg15
(lp4724
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4725
asg17
(lp4726
g32
asg19
(lp4727
g35
asg21
I0
sba(iArchitecture
Entity
p4728
(dp4729
g11
(lp4730
g25
asg13
S'com.google.common.collect.ImmutableSortedSet$SerializedForm'
p4731
sg15
(lp4732
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p4733
asg17
(lp4734
g32
asg19
(lp4735
g35
asg21
I0
sba(iArchitecture
Entity
p4736
(dp4737
g11
(lp4738
sg13
S'com.google.common.collect.ImmutableSortedSetFauxverideShim'
p4739
sg15
(lp4740
sg17
(lp4741
sg19
(lp4742
sg21
I0
sba(iArchitecture
Entity
p4743
(dp4744
g11
(lp4745
sg13
S'com.google.common.collect.ImmutableTable'
p4746
sg15
(lp4747
sg17
(lp4748
sg19
(lp4749
sg21
I0
sba(iArchitecture
Entity
p4750
(dp4751
g11
(lp4752
sg13
S'com.google.common.collect.ImmutableTable$Builder'
p4753
sg15
(lp4754
sg17
(lp4755
sg19
(lp4756
sg21
I0
sba(iArchitecture
Entity
p4757
(dp4758
g11
(lp4759
sg13
S'com.google.common.collect.Interner'
p4760
sg15
(lp4761
sg17
(lp4762
sg19
(lp4763
sg21
I0
sba(iArchitecture
Entity
p4764
(dp4765
g11
(lp4766
sg13
S'com.google.common.collect.Interners'
p4767
sg15
(lp4768
sg17
(lp4769
sg19
(lp4770
sg21
I0
sba(iArchitecture
Entity
p4771
(dp4772
g11
(lp4773
sg13
S'com.google.common.collect.Interners$1'
p4774
sg15
(lp4775
sg17
(lp4776
sg19
(lp4777
sg21
I0
sba(iArchitecture
Entity
p4778
(dp4779
g11
(lp4780
sg13
S'com.google.common.collect.Interners$InternerFunction'
p4781
sg15
(lp4782
sg17
(lp4783
sg19
(lp4784
sg21
I0
sba(iArchitecture
Entity
p4785
(dp4786
g11
(lp4787
sg13
S'com.google.common.collect.Interners$WeakInterner'
p4788
sg15
(lp4789
sg17
(lp4790
sg19
(lp4791
sg21
I0
sba(iArchitecture
Entity
p4792
(dp4793
g11
(lp4794
sg13
S'com.google.common.collect.Interners$WeakInterner$Dummy'
p4795
sg15
(lp4796
sg17
(lp4797
sg19
(lp4798
sg21
I0
sba(iArchitecture
Entity
p4799
(dp4800
g11
(lp4801
V1596
p4802
ag4802
ag4802
aV2008
p4803
ag4803
aV1543
p4804
ag4804
aV1558
p4805
ag4805
asg13
S'com.google.common.collect.Iterables'
p4806
sg15
(lp4807
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4808
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4809
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4810
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4811
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4812
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4813
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4814
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4815
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4816
asg17
(lp4817
(lp4818
I1
aag4818
ag4818
a(lp4819
I1
aag4819
a(lp4820
I2
aag4820
a(lp4821
I1
aag4821
asg19
(lp4822
VIterables.removeIfFromRandomAccessList(..) not working with Lists prohibiting duplicates
p4823
ag4823
ag4823
aVIterators.concat is not gc friendly
p4824
ag4824
aVIterables.removeIf wrong items removed when ArrayList is used
p4825
ag4825
aVIterables.toArray broken in case of concurrent modifications
p4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4827
(dp4828
g11
(lp4829
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$1'
p4830
sg15
(lp4831
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4832
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4833
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4834
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4835
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4836
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4837
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4838
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4839
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4840
asg17
(lp4841
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp4842
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4843
(dp4844
g11
(lp4845
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$10'
p4846
sg15
(lp4847
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4848
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4849
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4850
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4851
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4852
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4853
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4854
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4855
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4856
asg17
(lp4857
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp4858
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4859
(dp4860
g11
(lp4861
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$10$1'
p4862
sg15
(lp4863
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4864
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4865
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4866
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4867
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4868
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4869
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4870
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4871
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4872
asg17
(lp4873
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp4874
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4875
(dp4876
g11
(lp4877
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$11'
p4878
sg15
(lp4879
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4880
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4881
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4882
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4883
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4884
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4885
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4886
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4887
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4888
asg17
(lp4889
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp4890
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4891
(dp4892
g11
(lp4893
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$12'
p4894
sg15
(lp4895
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4896
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4897
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4898
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4899
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4900
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4901
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4902
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4903
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4904
asg17
(lp4905
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp4906
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4907
(dp4908
g11
(lp4909
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$13'
p4910
sg15
(lp4911
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4912
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4913
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4914
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4915
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4916
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4917
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4918
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4919
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4920
asg17
(lp4921
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp4922
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4923
(dp4924
g11
(lp4925
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$14'
p4926
sg15
(lp4927
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4928
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4929
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4930
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4931
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4932
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4933
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4934
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4935
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4936
asg17
(lp4937
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp4938
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4939
(dp4940
g11
(lp4941
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$15'
p4942
sg15
(lp4943
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4944
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4945
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4946
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4947
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4948
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4949
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4950
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4951
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4952
asg17
(lp4953
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp4954
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4955
(dp4956
g11
(lp4957
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$2'
p4958
sg15
(lp4959
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4960
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4961
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4962
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4963
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4964
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4965
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4966
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4967
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4968
asg17
(lp4969
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp4970
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4971
(dp4972
g11
(lp4973
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$3'
p4974
sg15
(lp4975
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4976
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4977
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4978
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4979
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4980
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4981
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4982
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4983
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4984
asg17
(lp4985
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp4986
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p4987
(dp4988
g11
(lp4989
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$4'
p4990
sg15
(lp4991
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4992
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4993
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p4994
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4995
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p4996
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4997
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p4998
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p4999
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5000
asg17
(lp5001
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp5002
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p5003
(dp5004
g11
(lp5005
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$5'
p5006
sg15
(lp5007
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5008
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5009
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5010
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5011
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5012
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5013
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5014
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5015
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5016
asg17
(lp5017
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp5018
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p5019
(dp5020
g11
(lp5021
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$6'
p5022
sg15
(lp5023
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5024
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5025
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5026
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5027
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5028
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5029
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5030
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5031
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5032
asg17
(lp5033
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp5034
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p5035
(dp5036
g11
(lp5037
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$7'
p5038
sg15
(lp5039
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5040
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5041
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5042
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5043
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5044
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5045
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5046
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5047
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5048
asg17
(lp5049
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp5050
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p5051
(dp5052
g11
(lp5053
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$8'
p5054
sg15
(lp5055
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5056
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5057
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5058
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5059
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5060
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5061
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5062
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5063
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5064
asg17
(lp5065
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp5066
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p5067
(dp5068
g11
(lp5069
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$9'
p5070
sg15
(lp5071
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5072
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5073
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5074
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5075
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5076
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5077
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5078
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5079
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5080
asg17
(lp5081
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp5082
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p5083
(dp5084
g11
(lp5085
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$ConsumingQueueIterator'
p5086
sg15
(lp5087
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5088
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5089
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5090
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5091
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5092
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5093
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5094
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5095
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5096
asg17
(lp5097
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp5098
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p5099
(dp5100
g11
(lp5101
g4802
ag4802
ag4802
ag4803
ag4803
ag4804
ag4804
ag4805
ag4805
asg13
S'com.google.common.collect.Iterables$UnmodifiableIterable'
p5102
sg15
(lp5103
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5104
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5105
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1596) created by **jens.von...@numberfour.eu** on 2013-11-29 at 03:56 PM_\u000a\u000a---\u000a\u000aThe List interface does not state that it must allow duplicate elements, it is only stated as the typical case:\u000a\u000a"Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare." (java.util.List, JavaDoc).\u000a\u000aWhen a list prohibits duplicates, \u000acom.google.common.collect.Iterables.removeIfFromRandomAccessList(List&lt;T>, Predicate<? super T>) \u000aleads to exceptions, because an element temporarily may be contained muiltple times in the list. \u000aThis is true in particular for EMF's org.eclipse.emf.common.util.AbstractEList&lt;E>, which does not allow duplicates.\u000a\u000aSince allowing of duplicates is not a hard constraint of the List interface, I would consider this a bug. In particular since this specialized method is called from com.google.common.collect.Iterables.removeIf(Iterable&lt;T>, Predicate<? super T>), so the client has little control over what's going to happen.\u000a
p5106
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5107
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5108
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5109
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1543) created by **bedla.czech** on 2013-09-25 at 11:58 AM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aI have found strange behaviour of Iterables.removeIf method. When I remove items from iterable by frequency and having them nearby, every found duplicate item is removed even the last one. At a bottom you can find test snippets. There is difference between use of ArrayList and LinkedList.\u000a\u000aNote: I know that I should use Set for this kind of situations, but imagine that you do not have String list but list full of legacy uneditable s*it classes. Problem is inside Iterables.removeIfFromRandomAccessList method.\u000a\u000a<code language="java">\u000a&nbsp;&nbsp;&nbsp;&nbsp;@\ufeffTest\u000a&nbsp;&nbsp;&nbsp;&nbsp;public void testOk() throws Exception {\u000a\u000a```\u000a    final List<String> list = Lists.newArrayList("a", "b", "a");\u000a\u000a    System.out.println(list); // [a, b, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [b, a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testWrong() throws Exception {\u000a\u000a    final List<String> list = Lists.newArrayList("a", "a", "a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [] should be [a]\u000a\u000a}\u000a\u000a@Test\u000apublic void testOkWithLinkedList() throws Exception {\u000a\u000a    final List<String> list = Lists.newLinkedList();\u000a    list.add("a");\u000a    list.add("a");\u000a    list.add("a");\u000a\u000a    System.out.println(list); // [a, a, a]\u000a    Iterables.removeIf(list, new Predicate<String>() {\u000a        @Override\u000a        public boolean apply(String input) {\u000a            return Iterables.frequency(list, input) >= 2;\u000a        }\u000a    });\u000a    System.out.println(list); // [a]\u000a\u000a}\u000a```\u000a\u000a</code>\u000a
p5110
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5111
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1558) created by **Maaartinus** on 2013-10-19 at 04:37 PM_\u000a\u000a---\u000a\u000aIn case the iterable shrinks in the meantime, the result of the class-accepting version of `Iterables.toArray`&nbsp;may contain nulls at its end.\u000a\u000aThe documentation says "return a newly-allocated array into which all the elements of the iterable have been copied", which actually doesn't prevent this. However, nobody expects `Iterables.toArray(a_not_null_allowing_set, some_class)`&nbsp;to contain several nulls.\u000a\u000aIn case you don't want to fix it, the documentation should state this very explicitly. Note that the other overload works fine.\u000a\u000aThe fix is trivial, just pass an empty array in place of the presized one. The only cost is the allocation of the empty array. A test is attached.\u000a
p5112
asg17
(lp5113
g4818
ag4818
ag4818
ag4819
ag4819
ag4820
ag4820
ag4821
ag4821
asg19
(lp5114
g4823
ag4823
ag4823
ag4824
ag4824
ag4825
ag4825
ag4826
ag4826
asg21
I0
sba(iArchitecture
Entity
p5115
(dp5116
g11
(lp5117
g4803
ag4803
asg13
S'com.google.common.collect.Iterators'
p5118
sg15
(lp5119
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5120
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5121
asg17
(lp5122
g4819
ag4819
asg19
(lp5123
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5124
(dp5125
g11
(lp5126
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$1'
p5127
sg15
(lp5128
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5129
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5130
asg17
(lp5131
g4819
ag4819
asg19
(lp5132
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5133
(dp5134
g11
(lp5135
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$10'
p5136
sg15
(lp5137
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5138
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5139
asg17
(lp5140
g4819
ag4819
asg19
(lp5141
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5142
(dp5143
g11
(lp5144
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$11'
p5145
sg15
(lp5146
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5147
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5148
asg17
(lp5149
g4819
ag4819
asg19
(lp5150
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5151
(dp5152
g11
(lp5153
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$12'
p5154
sg15
(lp5155
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5156
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5157
asg17
(lp5158
g4819
ag4819
asg19
(lp5159
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5160
(dp5161
g11
(lp5162
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$13'
p5163
sg15
(lp5164
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5165
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5166
asg17
(lp5167
g4819
ag4819
asg19
(lp5168
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5169
(dp5170
g11
(lp5171
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$14'
p5172
sg15
(lp5173
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5174
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5175
asg17
(lp5176
g4819
ag4819
asg19
(lp5177
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5178
(dp5179
g11
(lp5180
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$2'
p5181
sg15
(lp5182
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5183
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5184
asg17
(lp5185
g4819
ag4819
asg19
(lp5186
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5187
(dp5188
g11
(lp5189
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$3'
p5190
sg15
(lp5191
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5192
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5193
asg17
(lp5194
g4819
ag4819
asg19
(lp5195
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5196
(dp5197
g11
(lp5198
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$4'
p5199
sg15
(lp5200
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5201
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5202
asg17
(lp5203
g4819
ag4819
asg19
(lp5204
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5205
(dp5206
g11
(lp5207
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$5'
p5208
sg15
(lp5209
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5210
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5211
asg17
(lp5212
g4819
ag4819
asg19
(lp5213
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5214
(dp5215
g11
(lp5216
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$6'
p5217
sg15
(lp5218
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5219
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5220
asg17
(lp5221
g4819
ag4819
asg19
(lp5222
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5223
(dp5224
g11
(lp5225
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$7'
p5226
sg15
(lp5227
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5228
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5229
asg17
(lp5230
g4819
ag4819
asg19
(lp5231
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5232
(dp5233
g11
(lp5234
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$8'
p5235
sg15
(lp5236
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5237
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5238
asg17
(lp5239
g4819
ag4819
asg19
(lp5240
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5241
(dp5242
g11
(lp5243
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$9'
p5244
sg15
(lp5245
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5246
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5247
asg17
(lp5248
g4819
ag4819
asg19
(lp5249
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5250
(dp5251
g11
(lp5252
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$MergingIterator'
p5253
sg15
(lp5254
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5255
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5256
asg17
(lp5257
g4819
ag4819
asg19
(lp5258
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5259
(dp5260
g11
(lp5261
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$MergingIterator$1'
p5262
sg15
(lp5263
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5264
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5265
asg17
(lp5266
g4819
ag4819
asg19
(lp5267
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5268
(dp5269
g11
(lp5270
g4803
ag4803
asg13
S'com.google.common.collect.Iterators$PeekingImpl'
p5271
sg15
(lp5272
VI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5273
aVI ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\u000a\u000a(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\u000a\u000aHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\u000a
p5274
asg17
(lp5275
g4819
ag4819
asg19
(lp5276
g4824
ag4824
asg21
I0
sba(iArchitecture
Entity
p5277
(dp5278
g11
(lp5279
sg13
S'com.google.common.collect.LexicographicalOrdering'
p5280
sg15
(lp5281
sg17
(lp5282
sg19
(lp5283
sg21
I0
sba(iArchitecture
Entity
p5284
(dp5285
g11
(lp5286
sg13
S'com.google.common.collect.LinkedHashMultimap'
p5287
sg15
(lp5288
sg17
(lp5289
sg19
(lp5290
sg21
I0
sba(iArchitecture
Entity
p5291
(dp5292
g11
(lp5293
sg13
S'com.google.common.collect.LinkedHashMultimap$1'
p5294
sg15
(lp5295
sg17
(lp5296
sg19
(lp5297
sg21
I0
sba(iArchitecture
Entity
p5298
(dp5299
g11
(lp5300
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueEntry'
p5301
sg15
(lp5302
sg17
(lp5303
sg19
(lp5304
sg21
I0
sba(iArchitecture
Entity
p5305
(dp5306
g11
(lp5307
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueSet'
p5308
sg15
(lp5309
sg17
(lp5310
sg19
(lp5311
sg21
I0
sba(iArchitecture
Entity
p5312
(dp5313
g11
(lp5314
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueSet$1'
p5315
sg15
(lp5316
sg17
(lp5317
sg19
(lp5318
sg21
I0
sba(iArchitecture
Entity
p5319
(dp5320
g11
(lp5321
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueSetLink'
p5322
sg15
(lp5323
sg17
(lp5324
sg19
(lp5325
sg21
I0
sba(iArchitecture
Entity
p5326
(dp5327
g11
(lp5328
sg13
S'com.google.common.collect.LinkedHashMultiset'
p5329
sg15
(lp5330
sg17
(lp5331
sg19
(lp5332
sg21
I0
sba(iArchitecture
Entity
p5333
(dp5334
g11
(lp5335
sg13
S'com.google.common.collect.LinkedListMultimap'
p5336
sg15
(lp5337
sg17
(lp5338
sg19
(lp5339
sg21
I0
sba(iArchitecture
Entity
p5340
(dp5341
g11
(lp5342
sg13
S'com.google.common.collect.LinkedListMultimap$1'
p5343
sg15
(lp5344
sg17
(lp5345
sg19
(lp5346
sg21
I0
sba(iArchitecture
Entity
p5347
(dp5348
g11
(lp5349
sg13
S'com.google.common.collect.LinkedListMultimap$2'
p5350
sg15
(lp5351
sg17
(lp5352
sg19
(lp5353
sg21
I0
sba(iArchitecture
Entity
p5354
(dp5355
g11
(lp5356
sg13
S'com.google.common.collect.LinkedListMultimap$3'
p5357
sg15
(lp5358
sg17
(lp5359
sg19
(lp5360
sg21
I0
sba(iArchitecture
Entity
p5361
(dp5362
g11
(lp5363
sg13
S'com.google.common.collect.LinkedListMultimap$3$1'
p5364
sg15
(lp5365
sg17
(lp5366
sg19
(lp5367
sg21
I0
sba(iArchitecture
Entity
p5368
(dp5369
g11
(lp5370
sg13
S'com.google.common.collect.LinkedListMultimap$4'
p5371
sg15
(lp5372
sg17
(lp5373
sg19
(lp5374
sg21
I0
sba(iArchitecture
Entity
p5375
(dp5376
g11
(lp5377
sg13
S'com.google.common.collect.LinkedListMultimap$DistinctKeyIterator'
p5378
sg15
(lp5379
sg17
(lp5380
sg19
(lp5381
sg21
I0
sba(iArchitecture
Entity
p5382
(dp5383
g11
(lp5384
sg13
S'com.google.common.collect.LinkedListMultimap$KeyList'
p5385
sg15
(lp5386
sg17
(lp5387
sg19
(lp5388
sg21
I0
sba(iArchitecture
Entity
p5389
(dp5390
g11
(lp5391
sg13
S'com.google.common.collect.LinkedListMultimap$Node'
p5392
sg15
(lp5393
sg17
(lp5394
sg19
(lp5395
sg21
I0
sba(iArchitecture
Entity
p5396
(dp5397
g11
(lp5398
sg13
S'com.google.common.collect.LinkedListMultimap$NodeIterator'
p5399
sg15
(lp5400
sg17
(lp5401
sg19
(lp5402
sg21
I0
sba(iArchitecture
Entity
p5403
(dp5404
g11
(lp5405
sg13
S'com.google.common.collect.LinkedListMultimap$ValueForKeyIterator'
p5406
sg15
(lp5407
sg17
(lp5408
sg19
(lp5409
sg21
I0
sba(iArchitecture
Entity
p5410
(dp5411
g11
(lp5412
sg13
S'com.google.common.collect.ListMultimap'
p5413
sg15
(lp5414
sg17
(lp5415
sg19
(lp5416
sg21
I0
sba(iArchitecture
Entity
p5417
(dp5418
g11
(lp5419
sg13
S'com.google.common.collect.Lists'
p5420
sg15
(lp5421
sg17
(lp5422
sg19
(lp5423
sg21
I0
sba(iArchitecture
Entity
p5424
(dp5425
g11
(lp5426
sg13
S'com.google.common.collect.Lists$1'
p5427
sg15
(lp5428
sg17
(lp5429
sg19
(lp5430
sg21
I0
sba(iArchitecture
Entity
p5431
(dp5432
g11
(lp5433
sg13
S'com.google.common.collect.Lists$2'
p5434
sg15
(lp5435
sg17
(lp5436
sg19
(lp5437
sg21
I0
sba(iArchitecture
Entity
p5438
(dp5439
g11
(lp5440
sg13
S'com.google.common.collect.Lists$AbstractListWrapper'
p5441
sg15
(lp5442
sg17
(lp5443
sg19
(lp5444
sg21
I0
sba(iArchitecture
Entity
p5445
(dp5446
g11
(lp5447
sg13
S'com.google.common.collect.Lists$CharSequenceAsList'
p5448
sg15
(lp5449
sg17
(lp5450
sg19
(lp5451
sg21
I0
sba(iArchitecture
Entity
p5452
(dp5453
g11
(lp5454
sg13
S'com.google.common.collect.Lists$OnePlusArrayList'
p5455
sg15
(lp5456
sg17
(lp5457
sg19
(lp5458
sg21
I0
sba(iArchitecture
Entity
p5459
(dp5460
g11
(lp5461
sg13
S'com.google.common.collect.Lists$Partition'
p5462
sg15
(lp5463
sg17
(lp5464
sg19
(lp5465
sg21
I0
sba(iArchitecture
Entity
p5466
(dp5467
g11
(lp5468
sg13
S'com.google.common.collect.Lists$RandomAccessListWrapper'
p5469
sg15
(lp5470
sg17
(lp5471
sg19
(lp5472
sg21
I0
sba(iArchitecture
Entity
p5473
(dp5474
g11
(lp5475
sg13
S'com.google.common.collect.Lists$RandomAccessPartition'
p5476
sg15
(lp5477
sg17
(lp5478
sg19
(lp5479
sg21
I0
sba(iArchitecture
Entity
p5480
(dp5481
g11
(lp5482
sg13
S'com.google.common.collect.Lists$RandomAccessReverseList'
p5483
sg15
(lp5484
sg17
(lp5485
sg19
(lp5486
sg21
I0
sba(iArchitecture
Entity
p5487
(dp5488
g11
(lp5489
sg13
S'com.google.common.collect.Lists$ReverseList'
p5490
sg15
(lp5491
sg17
(lp5492
sg19
(lp5493
sg21
I0
sba(iArchitecture
Entity
p5494
(dp5495
g11
(lp5496
sg13
S'com.google.common.collect.Lists$ReverseList$1'
p5497
sg15
(lp5498
sg17
(lp5499
sg19
(lp5500
sg21
I0
sba(iArchitecture
Entity
p5501
(dp5502
g11
(lp5503
sg13
S'com.google.common.collect.Lists$StringAsImmutableList'
p5504
sg15
(lp5505
sg17
(lp5506
sg19
(lp5507
sg21
I0
sba(iArchitecture
Entity
p5508
(dp5509
g11
(lp5510
sg13
S'com.google.common.collect.Lists$TransformingRandomAccessList'
p5511
sg15
(lp5512
sg17
(lp5513
sg19
(lp5514
sg21
I0
sba(iArchitecture
Entity
p5515
(dp5516
g11
(lp5517
sg13
S'com.google.common.collect.Lists$TransformingRandomAccessList$1'
p5518
sg15
(lp5519
sg17
(lp5520
sg19
(lp5521
sg21
I0
sba(iArchitecture
Entity
p5522
(dp5523
g11
(lp5524
sg13
S'com.google.common.collect.Lists$TransformingSequentialList'
p5525
sg15
(lp5526
sg17
(lp5527
sg19
(lp5528
sg21
I0
sba(iArchitecture
Entity
p5529
(dp5530
g11
(lp5531
sg13
S'com.google.common.collect.Lists$TransformingSequentialList$1'
p5532
sg15
(lp5533
sg17
(lp5534
sg19
(lp5535
sg21
I0
sba(iArchitecture
Entity
p5536
(dp5537
g11
(lp5538
sg13
S'com.google.common.collect.Lists$TwoPlusArrayList'
p5539
sg15
(lp5540
sg17
(lp5541
sg19
(lp5542
sg21
I0
sba(iArchitecture
Entity
p5543
(dp5544
g11
(lp5545
sg13
S'com.google.common.collect.MapConstraint'
p5546
sg15
(lp5547
sg17
(lp5548
sg19
(lp5549
sg21
I0
sba(iArchitecture
Entity
p5550
(dp5551
g11
(lp5552
sg13
S'com.google.common.collect.MapConstraints'
p5553
sg15
(lp5554
sg17
(lp5555
sg19
(lp5556
sg21
I0
sba(iArchitecture
Entity
p5557
(dp5558
g11
(lp5559
sg13
S'com.google.common.collect.MapConstraints$1'
p5560
sg15
(lp5561
sg17
(lp5562
sg19
(lp5563
sg21
I0
sba(iArchitecture
Entity
p5564
(dp5565
g11
(lp5566
sg13
S'com.google.common.collect.MapConstraints$2'
p5567
sg15
(lp5568
sg17
(lp5569
sg19
(lp5570
sg21
I0
sba(iArchitecture
Entity
p5571
(dp5572
g11
(lp5573
sg13
S'com.google.common.collect.MapConstraints$2$1'
p5574
sg15
(lp5575
sg17
(lp5576
sg19
(lp5577
sg21
I0
sba(iArchitecture
Entity
p5578
(dp5579
g11
(lp5580
sg13
S'com.google.common.collect.MapConstraints$ConstrainedAsMapEntries'
p5581
sg15
(lp5582
sg17
(lp5583
sg19
(lp5584
sg21
I0
sba(iArchitecture
Entity
p5585
(dp5586
g11
(lp5587
sg13
S'com.google.common.collect.MapConstraints$ConstrainedAsMapEntries$1'
p5588
sg15
(lp5589
sg17
(lp5590
sg19
(lp5591
sg21
I0
sba(iArchitecture
Entity
p5592
(dp5593
g11
(lp5594
sg13
S'com.google.common.collect.MapConstraints$ConstrainedAsMapValues'
p5595
sg15
(lp5596
sg17
(lp5597
sg19
(lp5598
sg21
I0
sba(iArchitecture
Entity
p5599
(dp5600
g11
(lp5601
sg13
S'com.google.common.collect.MapConstraints$ConstrainedAsMapValues$1'
p5602
sg15
(lp5603
sg17
(lp5604
sg19
(lp5605
sg21
I0
sba(iArchitecture
Entity
p5606
(dp5607
g11
(lp5608
sg13
S'com.google.common.collect.MapConstraints$ConstrainedBiMap'
p5609
sg15
(lp5610
sg17
(lp5611
sg19
(lp5612
sg21
I0
sba(iArchitecture
Entity
p5613
(dp5614
g11
(lp5615
sg13
S'com.google.common.collect.MapConstraints$ConstrainedEntries'
p5616
sg15
(lp5617
sg17
(lp5618
sg19
(lp5619
sg21
I0
sba(iArchitecture
Entity
p5620
(dp5621
g11
(lp5622
sg13
S'com.google.common.collect.MapConstraints$ConstrainedEntries$1'
p5623
sg15
(lp5624
sg17
(lp5625
sg19
(lp5626
sg21
I0
sba(iArchitecture
Entity
p5627
(dp5628
g11
(lp5629
sg13
S'com.google.common.collect.MapConstraints$ConstrainedEntrySet'
p5630
sg15
(lp5631
sg17
(lp5632
sg19
(lp5633
sg21
I0
sba(iArchitecture
Entity
p5634
(dp5635
g11
(lp5636
sg13
S'com.google.common.collect.MapConstraints$ConstrainedListMultimap'
p5637
sg15
(lp5638
sg17
(lp5639
sg19
(lp5640
sg21
I0
sba(iArchitecture
Entity
p5641
(dp5642
g11
(lp5643
sg13
S'com.google.common.collect.MapConstraints$ConstrainedMap'
p5644
sg15
(lp5645
sg17
(lp5646
sg19
(lp5647
sg21
I0
sba(iArchitecture
Entity
p5648
(dp5649
g11
(lp5650
sg13
S'com.google.common.collect.MapConstraints$ConstrainedMultimap'
p5651
sg15
(lp5652
sg17
(lp5653
sg19
(lp5654
sg21
I0
sba(iArchitecture
Entity
p5655
(dp5656
g11
(lp5657
sg13
S'com.google.common.collect.MapConstraints$ConstrainedMultimap$1'
p5658
sg15
(lp5659
sg17
(lp5660
sg19
(lp5661
sg21
I0
sba(iArchitecture
Entity
p5662
(dp5663
g11
(lp5664
sg13
S'com.google.common.collect.MapConstraints$ConstrainedMultimap$2'
p5665
sg15
(lp5666
sg17
(lp5667
sg19
(lp5668
sg21
I0
sba(iArchitecture
Entity
p5669
(dp5670
g11
(lp5671
sg13
S'com.google.common.collect.MapConstraints$ConstrainedSetMultimap'
p5672
sg15
(lp5673
sg17
(lp5674
sg19
(lp5675
sg21
I0
sba(iArchitecture
Entity
p5676
(dp5677
g11
(lp5678
sg13
S'com.google.common.collect.MapConstraints$ConstrainedSortedSetMultimap'
p5679
sg15
(lp5680
sg17
(lp5681
sg19
(lp5682
sg21
I0
sba(iArchitecture
Entity
p5683
(dp5684
g11
(lp5685
sg13
S'com.google.common.collect.MapConstraints$InverseConstraint'
p5686
sg15
(lp5687
sg17
(lp5688
sg19
(lp5689
sg21
I0
sba(iArchitecture
Entity
p5690
(dp5691
g11
(lp5692
sg13
S'com.google.common.collect.MapConstraints$NotNullMapConstraint'
p5693
sg15
(lp5694
sg17
(lp5695
sg19
(lp5696
sg21
I0
sba(iArchitecture
Entity
p5697
(dp5698
g11
(lp5699
sg13
S'com.google.common.collect.MapDifference'
p5700
sg15
(lp5701
sg17
(lp5702
sg19
(lp5703
sg21
I0
sba(iArchitecture
Entity
p5704
(dp5705
g11
(lp5706
sg13
S'com.google.common.collect.MapDifference$ValueDifference'
p5707
sg15
(lp5708
sg17
(lp5709
sg19
(lp5710
sg21
I0
sba(iArchitecture
Entity
p5711
(dp5712
g11
(lp5713
V1885
p5714
asg13
S'com.google.common.collect.MapMaker'
p5715
sg15
(lp5716
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5717
asg17
(lp5718
(lp5719
I2
aasg19
(lp5720
VJavadoc error in MapMaker
p5721
asg21
I0
sba(iArchitecture
Entity
p5722
(dp5723
g11
(lp5724
g5714
asg13
S'com.google.common.collect.MapMaker$1'
p5725
sg15
(lp5726
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5727
asg17
(lp5728
g5719
asg19
(lp5729
g5721
asg21
I0
sba(iArchitecture
Entity
p5730
(dp5731
g11
(lp5732
g5714
asg13
S'com.google.common.collect.MapMaker$ComputingMapAdapter'
p5733
sg15
(lp5734
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5735
asg17
(lp5736
g5719
asg19
(lp5737
g5721
asg21
I0
sba(iArchitecture
Entity
p5738
(dp5739
g11
(lp5740
g5714
asg13
S'com.google.common.collect.MapMaker$NullComputingConcurrentMap'
p5741
sg15
(lp5742
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5743
asg17
(lp5744
g5719
asg19
(lp5745
g5721
asg21
I0
sba(iArchitecture
Entity
p5746
(dp5747
g11
(lp5748
g5714
asg13
S'com.google.common.collect.MapMaker$NullConcurrentMap'
p5749
sg15
(lp5750
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5751
asg17
(lp5752
g5719
asg19
(lp5753
g5721
asg21
I0
sba(iArchitecture
Entity
p5754
(dp5755
g11
(lp5756
g5714
asg13
S'com.google.common.collect.MapMaker$RemovalCause'
p5757
sg15
(lp5758
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5759
asg17
(lp5760
g5719
asg19
(lp5761
g5721
asg21
I0
sba(iArchitecture
Entity
p5762
(dp5763
g11
(lp5764
g5714
asg13
S'com.google.common.collect.MapMaker$RemovalCause$1'
p5765
sg15
(lp5766
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5767
asg17
(lp5768
g5719
asg19
(lp5769
g5721
asg21
I0
sba(iArchitecture
Entity
p5770
(dp5771
g11
(lp5772
g5714
asg13
S'com.google.common.collect.MapMaker$RemovalCause$2'
p5773
sg15
(lp5774
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5775
asg17
(lp5776
g5719
asg19
(lp5777
g5721
asg21
I0
sba(iArchitecture
Entity
p5778
(dp5779
g11
(lp5780
g5714
asg13
S'com.google.common.collect.MapMaker$RemovalCause$3'
p5781
sg15
(lp5782
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5783
asg17
(lp5784
g5719
asg19
(lp5785
g5721
asg21
I0
sba(iArchitecture
Entity
p5786
(dp5787
g11
(lp5788
g5714
asg13
S'com.google.common.collect.MapMaker$RemovalCause$4'
p5789
sg15
(lp5790
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5791
asg17
(lp5792
g5719
asg19
(lp5793
g5721
asg21
I0
sba(iArchitecture
Entity
p5794
(dp5795
g11
(lp5796
g5714
asg13
S'com.google.common.collect.MapMaker$RemovalCause$5'
p5797
sg15
(lp5798
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5799
asg17
(lp5800
g5719
asg19
(lp5801
g5721
asg21
I0
sba(iArchitecture
Entity
p5802
(dp5803
g11
(lp5804
g5714
asg13
S'com.google.common.collect.MapMaker$RemovalListener'
p5805
sg15
(lp5806
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5807
asg17
(lp5808
g5719
asg19
(lp5809
g5721
asg21
I0
sba(iArchitecture
Entity
p5810
(dp5811
g11
(lp5812
g5714
asg13
S'com.google.common.collect.MapMaker$RemovalNotification'
p5813
sg15
(lp5814
VMapMaker javadoc advertises "on-demand computation of values for keys not already present" but this doesn't appear to actually be possible.\u000a
p5815
asg17
(lp5816
g5719
asg19
(lp5817
g5721
asg21
I0
sba(iArchitecture
Entity
p5818
(dp5819
g11
(lp5820
sg13
S'com.google.common.collect.MapMakerInternalMap'
p5821
sg15
(lp5822
sg17
(lp5823
sg19
(lp5824
sg21
I0
sba(iArchitecture
Entity
p5825
(dp5826
g11
(lp5827
sg13
S'com.google.common.collect.MapMakerInternalMap$1'
p5828
sg15
(lp5829
sg17
(lp5830
sg19
(lp5831
sg21
I0
sba(iArchitecture
Entity
p5832
(dp5833
g11
(lp5834
sg13
S'com.google.common.collect.MapMakerInternalMap$2'
p5835
sg15
(lp5836
sg17
(lp5837
sg19
(lp5838
sg21
I0
sba(iArchitecture
Entity
p5839
(dp5840
g11
(lp5841
sg13
S'com.google.common.collect.MapMakerInternalMap$AbstractReferenceEntry'
p5842
sg15
(lp5843
sg17
(lp5844
sg19
(lp5845
sg21
I0
sba(iArchitecture
Entity
p5846
(dp5847
g11
(lp5848
sg13
S'com.google.common.collect.MapMakerInternalMap$AbstractSerializationProxy'
p5849
sg15
(lp5850
sg17
(lp5851
sg19
(lp5852
sg21
I0
sba(iArchitecture
Entity
p5853
(dp5854
g11
(lp5855
sg13
S'com.google.common.collect.MapMakerInternalMap$CleanupMapTask'
p5856
sg15
(lp5857
sg17
(lp5858
sg19
(lp5859
sg21
I0
sba(iArchitecture
Entity
p5860
(dp5861
g11
(lp5862
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryFactory'
p5863
sg15
(lp5864
sg17
(lp5865
sg19
(lp5866
sg21
I0
sba(iArchitecture
Entity
p5867
(dp5868
g11
(lp5869
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryFactory$1'
p5870
sg15
(lp5871
sg17
(lp5872
sg19
(lp5873
sg21
I0
sba(iArchitecture
Entity
p5874
(dp5875
g11
(lp5876
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryFactory$2'
p5877
sg15
(lp5878
sg17
(lp5879
sg19
(lp5880
sg21
I0
sba(iArchitecture
Entity
p5881
(dp5882
g11
(lp5883
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryFactory$3'
p5884
sg15
(lp5885
sg17
(lp5886
sg19
(lp5887
sg21
I0
sba(iArchitecture
Entity
p5888
(dp5889
g11
(lp5890
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryFactory$4'
p5891
sg15
(lp5892
sg17
(lp5893
sg19
(lp5894
sg21
I0
sba(iArchitecture
Entity
p5895
(dp5896
g11
(lp5897
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryFactory$5'
p5898
sg15
(lp5899
sg17
(lp5900
sg19
(lp5901
sg21
I0
sba(iArchitecture
Entity
p5902
(dp5903
g11
(lp5904
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryFactory$6'
p5905
sg15
(lp5906
sg17
(lp5907
sg19
(lp5908
sg21
I0
sba(iArchitecture
Entity
p5909
(dp5910
g11
(lp5911
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryFactory$7'
p5912
sg15
(lp5913
sg17
(lp5914
sg19
(lp5915
sg21
I0
sba(iArchitecture
Entity
p5916
(dp5917
g11
(lp5918
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryFactory$8'
p5919
sg15
(lp5920
sg17
(lp5921
sg19
(lp5922
sg21
I0
sba(iArchitecture
Entity
p5923
(dp5924
g11
(lp5925
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryIterator'
p5926
sg15
(lp5927
sg17
(lp5928
sg19
(lp5929
sg21
I0
sba(iArchitecture
Entity
p5930
(dp5931
g11
(lp5932
sg13
S'com.google.common.collect.MapMakerInternalMap$EntrySet'
p5933
sg15
(lp5934
sg17
(lp5935
sg19
(lp5936
sg21
I0
sba(iArchitecture
Entity
p5937
(dp5938
g11
(lp5939
sg13
S'com.google.common.collect.MapMakerInternalMap$EvictionQueue'
p5940
sg15
(lp5941
sg17
(lp5942
sg19
(lp5943
sg21
I0
sba(iArchitecture
Entity
p5944
(dp5945
g11
(lp5946
sg13
S'com.google.common.collect.MapMakerInternalMap$EvictionQueue$1'
p5947
sg15
(lp5948
sg17
(lp5949
sg19
(lp5950
sg21
I0
sba(iArchitecture
Entity
p5951
(dp5952
g11
(lp5953
sg13
S'com.google.common.collect.MapMakerInternalMap$EvictionQueue$2'
p5954
sg15
(lp5955
sg17
(lp5956
sg19
(lp5957
sg21
I0
sba(iArchitecture
Entity
p5958
(dp5959
g11
(lp5960
sg13
S'com.google.common.collect.MapMakerInternalMap$ExpirationQueue'
p5961
sg15
(lp5962
sg17
(lp5963
sg19
(lp5964
sg21
I0
sba(iArchitecture
Entity
p5965
(dp5966
g11
(lp5967
sg13
S'com.google.common.collect.MapMakerInternalMap$ExpirationQueue$1'
p5968
sg15
(lp5969
sg17
(lp5970
sg19
(lp5971
sg21
I0
sba(iArchitecture
Entity
p5972
(dp5973
g11
(lp5974
sg13
S'com.google.common.collect.MapMakerInternalMap$ExpirationQueue$2'
p5975
sg15
(lp5976
sg17
(lp5977
sg19
(lp5978
sg21
I0
sba(iArchitecture
Entity
p5979
(dp5980
g11
(lp5981
sg13
S'com.google.common.collect.MapMakerInternalMap$HashIterator'
p5982
sg15
(lp5983
sg17
(lp5984
sg19
(lp5985
sg21
I0
sba(iArchitecture
Entity
p5986
(dp5987
g11
(lp5988
sg13
S'com.google.common.collect.MapMakerInternalMap$KeyIterator'
p5989
sg15
(lp5990
sg17
(lp5991
sg19
(lp5992
sg21
I0
sba(iArchitecture
Entity
p5993
(dp5994
g11
(lp5995
sg13
S'com.google.common.collect.MapMakerInternalMap$KeySet'
p5996
sg15
(lp5997
sg17
(lp5998
sg19
(lp5999
sg21
I0
sba(iArchitecture
Entity
p6000
(dp6001
g11
(lp6002
sg13
S'com.google.common.collect.MapMakerInternalMap$NullEntry'
p6003
sg15
(lp6004
sg17
(lp6005
sg19
(lp6006
sg21
I0
sba(iArchitecture
Entity
p6007
(dp6008
g11
(lp6009
sg13
S'com.google.common.collect.MapMakerInternalMap$ReferenceEntry'
p6010
sg15
(lp6011
sg17
(lp6012
sg19
(lp6013
sg21
I0
sba(iArchitecture
Entity
p6014
(dp6015
g11
(lp6016
sg13
S'com.google.common.collect.MapMakerInternalMap$Segment'
p6017
sg15
(lp6018
sg17
(lp6019
sg19
(lp6020
sg21
I0
sba(iArchitecture
Entity
p6021
(dp6022
g11
(lp6023
sg13
S'com.google.common.collect.MapMakerInternalMap$SerializationProxy'
p6024
sg15
(lp6025
sg17
(lp6026
sg19
(lp6027
sg21
I0
sba(iArchitecture
Entity
p6028
(dp6029
g11
(lp6030
sg13
S'com.google.common.collect.MapMakerInternalMap$SoftEntry'
p6031
sg15
(lp6032
sg17
(lp6033
sg19
(lp6034
sg21
I0
sba(iArchitecture
Entity
p6035
(dp6036
g11
(lp6037
sg13
S'com.google.common.collect.MapMakerInternalMap$SoftEvictableEntry'
p6038
sg15
(lp6039
sg17
(lp6040
sg19
(lp6041
sg21
I0
sba(iArchitecture
Entity
p6042
(dp6043
g11
(lp6044
sg13
S'com.google.common.collect.MapMakerInternalMap$SoftExpirableEntry'
p6045
sg15
(lp6046
sg17
(lp6047
sg19
(lp6048
sg21
I0
sba(iArchitecture
Entity
p6049
(dp6050
g11
(lp6051
sg13
S'com.google.common.collect.MapMakerInternalMap$SoftExpirableEvictableEntry'
p6052
sg15
(lp6053
sg17
(lp6054
sg19
(lp6055
sg21
I0
sba(iArchitecture
Entity
p6056
(dp6057
g11
(lp6058
sg13
S'com.google.common.collect.MapMakerInternalMap$SoftValueReference'
p6059
sg15
(lp6060
sg17
(lp6061
sg19
(lp6062
sg21
I0
sba(iArchitecture
Entity
p6063
(dp6064
g11
(lp6065
sg13
S'com.google.common.collect.MapMakerInternalMap$Strength'
p6066
sg15
(lp6067
sg17
(lp6068
sg19
(lp6069
sg21
I0
sba(iArchitecture
Entity
p6070
(dp6071
g11
(lp6072
sg13
S'com.google.common.collect.MapMakerInternalMap$Strength$1'
p6073
sg15
(lp6074
sg17
(lp6075
sg19
(lp6076
sg21
I0
sba(iArchitecture
Entity
p6077
(dp6078
g11
(lp6079
sg13
S'com.google.common.collect.MapMakerInternalMap$Strength$2'
p6080
sg15
(lp6081
sg17
(lp6082
sg19
(lp6083
sg21
I0
sba(iArchitecture
Entity
p6084
(dp6085
g11
(lp6086
sg13
S'com.google.common.collect.MapMakerInternalMap$Strength$3'
p6087
sg15
(lp6088
sg17
(lp6089
sg19
(lp6090
sg21
I0
sba(iArchitecture
Entity
p6091
(dp6092
g11
(lp6093
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongEntry'
p6094
sg15
(lp6095
sg17
(lp6096
sg19
(lp6097
sg21
I0
sba(iArchitecture
Entity
p6098
(dp6099
g11
(lp6100
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongEvictableEntry'
p6101
sg15
(lp6102
sg17
(lp6103
sg19
(lp6104
sg21
I0
sba(iArchitecture
Entity
p6105
(dp6106
g11
(lp6107
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongExpirableEntry'
p6108
sg15
(lp6109
sg17
(lp6110
sg19
(lp6111
sg21
I0
sba(iArchitecture
Entity
p6112
(dp6113
g11
(lp6114
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongExpirableEvictableEntry'
p6115
sg15
(lp6116
sg17
(lp6117
sg19
(lp6118
sg21
I0
sba(iArchitecture
Entity
p6119
(dp6120
g11
(lp6121
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongValueReference'
p6122
sg15
(lp6123
sg17
(lp6124
sg19
(lp6125
sg21
I0
sba(iArchitecture
Entity
p6126
(dp6127
g11
(lp6128
sg13
S'com.google.common.collect.MapMakerInternalMap$ValueIterator'
p6129
sg15
(lp6130
sg17
(lp6131
sg19
(lp6132
sg21
I0
sba(iArchitecture
Entity
p6133
(dp6134
g11
(lp6135
sg13
S'com.google.common.collect.MapMakerInternalMap$ValueReference'
p6136
sg15
(lp6137
sg17
(lp6138
sg19
(lp6139
sg21
I0
sba(iArchitecture
Entity
p6140
(dp6141
g11
(lp6142
sg13
S'com.google.common.collect.MapMakerInternalMap$Values'
p6143
sg15
(lp6144
sg17
(lp6145
sg19
(lp6146
sg21
I0
sba(iArchitecture
Entity
p6147
(dp6148
g11
(lp6149
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakEntry'
p6150
sg15
(lp6151
sg17
(lp6152
sg19
(lp6153
sg21
I0
sba(iArchitecture
Entity
p6154
(dp6155
g11
(lp6156
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakEvictableEntry'
p6157
sg15
(lp6158
sg17
(lp6159
sg19
(lp6160
sg21
I0
sba(iArchitecture
Entity
p6161
(dp6162
g11
(lp6163
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakExpirableEntry'
p6164
sg15
(lp6165
sg17
(lp6166
sg19
(lp6167
sg21
I0
sba(iArchitecture
Entity
p6168
(dp6169
g11
(lp6170
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakExpirableEvictableEntry'
p6171
sg15
(lp6172
sg17
(lp6173
sg19
(lp6174
sg21
I0
sba(iArchitecture
Entity
p6175
(dp6176
g11
(lp6177
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakValueReference'
p6178
sg15
(lp6179
sg17
(lp6180
sg19
(lp6181
sg21
I0
sba(iArchitecture
Entity
p6182
(dp6183
g11
(lp6184
sg13
S'com.google.common.collect.MapMakerInternalMap$WriteThroughEntry'
p6185
sg15
(lp6186
sg17
(lp6187
sg19
(lp6188
sg21
I0
sba(iArchitecture
Entity
p6189
(dp6190
g11
(lp6191
g3578
ag3578
asg13
S'com.google.common.collect.Maps'
p6192
sg15
(lp6193
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6194
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6195
asg17
(lp6196
g3584
ag3584
asg19
(lp6197
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6198
(dp6199
g11
(lp6200
g3578
ag3578
asg13
S'com.google.common.collect.Maps$1'
p6201
sg15
(lp6202
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6203
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6204
asg17
(lp6205
g3584
ag3584
asg19
(lp6206
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6207
(dp6208
g11
(lp6209
g3578
ag3578
asg13
S'com.google.common.collect.Maps$10'
p6210
sg15
(lp6211
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6212
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6213
asg17
(lp6214
g3584
ag3584
asg19
(lp6215
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6216
(dp6217
g11
(lp6218
g3578
ag3578
asg13
S'com.google.common.collect.Maps$11'
p6219
sg15
(lp6220
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6221
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6222
asg17
(lp6223
g3584
ag3584
asg19
(lp6224
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6225
(dp6226
g11
(lp6227
g3578
ag3578
asg13
S'com.google.common.collect.Maps$2'
p6228
sg15
(lp6229
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6230
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6231
asg17
(lp6232
g3584
ag3584
asg19
(lp6233
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6234
(dp6235
g11
(lp6236
g3578
ag3578
asg13
S'com.google.common.collect.Maps$3'
p6237
sg15
(lp6238
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6239
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6240
asg17
(lp6241
g3584
ag3584
asg19
(lp6242
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6243
(dp6244
g11
(lp6245
g3578
ag3578
asg13
S'com.google.common.collect.Maps$4'
p6246
sg15
(lp6247
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6248
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6249
asg17
(lp6250
g3584
ag3584
asg19
(lp6251
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6252
(dp6253
g11
(lp6254
g3578
ag3578
asg13
S'com.google.common.collect.Maps$5'
p6255
sg15
(lp6256
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6257
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6258
asg17
(lp6259
g3584
ag3584
asg19
(lp6260
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6261
(dp6262
g11
(lp6263
g3578
ag3578
asg13
S'com.google.common.collect.Maps$6'
p6264
sg15
(lp6265
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6266
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6267
asg17
(lp6268
g3584
ag3584
asg19
(lp6269
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6270
(dp6271
g11
(lp6272
g3578
ag3578
asg13
S'com.google.common.collect.Maps$7'
p6273
sg15
(lp6274
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6275
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6276
asg17
(lp6277
g3584
ag3584
asg19
(lp6278
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6279
(dp6280
g11
(lp6281
g3578
ag3578
asg13
S'com.google.common.collect.Maps$8'
p6282
sg15
(lp6283
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6284
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6285
asg17
(lp6286
g3584
ag3584
asg19
(lp6287
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6288
(dp6289
g11
(lp6290
g3578
ag3578
asg13
S'com.google.common.collect.Maps$9'
p6291
sg15
(lp6292
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6293
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6294
asg17
(lp6295
g3584
ag3584
asg19
(lp6296
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6297
(dp6298
g11
(lp6299
g3578
ag3578
asg13
S'com.google.common.collect.Maps$AbstractFilteredMap'
p6300
sg15
(lp6301
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6302
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6303
asg17
(lp6304
g3584
ag3584
asg19
(lp6305
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6306
(dp6307
g11
(lp6308
g3578
ag3578
asg13
S'com.google.common.collect.Maps$AsMapView'
p6309
sg15
(lp6310
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6311
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6312
asg17
(lp6313
g3584
ag3584
asg19
(lp6314
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6315
(dp6316
g11
(lp6317
g3578
ag3578
asg13
S'com.google.common.collect.Maps$AsMapView$1'
p6318
sg15
(lp6319
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6320
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6321
asg17
(lp6322
g3584
ag3584
asg19
(lp6323
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6324
(dp6325
g11
(lp6326
g3578
ag3578
asg13
S'com.google.common.collect.Maps$BiMapConverter'
p6327
sg15
(lp6328
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6329
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6330
asg17
(lp6331
g3584
ag3584
asg19
(lp6332
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6333
(dp6334
g11
(lp6335
g3578
ag3578
asg13
S'com.google.common.collect.Maps$DescendingMap'
p6336
sg15
(lp6337
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6338
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6339
asg17
(lp6340
g3584
ag3584
asg19
(lp6341
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6342
(dp6343
g11
(lp6344
g3578
ag3578
asg13
S'com.google.common.collect.Maps$DescendingMap$1'
p6345
sg15
(lp6346
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6347
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6348
asg17
(lp6349
g3584
ag3584
asg19
(lp6350
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6351
(dp6352
g11
(lp6353
g3578
ag3578
asg13
S'com.google.common.collect.Maps$EntryFunction'
p6354
sg15
(lp6355
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6356
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6357
asg17
(lp6358
g3584
ag3584
asg19
(lp6359
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6360
(dp6361
g11
(lp6362
g3578
ag3578
asg13
S'com.google.common.collect.Maps$EntryFunction$1'
p6363
sg15
(lp6364
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6365
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6366
asg17
(lp6367
g3584
ag3584
asg19
(lp6368
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6369
(dp6370
g11
(lp6371
g3578
ag3578
asg13
S'com.google.common.collect.Maps$EntryFunction$2'
p6372
sg15
(lp6373
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6374
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6375
asg17
(lp6376
g3584
ag3584
asg19
(lp6377
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6378
(dp6379
g11
(lp6380
g3578
ag3578
asg13
S'com.google.common.collect.Maps$EntrySet'
p6381
sg15
(lp6382
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6383
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6384
asg17
(lp6385
g3584
ag3584
asg19
(lp6386
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6387
(dp6388
g11
(lp6389
g3578
ag3578
asg13
S'com.google.common.collect.Maps$EntryTransformer'
p6390
sg15
(lp6391
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6392
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6393
asg17
(lp6394
g3584
ag3584
asg19
(lp6395
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6396
(dp6397
g11
(lp6398
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntryBiMap'
p6399
sg15
(lp6400
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6401
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6402
asg17
(lp6403
g3584
ag3584
asg19
(lp6404
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6405
(dp6406
g11
(lp6407
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntryBiMap$1'
p6408
sg15
(lp6409
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6410
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6411
asg17
(lp6412
g3584
ag3584
asg19
(lp6413
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6414
(dp6415
g11
(lp6416
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntryMap'
p6417
sg15
(lp6418
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6419
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6420
asg17
(lp6421
g3584
ag3584
asg19
(lp6422
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6423
(dp6424
g11
(lp6425
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntryMap$EntrySet'
p6426
sg15
(lp6427
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6428
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6429
asg17
(lp6430
g3584
ag3584
asg19
(lp6431
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6432
(dp6433
g11
(lp6434
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntryMap$EntrySet$1'
p6435
sg15
(lp6436
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6437
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6438
asg17
(lp6439
g3584
ag3584
asg19
(lp6440
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6441
(dp6442
g11
(lp6443
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntryMap$EntrySet$1$1'
p6444
sg15
(lp6445
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6446
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6447
asg17
(lp6448
g3584
ag3584
asg19
(lp6449
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6450
(dp6451
g11
(lp6452
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntryMap$KeySet'
p6453
sg15
(lp6454
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6455
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6456
asg17
(lp6457
g3584
ag3584
asg19
(lp6458
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6459
(dp6460
g11
(lp6461
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntryNavigableMap'
p6462
sg15
(lp6463
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6464
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6465
asg17
(lp6466
g3584
ag3584
asg19
(lp6467
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6468
(dp6469
g11
(lp6470
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntryNavigableMap$1'
p6471
sg15
(lp6472
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6473
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6474
asg17
(lp6475
g3584
ag3584
asg19
(lp6476
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6477
(dp6478
g11
(lp6479
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntrySortedMap'
p6480
sg15
(lp6481
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6482
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6483
asg17
(lp6484
g3584
ag3584
asg19
(lp6485
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6486
(dp6487
g11
(lp6488
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredEntrySortedMap$SortedKeySet'
p6489
sg15
(lp6490
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6491
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6492
asg17
(lp6493
g3584
ag3584
asg19
(lp6494
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6495
(dp6496
g11
(lp6497
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredKeyMap'
p6498
sg15
(lp6499
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6500
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6501
asg17
(lp6502
g3584
ag3584
asg19
(lp6503
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6504
(dp6505
g11
(lp6506
g3578
ag3578
asg13
S'com.google.common.collect.Maps$FilteredMapValues'
p6507
sg15
(lp6508
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6509
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6510
asg17
(lp6511
g3584
ag3584
asg19
(lp6512
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6513
(dp6514
g11
(lp6515
g3578
ag3578
asg13
S'com.google.common.collect.Maps$ImprovedAbstractMap'
p6516
sg15
(lp6517
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6518
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6519
asg17
(lp6520
g3584
ag3584
asg19
(lp6521
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6522
(dp6523
g11
(lp6524
g3578
ag3578
asg13
S'com.google.common.collect.Maps$KeySet'
p6525
sg15
(lp6526
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6527
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6528
asg17
(lp6529
g3584
ag3584
asg19
(lp6530
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6531
(dp6532
g11
(lp6533
g3578
ag3578
asg13
S'com.google.common.collect.Maps$MapDifferenceImpl'
p6534
sg15
(lp6535
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6536
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6537
asg17
(lp6538
g3584
ag3584
asg19
(lp6539
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6540
(dp6541
g11
(lp6542
g3578
ag3578
asg13
S'com.google.common.collect.Maps$NavigableAsMapView'
p6543
sg15
(lp6544
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6545
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6546
asg17
(lp6547
g3584
ag3584
asg19
(lp6548
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6549
(dp6550
g11
(lp6551
g3578
ag3578
asg13
S'com.google.common.collect.Maps$NavigableKeySet'
p6552
sg15
(lp6553
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6554
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6555
asg17
(lp6556
g3584
ag3584
asg19
(lp6557
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6558
(dp6559
g11
(lp6560
g3578
ag3578
asg13
S'com.google.common.collect.Maps$SortedAsMapView'
p6561
sg15
(lp6562
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6563
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6564
asg17
(lp6565
g3584
ag3584
asg19
(lp6566
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6567
(dp6568
g11
(lp6569
g3578
ag3578
asg13
S'com.google.common.collect.Maps$SortedKeySet'
p6570
sg15
(lp6571
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6572
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6573
asg17
(lp6574
g3584
ag3584
asg19
(lp6575
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6576
(dp6577
g11
(lp6578
g3578
ag3578
asg13
S'com.google.common.collect.Maps$SortedMapDifferenceImpl'
p6579
sg15
(lp6580
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6581
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6582
asg17
(lp6583
g3584
ag3584
asg19
(lp6584
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6585
(dp6586
g11
(lp6587
g3578
ag3578
asg13
S'com.google.common.collect.Maps$TransformedEntriesMap'
p6588
sg15
(lp6589
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6590
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6591
asg17
(lp6592
g3584
ag3584
asg19
(lp6593
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6594
(dp6595
g11
(lp6596
g3578
ag3578
asg13
S'com.google.common.collect.Maps$TransformedEntriesMap$1'
p6597
sg15
(lp6598
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6599
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6600
asg17
(lp6601
g3584
ag3584
asg19
(lp6602
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6603
(dp6604
g11
(lp6605
g3578
ag3578
asg13
S'com.google.common.collect.Maps$TransformedEntriesNavigableMap'
p6606
sg15
(lp6607
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6608
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6609
asg17
(lp6610
g3584
ag3584
asg19
(lp6611
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6612
(dp6613
g11
(lp6614
g3578
ag3578
asg13
S'com.google.common.collect.Maps$TransformedEntriesSortedMap'
p6615
sg15
(lp6616
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6617
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6618
asg17
(lp6619
g3584
ag3584
asg19
(lp6620
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6621
(dp6622
g11
(lp6623
g3578
ag3578
asg13
S'com.google.common.collect.Maps$UnmodifiableBiMap'
p6624
sg15
(lp6625
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6626
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6627
asg17
(lp6628
g3584
ag3584
asg19
(lp6629
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6630
(dp6631
g11
(lp6632
g3578
ag3578
asg13
S'com.google.common.collect.Maps$UnmodifiableEntries'
p6633
sg15
(lp6634
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6635
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6636
asg17
(lp6637
g3584
ag3584
asg19
(lp6638
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6639
(dp6640
g11
(lp6641
g3578
ag3578
asg13
S'com.google.common.collect.Maps$UnmodifiableEntries$1'
p6642
sg15
(lp6643
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6644
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6645
asg17
(lp6646
g3584
ag3584
asg19
(lp6647
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6648
(dp6649
g11
(lp6650
g3578
ag3578
asg13
S'com.google.common.collect.Maps$UnmodifiableEntrySet'
p6651
sg15
(lp6652
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6653
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6654
asg17
(lp6655
g3584
ag3584
asg19
(lp6656
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6657
(dp6658
g11
(lp6659
g3578
ag3578
asg13
S'com.google.common.collect.Maps$UnmodifiableNavigableMap'
p6660
sg15
(lp6661
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6662
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6663
asg17
(lp6664
g3584
ag3584
asg19
(lp6665
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6666
(dp6667
g11
(lp6668
g3578
ag3578
asg13
S'com.google.common.collect.Maps$ValueDifferenceImpl'
p6669
sg15
(lp6670
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6671
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6672
asg17
(lp6673
g3584
ag3584
asg19
(lp6674
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6675
(dp6676
g11
(lp6677
g3578
ag3578
asg13
S'com.google.common.collect.Maps$Values'
p6678
sg15
(lp6679
VWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6680
aVWould be keen to use these in non-`@Beta`. Are there any plans?\u000a
p6681
asg17
(lp6682
g3584
ag3584
asg19
(lp6683
g3586
ag3586
asg21
I0
sba(iArchitecture
Entity
p6684
(dp6685
g11
(lp6686
g25
asg13
S'com.google.common.collect.MinMaxPriorityQueue'
p6687
sg15
(lp6688
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p6689
asg17
(lp6690
g32
asg19
(lp6691
g35
asg21
I0
sba(iArchitecture
Entity
p6692
(dp6693
g11
(lp6694
g25
asg13
S'com.google.common.collect.MinMaxPriorityQueue$1'
p6695
sg15
(lp6696
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p6697
asg17
(lp6698
g32
asg19
(lp6699
g35
asg21
I0
sba(iArchitecture
Entity
p6700
(dp6701
g11
(lp6702
g25
asg13
S'com.google.common.collect.MinMaxPriorityQueue$Builder'
p6703
sg15
(lp6704
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p6705
asg17
(lp6706
g32
asg19
(lp6707
g35
asg21
I0
sba(iArchitecture
Entity
p6708
(dp6709
g11
(lp6710
g25
asg13
S'com.google.common.collect.MinMaxPriorityQueue$Heap'
p6711
sg15
(lp6712
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p6713
asg17
(lp6714
g32
asg19
(lp6715
g35
asg21
I0
sba(iArchitecture
Entity
p6716
(dp6717
g11
(lp6718
g25
asg13
S'com.google.common.collect.MinMaxPriorityQueue$MoveDesc'
p6719
sg15
(lp6720
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p6721
asg17
(lp6722
g32
asg19
(lp6723
g35
asg21
I0
sba(iArchitecture
Entity
p6724
(dp6725
g11
(lp6726
g25
asg13
S'com.google.common.collect.MinMaxPriorityQueue$QueueIterator'
p6727
sg15
(lp6728
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p6729
asg17
(lp6730
g32
asg19
(lp6731
g35
asg21
I0
sba(iArchitecture
Entity
p6732
(dp6733
g11
(lp6734
sg13
S'com.google.common.collect.Multimap'
p6735
sg15
(lp6736
sg17
(lp6737
sg19
(lp6738
sg21
I0
sba(iArchitecture
Entity
p6739
(dp6740
g11
(lp6741
sg13
S'com.google.common.collect.MultimapBuilder'
p6742
sg15
(lp6743
sg17
(lp6744
sg19
(lp6745
sg21
I0
sba(iArchitecture
Entity
p6746
(dp6747
g11
(lp6748
sg13
S'com.google.common.collect.MultimapBuilder$1'
p6749
sg15
(lp6750
sg17
(lp6751
sg19
(lp6752
sg21
I0
sba(iArchitecture
Entity
p6753
(dp6754
g11
(lp6755
sg13
S'com.google.common.collect.MultimapBuilder$2'
p6756
sg15
(lp6757
sg17
(lp6758
sg19
(lp6759
sg21
I0
sba(iArchitecture
Entity
p6760
(dp6761
g11
(lp6762
sg13
S'com.google.common.collect.MultimapBuilder$3'
p6763
sg15
(lp6764
sg17
(lp6765
sg19
(lp6766
sg21
I0
sba(iArchitecture
Entity
p6767
(dp6768
g11
(lp6769
sg13
S'com.google.common.collect.MultimapBuilder$4'
p6770
sg15
(lp6771
sg17
(lp6772
sg19
(lp6773
sg21
I0
sba(iArchitecture
Entity
p6774
(dp6775
g11
(lp6776
sg13
S'com.google.common.collect.MultimapBuilder$ArrayListSupplier'
p6777
sg15
(lp6778
sg17
(lp6779
sg19
(lp6780
sg21
I0
sba(iArchitecture
Entity
p6781
(dp6782
g11
(lp6783
sg13
S'com.google.common.collect.MultimapBuilder$EnumSetSupplier'
p6784
sg15
(lp6785
sg17
(lp6786
sg19
(lp6787
sg21
I0
sba(iArchitecture
Entity
p6788
(dp6789
g11
(lp6790
sg13
S'com.google.common.collect.MultimapBuilder$HashSetSupplier'
p6791
sg15
(lp6792
sg17
(lp6793
sg19
(lp6794
sg21
I0
sba(iArchitecture
Entity
p6795
(dp6796
g11
(lp6797
sg13
S'com.google.common.collect.MultimapBuilder$LinkedHashSetSupplier'
p6798
sg15
(lp6799
sg17
(lp6800
sg19
(lp6801
sg21
I0
sba(iArchitecture
Entity
p6802
(dp6803
g11
(lp6804
sg13
S'com.google.common.collect.MultimapBuilder$LinkedListSupplier'
p6805
sg15
(lp6806
sg17
(lp6807
sg19
(lp6808
sg21
I0
sba(iArchitecture
Entity
p6809
(dp6810
g11
(lp6811
sg13
S'com.google.common.collect.MultimapBuilder$ListMultimapBuilder'
p6812
sg15
(lp6813
sg17
(lp6814
sg19
(lp6815
sg21
I0
sba(iArchitecture
Entity
p6816
(dp6817
g11
(lp6818
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys'
p6819
sg15
(lp6820
sg17
(lp6821
sg19
(lp6822
sg21
I0
sba(iArchitecture
Entity
p6823
(dp6824
g11
(lp6825
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$1'
p6826
sg15
(lp6827
sg17
(lp6828
sg19
(lp6829
sg21
I0
sba(iArchitecture
Entity
p6830
(dp6831
g11
(lp6832
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$2'
p6833
sg15
(lp6834
sg17
(lp6835
sg19
(lp6836
sg21
I0
sba(iArchitecture
Entity
p6837
(dp6838
g11
(lp6839
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$3'
p6840
sg15
(lp6841
sg17
(lp6842
sg19
(lp6843
sg21
I0
sba(iArchitecture
Entity
p6844
(dp6845
g11
(lp6846
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$4'
p6847
sg15
(lp6848
sg17
(lp6849
sg19
(lp6850
sg21
I0
sba(iArchitecture
Entity
p6851
(dp6852
g11
(lp6853
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$5'
p6854
sg15
(lp6855
sg17
(lp6856
sg19
(lp6857
sg21
I0
sba(iArchitecture
Entity
p6858
(dp6859
g11
(lp6860
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$6'
p6861
sg15
(lp6862
sg17
(lp6863
sg19
(lp6864
sg21
I0
sba(iArchitecture
Entity
p6865
(dp6866
g11
(lp6867
sg13
S'com.google.common.collect.MultimapBuilder$SetMultimapBuilder'
p6868
sg15
(lp6869
sg17
(lp6870
sg19
(lp6871
sg21
I0
sba(iArchitecture
Entity
p6872
(dp6873
g11
(lp6874
sg13
S'com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder'
p6875
sg15
(lp6876
sg17
(lp6877
sg19
(lp6878
sg21
I0
sba(iArchitecture
Entity
p6879
(dp6880
g11
(lp6881
sg13
S'com.google.common.collect.MultimapBuilder$TreeSetSupplier'
p6882
sg15
(lp6883
sg17
(lp6884
sg19
(lp6885
sg21
I0
sba(iArchitecture
Entity
p6886
(dp6887
g11
(lp6888
sg13
S'com.google.common.collect.Multimaps'
p6889
sg15
(lp6890
sg17
(lp6891
sg19
(lp6892
sg21
I0
sba(iArchitecture
Entity
p6893
(dp6894
g11
(lp6895
sg13
S'com.google.common.collect.Multimaps$AsMap'
p6896
sg15
(lp6897
sg17
(lp6898
sg19
(lp6899
sg21
I0
sba(iArchitecture
Entity
p6900
(dp6901
g11
(lp6902
sg13
S'com.google.common.collect.Multimaps$AsMap$EntrySet'
p6903
sg15
(lp6904
sg17
(lp6905
sg19
(lp6906
sg21
I0
sba(iArchitecture
Entity
p6907
(dp6908
g11
(lp6909
sg13
S'com.google.common.collect.Multimaps$AsMap$EntrySet$1'
p6910
sg15
(lp6911
sg17
(lp6912
sg19
(lp6913
sg21
I0
sba(iArchitecture
Entity
p6914
(dp6915
g11
(lp6916
sg13
S'com.google.common.collect.Multimaps$CustomListMultimap'
p6917
sg15
(lp6918
sg17
(lp6919
sg19
(lp6920
sg21
I0
sba(iArchitecture
Entity
p6921
(dp6922
g11
(lp6923
sg13
S'com.google.common.collect.Multimaps$CustomMultimap'
p6924
sg15
(lp6925
sg17
(lp6926
sg19
(lp6927
sg21
I0
sba(iArchitecture
Entity
p6928
(dp6929
g11
(lp6930
sg13
S'com.google.common.collect.Multimaps$CustomSetMultimap'
p6931
sg15
(lp6932
sg17
(lp6933
sg19
(lp6934
sg21
I0
sba(iArchitecture
Entity
p6935
(dp6936
g11
(lp6937
sg13
S'com.google.common.collect.Multimaps$CustomSortedSetMultimap'
p6938
sg15
(lp6939
sg17
(lp6940
sg19
(lp6941
sg21
I0
sba(iArchitecture
Entity
p6942
(dp6943
g11
(lp6944
sg13
S'com.google.common.collect.Multimaps$Entries'
p6945
sg15
(lp6946
sg17
(lp6947
sg19
(lp6948
sg21
I0
sba(iArchitecture
Entity
p6949
(dp6950
g11
(lp6951
sg13
S'com.google.common.collect.Multimaps$Keys'
p6952
sg15
(lp6953
sg17
(lp6954
sg19
(lp6955
sg21
I0
sba(iArchitecture
Entity
p6956
(dp6957
g11
(lp6958
sg13
S'com.google.common.collect.Multimaps$Keys$1'
p6959
sg15
(lp6960
sg17
(lp6961
sg19
(lp6962
sg21
I0
sba(iArchitecture
Entity
p6963
(dp6964
g11
(lp6965
sg13
S'com.google.common.collect.Multimaps$Keys$1$1'
p6966
sg15
(lp6967
sg17
(lp6968
sg19
(lp6969
sg21
I0
sba(iArchitecture
Entity
p6970
(dp6971
g11
(lp6972
sg13
S'com.google.common.collect.Multimaps$Keys$KeysEntrySet'
p6973
sg15
(lp6974
sg17
(lp6975
sg19
(lp6976
sg21
I0
sba(iArchitecture
Entity
p6977
(dp6978
g11
(lp6979
sg13
S'com.google.common.collect.Multimaps$MapMultimap'
p6980
sg15
(lp6981
sg17
(lp6982
sg19
(lp6983
sg21
I0
sba(iArchitecture
Entity
p6984
(dp6985
g11
(lp6986
sg13
S'com.google.common.collect.Multimaps$MapMultimap$1'
p6987
sg15
(lp6988
sg17
(lp6989
sg19
(lp6990
sg21
I0
sba(iArchitecture
Entity
p6991
(dp6992
g11
(lp6993
sg13
S'com.google.common.collect.Multimaps$MapMultimap$1$1'
p6994
sg15
(lp6995
sg17
(lp6996
sg19
(lp6997
sg21
I0
sba(iArchitecture
Entity
p6998
(dp6999
g11
(lp7000
sg13
S'com.google.common.collect.Multimaps$TransformedEntriesListMultimap'
p7001
sg15
(lp7002
sg17
(lp7003
sg19
(lp7004
sg21
I0
sba(iArchitecture
Entity
p7005
(dp7006
g11
(lp7007
sg13
S'com.google.common.collect.Multimaps$TransformedEntriesMultimap'
p7008
sg15
(lp7009
sg17
(lp7010
sg19
(lp7011
sg21
I0
sba(iArchitecture
Entity
p7012
(dp7013
g11
(lp7014
sg13
S'com.google.common.collect.Multimaps$TransformedEntriesMultimap$1'
p7015
sg15
(lp7016
sg17
(lp7017
sg19
(lp7018
sg21
I0
sba(iArchitecture
Entity
p7019
(dp7020
g11
(lp7021
sg13
S'com.google.common.collect.Multimaps$UnmodifiableListMultimap'
p7022
sg15
(lp7023
sg17
(lp7024
sg19
(lp7025
sg21
I0
sba(iArchitecture
Entity
p7026
(dp7027
g11
(lp7028
sg13
S'com.google.common.collect.Multimaps$UnmodifiableMultimap'
p7029
sg15
(lp7030
sg17
(lp7031
sg19
(lp7032
sg21
I0
sba(iArchitecture
Entity
p7033
(dp7034
g11
(lp7035
sg13
S'com.google.common.collect.Multimaps$UnmodifiableMultimap$1'
p7036
sg15
(lp7037
sg17
(lp7038
sg19
(lp7039
sg21
I0
sba(iArchitecture
Entity
p7040
(dp7041
g11
(lp7042
sg13
S'com.google.common.collect.Multimaps$UnmodifiableSetMultimap'
p7043
sg15
(lp7044
sg17
(lp7045
sg19
(lp7046
sg21
I0
sba(iArchitecture
Entity
p7047
(dp7048
g11
(lp7049
sg13
S'com.google.common.collect.Multimaps$UnmodifiableSortedSetMultimap'
p7050
sg15
(lp7051
sg17
(lp7052
sg19
(lp7053
sg21
I0
sba(iArchitecture
Entity
p7054
(dp7055
g11
(lp7056
sg13
S'com.google.common.collect.Multiset'
p7057
sg15
(lp7058
sg17
(lp7059
sg19
(lp7060
sg21
I0
sba(iArchitecture
Entity
p7061
(dp7062
g11
(lp7063
sg13
S'com.google.common.collect.Multiset$Entry'
p7064
sg15
(lp7065
sg17
(lp7066
sg19
(lp7067
sg21
I0
sba(iArchitecture
Entity
p7068
(dp7069
g11
(lp7070
sg13
S'com.google.common.collect.Multisets'
p7071
sg15
(lp7072
sg17
(lp7073
sg19
(lp7074
sg21
I0
sba(iArchitecture
Entity
p7075
(dp7076
g11
(lp7077
sg13
S'com.google.common.collect.Multisets$1'
p7078
sg15
(lp7079
sg17
(lp7080
sg19
(lp7081
sg21
I0
sba(iArchitecture
Entity
p7082
(dp7083
g11
(lp7084
sg13
S'com.google.common.collect.Multisets$1$1'
p7085
sg15
(lp7086
sg17
(lp7087
sg19
(lp7088
sg21
I0
sba(iArchitecture
Entity
p7089
(dp7090
g11
(lp7091
sg13
S'com.google.common.collect.Multisets$2'
p7092
sg15
(lp7093
sg17
(lp7094
sg19
(lp7095
sg21
I0
sba(iArchitecture
Entity
p7096
(dp7097
g11
(lp7098
sg13
S'com.google.common.collect.Multisets$2$1'
p7099
sg15
(lp7100
sg17
(lp7101
sg19
(lp7102
sg21
I0
sba(iArchitecture
Entity
p7103
(dp7104
g11
(lp7105
sg13
S'com.google.common.collect.Multisets$3'
p7106
sg15
(lp7107
sg17
(lp7108
sg19
(lp7109
sg21
I0
sba(iArchitecture
Entity
p7110
(dp7111
g11
(lp7112
sg13
S'com.google.common.collect.Multisets$3$1'
p7113
sg15
(lp7114
sg17
(lp7115
sg19
(lp7116
sg21
I0
sba(iArchitecture
Entity
p7117
(dp7118
g11
(lp7119
sg13
S'com.google.common.collect.Multisets$4'
p7120
sg15
(lp7121
sg17
(lp7122
sg19
(lp7123
sg21
I0
sba(iArchitecture
Entity
p7124
(dp7125
g11
(lp7126
sg13
S'com.google.common.collect.Multisets$4$1'
p7127
sg15
(lp7128
sg17
(lp7129
sg19
(lp7130
sg21
I0
sba(iArchitecture
Entity
p7131
(dp7132
g11
(lp7133
sg13
S'com.google.common.collect.Multisets$5'
p7134
sg15
(lp7135
sg17
(lp7136
sg19
(lp7137
sg21
I0
sba(iArchitecture
Entity
p7138
(dp7139
g11
(lp7140
sg13
S'com.google.common.collect.Multisets$AbstractEntry'
p7141
sg15
(lp7142
sg17
(lp7143
sg19
(lp7144
sg21
I0
sba(iArchitecture
Entity
p7145
(dp7146
g11
(lp7147
sg13
S'com.google.common.collect.Multisets$ElementSet'
p7148
sg15
(lp7149
sg17
(lp7150
sg19
(lp7151
sg21
I0
sba(iArchitecture
Entity
p7152
(dp7153
g11
(lp7154
sg13
S'com.google.common.collect.Multisets$ElementSet$1'
p7155
sg15
(lp7156
sg17
(lp7157
sg19
(lp7158
sg21
I0
sba(iArchitecture
Entity
p7159
(dp7160
g11
(lp7161
sg13
S'com.google.common.collect.Multisets$EntrySet'
p7162
sg15
(lp7163
sg17
(lp7164
sg19
(lp7165
sg21
I0
sba(iArchitecture
Entity
p7166
(dp7167
g11
(lp7168
sg13
S'com.google.common.collect.Multisets$FilteredMultiset'
p7169
sg15
(lp7170
sg17
(lp7171
sg19
(lp7172
sg21
I0
sba(iArchitecture
Entity
p7173
(dp7174
g11
(lp7175
sg13
S'com.google.common.collect.Multisets$FilteredMultiset$1'
p7176
sg15
(lp7177
sg17
(lp7178
sg19
(lp7179
sg21
I0
sba(iArchitecture
Entity
p7180
(dp7181
g11
(lp7182
sg13
S'com.google.common.collect.Multisets$ImmutableEntry'
p7183
sg15
(lp7184
sg17
(lp7185
sg19
(lp7186
sg21
I0
sba(iArchitecture
Entity
p7187
(dp7188
g11
(lp7189
sg13
S'com.google.common.collect.Multisets$MultisetIteratorImpl'
p7190
sg15
(lp7191
sg17
(lp7192
sg19
(lp7193
sg21
I0
sba(iArchitecture
Entity
p7194
(dp7195
g11
(lp7196
sg13
S'com.google.common.collect.Multisets$UnmodifiableMultiset'
p7197
sg15
(lp7198
sg17
(lp7199
sg19
(lp7200
sg21
I0
sba(iArchitecture
Entity
p7201
(dp7202
g11
(lp7203
V1437
p7204
ag7204
asg13
S'com.google.common.collect.MutableClassToInstanceMap'
p7205
sg15
(lp7206
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1437) created by **mike.rumpf** on 2013-05-31 at 06:11 AM_\u000a\u000a---\u000a\u000aMutableClassToInstanceMap defines a serialVersionUID but itself does not implement Serializable. This is inconsistent to other guava collection types.\u000a
p7207
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1437) created by **mike.rumpf** on 2013-05-31 at 06:11 AM_\u000a\u000a---\u000a\u000aMutableClassToInstanceMap defines a serialVersionUID but itself does not implement Serializable. This is inconsistent to other guava collection types.\u000a
p7208
asg17
(lp7209
(lp7210
I0
aag7210
asg19
(lp7211
VMutableClassToInstanceMap should implement Serializable
p7212
ag7212
asg21
I0
sba(iArchitecture
Entity
p7213
(dp7214
g11
(lp7215
g7204
ag7204
asg13
S'com.google.common.collect.MutableClassToInstanceMap$1'
p7216
sg15
(lp7217
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1437) created by **mike.rumpf** on 2013-05-31 at 06:11 AM_\u000a\u000a---\u000a\u000aMutableClassToInstanceMap defines a serialVersionUID but itself does not implement Serializable. This is inconsistent to other guava collection types.\u000a
p7218
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1437) created by **mike.rumpf** on 2013-05-31 at 06:11 AM_\u000a\u000a---\u000a\u000aMutableClassToInstanceMap defines a serialVersionUID but itself does not implement Serializable. This is inconsistent to other guava collection types.\u000a
p7219
asg17
(lp7220
g7210
ag7210
asg19
(lp7221
g7212
ag7212
asg21
I0
sba(iArchitecture
Entity
p7222
(dp7223
g11
(lp7224
g25
aV1451
p7225
asg13
S'com.google.common.collect.NaturalOrdering'
p7226
sg15
(lp7227
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p7228
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1451) created by **drothmaler** on 2013-06-18 at 01:46 PM_\u000a\u000a---\u000a\u000aI think it would be good to extend the NaturalOrdering and ReverseNaturalOrdering implementations, to hold instances of their nullsFirst() and nullsLast() versions too.\u000aThis is because things like Ordering.natural().nullsFirst() are frequently used and currently there will be created a NullsFirstOrdering/NullsLastOrdering instance each time, you access it. \u000a\u000aIn many cases this will not be a problem, but if you use it inside a compareTo or compare method (e.g. in combination with the ComparisonChain as suggested in Issue 500 & Issue 556), it really makes a difference whether you use a share instance, or not.\u000a
p7229
asg17
(lp7230
g32
a(lp7231
I3
aasg19
(lp7232
g35
aVUse Singleton instances for nullable natural Orderings
p7233
asg21
I0
sba(iArchitecture
Entity
p7234
(dp7235
g11
(lp7236
sg13
S'com.google.common.collect.NullsFirstOrdering'
p7237
sg15
(lp7238
sg17
(lp7239
sg19
(lp7240
sg21
I0
sba(iArchitecture
Entity
p7241
(dp7242
g11
(lp7243
sg13
S'com.google.common.collect.NullsLastOrdering'
p7244
sg15
(lp7245
sg17
(lp7246
sg19
(lp7247
sg21
I0
sba(iArchitecture
Entity
p7248
(dp7249
g11
(lp7250
sg13
S'com.google.common.collect.ObjectArrays'
p7251
sg15
(lp7252
sg17
(lp7253
sg19
(lp7254
sg21
I0
sba(iArchitecture
Entity
p7255
(dp7256
g11
(lp7257
V2525
p7258
aV1342
p7259
ag7259
ag7259
asg13
S'com.google.common.collect.Ordering'
p7260
sg15
(lp7261
VThe [snapshot Javadoc of Ordering#explicit(java.util.List)](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Ordering.html#explicit%28java.util.List%29)  contains the sentnece:\u000a\u000a> The returned comparator throws **an ClassCastException** when it receives an input parameter that isn't among the provided values.\u000a\u000ainstead of\u000a\u000a> The returned comparator throws **a ClassCastException** when it receives an input parameter that isn't among the provided values.\u000a
p7262
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7263
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7264
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7265
asg17
(lp7266
(lp7267
I2
aa(lp7268
I2
aag7268
ag7268
asg19
(lp7269
VTypo in the javadoc of Ordering's explicit(List<T>) method
p7270
aVAdd docs to Ordering to give guidance how to parse and understand long chains of calls
p7271
ag7271
ag7271
asg21
I0
sba(iArchitecture
Entity
p7272
(dp7273
g11
(lp7274
g7258
ag7259
ag7259
ag7259
asg13
S'com.google.common.collect.Ordering$ArbitraryOrdering'
p7275
sg15
(lp7276
VThe [snapshot Javadoc of Ordering#explicit(java.util.List)](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Ordering.html#explicit%28java.util.List%29)  contains the sentnece:\u000a\u000a> The returned comparator throws **an ClassCastException** when it receives an input parameter that isn't among the provided values.\u000a\u000ainstead of\u000a\u000a> The returned comparator throws **a ClassCastException** when it receives an input parameter that isn't among the provided values.\u000a
p7277
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7278
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7279
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7280
asg17
(lp7281
g7267
ag7268
ag7268
ag7268
asg19
(lp7282
g7270
ag7271
ag7271
ag7271
asg21
I0
sba(iArchitecture
Entity
p7283
(dp7284
g11
(lp7285
g7258
ag7259
ag7259
ag7259
asg13
S'com.google.common.collect.Ordering$ArbitraryOrdering$1'
p7286
sg15
(lp7287
VThe [snapshot Javadoc of Ordering#explicit(java.util.List)](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Ordering.html#explicit%28java.util.List%29)  contains the sentnece:\u000a\u000a> The returned comparator throws **an ClassCastException** when it receives an input parameter that isn't among the provided values.\u000a\u000ainstead of\u000a\u000a> The returned comparator throws **a ClassCastException** when it receives an input parameter that isn't among the provided values.\u000a
p7288
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7289
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7290
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7291
asg17
(lp7292
g7267
ag7268
ag7268
ag7268
asg19
(lp7293
g7270
ag7271
ag7271
ag7271
asg21
I0
sba(iArchitecture
Entity
p7294
(dp7295
g11
(lp7296
g7258
ag7259
ag7259
ag7259
asg13
S'com.google.common.collect.Ordering$ArbitraryOrderingHolder'
p7297
sg15
(lp7298
VThe [snapshot Javadoc of Ordering#explicit(java.util.List)](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Ordering.html#explicit%28java.util.List%29)  contains the sentnece:\u000a\u000a> The returned comparator throws **an ClassCastException** when it receives an input parameter that isn't among the provided values.\u000a\u000ainstead of\u000a\u000a> The returned comparator throws **a ClassCastException** when it receives an input parameter that isn't among the provided values.\u000a
p7299
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7300
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7301
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7302
asg17
(lp7303
g7267
ag7268
ag7268
ag7268
asg19
(lp7304
g7270
ag7271
ag7271
ag7271
asg21
I0
sba(iArchitecture
Entity
p7305
(dp7306
g11
(lp7307
g7258
ag7259
ag7259
ag7259
asg13
S'com.google.common.collect.Ordering$IncomparableValueException'
p7308
sg15
(lp7309
VThe [snapshot Javadoc of Ordering#explicit(java.util.List)](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Ordering.html#explicit%28java.util.List%29)  contains the sentnece:\u000a\u000a> The returned comparator throws **an ClassCastException** when it receives an input parameter that isn't among the provided values.\u000a\u000ainstead of\u000a\u000a> The returned comparator throws **a ClassCastException** when it receives an input parameter that isn't among the provided values.\u000a
p7310
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7311
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7312
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1342) created by **kevinb@google.com** on 2013-03-15 at 05:18 PM_\u000a\u000a---\u000a\u000aIt's very hard to figure out what Ordering.natural().nullsFirst().reverse().lexicographical().reverse().nullsLast() means.\u000a\u000aWe can make it a lot easier for the user by walking through how we read and interpret a few salient examples.\u000a
p7313
asg17
(lp7314
g7267
ag7268
ag7268
ag7268
asg19
(lp7315
g7270
ag7271
ag7271
ag7271
asg21
I0
sba(iArchitecture
Entity
p7316
(dp7317
g11
(lp7318
sg13
S'com.google.common.collect.PeekingIterator'
p7319
sg15
(lp7320
sg17
(lp7321
sg19
(lp7322
sg21
I0
sba(iArchitecture
Entity
p7323
(dp7324
g11
(lp7325
V1328
p7326
asg13
S'com.google.common.collect.Platform'
p7327
sg15
(lp7328
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1328) created by **gokhanoner** on 2013-03-11 at 03:23 PM_\u000a\u000a---\u000a\u000aHi,\u000a\u000aprivate static final ImmutableSet&lt;String> ISLEM_EB_FIELDS = ImmutableSet.of("ISLBLG");\u000a\u000aFor above desc, a singletonImmutableSet is created. When I try\u000a\u000aISLEM_EB_FIELDS.toArray(new String[0])\u000a\u000aon V13.0.1, ist OK but in v14, it throw class not found exception for\u000a\u000acom.google.common.collect.GwtPlatform.java\u000a\u000aI tried it on a GWT application.\u000a
p7329
asg17
(lp7330
(lp7331
I1
aasg19
(lp7332
VImmutableSet.toArray issue on singletonImmutableSet for v14
p7333
asg21
I0
sba(iArchitecture
Entity
p7334
(dp7335
g11
(lp7336
V2376
p7337
ag7337
ag7337
ag7337
asg13
S'com.google.common.collect.Range'
p7338
sg15
(lp7339
V`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7340
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7341
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7342
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7343
asg17
(lp7344
(lp7345
I1
aag7345
ag7345
ag7345
asg19
(lp7346
VConsider replacing unicode character in Range.toString()
p7347
ag7347
ag7347
ag7347
asg21
I0
sba(iArchitecture
Entity
p7348
(dp7349
g11
(lp7350
g7337
ag7337
ag7337
ag7337
asg13
S'com.google.common.collect.Range$1'
p7351
sg15
(lp7352
V`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7353
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7354
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7355
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7356
asg17
(lp7357
g7345
ag7345
ag7345
ag7345
asg19
(lp7358
g7347
ag7347
ag7347
ag7347
asg21
I0
sba(iArchitecture
Entity
p7359
(dp7360
g11
(lp7361
g7337
ag7337
ag7337
ag7337
asg13
S'com.google.common.collect.Range$2'
p7362
sg15
(lp7363
V`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7364
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7365
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7366
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7367
asg17
(lp7368
g7345
ag7345
ag7345
ag7345
asg19
(lp7369
g7347
ag7347
ag7347
ag7347
asg21
I0
sba(iArchitecture
Entity
p7370
(dp7371
g11
(lp7372
g7337
ag7337
ag7337
ag7337
asg13
S'com.google.common.collect.Range$3'
p7373
sg15
(lp7374
V`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7375
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7376
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7377
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7378
asg17
(lp7379
g7345
ag7345
ag7345
ag7345
asg19
(lp7380
g7347
ag7347
ag7347
ag7347
asg21
I0
sba(iArchitecture
Entity
p7381
(dp7382
g11
(lp7383
g7337
ag7337
ag7337
ag7337
asg13
S'com.google.common.collect.Range$4'
p7384
sg15
(lp7385
V`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7386
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7387
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7388
aV`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7389
asg17
(lp7390
g7345
ag7345
ag7345
ag7345
asg19
(lp7391
g7347
ag7347
ag7347
ag7347
asg21
I0
sba(iArchitecture
Entity
p7392
(dp7393
g11
(lp7394
g7337
asg13
S'com.google.common.collect.RangeMap'
p7395
sg15
(lp7396
V`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7397
asg17
(lp7398
g7345
asg19
(lp7399
g7347
asg21
I0
sba(iArchitecture
Entity
p7400
(dp7401
g11
(lp7402
g7337
asg13
S'com.google.common.collect.RangeSet'
p7403
sg15
(lp7404
V`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\u000a\u000aConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\u000a
p7405
asg17
(lp7406
g7345
asg19
(lp7407
g7347
asg21
I0
sba(iArchitecture
Entity
p7408
(dp7409
g11
(lp7410
g3141
asg13
S'com.google.common.collect.RegularContiguousSet'
p7411
sg15
(lp7412
VLet a < x < b:\u000a- [x].intersection([x]) should return [x], returns [],\u000a- [x].intersection([a..b]) should return [x], returns [],\u000a- [a..b].intersection([x]) should return [x], returns [],\u000a- [a..x].intersection([x..b]) should return [x], returns [].\u000a\u000aI'll create a PR in a minute.\u000a
p7413
asg17
(lp7414
g3146
asg19
(lp7415
g3148
asg21
I0
sba(iArchitecture
Entity
p7416
(dp7417
g11
(lp7418
g3141
asg13
S'com.google.common.collect.RegularContiguousSet$1'
p7419
sg15
(lp7420
VLet a < x < b:\u000a- [x].intersection([x]) should return [x], returns [],\u000a- [x].intersection([a..b]) should return [x], returns [],\u000a- [a..b].intersection([x]) should return [x], returns [],\u000a- [a..x].intersection([x..b]) should return [x], returns [].\u000a\u000aI'll create a PR in a minute.\u000a
p7421
asg17
(lp7422
g3146
asg19
(lp7423
g3148
asg21
I0
sba(iArchitecture
Entity
p7424
(dp7425
g11
(lp7426
g3141
asg13
S'com.google.common.collect.RegularContiguousSet$2'
p7427
sg15
(lp7428
VLet a < x < b:\u000a- [x].intersection([x]) should return [x], returns [],\u000a- [x].intersection([a..b]) should return [x], returns [],\u000a- [a..b].intersection([x]) should return [x], returns [],\u000a- [a..x].intersection([x..b]) should return [x], returns [].\u000a\u000aI'll create a PR in a minute.\u000a
p7429
asg17
(lp7430
g3146
asg19
(lp7431
g3148
asg21
I0
sba(iArchitecture
Entity
p7432
(dp7433
g11
(lp7434
g3141
asg13
S'com.google.common.collect.RegularContiguousSet$SerializedForm'
p7435
sg15
(lp7436
VLet a < x < b:\u000a- [x].intersection([x]) should return [x], returns [],\u000a- [x].intersection([a..b]) should return [x], returns [],\u000a- [a..b].intersection([x]) should return [x], returns [],\u000a- [a..x].intersection([x..b]) should return [x], returns [].\u000a\u000aI'll create a PR in a minute.\u000a
p7437
asg17
(lp7438
g3146
asg19
(lp7439
g3148
asg21
I0
sba(iArchitecture
Entity
p7440
(dp7441
g11
(lp7442
sg13
S'com.google.common.collect.RegularImmutableAsList'
p7443
sg15
(lp7444
sg17
(lp7445
sg19
(lp7446
sg21
I0
sba(iArchitecture
Entity
p7447
(dp7448
g11
(lp7449
sg13
S'com.google.common.collect.RegularImmutableBiMap'
p7450
sg15
(lp7451
sg17
(lp7452
sg19
(lp7453
sg21
I0
sba(iArchitecture
Entity
p7454
(dp7455
g11
(lp7456
sg13
S'com.google.common.collect.RegularImmutableBiMap$1'
p7457
sg15
(lp7458
sg17
(lp7459
sg19
(lp7460
sg21
I0
sba(iArchitecture
Entity
p7461
(dp7462
g11
(lp7463
sg13
S'com.google.common.collect.RegularImmutableBiMap$Inverse'
p7464
sg15
(lp7465
sg17
(lp7466
sg19
(lp7467
sg21
I0
sba(iArchitecture
Entity
p7468
(dp7469
g11
(lp7470
sg13
S'com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet'
p7471
sg15
(lp7472
sg17
(lp7473
sg19
(lp7474
sg21
I0
sba(iArchitecture
Entity
p7475
(dp7476
g11
(lp7477
sg13
S'com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet$1'
p7478
sg15
(lp7479
sg17
(lp7480
sg19
(lp7481
sg21
I0
sba(iArchitecture
Entity
p7482
(dp7483
g11
(lp7484
sg13
S'com.google.common.collect.RegularImmutableBiMap$InverseSerializedForm'
p7485
sg15
(lp7486
sg17
(lp7487
sg19
(lp7488
sg21
I0
sba(iArchitecture
Entity
p7489
(dp7490
g11
(lp7491
sg13
S'com.google.common.collect.RegularImmutableBiMap$NonTerminalBiMapEntry'
p7492
sg15
(lp7493
sg17
(lp7494
sg19
(lp7495
sg21
I0
sba(iArchitecture
Entity
p7496
(dp7497
g11
(lp7498
g4184
asg13
S'com.google.common.collect.RegularImmutableList'
p7499
sg15
(lp7500
VImmutableList contains following code since version 15.0\u000a\u000a private static final ImmutableList<Object> EMPTY =\u000a      new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);\u000a
p7501
asg17
(lp7502
g4190
asg19
(lp7503
g4192
asg21
I0
sba(iArchitecture
Entity
p7504
(dp7505
g11
(lp7506
sg13
S'com.google.common.collect.RegularImmutableMap'
p7507
sg15
(lp7508
sg17
(lp7509
sg19
(lp7510
sg21
I0
sba(iArchitecture
Entity
p7511
(dp7512
g11
(lp7513
sg13
S'com.google.common.collect.RegularImmutableMap$1'
p7514
sg15
(lp7515
sg17
(lp7516
sg19
(lp7517
sg21
I0
sba(iArchitecture
Entity
p7518
(dp7519
g11
(lp7520
sg13
S'com.google.common.collect.RegularImmutableMap$EntrySet'
p7521
sg15
(lp7522
sg17
(lp7523
sg19
(lp7524
sg21
I0
sba(iArchitecture
Entity
p7525
(dp7526
g11
(lp7527
sg13
S'com.google.common.collect.RegularImmutableMap$NonTerminalMapEntry'
p7528
sg15
(lp7529
sg17
(lp7530
sg19
(lp7531
sg21
I0
sba(iArchitecture
Entity
p7532
(dp7533
g11
(lp7534
sg13
S'com.google.common.collect.RegularImmutableMultiset'
p7535
sg15
(lp7536
sg17
(lp7537
sg19
(lp7538
sg21
I0
sba(iArchitecture
Entity
p7539
(dp7540
g11
(lp7541
sg13
S'com.google.common.collect.RegularImmutableSet'
p7542
sg15
(lp7543
sg17
(lp7544
sg19
(lp7545
sg21
I0
sba(iArchitecture
Entity
p7546
(dp7547
g11
(lp7548
sg13
S'com.google.common.collect.RegularImmutableSortedMap'
p7549
sg15
(lp7550
sg17
(lp7551
sg19
(lp7552
sg21
I0
sba(iArchitecture
Entity
p7553
(dp7554
g11
(lp7555
sg13
S'com.google.common.collect.RegularImmutableSortedMap$1'
p7556
sg15
(lp7557
sg17
(lp7558
sg19
(lp7559
sg21
I0
sba(iArchitecture
Entity
p7560
(dp7561
g11
(lp7562
sg13
S'com.google.common.collect.RegularImmutableSortedMap$EntrySet'
p7563
sg15
(lp7564
sg17
(lp7565
sg19
(lp7566
sg21
I0
sba(iArchitecture
Entity
p7567
(dp7568
g11
(lp7569
sg13
S'com.google.common.collect.RegularImmutableSortedMap$EntrySet$1'
p7570
sg15
(lp7571
sg17
(lp7572
sg19
(lp7573
sg21
I0
sba(iArchitecture
Entity
p7574
(dp7575
g11
(lp7576
sg13
S'com.google.common.collect.RegularImmutableSortedMultiset'
p7577
sg15
(lp7578
sg17
(lp7579
sg19
(lp7580
sg21
I0
sba(iArchitecture
Entity
p7581
(dp7582
g11
(lp7583
sg13
S'com.google.common.collect.RegularImmutableSortedSet'
p7584
sg15
(lp7585
sg17
(lp7586
sg19
(lp7587
sg21
I0
sba(iArchitecture
Entity
p7588
(dp7589
g11
(lp7590
sg13
S'com.google.common.collect.RegularImmutableTable'
p7591
sg15
(lp7592
sg17
(lp7593
sg19
(lp7594
sg21
I0
sba(iArchitecture
Entity
p7595
(dp7596
g11
(lp7597
sg13
S'com.google.common.collect.RegularImmutableTable$1'
p7598
sg15
(lp7599
sg17
(lp7600
sg19
(lp7601
sg21
I0
sba(iArchitecture
Entity
p7602
(dp7603
g11
(lp7604
sg13
S'com.google.common.collect.RegularImmutableTable$CellSet'
p7605
sg15
(lp7606
sg17
(lp7607
sg19
(lp7608
sg21
I0
sba(iArchitecture
Entity
p7609
(dp7610
g11
(lp7611
sg13
S'com.google.common.collect.RegularImmutableTable$CellSet$1'
p7612
sg15
(lp7613
sg17
(lp7614
sg19
(lp7615
sg21
I0
sba(iArchitecture
Entity
p7616
(dp7617
g11
(lp7618
sg13
S'com.google.common.collect.RegularImmutableTable$Values'
p7619
sg15
(lp7620
sg17
(lp7621
sg19
(lp7622
sg21
I0
sba(iArchitecture
Entity
p7623
(dp7624
g11
(lp7625
g25
asg13
S'com.google.common.collect.ReverseNaturalOrdering'
p7626
sg15
(lp7627
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p7628
asg17
(lp7629
g32
asg19
(lp7630
g35
asg21
I0
sba(iArchitecture
Entity
p7631
(dp7632
g11
(lp7633
sg13
S'com.google.common.collect.ReverseOrdering'
p7634
sg15
(lp7635
sg17
(lp7636
sg19
(lp7637
sg21
I0
sba(iArchitecture
Entity
p7638
(dp7639
g11
(lp7640
sg13
S'com.google.common.collect.RowSortedTable'
p7641
sg15
(lp7642
sg17
(lp7643
sg19
(lp7644
sg21
I0
sba(iArchitecture
Entity
p7645
(dp7646
g11
(lp7647
sg13
S'com.google.common.collect.Serialization'
p7648
sg15
(lp7649
sg17
(lp7650
sg19
(lp7651
sg21
I0
sba(iArchitecture
Entity
p7652
(dp7653
g11
(lp7654
sg13
S'com.google.common.collect.Serialization$1'
p7655
sg15
(lp7656
sg17
(lp7657
sg19
(lp7658
sg21
I0
sba(iArchitecture
Entity
p7659
(dp7660
g11
(lp7661
sg13
S'com.google.common.collect.Serialization$FieldSetter'
p7662
sg15
(lp7663
sg17
(lp7664
sg19
(lp7665
sg21
I0
sba(iArchitecture
Entity
p7666
(dp7667
g11
(lp7668
sg13
S'com.google.common.collect.SetMultimap'
p7669
sg15
(lp7670
sg17
(lp7671
sg19
(lp7672
sg21
I0
sba(iArchitecture
Entity
p7673
(dp7674
g11
(lp7675
V1001
p7676
ag7676
asg13
S'com.google.common.collect.Sets'
p7677
sg15
(lp7678
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7679
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7680
asg17
(lp7681
(lp7682
I0
aag7682
asg19
(lp7683
VReimplement and deprecate Sets.newSetFromMap (but no removing it)
p7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7685
(dp7686
g11
(lp7687
g7676
ag7676
asg13
S'com.google.common.collect.Sets$1'
p7688
sg15
(lp7689
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7690
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7691
asg17
(lp7692
g7682
ag7682
asg19
(lp7693
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7694
(dp7695
g11
(lp7696
g7676
ag7676
asg13
S'com.google.common.collect.Sets$2'
p7697
sg15
(lp7698
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7699
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7700
asg17
(lp7701
g7682
ag7682
asg19
(lp7702
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7703
(dp7704
g11
(lp7705
g7676
ag7676
asg13
S'com.google.common.collect.Sets$3'
p7706
sg15
(lp7707
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7708
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7709
asg17
(lp7710
g7682
ag7682
asg19
(lp7711
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7712
(dp7713
g11
(lp7714
g7676
ag7676
asg13
S'com.google.common.collect.Sets$CartesianSet'
p7715
sg15
(lp7716
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7717
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7718
asg17
(lp7719
g7682
ag7682
asg19
(lp7720
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7721
(dp7722
g11
(lp7723
g7676
ag7676
asg13
S'com.google.common.collect.Sets$CartesianSet$1'
p7724
sg15
(lp7725
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7726
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7727
asg17
(lp7728
g7682
ag7682
asg19
(lp7729
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7730
(dp7731
g11
(lp7732
g7676
ag7676
asg13
S'com.google.common.collect.Sets$DescendingSet'
p7733
sg15
(lp7734
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7735
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7736
asg17
(lp7737
g7682
ag7682
asg19
(lp7738
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7739
(dp7740
g11
(lp7741
g7676
ag7676
asg13
S'com.google.common.collect.Sets$FilteredNavigableSet'
p7742
sg15
(lp7743
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7744
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7745
asg17
(lp7746
g7682
ag7682
asg19
(lp7747
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7748
(dp7749
g11
(lp7750
g7676
ag7676
asg13
S'com.google.common.collect.Sets$FilteredSet'
p7751
sg15
(lp7752
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7753
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7754
asg17
(lp7755
g7682
ag7682
asg19
(lp7756
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7757
(dp7758
g11
(lp7759
g7676
ag7676
asg13
S'com.google.common.collect.Sets$FilteredSortedSet'
p7760
sg15
(lp7761
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7762
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7763
asg17
(lp7764
g7682
ag7682
asg19
(lp7765
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7766
(dp7767
g11
(lp7768
g7676
ag7676
asg13
S'com.google.common.collect.Sets$ImprovedAbstractSet'
p7769
sg15
(lp7770
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7771
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7772
asg17
(lp7773
g7682
ag7682
asg19
(lp7774
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7775
(dp7776
g11
(lp7777
g7676
ag7676
asg13
S'com.google.common.collect.Sets$PowerSet'
p7778
sg15
(lp7779
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7780
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7781
asg17
(lp7782
g7682
ag7682
asg19
(lp7783
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7784
(dp7785
g11
(lp7786
g7676
ag7676
asg13
S'com.google.common.collect.Sets$PowerSet$1'
p7787
sg15
(lp7788
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7789
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7790
asg17
(lp7791
g7682
ag7682
asg19
(lp7792
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7793
(dp7794
g11
(lp7795
g7676
ag7676
asg13
S'com.google.common.collect.Sets$SetView'
p7796
sg15
(lp7797
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7798
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7799
asg17
(lp7800
g7682
ag7682
asg19
(lp7801
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7802
(dp7803
g11
(lp7804
g7676
ag7676
asg13
S'com.google.common.collect.Sets$SubSet'
p7805
sg15
(lp7806
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7807
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7808
asg17
(lp7809
g7682
ag7682
asg19
(lp7810
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7811
(dp7812
g11
(lp7813
g7676
ag7676
asg13
S'com.google.common.collect.Sets$SubSet$1'
p7814
sg15
(lp7815
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7816
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7817
asg17
(lp7818
g7682
ag7682
asg19
(lp7819
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7820
(dp7821
g11
(lp7822
g7676
ag7676
asg13
S'com.google.common.collect.Sets$UnmodifiableNavigableSet'
p7823
sg15
(lp7824
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7825
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1001) created by **kevinb@google.com** on 2012-05-11 at 04:32 PM_\u000a\u000a---\u000a\u000aNow that Guava requires JDK 6, we can probably reimplement Sets.newSetFromMap as a pass-through to Collections.newSetFromMap(), and deprecate it.  However,\u000a\u000a(a) no sense doing that until after the backport is worked out, and\u000a\u000a(b) I don't think we can do the usual "schedule for deletion in 18 months" thing. For the time being, I think we need to ensure that the relationship between guava and guava5 is that of a purely compatible superset. Otherwise libraries that build against guava5 in order to be available to their JDK 5 users may break when used by JDK 6 users (who use guava instead of guava5).\u000a\u000aNot sure for which other libraries we might have a similar situation.\u000a
p7826
asg17
(lp7827
g7682
ag7682
asg19
(lp7828
g7684
ag7684
asg21
I0
sba(iArchitecture
Entity
p7829
(dp7830
g11
(lp7831
sg13
S'com.google.common.collect.SingletonImmutableBiMap'
p7832
sg15
(lp7833
sg17
(lp7834
sg19
(lp7835
sg21
I0
sba(iArchitecture
Entity
p7836
(dp7837
g11
(lp7838
sg13
S'com.google.common.collect.SingletonImmutableList'
p7839
sg15
(lp7840
sg17
(lp7841
sg19
(lp7842
sg21
I0
sba(iArchitecture
Entity
p7843
(dp7844
g11
(lp7845
sg13
S'com.google.common.collect.SingletonImmutableSet'
p7846
sg15
(lp7847
sg17
(lp7848
sg19
(lp7849
sg21
I0
sba(iArchitecture
Entity
p7850
(dp7851
g11
(lp7852
sg13
S'com.google.common.collect.SingletonImmutableTable'
p7853
sg15
(lp7854
sg17
(lp7855
sg19
(lp7856
sg21
I0
sba(iArchitecture
Entity
p7857
(dp7858
g11
(lp7859
sg13
S'com.google.common.collect.SortedIterable'
p7860
sg15
(lp7861
sg17
(lp7862
sg19
(lp7863
sg21
I0
sba(iArchitecture
Entity
p7864
(dp7865
g11
(lp7866
sg13
S'com.google.common.collect.SortedIterables'
p7867
sg15
(lp7868
sg17
(lp7869
sg19
(lp7870
sg21
I0
sba(iArchitecture
Entity
p7871
(dp7872
g11
(lp7873
sg13
S'com.google.common.collect.SortedLists'
p7874
sg15
(lp7875
sg17
(lp7876
sg19
(lp7877
sg21
I0
sba(iArchitecture
Entity
p7878
(dp7879
g11
(lp7880
sg13
S'com.google.common.collect.SortedLists$1'
p7881
sg15
(lp7882
sg17
(lp7883
sg19
(lp7884
sg21
I0
sba(iArchitecture
Entity
p7885
(dp7886
g11
(lp7887
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior'
p7888
sg15
(lp7889
sg17
(lp7890
sg19
(lp7891
sg21
I0
sba(iArchitecture
Entity
p7892
(dp7893
g11
(lp7894
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior$1'
p7895
sg15
(lp7896
sg17
(lp7897
sg19
(lp7898
sg21
I0
sba(iArchitecture
Entity
p7899
(dp7900
g11
(lp7901
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior$2'
p7902
sg15
(lp7903
sg17
(lp7904
sg19
(lp7905
sg21
I0
sba(iArchitecture
Entity
p7906
(dp7907
g11
(lp7908
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior$3'
p7909
sg15
(lp7910
sg17
(lp7911
sg19
(lp7912
sg21
I0
sba(iArchitecture
Entity
p7913
(dp7914
g11
(lp7915
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior'
p7916
sg15
(lp7917
sg17
(lp7918
sg19
(lp7919
sg21
I0
sba(iArchitecture
Entity
p7920
(dp7921
g11
(lp7922
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$1'
p7923
sg15
(lp7924
sg17
(lp7925
sg19
(lp7926
sg21
I0
sba(iArchitecture
Entity
p7927
(dp7928
g11
(lp7929
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$2'
p7930
sg15
(lp7931
sg17
(lp7932
sg19
(lp7933
sg21
I0
sba(iArchitecture
Entity
p7934
(dp7935
g11
(lp7936
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$3'
p7937
sg15
(lp7938
sg17
(lp7939
sg19
(lp7940
sg21
I0
sba(iArchitecture
Entity
p7941
(dp7942
g11
(lp7943
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$4'
p7944
sg15
(lp7945
sg17
(lp7946
sg19
(lp7947
sg21
I0
sba(iArchitecture
Entity
p7948
(dp7949
g11
(lp7950
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$5'
p7951
sg15
(lp7952
sg17
(lp7953
sg19
(lp7954
sg21
I0
sba(iArchitecture
Entity
p7955
(dp7956
g11
(lp7957
sg13
S'com.google.common.collect.SortedMapDifference'
p7958
sg15
(lp7959
sg17
(lp7960
sg19
(lp7961
sg21
I0
sba(iArchitecture
Entity
p7962
(dp7963
g11
(lp7964
sg13
S'com.google.common.collect.SortedMultiset'
p7965
sg15
(lp7966
sg17
(lp7967
sg19
(lp7968
sg21
I0
sba(iArchitecture
Entity
p7969
(dp7970
g11
(lp7971
sg13
S'com.google.common.collect.SortedMultisetBridge'
p7972
sg15
(lp7973
sg17
(lp7974
sg19
(lp7975
sg21
I0
sba(iArchitecture
Entity
p7976
(dp7977
g11
(lp7978
sg13
S'com.google.common.collect.SortedMultisets'
p7979
sg15
(lp7980
sg17
(lp7981
sg19
(lp7982
sg21
I0
sba(iArchitecture
Entity
p7983
(dp7984
g11
(lp7985
sg13
S'com.google.common.collect.SortedMultisets$ElementSet'
p7986
sg15
(lp7987
sg17
(lp7988
sg19
(lp7989
sg21
I0
sba(iArchitecture
Entity
p7990
(dp7991
g11
(lp7992
sg13
S'com.google.common.collect.SortedMultisets$NavigableElementSet'
p7993
sg15
(lp7994
sg17
(lp7995
sg19
(lp7996
sg21
I0
sba(iArchitecture
Entity
p7997
(dp7998
g11
(lp7999
sg13
S'com.google.common.collect.SortedSetMultimap'
p8000
sg15
(lp8001
sg17
(lp8002
sg19
(lp8003
sg21
I0
sba(iArchitecture
Entity
p8004
(dp8005
g11
(lp8006
sg13
S'com.google.common.collect.SparseImmutableTable'
p8007
sg15
(lp8008
sg17
(lp8009
sg19
(lp8010
sg21
I0
sba(iArchitecture
Entity
p8011
(dp8012
g11
(lp8013
sg13
S'com.google.common.collect.StandardRowSortedTable'
p8014
sg15
(lp8015
sg17
(lp8016
sg19
(lp8017
sg21
I0
sba(iArchitecture
Entity
p8018
(dp8019
g11
(lp8020
sg13
S'com.google.common.collect.StandardRowSortedTable$1'
p8021
sg15
(lp8022
sg17
(lp8023
sg19
(lp8024
sg21
I0
sba(iArchitecture
Entity
p8025
(dp8026
g11
(lp8027
sg13
S'com.google.common.collect.StandardRowSortedTable$RowSortedMap'
p8028
sg15
(lp8029
sg17
(lp8030
sg19
(lp8031
sg21
I0
sba(iArchitecture
Entity
p8032
(dp8033
g11
(lp8034
sg13
S'com.google.common.collect.StandardTable'
p8035
sg15
(lp8036
sg17
(lp8037
sg19
(lp8038
sg21
I0
sba(iArchitecture
Entity
p8039
(dp8040
g11
(lp8041
sg13
S'com.google.common.collect.StandardTable$1'
p8042
sg15
(lp8043
sg17
(lp8044
sg19
(lp8045
sg21
I0
sba(iArchitecture
Entity
p8046
(dp8047
g11
(lp8048
sg13
S'com.google.common.collect.StandardTable$CellIterator'
p8049
sg15
(lp8050
sg17
(lp8051
sg19
(lp8052
sg21
I0
sba(iArchitecture
Entity
p8053
(dp8054
g11
(lp8055
sg13
S'com.google.common.collect.StandardTable$Column'
p8056
sg15
(lp8057
sg17
(lp8058
sg19
(lp8059
sg21
I0
sba(iArchitecture
Entity
p8060
(dp8061
g11
(lp8062
sg13
S'com.google.common.collect.StandardTable$Column$EntrySet'
p8063
sg15
(lp8064
sg17
(lp8065
sg19
(lp8066
sg21
I0
sba(iArchitecture
Entity
p8067
(dp8068
g11
(lp8069
sg13
S'com.google.common.collect.StandardTable$Column$EntrySetIterator'
p8070
sg15
(lp8071
sg17
(lp8072
sg19
(lp8073
sg21
I0
sba(iArchitecture
Entity
p8074
(dp8075
g11
(lp8076
sg13
S'com.google.common.collect.StandardTable$Column$EntrySetIterator$1'
p8077
sg15
(lp8078
sg17
(lp8079
sg19
(lp8080
sg21
I0
sba(iArchitecture
Entity
p8081
(dp8082
g11
(lp8083
sg13
S'com.google.common.collect.StandardTable$Column$KeySet'
p8084
sg15
(lp8085
sg17
(lp8086
sg19
(lp8087
sg21
I0
sba(iArchitecture
Entity
p8088
(dp8089
g11
(lp8090
sg13
S'com.google.common.collect.StandardTable$Column$Values'
p8091
sg15
(lp8092
sg17
(lp8093
sg19
(lp8094
sg21
I0
sba(iArchitecture
Entity
p8095
(dp8096
g11
(lp8097
sg13
S'com.google.common.collect.StandardTable$ColumnKeyIterator'
p8098
sg15
(lp8099
sg17
(lp8100
sg19
(lp8101
sg21
I0
sba(iArchitecture
Entity
p8102
(dp8103
g11
(lp8104
sg13
S'com.google.common.collect.StandardTable$ColumnKeySet'
p8105
sg15
(lp8106
sg17
(lp8107
sg19
(lp8108
sg21
I0
sba(iArchitecture
Entity
p8109
(dp8110
g11
(lp8111
sg13
S'com.google.common.collect.StandardTable$ColumnMap'
p8112
sg15
(lp8113
sg17
(lp8114
sg19
(lp8115
sg21
I0
sba(iArchitecture
Entity
p8116
(dp8117
g11
(lp8118
sg13
S'com.google.common.collect.StandardTable$ColumnMap$ColumnMapEntrySet'
p8119
sg15
(lp8120
sg17
(lp8121
sg19
(lp8122
sg21
I0
sba(iArchitecture
Entity
p8123
(dp8124
g11
(lp8125
sg13
S'com.google.common.collect.StandardTable$ColumnMap$ColumnMapEntrySet$1'
p8126
sg15
(lp8127
sg17
(lp8128
sg19
(lp8129
sg21
I0
sba(iArchitecture
Entity
p8130
(dp8131
g11
(lp8132
sg13
S'com.google.common.collect.StandardTable$ColumnMap$ColumnMapValues'
p8133
sg15
(lp8134
sg17
(lp8135
sg19
(lp8136
sg21
I0
sba(iArchitecture
Entity
p8137
(dp8138
g11
(lp8139
sg13
S'com.google.common.collect.StandardTable$Row'
p8140
sg15
(lp8141
sg17
(lp8142
sg19
(lp8143
sg21
I0
sba(iArchitecture
Entity
p8144
(dp8145
g11
(lp8146
sg13
S'com.google.common.collect.StandardTable$Row$RowEntrySet'
p8147
sg15
(lp8148
sg17
(lp8149
sg19
(lp8150
sg21
I0
sba(iArchitecture
Entity
p8151
(dp8152
g11
(lp8153
sg13
S'com.google.common.collect.StandardTable$Row$RowEntrySet$1'
p8154
sg15
(lp8155
sg17
(lp8156
sg19
(lp8157
sg21
I0
sba(iArchitecture
Entity
p8158
(dp8159
g11
(lp8160
sg13
S'com.google.common.collect.StandardTable$Row$RowEntrySet$1$1'
p8161
sg15
(lp8162
sg17
(lp8163
sg19
(lp8164
sg21
I0
sba(iArchitecture
Entity
p8165
(dp8166
g11
(lp8167
sg13
S'com.google.common.collect.StandardTable$RowMap'
p8168
sg15
(lp8169
sg17
(lp8170
sg19
(lp8171
sg21
I0
sba(iArchitecture
Entity
p8172
(dp8173
g11
(lp8174
sg13
S'com.google.common.collect.StandardTable$RowMap$EntrySet'
p8175
sg15
(lp8176
sg17
(lp8177
sg19
(lp8178
sg21
I0
sba(iArchitecture
Entity
p8179
(dp8180
g11
(lp8181
sg13
S'com.google.common.collect.StandardTable$RowMap$EntrySet$1'
p8182
sg15
(lp8183
sg17
(lp8184
sg19
(lp8185
sg21
I0
sba(iArchitecture
Entity
p8186
(dp8187
g11
(lp8188
sg13
S'com.google.common.collect.StandardTable$TableSet'
p8189
sg15
(lp8190
sg17
(lp8191
sg19
(lp8192
sg21
I0
sba(iArchitecture
Entity
p8193
(dp8194
g11
(lp8195
sg13
S'com.google.common.collect.Synchronized'
p8196
sg15
(lp8197
sg17
(lp8198
sg19
(lp8199
sg21
I0
sba(iArchitecture
Entity
p8200
(dp8201
g11
(lp8202
sg13
S'com.google.common.collect.Synchronized$1'
p8203
sg15
(lp8204
sg17
(lp8205
sg19
(lp8206
sg21
I0
sba(iArchitecture
Entity
p8207
(dp8208
g11
(lp8209
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMap'
p8210
sg15
(lp8211
sg17
(lp8212
sg19
(lp8213
sg21
I0
sba(iArchitecture
Entity
p8214
(dp8215
g11
(lp8216
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapEntries'
p8217
sg15
(lp8218
sg17
(lp8219
sg19
(lp8220
sg21
I0
sba(iArchitecture
Entity
p8221
(dp8222
g11
(lp8223
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapEntries$1'
p8224
sg15
(lp8225
sg17
(lp8226
sg19
(lp8227
sg21
I0
sba(iArchitecture
Entity
p8228
(dp8229
g11
(lp8230
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapEntries$1$1'
p8231
sg15
(lp8232
sg17
(lp8233
sg19
(lp8234
sg21
I0
sba(iArchitecture
Entity
p8235
(dp8236
g11
(lp8237
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapValues'
p8238
sg15
(lp8239
sg17
(lp8240
sg19
(lp8241
sg21
I0
sba(iArchitecture
Entity
p8242
(dp8243
g11
(lp8244
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapValues$1'
p8245
sg15
(lp8246
sg17
(lp8247
sg19
(lp8248
sg21
I0
sba(iArchitecture
Entity
p8249
(dp8250
g11
(lp8251
sg13
S'com.google.common.collect.Synchronized$SynchronizedBiMap'
p8252
sg15
(lp8253
sg17
(lp8254
sg19
(lp8255
sg21
I0
sba(iArchitecture
Entity
p8256
(dp8257
g11
(lp8258
sg13
S'com.google.common.collect.Synchronized$SynchronizedCollection'
p8259
sg15
(lp8260
sg17
(lp8261
sg19
(lp8262
sg21
I0
sba(iArchitecture
Entity
p8263
(dp8264
g11
(lp8265
sg13
S'com.google.common.collect.Synchronized$SynchronizedDeque'
p8266
sg15
(lp8267
sg17
(lp8268
sg19
(lp8269
sg21
I0
sba(iArchitecture
Entity
p8270
(dp8271
g11
(lp8272
sg13
S'com.google.common.collect.Synchronized$SynchronizedEntry'
p8273
sg15
(lp8274
sg17
(lp8275
sg19
(lp8276
sg21
I0
sba(iArchitecture
Entity
p8277
(dp8278
g11
(lp8279
sg13
S'com.google.common.collect.Synchronized$SynchronizedList'
p8280
sg15
(lp8281
sg17
(lp8282
sg19
(lp8283
sg21
I0
sba(iArchitecture
Entity
p8284
(dp8285
g11
(lp8286
sg13
S'com.google.common.collect.Synchronized$SynchronizedListMultimap'
p8287
sg15
(lp8288
sg17
(lp8289
sg19
(lp8290
sg21
I0
sba(iArchitecture
Entity
p8291
(dp8292
g11
(lp8293
sg13
S'com.google.common.collect.Synchronized$SynchronizedMap'
p8294
sg15
(lp8295
sg17
(lp8296
sg19
(lp8297
sg21
I0
sba(iArchitecture
Entity
p8298
(dp8299
g11
(lp8300
sg13
S'com.google.common.collect.Synchronized$SynchronizedMultimap'
p8301
sg15
(lp8302
sg17
(lp8303
sg19
(lp8304
sg21
I0
sba(iArchitecture
Entity
p8305
(dp8306
g11
(lp8307
sg13
S'com.google.common.collect.Synchronized$SynchronizedMultiset'
p8308
sg15
(lp8309
sg17
(lp8310
sg19
(lp8311
sg21
I0
sba(iArchitecture
Entity
p8312
(dp8313
g11
(lp8314
sg13
S'com.google.common.collect.Synchronized$SynchronizedNavigableMap'
p8315
sg15
(lp8316
sg17
(lp8317
sg19
(lp8318
sg21
I0
sba(iArchitecture
Entity
p8319
(dp8320
g11
(lp8321
sg13
S'com.google.common.collect.Synchronized$SynchronizedNavigableSet'
p8322
sg15
(lp8323
sg17
(lp8324
sg19
(lp8325
sg21
I0
sba(iArchitecture
Entity
p8326
(dp8327
g11
(lp8328
sg13
S'com.google.common.collect.Synchronized$SynchronizedObject'
p8329
sg15
(lp8330
sg17
(lp8331
sg19
(lp8332
sg21
I0
sba(iArchitecture
Entity
p8333
(dp8334
g11
(lp8335
sg13
S'com.google.common.collect.Synchronized$SynchronizedQueue'
p8336
sg15
(lp8337
sg17
(lp8338
sg19
(lp8339
sg21
I0
sba(iArchitecture
Entity
p8340
(dp8341
g11
(lp8342
sg13
S'com.google.common.collect.Synchronized$SynchronizedRandomAccessList'
p8343
sg15
(lp8344
sg17
(lp8345
sg19
(lp8346
sg21
I0
sba(iArchitecture
Entity
p8347
(dp8348
g11
(lp8349
sg13
S'com.google.common.collect.Synchronized$SynchronizedSet'
p8350
sg15
(lp8351
sg17
(lp8352
sg19
(lp8353
sg21
I0
sba(iArchitecture
Entity
p8354
(dp8355
g11
(lp8356
sg13
S'com.google.common.collect.Synchronized$SynchronizedSetMultimap'
p8357
sg15
(lp8358
sg17
(lp8359
sg19
(lp8360
sg21
I0
sba(iArchitecture
Entity
p8361
(dp8362
g11
(lp8363
sg13
S'com.google.common.collect.Synchronized$SynchronizedSortedMap'
p8364
sg15
(lp8365
sg17
(lp8366
sg19
(lp8367
sg21
I0
sba(iArchitecture
Entity
p8368
(dp8369
g11
(lp8370
sg13
S'com.google.common.collect.Synchronized$SynchronizedSortedSet'
p8371
sg15
(lp8372
sg17
(lp8373
sg19
(lp8374
sg21
I0
sba(iArchitecture
Entity
p8375
(dp8376
g11
(lp8377
sg13
S'com.google.common.collect.Synchronized$SynchronizedSortedSetMultimap'
p8378
sg15
(lp8379
sg17
(lp8380
sg19
(lp8381
sg21
I0
sba(iArchitecture
Entity
p8382
(dp8383
g11
(lp8384
sg13
S'com.google.common.collect.Table'
p8385
sg15
(lp8386
sg17
(lp8387
sg19
(lp8388
sg21
I0
sba(iArchitecture
Entity
p8389
(dp8390
g11
(lp8391
sg13
S'com.google.common.collect.Table$Cell'
p8392
sg15
(lp8393
sg17
(lp8394
sg19
(lp8395
sg21
I0
sba(iArchitecture
Entity
p8396
(dp8397
g11
(lp8398
sg13
S'com.google.common.collect.Tables'
p8399
sg15
(lp8400
sg17
(lp8401
sg19
(lp8402
sg21
I0
sba(iArchitecture
Entity
p8403
(dp8404
g11
(lp8405
sg13
S'com.google.common.collect.Tables$1'
p8406
sg15
(lp8407
sg17
(lp8408
sg19
(lp8409
sg21
I0
sba(iArchitecture
Entity
p8410
(dp8411
g11
(lp8412
sg13
S'com.google.common.collect.Tables$AbstractCell'
p8413
sg15
(lp8414
sg17
(lp8415
sg19
(lp8416
sg21
I0
sba(iArchitecture
Entity
p8417
(dp8418
g11
(lp8419
sg13
S'com.google.common.collect.Tables$ImmutableCell'
p8420
sg15
(lp8421
sg17
(lp8422
sg19
(lp8423
sg21
I0
sba(iArchitecture
Entity
p8424
(dp8425
g11
(lp8426
sg13
S'com.google.common.collect.Tables$TransformedTable'
p8427
sg15
(lp8428
sg17
(lp8429
sg19
(lp8430
sg21
I0
sba(iArchitecture
Entity
p8431
(dp8432
g11
(lp8433
sg13
S'com.google.common.collect.Tables$TransformedTable$1'
p8434
sg15
(lp8435
sg17
(lp8436
sg19
(lp8437
sg21
I0
sba(iArchitecture
Entity
p8438
(dp8439
g11
(lp8440
sg13
S'com.google.common.collect.Tables$TransformedTable$2'
p8441
sg15
(lp8442
sg17
(lp8443
sg19
(lp8444
sg21
I0
sba(iArchitecture
Entity
p8445
(dp8446
g11
(lp8447
sg13
S'com.google.common.collect.Tables$TransformedTable$3'
p8448
sg15
(lp8449
sg17
(lp8450
sg19
(lp8451
sg21
I0
sba(iArchitecture
Entity
p8452
(dp8453
g11
(lp8454
sg13
S'com.google.common.collect.Tables$TransposeTable'
p8455
sg15
(lp8456
sg17
(lp8457
sg19
(lp8458
sg21
I0
sba(iArchitecture
Entity
p8459
(dp8460
g11
(lp8461
sg13
S'com.google.common.collect.Tables$TransposeTable$1'
p8462
sg15
(lp8463
sg17
(lp8464
sg19
(lp8465
sg21
I0
sba(iArchitecture
Entity
p8466
(dp8467
g11
(lp8468
sg13
S'com.google.common.collect.Tables$UnmodifiableRowSortedMap'
p8469
sg15
(lp8470
sg17
(lp8471
sg19
(lp8472
sg21
I0
sba(iArchitecture
Entity
p8473
(dp8474
g11
(lp8475
sg13
S'com.google.common.collect.Tables$UnmodifiableTable'
p8476
sg15
(lp8477
sg17
(lp8478
sg19
(lp8479
sg21
I0
sba(iArchitecture
Entity
p8480
(dp8481
g11
(lp8482
sg13
S'com.google.common.collect.TransformedIterator'
p8483
sg15
(lp8484
sg17
(lp8485
sg19
(lp8486
sg21
I0
sba(iArchitecture
Entity
p8487
(dp8488
g11
(lp8489
sg13
S'com.google.common.collect.TransformedListIterator'
p8490
sg15
(lp8491
sg17
(lp8492
sg19
(lp8493
sg21
I0
sba(iArchitecture
Entity
p8494
(dp8495
g11
(lp8496
sg13
S'com.google.common.collect.TreeBasedTable'
p8497
sg15
(lp8498
sg17
(lp8499
sg19
(lp8500
sg21
I0
sba(iArchitecture
Entity
p8501
(dp8502
g11
(lp8503
sg13
S'com.google.common.collect.TreeBasedTable$1'
p8504
sg15
(lp8505
sg17
(lp8506
sg19
(lp8507
sg21
I0
sba(iArchitecture
Entity
p8508
(dp8509
g11
(lp8510
sg13
S'com.google.common.collect.TreeBasedTable$2'
p8511
sg15
(lp8512
sg17
(lp8513
sg19
(lp8514
sg21
I0
sba(iArchitecture
Entity
p8515
(dp8516
g11
(lp8517
sg13
S'com.google.common.collect.TreeBasedTable$Factory'
p8518
sg15
(lp8519
sg17
(lp8520
sg19
(lp8521
sg21
I0
sba(iArchitecture
Entity
p8522
(dp8523
g11
(lp8524
sg13
S'com.google.common.collect.TreeBasedTable$TreeRow'
p8525
sg15
(lp8526
sg17
(lp8527
sg19
(lp8528
sg21
I0
sba(iArchitecture
Entity
p8529
(dp8530
g11
(lp8531
sg13
S'com.google.common.collect.TreeMultimap'
p8532
sg15
(lp8533
sg17
(lp8534
sg19
(lp8535
sg21
I0
sba(iArchitecture
Entity
p8536
(dp8537
g11
(lp8538
sg13
S'com.google.common.collect.TreeMultiset'
p8539
sg15
(lp8540
sg17
(lp8541
sg19
(lp8542
sg21
I0
sba(iArchitecture
Entity
p8543
(dp8544
g11
(lp8545
sg13
S'com.google.common.collect.TreeMultiset$1'
p8546
sg15
(lp8547
sg17
(lp8548
sg19
(lp8549
sg21
I0
sba(iArchitecture
Entity
p8550
(dp8551
g11
(lp8552
sg13
S'com.google.common.collect.TreeMultiset$2'
p8553
sg15
(lp8554
sg17
(lp8555
sg19
(lp8556
sg21
I0
sba(iArchitecture
Entity
p8557
(dp8558
g11
(lp8559
sg13
S'com.google.common.collect.TreeMultiset$3'
p8560
sg15
(lp8561
sg17
(lp8562
sg19
(lp8563
sg21
I0
sba(iArchitecture
Entity
p8564
(dp8565
g11
(lp8566
sg13
S'com.google.common.collect.TreeMultiset$4'
p8567
sg15
(lp8568
sg17
(lp8569
sg19
(lp8570
sg21
I0
sba(iArchitecture
Entity
p8571
(dp8572
g11
(lp8573
sg13
S'com.google.common.collect.TreeMultiset$Aggregate'
p8574
sg15
(lp8575
sg17
(lp8576
sg19
(lp8577
sg21
I0
sba(iArchitecture
Entity
p8578
(dp8579
g11
(lp8580
sg13
S'com.google.common.collect.TreeMultiset$Aggregate$1'
p8581
sg15
(lp8582
sg17
(lp8583
sg19
(lp8584
sg21
I0
sba(iArchitecture
Entity
p8585
(dp8586
g11
(lp8587
sg13
S'com.google.common.collect.TreeMultiset$Aggregate$2'
p8588
sg15
(lp8589
sg17
(lp8590
sg19
(lp8591
sg21
I0
sba(iArchitecture
Entity
p8592
(dp8593
g11
(lp8594
sg13
S'com.google.common.collect.TreeMultiset$AvlNode'
p8595
sg15
(lp8596
sg17
(lp8597
sg19
(lp8598
sg21
I0
sba(iArchitecture
Entity
p8599
(dp8600
g11
(lp8601
sg13
S'com.google.common.collect.TreeMultiset$Reference'
p8602
sg15
(lp8603
sg17
(lp8604
sg19
(lp8605
sg21
I0
sba(iArchitecture
Entity
p8606
(dp8607
g11
(lp8608
g25
asg13
S'com.google.common.collect.TreeRangeMap'
p8609
sg15
(lp8610
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8611
asg17
(lp8612
g32
asg19
(lp8613
g35
asg21
I0
sba(iArchitecture
Entity
p8614
(dp8615
g11
(lp8616
g25
asg13
S'com.google.common.collect.TreeRangeMap$1'
p8617
sg15
(lp8618
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8619
asg17
(lp8620
g32
asg19
(lp8621
g35
asg21
I0
sba(iArchitecture
Entity
p8622
(dp8623
g11
(lp8624
g25
asg13
S'com.google.common.collect.TreeRangeMap$AsMapOfRanges'
p8625
sg15
(lp8626
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8627
asg17
(lp8628
g32
asg19
(lp8629
g35
asg21
I0
sba(iArchitecture
Entity
p8630
(dp8631
g11
(lp8632
g25
asg13
S'com.google.common.collect.TreeRangeMap$AsMapOfRanges$1'
p8633
sg15
(lp8634
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8635
asg17
(lp8636
g32
asg19
(lp8637
g35
asg21
I0
sba(iArchitecture
Entity
p8638
(dp8639
g11
(lp8640
g25
asg13
S'com.google.common.collect.TreeRangeMap$RangeMapEntry'
p8641
sg15
(lp8642
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8643
asg17
(lp8644
g32
asg19
(lp8645
g35
asg21
I0
sba(iArchitecture
Entity
p8646
(dp8647
g11
(lp8648
g25
asg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap'
p8649
sg15
(lp8650
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8651
asg17
(lp8652
g32
asg19
(lp8653
g35
asg21
I0
sba(iArchitecture
Entity
p8654
(dp8655
g11
(lp8656
g25
asg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap'
p8657
sg15
(lp8658
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8659
asg17
(lp8660
g32
asg19
(lp8661
g35
asg21
I0
sba(iArchitecture
Entity
p8662
(dp8663
g11
(lp8664
g25
asg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$1'
p8665
sg15
(lp8666
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8667
asg17
(lp8668
g32
asg19
(lp8669
g35
asg21
I0
sba(iArchitecture
Entity
p8670
(dp8671
g11
(lp8672
g25
asg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$2'
p8673
sg15
(lp8674
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8675
asg17
(lp8676
g32
asg19
(lp8677
g35
asg21
I0
sba(iArchitecture
Entity
p8678
(dp8679
g11
(lp8680
g25
asg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$2$1'
p8681
sg15
(lp8682
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8683
asg17
(lp8684
g32
asg19
(lp8685
g35
asg21
I0
sba(iArchitecture
Entity
p8686
(dp8687
g11
(lp8688
g25
asg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$3'
p8689
sg15
(lp8690
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8691
asg17
(lp8692
g32
asg19
(lp8693
g35
asg21
I0
sba(iArchitecture
Entity
p8694
(dp8695
g11
(lp8696
sg13
S'com.google.common.collect.TreeRangeSet'
p8697
sg15
(lp8698
sg17
(lp8699
sg19
(lp8700
sg21
I0
sba(iArchitecture
Entity
p8701
(dp8702
g11
(lp8703
sg13
S'com.google.common.collect.TreeRangeSet$1'
p8704
sg15
(lp8705
sg17
(lp8706
sg19
(lp8707
sg21
I0
sba(iArchitecture
Entity
p8708
(dp8709
g11
(lp8710
sg13
S'com.google.common.collect.TreeRangeSet$AsRanges'
p8711
sg15
(lp8712
sg17
(lp8713
sg19
(lp8714
sg21
I0
sba(iArchitecture
Entity
p8715
(dp8716
g11
(lp8717
sg13
S'com.google.common.collect.TreeRangeSet$Complement'
p8718
sg15
(lp8719
sg17
(lp8720
sg19
(lp8721
sg21
I0
sba(iArchitecture
Entity
p8722
(dp8723
g11
(lp8724
sg13
S'com.google.common.collect.TreeRangeSet$ComplementRangesByLowerBound'
p8725
sg15
(lp8726
sg17
(lp8727
sg19
(lp8728
sg21
I0
sba(iArchitecture
Entity
p8729
(dp8730
g11
(lp8731
sg13
S'com.google.common.collect.TreeRangeSet$ComplementRangesByLowerBound$1'
p8732
sg15
(lp8733
sg17
(lp8734
sg19
(lp8735
sg21
I0
sba(iArchitecture
Entity
p8736
(dp8737
g11
(lp8738
sg13
S'com.google.common.collect.TreeRangeSet$ComplementRangesByLowerBound$2'
p8739
sg15
(lp8740
sg17
(lp8741
sg19
(lp8742
sg21
I0
sba(iArchitecture
Entity
p8743
(dp8744
g11
(lp8745
sg13
S'com.google.common.collect.TreeRangeSet$RangesByUpperBound'
p8746
sg15
(lp8747
sg17
(lp8748
sg19
(lp8749
sg21
I0
sba(iArchitecture
Entity
p8750
(dp8751
g11
(lp8752
sg13
S'com.google.common.collect.TreeRangeSet$RangesByUpperBound$1'
p8753
sg15
(lp8754
sg17
(lp8755
sg19
(lp8756
sg21
I0
sba(iArchitecture
Entity
p8757
(dp8758
g11
(lp8759
sg13
S'com.google.common.collect.TreeRangeSet$RangesByUpperBound$2'
p8760
sg15
(lp8761
sg17
(lp8762
sg19
(lp8763
sg21
I0
sba(iArchitecture
Entity
p8764
(dp8765
g11
(lp8766
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSet'
p8767
sg15
(lp8768
sg17
(lp8769
sg19
(lp8770
sg21
I0
sba(iArchitecture
Entity
p8771
(dp8772
g11
(lp8773
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSetRangesByLowerBound'
p8774
sg15
(lp8775
sg17
(lp8776
sg19
(lp8777
sg21
I0
sba(iArchitecture
Entity
p8778
(dp8779
g11
(lp8780
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSetRangesByLowerBound$1'
p8781
sg15
(lp8782
sg17
(lp8783
sg19
(lp8784
sg21
I0
sba(iArchitecture
Entity
p8785
(dp8786
g11
(lp8787
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSetRangesByLowerBound$2'
p8788
sg15
(lp8789
sg17
(lp8790
sg19
(lp8791
sg21
I0
sba(iArchitecture
Entity
p8792
(dp8793
g11
(lp8794
sg13
S'com.google.common.collect.TreeTraverser'
p8795
sg15
(lp8796
sg17
(lp8797
sg19
(lp8798
sg21
I0
sba(iArchitecture
Entity
p8799
(dp8800
g11
(lp8801
sg13
S'com.google.common.collect.TreeTraverser$1'
p8802
sg15
(lp8803
sg17
(lp8804
sg19
(lp8805
sg21
I0
sba(iArchitecture
Entity
p8806
(dp8807
g11
(lp8808
sg13
S'com.google.common.collect.TreeTraverser$2'
p8809
sg15
(lp8810
sg17
(lp8811
sg19
(lp8812
sg21
I0
sba(iArchitecture
Entity
p8813
(dp8814
g11
(lp8815
sg13
S'com.google.common.collect.TreeTraverser$3'
p8816
sg15
(lp8817
sg17
(lp8818
sg19
(lp8819
sg21
I0
sba(iArchitecture
Entity
p8820
(dp8821
g11
(lp8822
sg13
S'com.google.common.collect.TreeTraverser$BreadthFirstIterator'
p8823
sg15
(lp8824
sg17
(lp8825
sg19
(lp8826
sg21
I0
sba(iArchitecture
Entity
p8827
(dp8828
g11
(lp8829
sg13
S'com.google.common.collect.TreeTraverser$PostOrderIterator'
p8830
sg15
(lp8831
sg17
(lp8832
sg19
(lp8833
sg21
I0
sba(iArchitecture
Entity
p8834
(dp8835
g11
(lp8836
sg13
S'com.google.common.collect.TreeTraverser$PostOrderNode'
p8837
sg15
(lp8838
sg17
(lp8839
sg19
(lp8840
sg21
I0
sba(iArchitecture
Entity
p8841
(dp8842
g11
(lp8843
sg13
S'com.google.common.collect.TreeTraverser$PreOrderIterator'
p8844
sg15
(lp8845
sg17
(lp8846
sg19
(lp8847
sg21
I0
sba(iArchitecture
Entity
p8848
(dp8849
g11
(lp8850
sg13
S'com.google.common.collect.UnmodifiableIterator'
p8851
sg15
(lp8852
sg17
(lp8853
sg19
(lp8854
sg21
I0
sba(iArchitecture
Entity
p8855
(dp8856
g11
(lp8857
sg13
S'com.google.common.collect.UnmodifiableListIterator'
p8858
sg15
(lp8859
sg17
(lp8860
sg19
(lp8861
sg21
I0
sba(iArchitecture
Entity
p8862
(dp8863
g11
(lp8864
sg13
S'com.google.common.collect.UnmodifiableSortedMultiset'
p8865
sg15
(lp8866
sg17
(lp8867
sg19
(lp8868
sg21
I0
sba(iArchitecture
Entity
p8869
(dp8870
g11
(lp8871
g25
asg13
S'com.google.common.collect.UsingToStringOrdering'
p8872
sg15
(lp8873
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p8874
asg17
(lp8875
g32
asg19
(lp8876
g35
asg21
I0
sba(iArchitecture
Entity
p8877
(dp8878
g11
(lp8879
sg13
S'com.google.common.collect.WellBehavedMap'
p8880
sg15
(lp8881
sg17
(lp8882
sg19
(lp8883
sg21
I0
sba(iArchitecture
Entity
p8884
(dp8885
g11
(lp8886
sg13
S'com.google.common.collect.WellBehavedMap$1'
p8887
sg15
(lp8888
sg17
(lp8889
sg19
(lp8890
sg21
I0
sba(iArchitecture
Entity
p8891
(dp8892
g11
(lp8893
sg13
S'com.google.common.collect.WellBehavedMap$EntrySet'
p8894
sg15
(lp8895
sg17
(lp8896
sg19
(lp8897
sg21
I0
sba(iArchitecture
Entity
p8898
(dp8899
g11
(lp8900
sg13
S'com.google.common.collect.WellBehavedMap$EntrySet$1'
p8901
sg15
(lp8902
sg17
(lp8903
sg19
(lp8904
sg21
I0
sba(iArchitecture
Entity
p8905
(dp8906
g11
(lp8907
sg13
S'com.google.common.collect.WellBehavedMap$EntrySet$1$1'
p8908
sg15
(lp8909
sg17
(lp8910
sg19
(lp8911
sg21
I0
sba(iArchitecture
Entity
p8912
(dp8913
g11
(lp8914
sg13
S'com.google.common.io.CountingInputStream'
p8915
sg15
(lp8916
sg17
(lp8917
sg19
(lp8918
sg21
I0
sba(iArchitecture
Entity
p8919
(dp8920
g11
(lp8921
sg13
S'com.google.common.io.CountingOutputStream'
p8922
sg15
(lp8923
sg17
(lp8924
sg19
(lp8925
sg21
I0
sba(iArchitecture
Entity
p8926
(dp8927
g11
(lp8928
sg13
S'com.google.common.io.Flushables'
p8929
sg15
(lp8930
sg17
(lp8931
sg19
(lp8932
sg21
I0
sba(iArchitecture
Entity
p8933
(dp8934
g11
(lp8935
V2430
p8936
asg13
S'com.google.common.net.HttpHeaders'
p8937
sg15
(lp8938
VAs they are [common headers](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Common_non-standard_request_fields) (at least the `X-Forwarded-Host`) it would be nice if they are defined in the class `HttpHeaders`. The `X-Forwared-Port` is used for example in [AWS](http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/x-forwarded-headers.html).\u000a
p8939
asg17
(lp8940
(lp8941
I5
aasg19
(lp8942
VAdd a constant for X-Forwarded-Host and X-Forwarded-Port to HttpHeaders
p8943
asg21
I0
sba(iArchitecture
Entity
p8944
(dp8945
g11
(lp8946
sg13
S'com.google.common.reflect.AbstractInvocationHandler'
p8947
sg15
(lp8948
sg17
(lp8949
sg19
(lp8950
sg21
I0
sba(iArchitecture
Entity
p8951
(dp8952
g11
(lp8953
sg13
S'com.google.common.util.concurrent.ForwardingBlockingQueue'
p8954
sg15
(lp8955
sg17
(lp8956
sg19
(lp8957
sg21
I0
sbasg1135
(lp8958
g2213
ag2220
ag2227
ag2234
ag2241
ag2248
ag2255
ag2262
ag2269
ag2276
ag2283
ag2290
ag2297
ag2304
ag2311
ag2318
ag2325
ag2332
ag2340
ag2348
ag2356
ag2364
ag2372
ag2380
ag2388
ag2396
ag2404
ag2412
ag2420
ag2428
ag2436
ag2444
ag2452
ag2460
ag2468
ag2476
ag2484
ag2492
ag2500
ag2508
ag2516
ag2524
ag2532
ag2539
ag2546
ag2553
ag2560
ag2567
ag2574
ag2581
ag2588
ag2595
ag2602
ag2609
ag2616
ag2623
ag2630
ag2637
ag2644
ag2651
ag2658
ag2665
ag2672
ag2679
ag2686
ag2693
ag2701
ag2708
ag2715
ag2722
ag2729
ag2736
ag2743
ag2750
ag2757
ag2764
ag2771
ag2778
ag2785
ag2792
ag2799
ag2806
ag2813
ag2820
ag2827
ag2834
ag2841
ag2848
ag2855
ag2862
ag2869
ag2876
ag2883
ag2890
ag2897
ag2904
ag2911
ag2918
ag2925
ag2932
ag2939
ag2946
ag2953
ag2960
ag2967
ag2974
ag2981
ag2988
ag2995
ag3003
ag3011
ag3019
ag3027
ag3035
ag3043
ag3050
ag3057
ag3064
ag3071
ag3078
ag3085
ag3092
ag3099
ag3106
ag3113
ag3120
ag3127
ag3134
ag3142
ag3152
ag3159
ag3167
ag3175
ag3183
ag3191
ag3199
ag3207
ag3214
ag3221
ag3228
ag3235
ag3242
ag3249
ag3256
ag3263
ag3270
ag3277
ag3284
ag3291
ag3298
ag3306
ag3314
ag3322
ag3330
ag3337
ag3344
ag3351
ag3358
ag3366
ag3374
ag3382
ag3389
ag3396
ag3403
ag3410
ag3417
ag3424
ag3431
ag3438
ag3445
ag3452
ag3459
ag3466
ag3473
ag3480
ag3487
ag3494
ag3501
ag3508
ag3515
ag3522
ag3529
ag3536
ag3543
ag3550
ag3557
ag3564
ag3571
ag3579
ag3590
ag3599
ag3608
ag3615
ag3622
ag3629
ag3636
ag3643
ag3650
ag3657
ag3664
ag3671
ag3678
ag3685
ag3692
ag3699
ag3706
ag3713
ag3720
ag3727
ag3734
ag3741
ag3748
ag3755
ag3762
ag3769
ag3776
ag3783
ag3790
ag3797
ag3804
ag3811
ag3818
ag3825
ag3832
ag3839
ag3846
ag3853
ag3860
ag3867
ag3874
ag3881
ag3888
ag3895
ag3902
ag3909
ag3916
ag3923
ag3930
ag3937
ag3944
ag3951
ag3958
ag3965
ag3972
ag3979
ag3986
ag3993
ag4000
ag4007
ag4014
ag4021
ag4028
ag4035
ag4042
ag4050
ag4058
ag4065
ag4072
ag4079
ag4086
ag4093
ag4100
ag4107
ag4114
ag4121
ag4128
ag4135
ag4142
ag4149
ag4156
ag4163
ag4170
ag4177
ag4185
ag4196
ag4205
ag4214
ag4223
ag4232
ag4241
ag4248
ag4256
ag4266
ag4274
ag4282
ag4290
ag4298
ag4306
ag4314
ag4321
ag4328
ag4335
ag4342
ag4349
ag4356
ag4363
ag4370
ag4377
ag4384
ag4391
ag4398
ag4405
ag4412
ag4419
ag4426
ag4433
ag4440
ag4447
ag4454
ag4461
ag4468
ag4475
ag4482
ag4489
ag4496
ag4504
ag4514
ag4522
ag4530
ag4538
ag4546
ag4554
ag4562
ag4570
ag4578
ag4586
ag4594
ag4602
ag4610
ag4617
ag4624
ag4631
ag4638
ag4645
ag4652
ag4659
ag4666
ag4673
ag4680
ag4687
ag4694
ag4701
ag4708
ag4715
ag4723
ag4731
ag4739
ag4746
ag4753
ag4760
ag4767
ag4774
ag4781
ag4788
ag4795
ag4806
ag4830
ag4846
ag4862
ag4878
ag4894
ag4910
ag4926
ag4942
ag4958
ag4974
ag4990
ag5006
ag5022
ag5038
ag5054
ag5070
ag5086
ag5102
ag5118
ag5127
ag5136
ag5145
ag5154
ag5163
ag5172
ag5181
ag5190
ag5199
ag5208
ag5217
ag5226
ag5235
ag5244
ag5253
ag5262
ag5271
ag5280
ag5287
ag5294
ag5301
ag5308
ag5315
ag5322
ag5329
ag5336
ag5343
ag5350
ag5357
ag5364
ag5371
ag5378
ag5385
ag5392
ag5399
ag5406
ag5413
ag5420
ag5427
ag5434
ag5441
ag5448
ag5455
ag5462
ag5469
ag5476
ag5483
ag5490
ag5497
ag5504
ag5511
ag5518
ag5525
ag5532
ag5539
ag5546
ag5553
ag5560
ag5567
ag5574
ag5581
ag5588
ag5595
ag5602
ag5609
ag5616
ag5623
ag5630
ag5637
ag5644
ag5651
ag5658
ag5665
ag5672
ag5679
ag5686
ag5693
ag5700
ag5707
ag5715
ag5725
ag5733
ag5741
ag5749
ag5757
ag5765
ag5773
ag5781
ag5789
ag5797
ag5805
ag5813
ag5821
ag5828
ag5835
ag5842
ag5849
ag5856
ag5863
ag5870
ag5877
ag5884
ag5891
ag5898
ag5905
ag5912
ag5919
ag5926
ag5933
ag5940
ag5947
ag5954
ag5961
ag5968
ag5975
ag5982
ag5989
ag5996
ag6003
ag6010
ag6017
ag6024
ag6031
ag6038
ag6045
ag6052
ag6059
ag6066
ag6073
ag6080
ag6087
ag6094
ag6101
ag6108
ag6115
ag6122
ag6129
ag6136
ag6143
ag6150
ag6157
ag6164
ag6171
ag6178
ag6185
ag6192
ag6201
ag6210
ag6219
ag6228
ag6237
ag6246
ag6255
ag6264
ag6273
ag6282
ag6291
ag6300
ag6309
ag6318
ag6327
ag6336
ag6345
ag6354
ag6363
ag6372
ag6381
ag6390
ag6399
ag6408
ag6417
ag6426
ag6435
ag6444
ag6453
ag6462
ag6471
ag6480
ag6489
ag6498
ag6507
ag6516
ag6525
ag6534
ag6543
ag6552
ag6561
ag6570
ag6579
ag6588
ag6597
ag6606
ag6615
ag6624
ag6633
ag6642
ag6651
ag6660
ag6669
ag6678
ag6687
ag6695
ag6703
ag6711
ag6719
ag6727
ag6735
ag6742
ag6749
ag6756
ag6763
ag6770
ag6777
ag6784
ag6791
ag6798
ag6805
ag6812
ag6819
ag6826
ag6833
ag6840
ag6847
ag6854
ag6861
ag6868
ag6875
ag6882
ag6889
ag6896
ag6903
ag6910
ag6917
ag6924
ag6931
ag6938
ag6945
ag6952
ag6959
ag6966
ag6973
ag6980
ag6987
ag6994
ag7001
ag7008
ag7015
ag7022
ag7029
ag7036
ag7043
ag7050
ag7057
ag7064
ag7071
ag7078
ag7085
ag7092
ag7099
ag7106
ag7113
ag7120
ag7127
ag7134
ag7141
ag7148
ag7155
ag7162
ag7169
ag7176
ag7183
ag7190
ag7197
ag7205
ag7216
ag7226
ag7237
ag7244
ag7251
ag7260
ag7275
ag7286
ag7297
ag7308
ag7319
ag7327
ag7338
ag7351
ag7362
ag7373
ag7384
ag7395
ag7403
ag7411
ag7419
ag7427
ag7435
ag7443
ag7450
ag7457
ag7464
ag7471
ag7478
ag7485
ag7492
ag7499
ag7507
ag7514
ag7521
ag7528
ag7535
ag7542
ag7549
ag7556
ag7563
ag7570
ag7577
ag7584
ag7591
ag7598
ag7605
ag7612
ag7619
ag7626
ag7634
ag7641
ag7648
ag7655
ag7662
ag7669
ag7677
ag7688
ag7697
ag7706
ag7715
ag7724
ag7733
ag7742
ag7751
ag7760
ag7769
ag7778
ag7787
ag7796
ag7805
ag7814
ag7823
ag7832
ag7839
ag7846
ag7853
ag7860
ag7867
ag7874
ag7881
ag7888
ag7895
ag7902
ag7909
ag7916
ag7923
ag7930
ag7937
ag7944
ag7951
ag7958
ag7965
ag7972
ag7979
ag7986
ag7993
ag8000
ag8007
ag8014
ag8021
ag8028
ag8035
ag8042
ag8049
ag8056
ag8063
ag8070
ag8077
ag8084
ag8091
ag8098
ag8105
ag8112
ag8119
ag8126
ag8133
ag8140
ag8147
ag8154
ag8161
ag8168
ag8175
ag8182
ag8189
ag8196
ag8203
ag8210
ag8217
ag8224
ag8231
ag8238
ag8245
ag8252
ag8259
ag8266
ag8273
ag8280
ag8287
ag8294
ag8301
ag8308
ag8315
ag8322
ag8329
ag8336
ag8343
ag8350
ag8357
ag8364
ag8371
ag8378
ag8385
ag8392
ag8399
ag8406
ag8413
ag8420
ag8427
ag8434
ag8441
ag8448
ag8455
ag8462
ag8469
ag8476
ag8483
ag8490
ag8497
ag8504
ag8511
ag8518
ag8525
ag8532
ag8539
ag8546
ag8553
ag8560
ag8567
ag8574
ag8581
ag8588
ag8595
ag8602
ag8609
ag8617
ag8625
ag8633
ag8641
ag8649
ag8657
ag8665
ag8673
ag8681
ag8689
ag8697
ag8704
ag8711
ag8718
ag8725
ag8732
ag8739
ag8746
ag8753
ag8760
ag8767
ag8774
ag8781
ag8788
ag8795
ag8802
ag8809
ag8816
ag8823
ag8830
ag8837
ag8844
ag8851
ag8858
ag8865
ag8872
ag8880
ag8887
ag8894
ag8901
ag8908
ag8915
ag8922
ag8929
ag8937
ag8947
ag8954
asg1137
I0
sg21
I0
sg1138
S'com.google.common.collect.ss'
p8959
sba(iArchitecture
Cluster
p8960
(dp8961
g7
(lp8962
(iArchitecture
Entity
p8963
(dp8964
g11
(lp8965
sg13
S'com.google.common.escape.ArrayBasedCharEscaper'
p8966
sg15
(lp8967
sg17
(lp8968
sg19
(lp8969
sg21
I0
sba(iArchitecture
Entity
p8970
(dp8971
g11
(lp8972
sg13
S'com.google.common.escape.ArrayBasedEscaperMap'
p8973
sg15
(lp8974
sg17
(lp8975
sg19
(lp8976
sg21
I0
sba(iArchitecture
Entity
p8977
(dp8978
g11
(lp8979
sg13
S'com.google.common.escape.CharEscaper'
p8980
sg15
(lp8981
sg17
(lp8982
sg19
(lp8983
sg21
I0
sba(iArchitecture
Entity
p8984
(dp8985
g11
(lp8986
sg13
S'com.google.common.escape.CharEscaperBuilder'
p8987
sg15
(lp8988
sg17
(lp8989
sg19
(lp8990
sg21
I0
sba(iArchitecture
Entity
p8991
(dp8992
g11
(lp8993
sg13
S'com.google.common.escape.CharEscaperBuilder$CharArrayDecorator'
p8994
sg15
(lp8995
sg17
(lp8996
sg19
(lp8997
sg21
I0
sba(iArchitecture
Entity
p8998
(dp8999
g11
(lp9000
sg13
S'com.google.common.escape.Escaper'
p9001
sg15
(lp9002
sg17
(lp9003
sg19
(lp9004
sg21
I0
sba(iArchitecture
Entity
p9005
(dp9006
g11
(lp9007
sg13
S'com.google.common.escape.Escaper$1'
p9008
sg15
(lp9009
sg17
(lp9010
sg19
(lp9011
sg21
I0
sba(iArchitecture
Entity
p9012
(dp9013
g11
(lp9014
sg13
S'com.google.common.escape.Escapers'
p9015
sg15
(lp9016
sg17
(lp9017
sg19
(lp9018
sg21
I0
sba(iArchitecture
Entity
p9019
(dp9020
g11
(lp9021
sg13
S'com.google.common.escape.Escapers$1'
p9022
sg15
(lp9023
sg17
(lp9024
sg19
(lp9025
sg21
I0
sba(iArchitecture
Entity
p9026
(dp9027
g11
(lp9028
sg13
S'com.google.common.escape.Escapers$2'
p9029
sg15
(lp9030
sg17
(lp9031
sg19
(lp9032
sg21
I0
sba(iArchitecture
Entity
p9033
(dp9034
g11
(lp9035
sg13
S'com.google.common.escape.Escapers$Builder'
p9036
sg15
(lp9037
sg17
(lp9038
sg19
(lp9039
sg21
I0
sba(iArchitecture
Entity
p9040
(dp9041
g11
(lp9042
sg13
S'com.google.common.escape.Escapers$Builder$1'
p9043
sg15
(lp9044
sg17
(lp9045
sg19
(lp9046
sg21
I0
sba(iArchitecture
Entity
p9047
(dp9048
g11
(lp9049
sg13
S'com.google.common.escape.Platform'
p9050
sg15
(lp9051
sg17
(lp9052
sg19
(lp9053
sg21
I0
sba(iArchitecture
Entity
p9054
(dp9055
g11
(lp9056
sg13
S'com.google.common.escape.Platform$1'
p9057
sg15
(lp9058
sg17
(lp9059
sg19
(lp9060
sg21
I0
sba(iArchitecture
Entity
p9061
(dp9062
g11
(lp9063
g25
asg13
S'com.google.common.escape.UnicodeEscaper'
p9064
sg15
(lp9065
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p9066
asg17
(lp9067
g32
asg19
(lp9068
g35
asg21
I0
sba(iArchitecture
Entity
p9069
(dp9070
g11
(lp9071
sg13
S'com.google.common.html.HtmlEscapers'
p9072
sg15
(lp9073
sg17
(lp9074
sg19
(lp9075
sg21
I0
sba(iArchitecture
Entity
p9076
(dp9077
g11
(lp9078
sg13
S'com.google.common.xml.XmlEscapers'
p9079
sg15
(lp9080
sg17
(lp9081
sg19
(lp9082
sg21
I0
sbasg1135
(lp9083
g8966
ag8973
ag8980
ag8987
ag8994
ag9001
ag9008
ag9015
ag9022
ag9029
ag9036
ag9043
ag9050
ag9057
ag9064
ag9072
ag9079
asg1137
I0
sg21
I0
sg1138
S'com.google.common.escape.ss'
p9084
sba(iArchitecture
Cluster
p9085
(dp9086
g7
(lp9087
(iArchitecture
Entity
p9088
(dp9089
g11
(lp9090
sg13
S'com.google.common.collect.HashMultimap'
p9091
sg15
(lp9092
sg17
(lp9093
sg19
(lp9094
sg21
I0
sba(iArchitecture
Entity
p9095
(dp9096
g11
(lp9097
sg13
S'com.google.common.eventbus.AllowConcurrentEvents'
p9098
sg15
(lp9099
sg17
(lp9100
sg19
(lp9101
sg21
I0
sba(iArchitecture
Entity
p9102
(dp9103
g11
(lp9104
sg13
S'com.google.common.eventbus.AnnotatedSubscriberFinder'
p9105
sg15
(lp9106
sg17
(lp9107
sg19
(lp9108
sg21
I0
sba(iArchitecture
Entity
p9109
(dp9110
g11
(lp9111
sg13
S'com.google.common.eventbus.AnnotatedSubscriberFinder$1'
p9112
sg15
(lp9113
sg17
(lp9114
sg19
(lp9115
sg21
I0
sba(iArchitecture
Entity
p9116
(dp9117
g11
(lp9118
sg13
S'com.google.common.eventbus.AnnotatedSubscriberFinder$MethodIdentifier'
p9119
sg15
(lp9120
sg17
(lp9121
sg19
(lp9122
sg21
I0
sba(iArchitecture
Entity
p9123
(dp9124
g11
(lp9125
sg13
S'com.google.common.eventbus.AsyncEventBus'
p9126
sg15
(lp9127
sg17
(lp9128
sg19
(lp9129
sg21
I0
sba(iArchitecture
Entity
p9130
(dp9131
g11
(lp9132
sg13
S'com.google.common.eventbus.AsyncEventBus$1'
p9133
sg15
(lp9134
sg17
(lp9135
sg19
(lp9136
sg21
I0
sba(iArchitecture
Entity
p9137
(dp9138
g11
(lp9139
sg13
S'com.google.common.eventbus.DeadEvent'
p9140
sg15
(lp9141
sg17
(lp9142
sg19
(lp9143
sg21
I0
sba(iArchitecture
Entity
p9144
(dp9145
g11
(lp9146
g1014
asg13
S'com.google.common.eventbus.EventBus'
p9147
sg15
(lp9148
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9149
asg17
(lp9150
g1029
asg19
(lp9151
g1033
asg21
I0
sba(iArchitecture
Entity
p9152
(dp9153
g11
(lp9154
g1014
asg13
S'com.google.common.eventbus.EventBus$1'
p9155
sg15
(lp9156
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9157
asg17
(lp9158
g1029
asg19
(lp9159
g1033
asg21
I0
sba(iArchitecture
Entity
p9160
(dp9161
g11
(lp9162
g1014
asg13
S'com.google.common.eventbus.EventBus$2'
p9163
sg15
(lp9164
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9165
asg17
(lp9166
g1029
asg19
(lp9167
g1033
asg21
I0
sba(iArchitecture
Entity
p9168
(dp9169
g11
(lp9170
g1014
asg13
S'com.google.common.eventbus.EventBus$3'
p9171
sg15
(lp9172
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9173
asg17
(lp9174
g1029
asg19
(lp9175
g1033
asg21
I0
sba(iArchitecture
Entity
p9176
(dp9177
g11
(lp9178
g1014
asg13
S'com.google.common.eventbus.EventBus$EventWithSubscriber'
p9179
sg15
(lp9180
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9181
asg17
(lp9182
g1029
asg19
(lp9183
g1033
asg21
I0
sba(iArchitecture
Entity
p9184
(dp9185
g11
(lp9186
g1014
asg13
S'com.google.common.eventbus.EventBus$LoggingSubscriberExceptionHandler'
p9187
sg15
(lp9188
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9189
asg17
(lp9190
g1029
asg19
(lp9191
g1033
asg21
I0
sba(iArchitecture
Entity
p9192
(dp9193
g11
(lp9194
sg13
S'com.google.common.eventbus.EventSubscriber'
p9195
sg15
(lp9196
sg17
(lp9197
sg19
(lp9198
sg21
I0
sba(iArchitecture
Entity
p9199
(dp9200
g11
(lp9201
sg13
S'com.google.common.eventbus.Subscribe'
p9202
sg15
(lp9203
sg17
(lp9204
sg19
(lp9205
sg21
I0
sba(iArchitecture
Entity
p9206
(dp9207
g11
(lp9208
sg13
S'com.google.common.eventbus.SubscriberExceptionContext'
p9209
sg15
(lp9210
sg17
(lp9211
sg19
(lp9212
sg21
I0
sba(iArchitecture
Entity
p9213
(dp9214
g11
(lp9215
sg13
S'com.google.common.eventbus.SubscriberExceptionHandler'
p9216
sg15
(lp9217
sg17
(lp9218
sg19
(lp9219
sg21
I0
sba(iArchitecture
Entity
p9220
(dp9221
g11
(lp9222
sg13
S'com.google.common.eventbus.SubscriberFindingStrategy'
p9223
sg15
(lp9224
sg17
(lp9225
sg19
(lp9226
sg21
I0
sba(iArchitecture
Entity
p9227
(dp9228
g11
(lp9229
sg13
S'com.google.common.eventbus.SynchronizedEventSubscriber'
p9230
sg15
(lp9231
sg17
(lp9232
sg19
(lp9233
sg21
I0
sbasg1135
(lp9234
g9091
ag9098
ag9105
ag9112
ag9119
ag9126
ag9133
ag9140
ag9147
ag9155
ag9163
ag9171
ag9179
ag9187
ag9195
ag9202
ag9209
ag9216
ag9223
ag9230
asg1137
I0
sg21
I0
sg1138
S'com.google.common.eventbus.ss'
p9235
sba(iArchitecture
Cluster
p9236
(dp9237
g7
(lp9238
(iArchitecture
Entity
p9239
(dp9240
g11
(lp9241
sg13
S'com.google.common.hash.AbstractByteHasher'
p9242
sg15
(lp9243
sg17
(lp9244
sg19
(lp9245
sg21
I0
sba(iArchitecture
Entity
p9246
(dp9247
g11
(lp9248
sg13
S'com.google.common.hash.AbstractCompositeHashFunction'
p9249
sg15
(lp9250
sg17
(lp9251
sg19
(lp9252
sg21
I0
sba(iArchitecture
Entity
p9253
(dp9254
g11
(lp9255
sg13
S'com.google.common.hash.AbstractCompositeHashFunction$1'
p9256
sg15
(lp9257
sg17
(lp9258
sg19
(lp9259
sg21
I0
sba(iArchitecture
Entity
p9260
(dp9261
g11
(lp9262
sg13
S'com.google.common.hash.AbstractHasher'
p9263
sg15
(lp9264
sg17
(lp9265
sg19
(lp9266
sg21
I0
sba(iArchitecture
Entity
p9267
(dp9268
g11
(lp9269
sg13
S'com.google.common.hash.AbstractNonStreamingHashFunction'
p9270
sg15
(lp9271
sg17
(lp9272
sg19
(lp9273
sg21
I0
sba(iArchitecture
Entity
p9274
(dp9275
g11
(lp9276
sg13
S'com.google.common.hash.AbstractNonStreamingHashFunction$BufferingHasher'
p9277
sg15
(lp9278
sg17
(lp9279
sg19
(lp9280
sg21
I0
sba(iArchitecture
Entity
p9281
(dp9282
g11
(lp9283
sg13
S'com.google.common.hash.AbstractNonStreamingHashFunction$ExposedByteArrayOutputStream'
p9284
sg15
(lp9285
sg17
(lp9286
sg19
(lp9287
sg21
I0
sba(iArchitecture
Entity
p9288
(dp9289
g11
(lp9290
sg13
S'com.google.common.hash.AbstractStreamingHashFunction'
p9291
sg15
(lp9292
sg17
(lp9293
sg19
(lp9294
sg21
I0
sba(iArchitecture
Entity
p9295
(dp9296
g11
(lp9297
sg13
S'com.google.common.hash.AbstractStreamingHashFunction$AbstractStreamingHasher'
p9298
sg15
(lp9299
sg17
(lp9300
sg19
(lp9301
sg21
I0
sba(iArchitecture
Entity
p9302
(dp9303
g11
(lp9304
sg13
S'com.google.common.hash.BloomFilter'
p9305
sg15
(lp9306
sg17
(lp9307
sg19
(lp9308
sg21
I0
sba(iArchitecture
Entity
p9309
(dp9310
g11
(lp9311
sg13
S'com.google.common.hash.BloomFilter$1'
p9312
sg15
(lp9313
sg17
(lp9314
sg19
(lp9315
sg21
I0
sba(iArchitecture
Entity
p9316
(dp9317
g11
(lp9318
sg13
S'com.google.common.hash.BloomFilter$SerialForm'
p9319
sg15
(lp9320
sg17
(lp9321
sg19
(lp9322
sg21
I0
sba(iArchitecture
Entity
p9323
(dp9324
g11
(lp9325
sg13
S'com.google.common.hash.BloomFilter$Strategy'
p9326
sg15
(lp9327
sg17
(lp9328
sg19
(lp9329
sg21
I0
sba(iArchitecture
Entity
p9330
(dp9331
g11
(lp9332
sg13
S'com.google.common.hash.BloomFilterStrategies'
p9333
sg15
(lp9334
sg17
(lp9335
sg19
(lp9336
sg21
I0
sba(iArchitecture
Entity
p9337
(dp9338
g11
(lp9339
sg13
S'com.google.common.hash.BloomFilterStrategies$1'
p9340
sg15
(lp9341
sg17
(lp9342
sg19
(lp9343
sg21
I0
sba(iArchitecture
Entity
p9344
(dp9345
g11
(lp9346
sg13
S'com.google.common.hash.BloomFilterStrategies$2'
p9347
sg15
(lp9348
sg17
(lp9349
sg19
(lp9350
sg21
I0
sba(iArchitecture
Entity
p9351
(dp9352
g11
(lp9353
sg13
S'com.google.common.hash.BloomFilterStrategies$BitArray'
p9354
sg15
(lp9355
sg17
(lp9356
sg19
(lp9357
sg21
I0
sba(iArchitecture
Entity
p9358
(dp9359
g11
(lp9360
sg13
S'com.google.common.hash.ChecksumHashFunction'
p9361
sg15
(lp9362
sg17
(lp9363
sg19
(lp9364
sg21
I0
sba(iArchitecture
Entity
p9365
(dp9366
g11
(lp9367
sg13
S'com.google.common.hash.ChecksumHashFunction$1'
p9368
sg15
(lp9369
sg17
(lp9370
sg19
(lp9371
sg21
I0
sba(iArchitecture
Entity
p9372
(dp9373
g11
(lp9374
sg13
S'com.google.common.hash.ChecksumHashFunction$ChecksumHasher'
p9375
sg15
(lp9376
sg17
(lp9377
sg19
(lp9378
sg21
I0
sba(iArchitecture
Entity
p9379
(dp9380
g11
(lp9381
sg13
S'com.google.common.hash.Crc32cHashFunction'
p9382
sg15
(lp9383
sg17
(lp9384
sg19
(lp9385
sg21
I0
sba(iArchitecture
Entity
p9386
(dp9387
g11
(lp9388
sg13
S'com.google.common.hash.Crc32cHashFunction$Crc32cHasher'
p9389
sg15
(lp9390
sg17
(lp9391
sg19
(lp9392
sg21
I0
sba(iArchitecture
Entity
p9393
(dp9394
g11
(lp9395
sg13
S'com.google.common.hash.Funnel'
p9396
sg15
(lp9397
sg17
(lp9398
sg19
(lp9399
sg21
I0
sba(iArchitecture
Entity
p9400
(dp9401
g11
(lp9402
sg13
S'com.google.common.hash.Funnels'
p9403
sg15
(lp9404
sg17
(lp9405
sg19
(lp9406
sg21
I0
sba(iArchitecture
Entity
p9407
(dp9408
g11
(lp9409
sg13
S'com.google.common.hash.Funnels$ByteArrayFunnel'
p9410
sg15
(lp9411
sg17
(lp9412
sg19
(lp9413
sg21
I0
sba(iArchitecture
Entity
p9414
(dp9415
g11
(lp9416
sg13
S'com.google.common.hash.Funnels$IntegerFunnel'
p9417
sg15
(lp9418
sg17
(lp9419
sg19
(lp9420
sg21
I0
sba(iArchitecture
Entity
p9421
(dp9422
g11
(lp9423
sg13
S'com.google.common.hash.Funnels$LongFunnel'
p9424
sg15
(lp9425
sg17
(lp9426
sg19
(lp9427
sg21
I0
sba(iArchitecture
Entity
p9428
(dp9429
g11
(lp9430
sg13
S'com.google.common.hash.Funnels$SequentialFunnel'
p9431
sg15
(lp9432
sg17
(lp9433
sg19
(lp9434
sg21
I0
sba(iArchitecture
Entity
p9435
(dp9436
g11
(lp9437
sg13
S'com.google.common.hash.Funnels$SinkAsStream'
p9438
sg15
(lp9439
sg17
(lp9440
sg19
(lp9441
sg21
I0
sba(iArchitecture
Entity
p9442
(dp9443
g11
(lp9444
sg13
S'com.google.common.hash.Funnels$StringCharsetFunnel'
p9445
sg15
(lp9446
sg17
(lp9447
sg19
(lp9448
sg21
I0
sba(iArchitecture
Entity
p9449
(dp9450
g11
(lp9451
sg13
S'com.google.common.hash.Funnels$StringCharsetFunnel$SerializedForm'
p9452
sg15
(lp9453
sg17
(lp9454
sg19
(lp9455
sg21
I0
sba(iArchitecture
Entity
p9456
(dp9457
g11
(lp9458
sg13
S'com.google.common.hash.Funnels$UnencodedCharsFunnel'
p9459
sg15
(lp9460
sg17
(lp9461
sg19
(lp9462
sg21
I0
sba(iArchitecture
Entity
p9463
(dp9464
g11
(lp9465
sg13
S'com.google.common.hash.HashCode'
p9466
sg15
(lp9467
sg17
(lp9468
sg19
(lp9469
sg21
I0
sba(iArchitecture
Entity
p9470
(dp9471
g11
(lp9472
sg13
S'com.google.common.hash.HashCode$BytesHashCode'
p9473
sg15
(lp9474
sg17
(lp9475
sg19
(lp9476
sg21
I0
sba(iArchitecture
Entity
p9477
(dp9478
g11
(lp9479
sg13
S'com.google.common.hash.HashCode$IntHashCode'
p9480
sg15
(lp9481
sg17
(lp9482
sg19
(lp9483
sg21
I0
sba(iArchitecture
Entity
p9484
(dp9485
g11
(lp9486
sg13
S'com.google.common.hash.HashCode$LongHashCode'
p9487
sg15
(lp9488
sg17
(lp9489
sg19
(lp9490
sg21
I0
sba(iArchitecture
Entity
p9491
(dp9492
g11
(lp9493
sg13
S'com.google.common.hash.HashFunction'
p9494
sg15
(lp9495
sg17
(lp9496
sg19
(lp9497
sg21
I0
sba(iArchitecture
Entity
p9498
(dp9499
g11
(lp9500
sg13
S'com.google.common.hash.Hasher'
p9501
sg15
(lp9502
sg17
(lp9503
sg19
(lp9504
sg21
I0
sba(iArchitecture
Entity
p9505
(dp9506
g11
(lp9507
g1014
asg13
S'com.google.common.hash.Hashing'
p9508
sg15
(lp9509
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9510
asg17
(lp9511
g1029
asg19
(lp9512
g1033
asg21
I0
sba(iArchitecture
Entity
p9513
(dp9514
g11
(lp9515
g1014
asg13
S'com.google.common.hash.Hashing$1'
p9516
sg15
(lp9517
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9518
asg17
(lp9519
g1029
asg19
(lp9520
g1033
asg21
I0
sba(iArchitecture
Entity
p9521
(dp9522
g11
(lp9523
g1014
asg13
S'com.google.common.hash.Hashing$Adler32Holder'
p9524
sg15
(lp9525
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9526
asg17
(lp9527
g1029
asg19
(lp9528
g1033
asg21
I0
sba(iArchitecture
Entity
p9529
(dp9530
g11
(lp9531
g1014
asg13
S'com.google.common.hash.Hashing$ChecksumType'
p9532
sg15
(lp9533
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9534
asg17
(lp9535
g1029
asg19
(lp9536
g1033
asg21
I0
sba(iArchitecture
Entity
p9537
(dp9538
g11
(lp9539
g1014
asg13
S'com.google.common.hash.Hashing$ChecksumType$1'
p9540
sg15
(lp9541
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9542
asg17
(lp9543
g1029
asg19
(lp9544
g1033
asg21
I0
sba(iArchitecture
Entity
p9545
(dp9546
g11
(lp9547
g1014
asg13
S'com.google.common.hash.Hashing$ChecksumType$2'
p9548
sg15
(lp9549
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9550
asg17
(lp9551
g1029
asg19
(lp9552
g1033
asg21
I0
sba(iArchitecture
Entity
p9553
(dp9554
g11
(lp9555
g1014
asg13
S'com.google.common.hash.Hashing$ConcatenatedHashFunction'
p9556
sg15
(lp9557
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9558
asg17
(lp9559
g1029
asg19
(lp9560
g1033
asg21
I0
sba(iArchitecture
Entity
p9561
(dp9562
g11
(lp9563
g1014
asg13
S'com.google.common.hash.Hashing$Crc32Holder'
p9564
sg15
(lp9565
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9566
asg17
(lp9567
g1029
asg19
(lp9568
g1033
asg21
I0
sba(iArchitecture
Entity
p9569
(dp9570
g11
(lp9571
g1014
asg13
S'com.google.common.hash.Hashing$Crc32cHolder'
p9572
sg15
(lp9573
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9574
asg17
(lp9575
g1029
asg19
(lp9576
g1033
asg21
I0
sba(iArchitecture
Entity
p9577
(dp9578
g11
(lp9579
g1014
asg13
S'com.google.common.hash.Hashing$LinearCongruentialGenerator'
p9580
sg15
(lp9581
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9582
asg17
(lp9583
g1029
asg19
(lp9584
g1033
asg21
I0
sba(iArchitecture
Entity
p9585
(dp9586
g11
(lp9587
g1014
asg13
S'com.google.common.hash.Hashing$Md5Holder'
p9588
sg15
(lp9589
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9590
asg17
(lp9591
g1029
asg19
(lp9592
g1033
asg21
I0
sba(iArchitecture
Entity
p9593
(dp9594
g11
(lp9595
g1014
asg13
S'com.google.common.hash.Hashing$Murmur3_128Holder'
p9596
sg15
(lp9597
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9598
asg17
(lp9599
g1029
asg19
(lp9600
g1033
asg21
I0
sba(iArchitecture
Entity
p9601
(dp9602
g11
(lp9603
g1014
asg13
S'com.google.common.hash.Hashing$Murmur3_32Holder'
p9604
sg15
(lp9605
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9606
asg17
(lp9607
g1029
asg19
(lp9608
g1033
asg21
I0
sba(iArchitecture
Entity
p9609
(dp9610
g11
(lp9611
g1014
asg13
S'com.google.common.hash.Hashing$Sha1Holder'
p9612
sg15
(lp9613
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9614
asg17
(lp9615
g1029
asg19
(lp9616
g1033
asg21
I0
sba(iArchitecture
Entity
p9617
(dp9618
g11
(lp9619
g1014
asg13
S'com.google.common.hash.Hashing$Sha256Holder'
p9620
sg15
(lp9621
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9622
asg17
(lp9623
g1029
asg19
(lp9624
g1033
asg21
I0
sba(iArchitecture
Entity
p9625
(dp9626
g11
(lp9627
g1014
asg13
S'com.google.common.hash.Hashing$Sha512Holder'
p9628
sg15
(lp9629
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9630
asg17
(lp9631
g1029
asg19
(lp9632
g1033
asg21
I0
sba(iArchitecture
Entity
p9633
(dp9634
g11
(lp9635
g1014
asg13
S'com.google.common.hash.Hashing$SipHash24Holder'
p9636
sg15
(lp9637
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p9638
asg17
(lp9639
g1029
asg19
(lp9640
g1033
asg21
I0
sba(iArchitecture
Entity
p9641
(dp9642
g11
(lp9643
sg13
S'com.google.common.hash.MessageDigestHashFunction'
p9644
sg15
(lp9645
sg17
(lp9646
sg19
(lp9647
sg21
I0
sba(iArchitecture
Entity
p9648
(dp9649
g11
(lp9650
sg13
S'com.google.common.hash.MessageDigestHashFunction$1'
p9651
sg15
(lp9652
sg17
(lp9653
sg19
(lp9654
sg21
I0
sba(iArchitecture
Entity
p9655
(dp9656
g11
(lp9657
sg13
S'com.google.common.hash.MessageDigestHashFunction$MessageDigestHasher'
p9658
sg15
(lp9659
sg17
(lp9660
sg19
(lp9661
sg21
I0
sba(iArchitecture
Entity
p9662
(dp9663
g11
(lp9664
sg13
S'com.google.common.hash.MessageDigestHashFunction$SerializedForm'
p9665
sg15
(lp9666
sg17
(lp9667
sg19
(lp9668
sg21
I0
sba(iArchitecture
Entity
p9669
(dp9670
g11
(lp9671
sg13
S'com.google.common.hash.Murmur3_128HashFunction'
p9672
sg15
(lp9673
sg17
(lp9674
sg19
(lp9675
sg21
I0
sba(iArchitecture
Entity
p9676
(dp9677
g11
(lp9678
sg13
S'com.google.common.hash.Murmur3_128HashFunction$Murmur3_128Hasher'
p9679
sg15
(lp9680
sg17
(lp9681
sg19
(lp9682
sg21
I0
sba(iArchitecture
Entity
p9683
(dp9684
g11
(lp9685
sg13
S'com.google.common.hash.Murmur3_32HashFunction'
p9686
sg15
(lp9687
sg17
(lp9688
sg19
(lp9689
sg21
I0
sba(iArchitecture
Entity
p9690
(dp9691
g11
(lp9692
sg13
S'com.google.common.hash.Murmur3_32HashFunction$Murmur3_32Hasher'
p9693
sg15
(lp9694
sg17
(lp9695
sg19
(lp9696
sg21
I0
sba(iArchitecture
Entity
p9697
(dp9698
g11
(lp9699
sg13
S'com.google.common.hash.PrimitiveSink'
p9700
sg15
(lp9701
sg17
(lp9702
sg19
(lp9703
sg21
I0
sba(iArchitecture
Entity
p9704
(dp9705
g11
(lp9706
sg13
S'com.google.common.hash.SipHashFunction'
p9707
sg15
(lp9708
sg17
(lp9709
sg19
(lp9710
sg21
I0
sba(iArchitecture
Entity
p9711
(dp9712
g11
(lp9713
sg13
S'com.google.common.hash.SipHashFunction$SipHasher'
p9714
sg15
(lp9715
sg17
(lp9716
sg19
(lp9717
sg21
I0
sbasg1135
(lp9718
g9242
ag9249
ag9256
ag9263
ag9270
ag9277
ag9284
ag9291
ag9298
ag9305
ag9312
ag9319
ag9326
ag9333
ag9340
ag9347
ag9354
ag9361
ag9368
ag9375
ag9382
ag9389
ag9396
ag9403
ag9410
ag9417
ag9424
ag9431
ag9438
ag9445
ag9452
ag9459
ag9466
ag9473
ag9480
ag9487
ag9494
ag9501
ag9508
ag9516
ag9524
ag9532
ag9540
ag9548
ag9556
ag9564
ag9572
ag9580
ag9588
ag9596
ag9604
ag9612
ag9620
ag9628
ag9636
ag9644
ag9651
ag9658
ag9665
ag9672
ag9679
ag9686
ag9693
ag9700
ag9707
ag9714
asg1137
I0
sg21
I0
sg1138
S'com.google.common.hash.ss'
p9719
sba(iArchitecture
Cluster
p9720
(dp9721
g7
(lp9722
(iArchitecture
Entity
p9723
(dp9724
g11
(lp9725
sg13
S'com.google.common.io.AppendableWriter'
p9726
sg15
(lp9727
sg17
(lp9728
sg19
(lp9729
sg21
I0
sba(iArchitecture
Entity
p9730
(dp9731
g11
(lp9732
V1947
p9733
ag9733
ag9733
ag9733
ag9733
aV2124
p9734
asg13
S'com.google.common.io.BaseEncoding'
p9735
sg15
(lp9736
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9737
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9738
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9739
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9740
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9741
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9742
asg17
(lp9743
(lp9744
I0
aag9744
ag9744
ag9744
ag9744
a(lp9745
I0
aasg19
(lp9746
VImprove invalid character exceptions from BaseEncoding
p9747
ag9747
ag9747
ag9747
ag9747
aVUse String.getBytes(Charset) and other Charset utilities once GWT supports them
p9748
asg21
I0
sba(iArchitecture
Entity
p9749
(dp9750
g11
(lp9751
g9733
ag9733
ag9733
ag9733
ag9733
ag9734
asg13
S'com.google.common.io.BaseEncoding$1'
p9752
sg15
(lp9753
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9754
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9755
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9756
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9757
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9758
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9759
asg17
(lp9760
g9744
ag9744
ag9744
ag9744
ag9744
ag9745
asg19
(lp9761
g9747
ag9747
ag9747
ag9747
ag9747
ag9748
asg21
I0
sba(iArchitecture
Entity
p9762
(dp9763
g11
(lp9764
g9733
ag9733
ag9733
ag9733
ag9733
ag9734
asg13
S'com.google.common.io.BaseEncoding$2'
p9765
sg15
(lp9766
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9767
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9768
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9769
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9770
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9771
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9772
asg17
(lp9773
g9744
ag9744
ag9744
ag9744
ag9744
ag9745
asg19
(lp9774
g9747
ag9747
ag9747
ag9747
ag9747
ag9748
asg21
I0
sba(iArchitecture
Entity
p9775
(dp9776
g11
(lp9777
g9733
ag9733
ag9733
ag9733
ag9733
ag9734
asg13
S'com.google.common.io.BaseEncoding$3'
p9778
sg15
(lp9779
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9780
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9781
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9782
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9783
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9784
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9785
asg17
(lp9786
g9744
ag9744
ag9744
ag9744
ag9744
ag9745
asg19
(lp9787
g9747
ag9747
ag9747
ag9747
ag9747
ag9748
asg21
I0
sba(iArchitecture
Entity
p9788
(dp9789
g11
(lp9790
g9733
ag9733
ag9733
ag9733
ag9733
ag9734
asg13
S'com.google.common.io.BaseEncoding$4'
p9791
sg15
(lp9792
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9793
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9794
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9795
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9796
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9797
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9798
asg17
(lp9799
g9744
ag9744
ag9744
ag9744
ag9744
ag9745
asg19
(lp9800
g9747
ag9747
ag9747
ag9747
ag9747
ag9748
asg21
I0
sba(iArchitecture
Entity
p9801
(dp9802
g11
(lp9803
g9733
ag9733
ag9733
ag9733
ag9733
ag9734
asg13
S'com.google.common.io.BaseEncoding$Alphabet'
p9804
sg15
(lp9805
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9806
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9807
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9808
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9809
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9810
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9811
asg17
(lp9812
g9744
ag9744
ag9744
ag9744
ag9744
ag9745
asg19
(lp9813
g9747
ag9747
ag9747
ag9747
ag9747
ag9748
asg21
I0
sba(iArchitecture
Entity
p9814
(dp9815
g11
(lp9816
g9733
ag9733
ag9733
ag9733
ag9733
ag9734
asg13
S'com.google.common.io.BaseEncoding$DecodingException'
p9817
sg15
(lp9818
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9819
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9820
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9821
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9822
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9823
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9824
asg17
(lp9825
g9744
ag9744
ag9744
ag9744
ag9744
ag9745
asg19
(lp9826
g9747
ag9747
ag9747
ag9747
ag9747
ag9748
asg21
I0
sba(iArchitecture
Entity
p9827
(dp9828
g11
(lp9829
g9733
ag9733
ag9733
ag9733
ag9733
ag9734
asg13
S'com.google.common.io.BaseEncoding$SeparatedBaseEncoding'
p9830
sg15
(lp9831
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9832
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9833
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9834
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9835
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9836
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9837
asg17
(lp9838
g9744
ag9744
ag9744
ag9744
ag9744
ag9745
asg19
(lp9839
g9747
ag9747
ag9747
ag9747
ag9747
ag9748
asg21
I0
sba(iArchitecture
Entity
p9840
(dp9841
g11
(lp9842
g9733
ag9733
ag9733
ag9733
ag9733
ag9734
asg13
S'com.google.common.io.BaseEncoding$StandardBaseEncoding'
p9843
sg15
(lp9844
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9845
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9846
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9847
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9848
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9849
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9850
asg17
(lp9851
g9744
ag9744
ag9744
ag9744
ag9744
ag9745
asg19
(lp9852
g9747
ag9747
ag9747
ag9747
ag9747
ag9748
asg21
I0
sba(iArchitecture
Entity
p9853
(dp9854
g11
(lp9855
g9733
ag9733
ag9733
ag9733
ag9733
ag9734
asg13
S'com.google.common.io.BaseEncoding$StandardBaseEncoding$1'
p9856
sg15
(lp9857
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9858
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9859
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9860
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9861
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9862
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9863
asg17
(lp9864
g9744
ag9744
ag9744
ag9744
ag9744
ag9745
asg19
(lp9865
g9747
ag9747
ag9747
ag9747
ag9747
ag9748
asg21
I0
sba(iArchitecture
Entity
p9866
(dp9867
g11
(lp9868
g9733
ag9733
ag9733
ag9733
ag9733
ag9734
asg13
S'com.google.common.io.BaseEncoding$StandardBaseEncoding$2'
p9869
sg15
(lp9870
VWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9871
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9872
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9873
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9874
aVWhen decoding Base64/32/16 data an exception is thrown if an invalid character is found:\u000a\u000aBaseEncoding.java:501:\u000a\u000a``` java\u000a    int decode(char ch) throws IOException {\u000a      if (ch > Ascii.MAX || decodabet[ch] == -1) {\u000a        throw new DecodingException("Unrecognized character: " + ch);\u000a      }\u000a      return decodabet[ch];\u000a    }\u000a```\u000a\u000aThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\u000a
p9875
aVThe next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\u000a\u000aThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\u000a
p9876
asg17
(lp9877
g9744
ag9744
ag9744
ag9744
ag9744
ag9745
asg19
(lp9878
g9747
ag9747
ag9747
ag9747
ag9747
ag9748
asg21
I0
sba(iArchitecture
Entity
p9879
(dp9880
g11
(lp9881
sg13
S'com.google.common.io.ByteArrayDataInput'
p9882
sg15
(lp9883
sg17
(lp9884
sg19
(lp9885
sg21
I0
sba(iArchitecture
Entity
p9886
(dp9887
g11
(lp9888
sg13
S'com.google.common.io.ByteArrayDataOutput'
p9889
sg15
(lp9890
sg17
(lp9891
sg19
(lp9892
sg21
I0
sba(iArchitecture
Entity
p9893
(dp9894
g11
(lp9895
sg13
S'com.google.common.io.ByteProcessor'
p9896
sg15
(lp9897
sg17
(lp9898
sg19
(lp9899
sg21
I0
sba(iArchitecture
Entity
p9900
(dp9901
g11
(lp9902
sg13
S'com.google.common.io.ByteSink'
p9903
sg15
(lp9904
sg17
(lp9905
sg19
(lp9906
sg21
I0
sba(iArchitecture
Entity
p9907
(dp9908
g11
(lp9909
sg13
S'com.google.common.io.ByteSink$1'
p9910
sg15
(lp9911
sg17
(lp9912
sg19
(lp9913
sg21
I0
sba(iArchitecture
Entity
p9914
(dp9915
g11
(lp9916
sg13
S'com.google.common.io.ByteSink$AsCharSink'
p9917
sg15
(lp9918
sg17
(lp9919
sg19
(lp9920
sg21
I0
sba(iArchitecture
Entity
p9921
(dp9922
g11
(lp9923
V2127
p9924
ag9924
asg13
S'com.google.common.io.ByteSource'
p9925
sg15
(lp9926
VAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9927
aVAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9928
asg17
(lp9929
(lp9930
I1
aag9930
asg19
(lp9931
V19rc1 regression in sliced bytesource: offset + length may overflow for large length values
p9932
ag9932
asg21
I0
sba(iArchitecture
Entity
p9933
(dp9934
g11
(lp9935
g9924
ag9924
asg13
S'com.google.common.io.ByteSource$1'
p9936
sg15
(lp9937
VAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9938
aVAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9939
asg17
(lp9940
g9930
ag9930
asg19
(lp9941
g9932
ag9932
asg21
I0
sba(iArchitecture
Entity
p9942
(dp9943
g11
(lp9944
g9924
ag9924
asg13
S'com.google.common.io.ByteSource$AsCharSource'
p9945
sg15
(lp9946
VAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9947
aVAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9948
asg17
(lp9949
g9930
ag9930
asg19
(lp9950
g9932
ag9932
asg21
I0
sba(iArchitecture
Entity
p9951
(dp9952
g11
(lp9953
g9924
ag9924
asg13
S'com.google.common.io.ByteSource$ByteArrayByteSource'
p9954
sg15
(lp9955
VAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9956
aVAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9957
asg17
(lp9958
g9930
ag9930
asg19
(lp9959
g9932
ag9932
asg21
I0
sba(iArchitecture
Entity
p9960
(dp9961
g11
(lp9962
g9924
ag9924
asg13
S'com.google.common.io.ByteSource$ConcatenatedByteSource'
p9963
sg15
(lp9964
VAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9965
aVAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9966
asg17
(lp9967
g9930
ag9930
asg19
(lp9968
g9932
ag9932
asg21
I0
sba(iArchitecture
Entity
p9969
(dp9970
g11
(lp9971
g9924
ag9924
asg13
S'com.google.common.io.ByteSource$EmptyByteSource'
p9972
sg15
(lp9973
VAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9974
aVAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9975
asg17
(lp9976
g9930
ag9930
asg19
(lp9977
g9932
ag9932
asg21
I0
sba(iArchitecture
Entity
p9978
(dp9979
g11
(lp9980
g9924
ag9924
asg13
S'com.google.common.io.ByteSource$SlicedByteSource'
p9981
sg15
(lp9982
VAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9983
aVAn algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \u000aThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\u000a\u000aI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\u000a
p9984
asg17
(lp9985
g9930
ag9930
asg19
(lp9986
g9932
ag9932
asg21
I0
sba(iArchitecture
Entity
p9987
(dp9988
g11
(lp9989
sg13
S'com.google.common.io.ByteStreams'
p9990
sg15
(lp9991
sg17
(lp9992
sg19
(lp9993
sg21
I0
sba(iArchitecture
Entity
p9994
(dp9995
g11
(lp9996
sg13
S'com.google.common.io.ByteStreams$1'
p9997
sg15
(lp9998
sg17
(lp9999
sg19
(lp10000
sg21
I0
sba(iArchitecture
Entity
p10001
(dp10002
g11
(lp10003
sg13
S'com.google.common.io.ByteStreams$ByteArrayDataInputStream'
p10004
sg15
(lp10005
sg17
(lp10006
sg19
(lp10007
sg21
I0
sba(iArchitecture
Entity
p10008
(dp10009
g11
(lp10010
sg13
S'com.google.common.io.ByteStreams$ByteArrayDataOutputStream'
p10011
sg15
(lp10012
sg17
(lp10013
sg19
(lp10014
sg21
I0
sba(iArchitecture
Entity
p10015
(dp10016
g11
(lp10017
sg13
S'com.google.common.io.ByteStreams$FastByteArrayOutputStream'
p10018
sg15
(lp10019
sg17
(lp10020
sg19
(lp10021
sg21
I0
sba(iArchitecture
Entity
p10022
(dp10023
g11
(lp10024
sg13
S'com.google.common.io.ByteStreams$LimitedInputStream'
p10025
sg15
(lp10026
sg17
(lp10027
sg19
(lp10028
sg21
I0
sba(iArchitecture
Entity
p10029
(dp10030
g11
(lp10031
sg13
S'com.google.common.io.CharSequenceReader'
p10032
sg15
(lp10033
sg17
(lp10034
sg19
(lp10035
sg21
I0
sba(iArchitecture
Entity
p10036
(dp10037
g11
(lp10038
sg13
S'com.google.common.io.CharSink'
p10039
sg15
(lp10040
sg17
(lp10041
sg19
(lp10042
sg21
I0
sba(iArchitecture
Entity
p10043
(dp10044
g11
(lp10045
sg13
S'com.google.common.io.CharSource'
p10046
sg15
(lp10047
sg17
(lp10048
sg19
(lp10049
sg21
I0
sba(iArchitecture
Entity
p10050
(dp10051
g11
(lp10052
sg13
S'com.google.common.io.CharSource$CharSequenceCharSource'
p10053
sg15
(lp10054
sg17
(lp10055
sg19
(lp10056
sg21
I0
sba(iArchitecture
Entity
p10057
(dp10058
g11
(lp10059
sg13
S'com.google.common.io.CharSource$CharSequenceCharSource$1'
p10060
sg15
(lp10061
sg17
(lp10062
sg19
(lp10063
sg21
I0
sba(iArchitecture
Entity
p10064
(dp10065
g11
(lp10066
sg13
S'com.google.common.io.CharSource$CharSequenceCharSource$1$1'
p10067
sg15
(lp10068
sg17
(lp10069
sg19
(lp10070
sg21
I0
sba(iArchitecture
Entity
p10071
(dp10072
g11
(lp10073
sg13
S'com.google.common.io.CharSource$ConcatenatedCharSource'
p10074
sg15
(lp10075
sg17
(lp10076
sg19
(lp10077
sg21
I0
sba(iArchitecture
Entity
p10078
(dp10079
g11
(lp10080
sg13
S'com.google.common.io.CharSource$EmptyCharSource'
p10081
sg15
(lp10082
sg17
(lp10083
sg19
(lp10084
sg21
I0
sba(iArchitecture
Entity
p10085
(dp10086
g11
(lp10087
sg13
S'com.google.common.io.CharStreams'
p10088
sg15
(lp10089
sg17
(lp10090
sg19
(lp10091
sg21
I0
sba(iArchitecture
Entity
p10092
(dp10093
g11
(lp10094
sg13
S'com.google.common.io.CharStreams$1'
p10095
sg15
(lp10096
sg17
(lp10097
sg19
(lp10098
sg21
I0
sba(iArchitecture
Entity
p10099
(dp10100
g11
(lp10101
sg13
S'com.google.common.io.CharStreams$NullWriter'
p10102
sg15
(lp10103
sg17
(lp10104
sg19
(lp10105
sg21
I0
sba(iArchitecture
Entity
p10106
(dp10107
g11
(lp10108
sg13
S'com.google.common.io.Closeables'
p10109
sg15
(lp10110
sg17
(lp10111
sg19
(lp10112
sg21
I0
sba(iArchitecture
Entity
p10113
(dp10114
g11
(lp10115
sg13
S'com.google.common.io.Closer'
p10116
sg15
(lp10117
sg17
(lp10118
sg19
(lp10119
sg21
I0
sba(iArchitecture
Entity
p10120
(dp10121
g11
(lp10122
sg13
S'com.google.common.io.Closer$LoggingSuppressor'
p10123
sg15
(lp10124
sg17
(lp10125
sg19
(lp10126
sg21
I0
sba(iArchitecture
Entity
p10127
(dp10128
g11
(lp10129
sg13
S'com.google.common.io.Closer$SuppressingSuppressor'
p10130
sg15
(lp10131
sg17
(lp10132
sg19
(lp10133
sg21
I0
sba(iArchitecture
Entity
p10134
(dp10135
g11
(lp10136
sg13
S'com.google.common.io.Closer$Suppressor'
p10137
sg15
(lp10138
sg17
(lp10139
sg19
(lp10140
sg21
I0
sba(iArchitecture
Entity
p10141
(dp10142
g11
(lp10143
sg13
S'com.google.common.io.FileBackedOutputStream'
p10144
sg15
(lp10145
sg17
(lp10146
sg19
(lp10147
sg21
I0
sba(iArchitecture
Entity
p10148
(dp10149
g11
(lp10150
sg13
S'com.google.common.io.FileBackedOutputStream$1'
p10151
sg15
(lp10152
sg17
(lp10153
sg19
(lp10154
sg21
I0
sba(iArchitecture
Entity
p10155
(dp10156
g11
(lp10157
sg13
S'com.google.common.io.FileBackedOutputStream$2'
p10158
sg15
(lp10159
sg17
(lp10160
sg19
(lp10161
sg21
I0
sba(iArchitecture
Entity
p10162
(dp10163
g11
(lp10164
sg13
S'com.google.common.io.FileBackedOutputStream$MemoryOutput'
p10165
sg15
(lp10166
sg17
(lp10167
sg19
(lp10168
sg21
I0
sba(iArchitecture
Entity
p10169
(dp10170
g11
(lp10171
sg13
S'com.google.common.io.FileWriteMode'
p10172
sg15
(lp10173
sg17
(lp10174
sg19
(lp10175
sg21
I0
sba(iArchitecture
Entity
p10176
(dp10177
g11
(lp10178
sg13
S'com.google.common.io.Files'
p10179
sg15
(lp10180
sg17
(lp10181
sg19
(lp10182
sg21
I0
sba(iArchitecture
Entity
p10183
(dp10184
g11
(lp10185
sg13
S'com.google.common.io.Files$1'
p10186
sg15
(lp10187
sg17
(lp10188
sg19
(lp10189
sg21
I0
sba(iArchitecture
Entity
p10190
(dp10191
g11
(lp10192
sg13
S'com.google.common.io.Files$2'
p10193
sg15
(lp10194
sg17
(lp10195
sg19
(lp10196
sg21
I0
sba(iArchitecture
Entity
p10197
(dp10198
g11
(lp10199
sg13
S'com.google.common.io.Files$FileByteSink'
p10200
sg15
(lp10201
sg17
(lp10202
sg19
(lp10203
sg21
I0
sba(iArchitecture
Entity
p10204
(dp10205
g11
(lp10206
sg13
S'com.google.common.io.Files$FileByteSource'
p10207
sg15
(lp10208
sg17
(lp10209
sg19
(lp10210
sg21
I0
sba(iArchitecture
Entity
p10211
(dp10212
g11
(lp10213
sg13
S'com.google.common.io.Files$FilePredicate'
p10214
sg15
(lp10215
sg17
(lp10216
sg19
(lp10217
sg21
I0
sba(iArchitecture
Entity
p10218
(dp10219
g11
(lp10220
sg13
S'com.google.common.io.Files$FilePredicate$1'
p10221
sg15
(lp10222
sg17
(lp10223
sg19
(lp10224
sg21
I0
sba(iArchitecture
Entity
p10225
(dp10226
g11
(lp10227
sg13
S'com.google.common.io.Files$FilePredicate$2'
p10228
sg15
(lp10229
sg17
(lp10230
sg19
(lp10231
sg21
I0
sba(iArchitecture
Entity
p10232
(dp10233
g11
(lp10234
sg13
S'com.google.common.io.GwtWorkarounds'
p10235
sg15
(lp10236
sg17
(lp10237
sg19
(lp10238
sg21
I0
sba(iArchitecture
Entity
p10239
(dp10240
g11
(lp10241
sg13
S'com.google.common.io.GwtWorkarounds$1'
p10242
sg15
(lp10243
sg17
(lp10244
sg19
(lp10245
sg21
I0
sba(iArchitecture
Entity
p10246
(dp10247
g11
(lp10248
sg13
S'com.google.common.io.GwtWorkarounds$2'
p10249
sg15
(lp10250
sg17
(lp10251
sg19
(lp10252
sg21
I0
sba(iArchitecture
Entity
p10253
(dp10254
g11
(lp10255
sg13
S'com.google.common.io.GwtWorkarounds$3'
p10256
sg15
(lp10257
sg17
(lp10258
sg19
(lp10259
sg21
I0
sba(iArchitecture
Entity
p10260
(dp10261
g11
(lp10262
sg13
S'com.google.common.io.GwtWorkarounds$4'
p10263
sg15
(lp10264
sg17
(lp10265
sg19
(lp10266
sg21
I0
sba(iArchitecture
Entity
p10267
(dp10268
g11
(lp10269
sg13
S'com.google.common.io.GwtWorkarounds$5'
p10270
sg15
(lp10271
sg17
(lp10272
sg19
(lp10273
sg21
I0
sba(iArchitecture
Entity
p10274
(dp10275
g11
(lp10276
sg13
S'com.google.common.io.GwtWorkarounds$6'
p10277
sg15
(lp10278
sg17
(lp10279
sg19
(lp10280
sg21
I0
sba(iArchitecture
Entity
p10281
(dp10282
g11
(lp10283
sg13
S'com.google.common.io.GwtWorkarounds$ByteInput'
p10284
sg15
(lp10285
sg17
(lp10286
sg19
(lp10287
sg21
I0
sba(iArchitecture
Entity
p10288
(dp10289
g11
(lp10290
sg13
S'com.google.common.io.GwtWorkarounds$ByteOutput'
p10291
sg15
(lp10292
sg17
(lp10293
sg19
(lp10294
sg21
I0
sba(iArchitecture
Entity
p10295
(dp10296
g11
(lp10297
sg13
S'com.google.common.io.GwtWorkarounds$CharInput'
p10298
sg15
(lp10299
sg17
(lp10300
sg19
(lp10301
sg21
I0
sba(iArchitecture
Entity
p10302
(dp10303
g11
(lp10304
sg13
S'com.google.common.io.GwtWorkarounds$CharOutput'
p10305
sg15
(lp10306
sg17
(lp10307
sg19
(lp10308
sg21
I0
sba(iArchitecture
Entity
p10309
(dp10310
g11
(lp10311
sg13
S'com.google.common.io.LineBuffer'
p10312
sg15
(lp10313
sg17
(lp10314
sg19
(lp10315
sg21
I0
sba(iArchitecture
Entity
p10316
(dp10317
g11
(lp10318
sg13
S'com.google.common.io.LineProcessor'
p10319
sg15
(lp10320
sg17
(lp10321
sg19
(lp10322
sg21
I0
sba(iArchitecture
Entity
p10323
(dp10324
g11
(lp10325
sg13
S'com.google.common.io.LineReader'
p10326
sg15
(lp10327
sg17
(lp10328
sg19
(lp10329
sg21
I0
sba(iArchitecture
Entity
p10330
(dp10331
g11
(lp10332
sg13
S'com.google.common.io.LineReader$1'
p10333
sg15
(lp10334
sg17
(lp10335
sg19
(lp10336
sg21
I0
sba(iArchitecture
Entity
p10337
(dp10338
g11
(lp10339
sg13
S'com.google.common.io.MultiInputStream'
p10340
sg15
(lp10341
sg17
(lp10342
sg19
(lp10343
sg21
I0
sba(iArchitecture
Entity
p10344
(dp10345
g11
(lp10346
sg13
S'com.google.common.io.MultiReader'
p10347
sg15
(lp10348
sg17
(lp10349
sg19
(lp10350
sg21
I0
sba(iArchitecture
Entity
p10351
(dp10352
g11
(lp10353
sg13
S'com.google.common.io.Resources'
p10354
sg15
(lp10355
sg17
(lp10356
sg19
(lp10357
sg21
I0
sba(iArchitecture
Entity
p10358
(dp10359
g11
(lp10360
sg13
S'com.google.common.io.Resources$1'
p10361
sg15
(lp10362
sg17
(lp10363
sg19
(lp10364
sg21
I0
sba(iArchitecture
Entity
p10365
(dp10366
g11
(lp10367
sg13
S'com.google.common.io.Resources$UrlByteSource'
p10368
sg15
(lp10369
sg17
(lp10370
sg19
(lp10371
sg21
I0
sbasg1135
(lp10372
g9726
ag9735
ag9752
ag9765
ag9778
ag9791
ag9804
ag9817
ag9830
ag9843
ag9856
ag9869
ag9882
ag9889
ag9896
ag9903
ag9910
ag9917
ag9925
ag9936
ag9945
ag9954
ag9963
ag9972
ag9981
ag9990
ag9997
ag10004
ag10011
ag10018
ag10025
ag10032
ag10039
ag10046
ag10053
ag10060
ag10067
ag10074
ag10081
ag10088
ag10095
ag10102
ag10109
ag10116
ag10123
ag10130
ag10137
ag10144
ag10151
ag10158
ag10165
ag10172
ag10179
ag10186
ag10193
ag10200
ag10207
ag10214
ag10221
ag10228
ag10235
ag10242
ag10249
ag10256
ag10263
ag10270
ag10277
ag10284
ag10291
ag10298
ag10305
ag10312
ag10319
ag10326
ag10333
ag10340
ag10347
ag10354
ag10361
ag10368
asg1137
I0
sg21
I0
sg1138
S'com.google.common.io.ss'
p10373
sba(iArchitecture
Cluster
p10374
(dp10375
g7
(lp10376
(iArchitecture
Entity
p10377
(dp10378
g11
(lp10379
sg13
S'com.google.common.math.BigIntegerMath'
p10380
sg15
(lp10381
sg17
(lp10382
sg19
(lp10383
sg21
I0
sba(iArchitecture
Entity
p10384
(dp10385
g11
(lp10386
sg13
S'com.google.common.math.BigIntegerMath$1'
p10387
sg15
(lp10388
sg17
(lp10389
sg19
(lp10390
sg21
I0
sba(iArchitecture
Entity
p10391
(dp10392
g11
(lp10393
sg13
S'com.google.common.math.DoubleMath'
p10394
sg15
(lp10395
sg17
(lp10396
sg19
(lp10397
sg21
I0
sba(iArchitecture
Entity
p10398
(dp10399
g11
(lp10400
sg13
S'com.google.common.math.DoubleMath$1'
p10401
sg15
(lp10402
sg17
(lp10403
sg19
(lp10404
sg21
I0
sba(iArchitecture
Entity
p10405
(dp10406
g11
(lp10407
sg13
S'com.google.common.math.DoubleMath$MeanAccumulator'
p10408
sg15
(lp10409
sg17
(lp10410
sg19
(lp10411
sg21
I0
sba(iArchitecture
Entity
p10412
(dp10413
g11
(lp10414
sg13
S'com.google.common.math.DoubleUtils'
p10415
sg15
(lp10416
sg17
(lp10417
sg19
(lp10418
sg21
I0
sba(iArchitecture
Entity
p10419
(dp10420
g11
(lp10421
sg13
S'com.google.common.math.IntMath'
p10422
sg15
(lp10423
sg17
(lp10424
sg19
(lp10425
sg21
I0
sba(iArchitecture
Entity
p10426
(dp10427
g11
(lp10428
sg13
S'com.google.common.math.IntMath$1'
p10429
sg15
(lp10430
sg17
(lp10431
sg19
(lp10432
sg21
I0
sba(iArchitecture
Entity
p10433
(dp10434
g11
(lp10435
sg13
S'com.google.common.math.LongMath'
p10436
sg15
(lp10437
sg17
(lp10438
sg19
(lp10439
sg21
I0
sba(iArchitecture
Entity
p10440
(dp10441
g11
(lp10442
sg13
S'com.google.common.math.LongMath$1'
p10443
sg15
(lp10444
sg17
(lp10445
sg19
(lp10446
sg21
I0
sba(iArchitecture
Entity
p10447
(dp10448
g11
(lp10449
sg13
S'com.google.common.math.MathPreconditions'
p10450
sg15
(lp10451
sg17
(lp10452
sg19
(lp10453
sg21
I0
sbasg1135
(lp10454
g10380
ag10387
ag10394
ag10401
ag10408
ag10415
ag10422
ag10429
ag10436
ag10443
ag10450
asg1137
I0
sg21
I0
sg1138
S'com.google.common.math.ss'
p10455
sba(iArchitecture
Cluster
p10456
(dp10457
g7
(lp10458
(iArchitecture
Entity
p10459
(dp10460
g11
(lp10461
sg13
S'com.google.common.base.Charsets'
p10462
sg15
(lp10463
sg17
(lp10464
sg19
(lp10465
sg21
I0
sba(iArchitecture
Entity
p10466
(dp10467
g11
(lp10468
sg13
S'com.google.common.base.Strings'
p10469
sg15
(lp10470
sg17
(lp10471
sg19
(lp10472
sg21
I0
sba(iArchitecture
Entity
p10473
(dp10474
g11
(lp10475
sg13
S'com.google.common.net.HostAndPort'
p10476
sg15
(lp10477
sg17
(lp10478
sg19
(lp10479
sg21
I0
sba(iArchitecture
Entity
p10480
(dp10481
g11
(lp10482
sg13
S'com.google.common.net.HostSpecifier'
p10483
sg15
(lp10484
sg17
(lp10485
sg19
(lp10486
sg21
I0
sba(iArchitecture
Entity
p10487
(dp10488
g11
(lp10489
g1014
asg13
S'com.google.common.net.InetAddresses'
p10490
sg15
(lp10491
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p10492
asg17
(lp10493
g1029
asg19
(lp10494
g1033
asg21
I0
sba(iArchitecture
Entity
p10495
(dp10496
g11
(lp10497
g1014
asg13
S'com.google.common.net.InetAddresses$TeredoInfo'
p10498
sg15
(lp10499
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p10500
asg17
(lp10501
g1029
asg19
(lp10502
g1033
asg21
I0
sba(iArchitecture
Entity
p10503
(dp10504
g11
(lp10505
sg13
S'com.google.common.net.InternetDomainName'
p10506
sg15
(lp10507
sg17
(lp10508
sg19
(lp10509
sg21
I0
sba(iArchitecture
Entity
p10510
(dp10511
g11
(lp10512
V2132
p10513
asg13
S'com.google.common.net.MediaType'
p10514
sg15
(lp10515
VMissed several video MimeTypes in MediaType class:\u000a\u000a```\u000avideo/x-flv\u000avideo/3gpp\u000avideo/3gpp2\u000a```\u000a\u000aand some audio types:\u000a\u000a```\u000aaudio/basic\u000aaudio/L24\u000aaudio/aac\u000aaudio/vorbis\u000aaudio/x-ms-wma\u000aaudio/x-ms-wax\u000aaudio/vnd.rn-realaudio\u000aaudio/vnd.wave\u000a```\u000a
p10516
asg17
(lp10517
(lp10518
I5
aasg19
(lp10519
VAdd video MediaTypes
p10520
asg21
I0
sba(iArchitecture
Entity
p10521
(dp10522
g11
(lp10523
g10513
asg13
S'com.google.common.net.MediaType$1'
p10524
sg15
(lp10525
VMissed several video MimeTypes in MediaType class:\u000a\u000a```\u000avideo/x-flv\u000avideo/3gpp\u000avideo/3gpp2\u000a```\u000a\u000aand some audio types:\u000a\u000a```\u000aaudio/basic\u000aaudio/L24\u000aaudio/aac\u000aaudio/vorbis\u000aaudio/x-ms-wma\u000aaudio/x-ms-wax\u000aaudio/vnd.rn-realaudio\u000aaudio/vnd.wave\u000a```\u000a
p10526
asg17
(lp10527
g10518
asg19
(lp10528
g10520
asg21
I0
sba(iArchitecture
Entity
p10529
(dp10530
g11
(lp10531
g10513
asg13
S'com.google.common.net.MediaType$2'
p10532
sg15
(lp10533
VMissed several video MimeTypes in MediaType class:\u000a\u000a```\u000avideo/x-flv\u000avideo/3gpp\u000avideo/3gpp2\u000a```\u000a\u000aand some audio types:\u000a\u000a```\u000aaudio/basic\u000aaudio/L24\u000aaudio/aac\u000aaudio/vorbis\u000aaudio/x-ms-wma\u000aaudio/x-ms-wax\u000aaudio/vnd.rn-realaudio\u000aaudio/vnd.wave\u000a```\u000a
p10534
asg17
(lp10535
g10518
asg19
(lp10536
g10520
asg21
I0
sba(iArchitecture
Entity
p10537
(dp10538
g11
(lp10539
g10513
asg13
S'com.google.common.net.MediaType$Tokenizer'
p10540
sg15
(lp10541
VMissed several video MimeTypes in MediaType class:\u000a\u000a```\u000avideo/x-flv\u000avideo/3gpp\u000avideo/3gpp2\u000a```\u000a\u000aand some audio types:\u000a\u000a```\u000aaudio/basic\u000aaudio/L24\u000aaudio/aac\u000aaudio/vorbis\u000aaudio/x-ms-wma\u000aaudio/x-ms-wax\u000aaudio/vnd.rn-realaudio\u000aaudio/vnd.wave\u000a```\u000a
p10542
asg17
(lp10543
g10518
asg19
(lp10544
g10520
asg21
I0
sba(iArchitecture
Entity
p10545
(dp10546
g11
(lp10547
sg13
S'com.google.common.net.PercentEscaper'
p10548
sg15
(lp10549
sg17
(lp10550
sg19
(lp10551
sg21
I0
sba(iArchitecture
Entity
p10552
(dp10553
g11
(lp10554
sg13
S'com.google.common.net.UrlEscapers'
p10555
sg15
(lp10556
sg17
(lp10557
sg19
(lp10558
sg21
I0
sba(iArchitecture
Entity
p10559
(dp10560
g11
(lp10561
sg13
S'com.google.thirdparty.publicsuffix.PublicSuffixPatterns'
p10562
sg15
(lp10563
sg17
(lp10564
sg19
(lp10565
sg21
I0
sba(iArchitecture
Entity
p10566
(dp10567
g11
(lp10568
sg13
S'com.google.thirdparty.publicsuffix.PublicSuffixType'
p10569
sg15
(lp10570
sg17
(lp10571
sg19
(lp10572
sg21
I0
sba(iArchitecture
Entity
p10573
(dp10574
g11
(lp10575
sg13
S'com.google.thirdparty.publicsuffix.TrieParser'
p10576
sg15
(lp10577
sg17
(lp10578
sg19
(lp10579
sg21
I0
sbasg1135
(lp10580
g10462
ag10469
ag10476
ag10483
ag10490
ag10498
ag10506
ag10514
ag10524
ag10532
ag10540
ag10548
ag10555
ag10562
ag10569
ag10576
asg1137
I0
sg21
I0
sg1138
S'com.google.common.net.ss'
p10581
sba(iArchitecture
Cluster
p10582
(dp10583
g7
(lp10584
(iArchitecture
Entity
p10585
(dp10586
g11
(lp10587
sg13
S'com.google.common.io.LittleEndianDataInputStream'
p10588
sg15
(lp10589
sg17
(lp10590
sg19
(lp10591
sg21
I0
sba(iArchitecture
Entity
p10592
(dp10593
g11
(lp10594
sg13
S'com.google.common.io.LittleEndianDataOutputStream'
p10595
sg15
(lp10596
sg17
(lp10597
sg19
(lp10598
sg21
I0
sba(iArchitecture
Entity
p10599
(dp10600
g11
(lp10601
V1942
p10602
asg13
S'com.google.common.primitives.Booleans'
p10603
sg15
(lp10604
VPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10605
asg17
(lp10606
(lp10607
I6
aasg19
(lp10608
VLine comment on requiring Java 6
p10609
asg21
I0
sba(iArchitecture
Entity
p10610
(dp10611
g11
(lp10612
g10602
asg13
S'com.google.common.primitives.Booleans$BooleanArrayAsList'
p10613
sg15
(lp10614
VPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10615
asg17
(lp10616
g10607
asg19
(lp10617
g10609
asg21
I0
sba(iArchitecture
Entity
p10618
(dp10619
g11
(lp10620
g10602
asg13
S'com.google.common.primitives.Booleans$LexicographicalComparator'
p10621
sg15
(lp10622
VPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10623
asg17
(lp10624
g10607
asg19
(lp10625
g10609
asg21
I0
sba(iArchitecture
Entity
p10626
(dp10627
g11
(lp10628
g10602
asg13
S'com.google.common.primitives.Bytes'
p10629
sg15
(lp10630
VPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10631
asg17
(lp10632
g10607
asg19
(lp10633
g10609
asg21
I0
sba(iArchitecture
Entity
p10634
(dp10635
g11
(lp10636
g10602
asg13
S'com.google.common.primitives.Bytes$ByteArrayAsList'
p10637
sg15
(lp10638
VPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10639
asg17
(lp10640
g10607
asg19
(lp10641
g10609
asg21
I0
sba(iArchitecture
Entity
p10642
(dp10643
g11
(lp10644
g10602
ag1014
asg13
S'com.google.common.primitives.Chars'
p10645
sg15
(lp10646
VPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10647
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p10648
asg17
(lp10649
g10607
ag1029
asg19
(lp10650
g10609
ag1033
asg21
I0
sba(iArchitecture
Entity
p10651
(dp10652
g11
(lp10653
g10602
ag1014
asg13
S'com.google.common.primitives.Chars$CharArrayAsList'
p10654
sg15
(lp10655
VPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10656
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p10657
asg17
(lp10658
g10607
ag1029
asg19
(lp10659
g10609
ag1033
asg21
I0
sba(iArchitecture
Entity
p10660
(dp10661
g11
(lp10662
g10602
ag1014
asg13
S'com.google.common.primitives.Chars$LexicographicalComparator'
p10663
sg15
(lp10664
VPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10665
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p10666
asg17
(lp10667
g10607
ag1029
asg19
(lp10668
g10609
ag1033
asg21
I0
sba(iArchitecture
Entity
p10669
(dp10670
g11
(lp10671
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Doubles'
p10672
sg15
(lp10673
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10674
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10675
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10676
asg17
(lp10677
g32
ag32
ag10607
asg19
(lp10678
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10679
(dp10680
g11
(lp10681
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Doubles$DoubleArrayAsList'
p10682
sg15
(lp10683
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10684
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10685
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10686
asg17
(lp10687
g32
ag32
ag10607
asg19
(lp10688
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10689
(dp10690
g11
(lp10691
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Doubles$DoubleConverter'
p10692
sg15
(lp10693
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10694
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10695
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10696
asg17
(lp10697
g32
ag32
ag10607
asg19
(lp10698
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10699
(dp10700
g11
(lp10701
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Doubles$LexicographicalComparator'
p10702
sg15
(lp10703
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10704
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10705
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10706
asg17
(lp10707
g32
ag32
ag10607
asg19
(lp10708
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10709
(dp10710
g11
(lp10711
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Floats'
p10712
sg15
(lp10713
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10714
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10715
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10716
asg17
(lp10717
g32
ag32
ag10607
asg19
(lp10718
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10719
(dp10720
g11
(lp10721
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Floats$FloatArrayAsList'
p10722
sg15
(lp10723
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10724
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10725
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10726
asg17
(lp10727
g32
ag32
ag10607
asg19
(lp10728
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10729
(dp10730
g11
(lp10731
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Floats$FloatConverter'
p10732
sg15
(lp10733
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10734
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10735
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10736
asg17
(lp10737
g32
ag32
ag10607
asg19
(lp10738
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10739
(dp10740
g11
(lp10741
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Floats$LexicographicalComparator'
p10742
sg15
(lp10743
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10744
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10745
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10746
asg17
(lp10747
g32
ag32
ag10607
asg19
(lp10748
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10749
(dp10750
g11
(lp10751
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Ints'
p10752
sg15
(lp10753
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10754
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10755
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10756
asg17
(lp10757
g32
ag32
ag10607
asg19
(lp10758
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10759
(dp10760
g11
(lp10761
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Ints$IntArrayAsList'
p10762
sg15
(lp10763
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10764
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10765
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10766
asg17
(lp10767
g32
ag32
ag10607
asg19
(lp10768
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10769
(dp10770
g11
(lp10771
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Ints$IntConverter'
p10772
sg15
(lp10773
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10774
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10775
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10776
asg17
(lp10777
g32
ag32
ag10607
asg19
(lp10778
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10779
(dp10780
g11
(lp10781
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Ints$LexicographicalComparator'
p10782
sg15
(lp10783
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10784
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10785
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10786
asg17
(lp10787
g32
ag32
ag10607
asg19
(lp10788
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10789
(dp10790
g11
(lp10791
g25
ag10602
asg13
S'com.google.common.primitives.Longs'
p10792
sg15
(lp10793
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10794
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10795
asg17
(lp10796
g32
ag10607
asg19
(lp10797
g35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10798
(dp10799
g11
(lp10800
g25
ag10602
asg13
S'com.google.common.primitives.Longs$LexicographicalComparator'
p10801
sg15
(lp10802
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10803
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10804
asg17
(lp10805
g32
ag10607
asg19
(lp10806
g35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10807
(dp10808
g11
(lp10809
g25
ag10602
asg13
S'com.google.common.primitives.Longs$LongArrayAsList'
p10810
sg15
(lp10811
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10812
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10813
asg17
(lp10814
g32
ag10607
asg19
(lp10815
g35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10816
(dp10817
g11
(lp10818
g25
ag10602
asg13
S'com.google.common.primitives.Longs$LongConverter'
p10819
sg15
(lp10820
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10821
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10822
asg17
(lp10823
g32
ag10607
asg19
(lp10824
g35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10825
(dp10826
g11
(lp10827
sg13
S'com.google.common.primitives.ParseRequest'
p10828
sg15
(lp10829
sg17
(lp10830
sg19
(lp10831
sg21
I0
sba(iArchitecture
Entity
p10832
(dp10833
g11
(lp10834
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Shorts'
p10835
sg15
(lp10836
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10837
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10838
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10839
asg17
(lp10840
g32
ag32
ag10607
asg19
(lp10841
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10842
(dp10843
g11
(lp10844
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Shorts$LexicographicalComparator'
p10845
sg15
(lp10846
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10847
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10848
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10849
asg17
(lp10850
g32
ag32
ag10607
asg19
(lp10851
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10852
(dp10853
g11
(lp10854
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Shorts$ShortArrayAsList'
p10855
sg15
(lp10856
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10857
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10858
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10859
asg17
(lp10860
g32
ag32
ag10607
asg19
(lp10861
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10862
(dp10863
g11
(lp10864
g25
ag25
ag10602
asg13
S'com.google.common.primitives.Shorts$ShortConverter'
p10865
sg15
(lp10866
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10867
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p10868
aVPlease see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\u000a\u000aIsn't Java 6 available?\u000aIf it is, should that comment be removed?\u000aShould the method be removed? (It is private and only used in a single place).\u000a
p10869
asg17
(lp10870
g32
ag32
ag10607
asg19
(lp10871
g35
ag35
ag10609
asg21
I0
sba(iArchitecture
Entity
p10872
(dp10873
g11
(lp10874
sg13
S'com.google.common.primitives.SignedBytes'
p10875
sg15
(lp10876
sg17
(lp10877
sg19
(lp10878
sg21
I0
sba(iArchitecture
Entity
p10879
(dp10880
g11
(lp10881
sg13
S'com.google.common.primitives.SignedBytes$LexicographicalComparator'
p10882
sg15
(lp10883
sg17
(lp10884
sg19
(lp10885
sg21
I0
sba(iArchitecture
Entity
p10886
(dp10887
g11
(lp10888
sg13
S'com.google.common.primitives.UnsignedBytes'
p10889
sg15
(lp10890
sg17
(lp10891
sg19
(lp10892
sg21
I0
sba(iArchitecture
Entity
p10893
(dp10894
g11
(lp10895
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder'
p10896
sg15
(lp10897
sg17
(lp10898
sg19
(lp10899
sg21
I0
sba(iArchitecture
Entity
p10900
(dp10901
g11
(lp10902
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder$PureJavaComparator'
p10903
sg15
(lp10904
sg17
(lp10905
sg19
(lp10906
sg21
I0
sba(iArchitecture
Entity
p10907
(dp10908
g11
(lp10909
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator'
p10910
sg15
(lp10911
sg17
(lp10912
sg19
(lp10913
sg21
I0
sba(iArchitecture
Entity
p10914
(dp10915
g11
(lp10916
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator$1'
p10917
sg15
(lp10918
sg17
(lp10919
sg19
(lp10920
sg21
I0
sba(iArchitecture
Entity
p10921
(dp10922
g11
(lp10923
sg13
S'com.google.common.primitives.UnsignedInts'
p10924
sg15
(lp10925
sg17
(lp10926
sg19
(lp10927
sg21
I0
sba(iArchitecture
Entity
p10928
(dp10929
g11
(lp10930
sg13
S'com.google.common.primitives.UnsignedInts$LexicographicalComparator'
p10931
sg15
(lp10932
sg17
(lp10933
sg19
(lp10934
sg21
I0
sba(iArchitecture
Entity
p10935
(dp10936
g11
(lp10937
sg13
S'com.google.common.primitives.UnsignedLong'
p10938
sg15
(lp10939
sg17
(lp10940
sg19
(lp10941
sg21
I0
sba(iArchitecture
Entity
p10942
(dp10943
g11
(lp10944
sg13
S'com.google.common.primitives.UnsignedLongs'
p10945
sg15
(lp10946
sg17
(lp10947
sg19
(lp10948
sg21
I0
sba(iArchitecture
Entity
p10949
(dp10950
g11
(lp10951
sg13
S'com.google.common.primitives.UnsignedLongs$LexicographicalComparator'
p10952
sg15
(lp10953
sg17
(lp10954
sg19
(lp10955
sg21
I0
sbasg1135
(lp10956
g10588
ag10595
ag10603
ag10613
ag10621
ag10629
ag10637
ag10645
ag10654
ag10663
ag10672
ag10682
ag10692
ag10702
ag10712
ag10722
ag10732
ag10742
ag10752
ag10762
ag10772
ag10782
ag10792
ag10801
ag10810
ag10819
ag10828
ag10835
ag10845
ag10855
ag10865
ag10875
ag10882
ag10889
ag10896
ag10903
ag10910
ag10917
ag10924
ag10931
ag10938
ag10945
ag10952
asg1137
I0
sg21
I0
sg1138
S'com.google.common.primitives.ss'
p10957
sba(iArchitecture
Cluster
p10958
(dp10959
g7
(lp10960
(iArchitecture
Entity
p10961
(dp10962
g11
(lp10963
sg13
S'com.google.common.collect.ForwardingMapEntry'
p10964
sg15
(lp10965
sg17
(lp10966
sg19
(lp10967
sg21
I0
sba(iArchitecture
Entity
p10968
(dp10969
g11
(lp10970
sg13
S'com.google.common.collect.ImmutableSet$Builder'
p10971
sg15
(lp10972
sg17
(lp10973
sg19
(lp10974
sg21
I0
sba(iArchitecture
Entity
p10975
(dp10976
g11
(lp10977
sg13
S'com.google.common.primitives.Primitives'
p10978
sg15
(lp10979
sg17
(lp10980
sg19
(lp10981
sg21
I0
sba(iArchitecture
Entity
p10982
(dp10983
g11
(lp10984
V2228
p10985
ag10985
asg13
S'com.google.common.reflect.ClassPath'
p10986
sg15
(lp10987
VIf I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\u000a\u000aA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\u000a
p10988
aVIf I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\u000a\u000aA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\u000a
p10989
asg17
(lp10990
(lp10991
I5
aag10991
asg19
(lp10992
VAdd ClassPath.ResourceInfo.asByteSource()
p10993
ag10993
asg21
I0
sba(iArchitecture
Entity
p10994
(dp10995
g11
(lp10996
g10985
ag10985
asg13
S'com.google.common.reflect.ClassPath$1'
p10997
sg15
(lp10998
VIf I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\u000a\u000aA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\u000a
p10999
aVIf I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\u000a\u000aA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\u000a
p11000
asg17
(lp11001
g10991
ag10991
asg19
(lp11002
g10993
ag10993
asg21
I0
sba(iArchitecture
Entity
p11003
(dp11004
g11
(lp11005
g10985
ag10985
asg13
S'com.google.common.reflect.ClassPath$ClassInfo'
p11006
sg15
(lp11007
VIf I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\u000a\u000aA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\u000a
p11008
aVIf I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\u000a\u000aA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\u000a
p11009
asg17
(lp11010
g10991
ag10991
asg19
(lp11011
g10993
ag10993
asg21
I0
sba(iArchitecture
Entity
p11012
(dp11013
g11
(lp11014
g10985
ag10985
asg13
S'com.google.common.reflect.ClassPath$ResourceInfo'
p11015
sg15
(lp11016
VIf I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\u000a\u000aA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\u000a
p11017
aVIf I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\u000a\u000aA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\u000a
p11018
asg17
(lp11019
g10991
ag10991
asg19
(lp11020
g10993
ag10993
asg21
I0
sba(iArchitecture
Entity
p11021
(dp11022
g11
(lp11023
g10985
ag10985
asg13
S'com.google.common.reflect.ClassPath$Scanner'
p11024
sg15
(lp11025
VIf I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\u000a\u000aA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\u000a
p11026
aVIf I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\u000a\u000aA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\u000a
p11027
asg17
(lp11028
g10991
ag10991
asg19
(lp11029
g10993
ag10993
asg21
I0
sba(iArchitecture
Entity
p11030
(dp11031
g11
(lp11032
g25
asg13
S'com.google.common.reflect.Element'
p11033
sg15
(lp11034
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11035
asg17
(lp11036
g32
asg19
(lp11037
g35
asg21
I0
sba(iArchitecture
Entity
p11038
(dp11039
g11
(lp11040
sg13
S'com.google.common.reflect.ImmutableTypeToInstanceMap'
p11041
sg15
(lp11042
sg17
(lp11043
sg19
(lp11044
sg21
I0
sba(iArchitecture
Entity
p11045
(dp11046
g11
(lp11047
sg13
S'com.google.common.reflect.ImmutableTypeToInstanceMap$1'
p11048
sg15
(lp11049
sg17
(lp11050
sg19
(lp11051
sg21
I0
sba(iArchitecture
Entity
p11052
(dp11053
g11
(lp11054
sg13
S'com.google.common.reflect.ImmutableTypeToInstanceMap$Builder'
p11055
sg15
(lp11056
sg17
(lp11057
sg19
(lp11058
sg21
I0
sba(iArchitecture
Entity
p11059
(dp11060
g11
(lp11061
g25
asg13
S'com.google.common.reflect.Invokable'
p11062
sg15
(lp11063
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11064
asg17
(lp11065
g32
asg19
(lp11066
g35
asg21
I0
sba(iArchitecture
Entity
p11067
(dp11068
g11
(lp11069
g25
asg13
S'com.google.common.reflect.Invokable$ConstructorInvokable'
p11070
sg15
(lp11071
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11072
asg17
(lp11073
g32
asg19
(lp11074
g35
asg21
I0
sba(iArchitecture
Entity
p11075
(dp11076
g11
(lp11077
g25
asg13
S'com.google.common.reflect.Invokable$MethodInvokable'
p11078
sg15
(lp11079
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11080
asg17
(lp11081
g32
asg19
(lp11082
g35
asg21
I0
sba(iArchitecture
Entity
p11083
(dp11084
g11
(lp11085
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap'
p11086
sg15
(lp11087
sg17
(lp11088
sg19
(lp11089
sg21
I0
sba(iArchitecture
Entity
p11090
(dp11091
g11
(lp11092
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$1'
p11093
sg15
(lp11094
sg17
(lp11095
sg19
(lp11096
sg21
I0
sba(iArchitecture
Entity
p11097
(dp11098
g11
(lp11099
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry'
p11100
sg15
(lp11101
sg17
(lp11102
sg19
(lp11103
sg21
I0
sba(iArchitecture
Entity
p11104
(dp11105
g11
(lp11106
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry$1'
p11107
sg15
(lp11108
sg17
(lp11109
sg19
(lp11110
sg21
I0
sba(iArchitecture
Entity
p11111
(dp11112
g11
(lp11113
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry$2'
p11114
sg15
(lp11115
sg17
(lp11116
sg19
(lp11117
sg21
I0
sba(iArchitecture
Entity
p11118
(dp11119
g11
(lp11120
g25
asg13
S'com.google.common.reflect.Parameter'
p11121
sg15
(lp11122
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11123
asg17
(lp11124
g32
asg19
(lp11125
g35
asg21
I0
sba(iArchitecture
Entity
p11126
(dp11127
g11
(lp11128
sg13
S'com.google.common.reflect.Reflection'
p11129
sg15
(lp11130
sg17
(lp11131
sg19
(lp11132
sg21
I0
sba(iArchitecture
Entity
p11133
(dp11134
g11
(lp11135
sg13
S'com.google.common.reflect.TypeCapture'
p11136
sg15
(lp11137
sg17
(lp11138
sg19
(lp11139
sg21
I0
sba(iArchitecture
Entity
p11140
(dp11141
g11
(lp11142
sg13
S'com.google.common.reflect.TypeParameter'
p11143
sg15
(lp11144
sg17
(lp11145
sg19
(lp11146
sg21
I0
sba(iArchitecture
Entity
p11147
(dp11148
g11
(lp11149
V2158
p11150
asg13
S'com.google.common.reflect.TypeResolver'
p11151
sg15
(lp11152
VThe visitClass implementation in TypeResolver.populateTypeMappings has the following body:\u000a\u000a```\u000a  @Override void visitClass(Class<?> fromClass) {\u000a    // Can't map from a raw class to anything other than itself.\u000a    // You can't say "assuming String is Integer".\u000a    // And we don't support "assuming String is T"; user has to say "assuming T is String". \u000a    throw new IllegalArgumentException("No type mapping from " + fromClass);\u000a  }\u000a```\u000a\u000aIt would be great if the IllegalArgumentException message reported the type it's trying to convert to, as well as the one its converting from, for easier debugging should this exception be thrown.\u000a
p11153
asg17
(lp11154
(lp11155
I0
aasg19
(lp11156
VTypeVisitor.visitClass in TypeResolver.populateTypeMappings should report the to type as well as the from type
p11157
asg21
I0
sba(iArchitecture
Entity
p11158
(dp11159
g11
(lp11160
g11150
asg13
S'com.google.common.reflect.TypeResolver$1'
p11161
sg15
(lp11162
VThe visitClass implementation in TypeResolver.populateTypeMappings has the following body:\u000a\u000a```\u000a  @Override void visitClass(Class<?> fromClass) {\u000a    // Can't map from a raw class to anything other than itself.\u000a    // You can't say "assuming String is Integer".\u000a    // And we don't support "assuming String is T"; user has to say "assuming T is String". \u000a    throw new IllegalArgumentException("No type mapping from " + fromClass);\u000a  }\u000a```\u000a\u000aIt would be great if the IllegalArgumentException message reported the type it's trying to convert to, as well as the one its converting from, for easier debugging should this exception be thrown.\u000a
p11163
asg17
(lp11164
g11155
asg19
(lp11165
g11157
asg21
I0
sba(iArchitecture
Entity
p11166
(dp11167
g11
(lp11168
g11150
asg13
S'com.google.common.reflect.TypeResolver$TypeMappingIntrospector'
p11169
sg15
(lp11170
VThe visitClass implementation in TypeResolver.populateTypeMappings has the following body:\u000a\u000a```\u000a  @Override void visitClass(Class<?> fromClass) {\u000a    // Can't map from a raw class to anything other than itself.\u000a    // You can't say "assuming String is Integer".\u000a    // And we don't support "assuming String is T"; user has to say "assuming T is String". \u000a    throw new IllegalArgumentException("No type mapping from " + fromClass);\u000a  }\u000a```\u000a\u000aIt would be great if the IllegalArgumentException message reported the type it's trying to convert to, as well as the one its converting from, for easier debugging should this exception be thrown.\u000a
p11171
asg17
(lp11172
g11155
asg19
(lp11173
g11157
asg21
I0
sba(iArchitecture
Entity
p11174
(dp11175
g11
(lp11176
g11150
asg13
S'com.google.common.reflect.TypeResolver$TypeTable'
p11177
sg15
(lp11178
VThe visitClass implementation in TypeResolver.populateTypeMappings has the following body:\u000a\u000a```\u000a  @Override void visitClass(Class<?> fromClass) {\u000a    // Can't map from a raw class to anything other than itself.\u000a    // You can't say "assuming String is Integer".\u000a    // And we don't support "assuming String is T"; user has to say "assuming T is String". \u000a    throw new IllegalArgumentException("No type mapping from " + fromClass);\u000a  }\u000a```\u000a\u000aIt would be great if the IllegalArgumentException message reported the type it's trying to convert to, as well as the one its converting from, for easier debugging should this exception be thrown.\u000a
p11179
asg17
(lp11180
g11155
asg19
(lp11181
g11157
asg21
I0
sba(iArchitecture
Entity
p11182
(dp11183
g11
(lp11184
g11150
asg13
S'com.google.common.reflect.TypeResolver$TypeTable$1'
p11185
sg15
(lp11186
VThe visitClass implementation in TypeResolver.populateTypeMappings has the following body:\u000a\u000a```\u000a  @Override void visitClass(Class<?> fromClass) {\u000a    // Can't map from a raw class to anything other than itself.\u000a    // You can't say "assuming String is Integer".\u000a    // And we don't support "assuming String is T"; user has to say "assuming T is String". \u000a    throw new IllegalArgumentException("No type mapping from " + fromClass);\u000a  }\u000a```\u000a\u000aIt would be great if the IllegalArgumentException message reported the type it's trying to convert to, as well as the one its converting from, for easier debugging should this exception be thrown.\u000a
p11187
asg17
(lp11188
g11155
asg19
(lp11189
g11157
asg21
I0
sba(iArchitecture
Entity
p11190
(dp11191
g11
(lp11192
g11150
asg13
S'com.google.common.reflect.TypeResolver$TypeVariableKey'
p11193
sg15
(lp11194
VThe visitClass implementation in TypeResolver.populateTypeMappings has the following body:\u000a\u000a```\u000a  @Override void visitClass(Class<?> fromClass) {\u000a    // Can't map from a raw class to anything other than itself.\u000a    // You can't say "assuming String is Integer".\u000a    // And we don't support "assuming String is T"; user has to say "assuming T is String". \u000a    throw new IllegalArgumentException("No type mapping from " + fromClass);\u000a  }\u000a```\u000a\u000aIt would be great if the IllegalArgumentException message reported the type it's trying to convert to, as well as the one its converting from, for easier debugging should this exception be thrown.\u000a
p11195
asg17
(lp11196
g11155
asg19
(lp11197
g11157
asg21
I0
sba(iArchitecture
Entity
p11198
(dp11199
g11
(lp11200
g11150
asg13
S'com.google.common.reflect.TypeResolver$WildcardCapturer'
p11201
sg15
(lp11202
VThe visitClass implementation in TypeResolver.populateTypeMappings has the following body:\u000a\u000a```\u000a  @Override void visitClass(Class<?> fromClass) {\u000a    // Can't map from a raw class to anything other than itself.\u000a    // You can't say "assuming String is Integer".\u000a    // And we don't support "assuming String is T"; user has to say "assuming T is String". \u000a    throw new IllegalArgumentException("No type mapping from " + fromClass);\u000a  }\u000a```\u000a\u000aIt would be great if the IllegalArgumentException message reported the type it's trying to convert to, as well as the one its converting from, for easier debugging should this exception be thrown.\u000a
p11203
asg17
(lp11204
g11155
asg19
(lp11205
g11157
asg21
I0
sba(iArchitecture
Entity
p11206
(dp11207
g11
(lp11208
sg13
S'com.google.common.reflect.TypeToInstanceMap'
p11209
sg15
(lp11210
sg17
(lp11211
sg19
(lp11212
sg21
I0
sba(iArchitecture
Entity
p11213
(dp11214
g11
(lp11215
sg13
S'com.google.common.reflect.TypeToken'
p11216
sg15
(lp11217
sg17
(lp11218
sg19
(lp11219
sg21
I0
sba(iArchitecture
Entity
p11220
(dp11221
g11
(lp11222
sg13
S'com.google.common.reflect.TypeToken$1'
p11223
sg15
(lp11224
sg17
(lp11225
sg19
(lp11226
sg21
I0
sba(iArchitecture
Entity
p11227
(dp11228
g11
(lp11229
sg13
S'com.google.common.reflect.TypeToken$2'
p11230
sg15
(lp11231
sg17
(lp11232
sg19
(lp11233
sg21
I0
sba(iArchitecture
Entity
p11234
(dp11235
g11
(lp11236
sg13
S'com.google.common.reflect.TypeToken$3'
p11237
sg15
(lp11238
sg17
(lp11239
sg19
(lp11240
sg21
I0
sba(iArchitecture
Entity
p11241
(dp11242
g11
(lp11243
sg13
S'com.google.common.reflect.TypeToken$4'
p11244
sg15
(lp11245
sg17
(lp11246
sg19
(lp11247
sg21
I0
sba(iArchitecture
Entity
p11248
(dp11249
g11
(lp11250
sg13
S'com.google.common.reflect.TypeToken$ClassSet'
p11251
sg15
(lp11252
sg17
(lp11253
sg19
(lp11254
sg21
I0
sba(iArchitecture
Entity
p11255
(dp11256
g11
(lp11257
sg13
S'com.google.common.reflect.TypeToken$InterfaceSet'
p11258
sg15
(lp11259
sg17
(lp11260
sg19
(lp11261
sg21
I0
sba(iArchitecture
Entity
p11262
(dp11263
g11
(lp11264
sg13
S'com.google.common.reflect.TypeToken$InterfaceSet$1'
p11265
sg15
(lp11266
sg17
(lp11267
sg19
(lp11268
sg21
I0
sba(iArchitecture
Entity
p11269
(dp11270
g11
(lp11271
sg13
S'com.google.common.reflect.TypeToken$SimpleTypeToken'
p11272
sg15
(lp11273
sg17
(lp11274
sg19
(lp11275
sg21
I0
sba(iArchitecture
Entity
p11276
(dp11277
g11
(lp11278
sg13
S'com.google.common.reflect.TypeToken$TypeCollector'
p11279
sg15
(lp11280
sg17
(lp11281
sg19
(lp11282
sg21
I0
sba(iArchitecture
Entity
p11283
(dp11284
g11
(lp11285
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$1'
p11286
sg15
(lp11287
sg17
(lp11288
sg19
(lp11289
sg21
I0
sba(iArchitecture
Entity
p11290
(dp11291
g11
(lp11292
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$2'
p11293
sg15
(lp11294
sg17
(lp11295
sg19
(lp11296
sg21
I0
sba(iArchitecture
Entity
p11297
(dp11298
g11
(lp11299
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$3'
p11300
sg15
(lp11301
sg17
(lp11302
sg19
(lp11303
sg21
I0
sba(iArchitecture
Entity
p11304
(dp11305
g11
(lp11306
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$4'
p11307
sg15
(lp11308
sg17
(lp11309
sg19
(lp11310
sg21
I0
sba(iArchitecture
Entity
p11311
(dp11312
g11
(lp11313
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$ForwardingTypeCollector'
p11314
sg15
(lp11315
sg17
(lp11316
sg19
(lp11317
sg21
I0
sba(iArchitecture
Entity
p11318
(dp11319
g11
(lp11320
sg13
S'com.google.common.reflect.TypeToken$TypeFilter'
p11321
sg15
(lp11322
sg17
(lp11323
sg19
(lp11324
sg21
I0
sba(iArchitecture
Entity
p11325
(dp11326
g11
(lp11327
sg13
S'com.google.common.reflect.TypeToken$TypeFilter$1'
p11328
sg15
(lp11329
sg17
(lp11330
sg19
(lp11331
sg21
I0
sba(iArchitecture
Entity
p11332
(dp11333
g11
(lp11334
sg13
S'com.google.common.reflect.TypeToken$TypeFilter$2'
p11335
sg15
(lp11336
sg17
(lp11337
sg19
(lp11338
sg21
I0
sba(iArchitecture
Entity
p11339
(dp11340
g11
(lp11341
sg13
S'com.google.common.reflect.TypeToken$TypeSet'
p11342
sg15
(lp11343
sg17
(lp11344
sg19
(lp11345
sg21
I0
sba(iArchitecture
Entity
p11346
(dp11347
g11
(lp11348
sg13
S'com.google.common.reflect.TypeVisitor'
p11349
sg15
(lp11350
sg17
(lp11351
sg19
(lp11352
sg21
I0
sba(iArchitecture
Entity
p11353
(dp11354
g11
(lp11355
V1738
p11356
asg13
S'com.google.common.reflect.Types'
p11357
sg15
(lp11358
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11359
asg17
(lp11360
(lp11361
I7
aasg19
(lp11362
VUnable to compile on Java 8
p11363
asg21
I0
sba(iArchitecture
Entity
p11364
(dp11365
g11
(lp11366
g11356
asg13
S'com.google.common.reflect.Types$1'
p11367
sg15
(lp11368
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11369
asg17
(lp11370
g11361
asg19
(lp11371
g11363
asg21
I0
sba(iArchitecture
Entity
p11372
(dp11373
g11
(lp11374
g11356
asg13
S'com.google.common.reflect.Types$2'
p11375
sg15
(lp11376
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11377
asg17
(lp11378
g11361
asg19
(lp11379
g11363
asg21
I0
sba(iArchitecture
Entity
p11380
(dp11381
g11
(lp11382
g11356
asg13
S'com.google.common.reflect.Types$ClassOwnership'
p11383
sg15
(lp11384
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11385
asg17
(lp11386
g11361
asg19
(lp11387
g11363
asg21
I0
sba(iArchitecture
Entity
p11388
(dp11389
g11
(lp11390
g11356
asg13
S'com.google.common.reflect.Types$ClassOwnership$1'
p11391
sg15
(lp11392
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11393
asg17
(lp11394
g11361
asg19
(lp11395
g11363
asg21
I0
sba(iArchitecture
Entity
p11396
(dp11397
g11
(lp11398
g11356
asg13
S'com.google.common.reflect.Types$ClassOwnership$1LocalClass'
p11399
sg15
(lp11400
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11401
asg17
(lp11402
g11361
asg19
(lp11403
g11363
asg21
I0
sba(iArchitecture
Entity
p11404
(dp11405
g11
(lp11406
g11356
asg13
S'com.google.common.reflect.Types$ClassOwnership$2'
p11407
sg15
(lp11408
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11409
asg17
(lp11410
g11361
asg19
(lp11411
g11363
asg21
I0
sba(iArchitecture
Entity
p11412
(dp11413
g11
(lp11414
g11356
asg13
S'com.google.common.reflect.Types$ClassOwnership$3'
p11415
sg15
(lp11416
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11417
asg17
(lp11418
g11361
asg19
(lp11419
g11363
asg21
I0
sba(iArchitecture
Entity
p11420
(dp11421
g11
(lp11422
g11356
asg13
S'com.google.common.reflect.Types$GenericArrayTypeImpl'
p11423
sg15
(lp11424
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11425
asg17
(lp11426
g11361
asg19
(lp11427
g11363
asg21
I0
sba(iArchitecture
Entity
p11428
(dp11429
g11
(lp11430
g11356
asg13
S'com.google.common.reflect.Types$JavaVersion'
p11431
sg15
(lp11432
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11433
asg17
(lp11434
g11361
asg19
(lp11435
g11363
asg21
I0
sba(iArchitecture
Entity
p11436
(dp11437
g11
(lp11438
g11356
asg13
S'com.google.common.reflect.Types$JavaVersion$1'
p11439
sg15
(lp11440
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11441
asg17
(lp11442
g11361
asg19
(lp11443
g11363
asg21
I0
sba(iArchitecture
Entity
p11444
(dp11445
g11
(lp11446
g11356
asg13
S'com.google.common.reflect.Types$JavaVersion$2'
p11447
sg15
(lp11448
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11449
asg17
(lp11450
g11361
asg19
(lp11451
g11363
asg21
I0
sba(iArchitecture
Entity
p11452
(dp11453
g11
(lp11454
g11356
asg13
S'com.google.common.reflect.Types$JavaVersion$3'
p11455
sg15
(lp11456
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11457
asg17
(lp11458
g11361
asg19
(lp11459
g11363
asg21
I0
sba(iArchitecture
Entity
p11460
(dp11461
g11
(lp11462
g11356
asg13
S'com.google.common.reflect.Types$JavaVersion$4'
p11463
sg15
(lp11464
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11465
asg17
(lp11466
g11361
asg19
(lp11467
g11363
asg21
I0
sba(iArchitecture
Entity
p11468
(dp11469
g11
(lp11470
g11356
asg13
S'com.google.common.reflect.Types$NativeTypeVariableEquals'
p11471
sg15
(lp11472
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11473
asg17
(lp11474
g11361
asg19
(lp11475
g11363
asg21
I0
sba(iArchitecture
Entity
p11476
(dp11477
g11
(lp11478
g11356
asg13
S'com.google.common.reflect.Types$ParameterizedTypeImpl'
p11479
sg15
(lp11480
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11481
asg17
(lp11482
g11361
asg19
(lp11483
g11363
asg21
I0
sba(iArchitecture
Entity
p11484
(dp11485
g11
(lp11486
g11356
asg13
S'com.google.common.reflect.Types$TypeVariableImpl'
p11487
sg15
(lp11488
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11489
asg17
(lp11490
g11361
asg19
(lp11491
g11363
asg21
I0
sba(iArchitecture
Entity
p11492
(dp11493
g11
(lp11494
g11356
asg13
S'com.google.common.reflect.Types$TypeVariableInvocationHandler'
p11495
sg15
(lp11496
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11497
asg17
(lp11498
g11361
asg19
(lp11499
g11363
asg21
I0
sba(iArchitecture
Entity
p11500
(dp11501
g11
(lp11502
g11356
asg13
S'com.google.common.reflect.Types$WildcardTypeImpl'
p11503
sg15
(lp11504
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\u000a\u000a---\u000a\u000aApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\u000a
p11505
asg17
(lp11506
g11361
asg19
(lp11507
g11363
asg21
I0
sbasg1135
(lp11508
g10964
ag10971
ag10978
ag10986
ag10997
ag11006
ag11015
ag11024
ag11033
ag11041
ag11048
ag11055
ag11062
ag11070
ag11078
ag11086
ag11093
ag11100
ag11107
ag11114
ag11121
ag11129
ag11136
ag11143
ag11151
ag11161
ag11169
ag11177
ag11185
ag11193
ag11201
ag11209
ag11216
ag11223
ag11230
ag11237
ag11244
ag11251
ag11258
ag11265
ag11272
ag11279
ag11286
ag11293
ag11300
ag11307
ag11314
ag11321
ag11328
ag11335
ag11342
ag11349
ag11357
ag11367
ag11375
ag11383
ag11391
ag11399
ag11407
ag11415
ag11423
ag11431
ag11439
ag11447
ag11455
ag11463
ag11471
ag11479
ag11487
ag11495
ag11503
asg1137
I0
sg21
I0
sg1138
S'com.google.common.reflect.ss'
p11509
sba(iArchitecture
Cluster
p11510
(dp11511
g7
(lp11512
(iArchitecture
Entity
p11513
(dp11514
g11
(lp11515
sg13
S'com.google.common.base.Supplier'
p11516
sg15
(lp11517
sg17
(lp11518
sg19
(lp11519
sg21
I0
sba(iArchitecture
Entity
p11520
(dp11521
g11
(lp11522
V2457
p11523
ag11523
ag11523
asg13
S'com.google.common.base.Throwables'
p11524
sg15
(lp11525
V
p11526
ag11526
ag11526
asg17
(lp11527
(lp11528
I0
aag11528
ag11528
asg19
(lp11529
VEmulate Throwables in GWT
p11530
ag11530
ag11530
asg21
I0
sba(iArchitecture
Entity
p11531
(dp11532
g11
(lp11533
sg13
S'com.google.common.collect.ForwardingObject'
p11534
sg15
(lp11535
sg17
(lp11536
sg19
(lp11537
sg21
I0
sba(iArchitecture
Entity
p11538
(dp11539
g11
(lp11540
sg13
S'com.google.common.collect.Queues'
p11541
sg15
(lp11542
sg17
(lp11543
sg19
(lp11544
sg21
I0
sba(iArchitecture
Entity
p11545
(dp11546
g11
(lp11547
sg13
S'com.google.common.util.concurrent.AbstractCheckedFuture'
p11548
sg15
(lp11549
sg17
(lp11550
sg19
(lp11551
sg21
I0
sba(iArchitecture
Entity
p11552
(dp11553
g11
(lp11554
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService'
p11555
sg15
(lp11556
sg17
(lp11557
sg19
(lp11558
sg21
I0
sba(iArchitecture
Entity
p11559
(dp11560
g11
(lp11561
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$1'
p11562
sg15
(lp11563
sg17
(lp11564
sg19
(lp11565
sg21
I0
sba(iArchitecture
Entity
p11566
(dp11567
g11
(lp11568
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$1$1'
p11569
sg15
(lp11570
sg17
(lp11571
sg19
(lp11572
sg21
I0
sba(iArchitecture
Entity
p11573
(dp11574
g11
(lp11575
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$1$2'
p11576
sg15
(lp11577
sg17
(lp11578
sg19
(lp11579
sg21
I0
sba(iArchitecture
Entity
p11580
(dp11581
g11
(lp11582
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$2'
p11583
sg15
(lp11584
sg17
(lp11585
sg19
(lp11586
sg21
I0
sba(iArchitecture
Entity
p11587
(dp11588
g11
(lp11589
g25
aV1961
p11590
asg13
S'com.google.common.util.concurrent.AbstractFuture'
p11591
sg15
(lp11592
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11593
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p11594
asg17
(lp11595
g32
a(lp11596
I0
aasg19
(lp11597
g35
aVMake immediateFailedFuture and immediateCancelledFuture return a TrustedFuture?
p11598
asg21
I0
sba(iArchitecture
Entity
p11599
(dp11600
g11
(lp11601
g25
ag11590
asg13
S'com.google.common.util.concurrent.AbstractFuture$Sync'
p11602
sg15
(lp11603
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11604
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p11605
asg17
(lp11606
g32
ag11596
asg19
(lp11607
g35
ag11598
asg21
I0
sba(iArchitecture
Entity
p11608
(dp11609
g11
(lp11610
sg13
S'com.google.common.util.concurrent.AbstractIdleService'
p11611
sg15
(lp11612
sg17
(lp11613
sg19
(lp11614
sg21
I0
sba(iArchitecture
Entity
p11615
(dp11616
g11
(lp11617
sg13
S'com.google.common.util.concurrent.AbstractIdleService$1'
p11618
sg15
(lp11619
sg17
(lp11620
sg19
(lp11621
sg21
I0
sba(iArchitecture
Entity
p11622
(dp11623
g11
(lp11624
sg13
S'com.google.common.util.concurrent.AbstractIdleService$2'
p11625
sg15
(lp11626
sg17
(lp11627
sg19
(lp11628
sg21
I0
sba(iArchitecture
Entity
p11629
(dp11630
g11
(lp11631
sg13
S'com.google.common.util.concurrent.AbstractIdleService$2$1'
p11632
sg15
(lp11633
sg17
(lp11634
sg19
(lp11635
sg21
I0
sba(iArchitecture
Entity
p11636
(dp11637
g11
(lp11638
sg13
S'com.google.common.util.concurrent.AbstractIdleService$2$2'
p11639
sg15
(lp11640
sg17
(lp11641
sg19
(lp11642
sg21
I0
sba(iArchitecture
Entity
p11643
(dp11644
g11
(lp11645
sg13
S'com.google.common.util.concurrent.AbstractIdleService$3'
p11646
sg15
(lp11647
sg17
(lp11648
sg19
(lp11649
sg21
I0
sba(iArchitecture
Entity
p11650
(dp11651
g11
(lp11652
sg13
S'com.google.common.util.concurrent.AbstractListeningExecutorService'
p11653
sg15
(lp11654
sg17
(lp11655
sg19
(lp11656
sg21
I0
sba(iArchitecture
Entity
p11657
(dp11658
g11
(lp11659
V2072
p11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService'
p11661
sg15
(lp11662
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11663
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11664
asg17
(lp11665
(lp11666
I1
aag11666
asg19
(lp11667
VDeadlock when stopping an AbstractScheduledService and Exception thrown from CustomScheduler.getNextSchedule()
p11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11669
(dp11670
g11
(lp11671
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$1'
p11672
sg15
(lp11673
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11674
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11675
asg17
(lp11676
g11666
ag11666
asg19
(lp11677
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11678
(dp11679
g11
(lp11680
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$1$1'
p11681
sg15
(lp11682
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11683
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11684
asg17
(lp11685
g11666
ag11666
asg19
(lp11686
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11687
(dp11688
g11
(lp11689
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$1$2'
p11690
sg15
(lp11691
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11692
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11693
asg17
(lp11694
g11666
ag11666
asg19
(lp11695
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11696
(dp11697
g11
(lp11698
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$1$3'
p11699
sg15
(lp11700
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11701
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11702
asg17
(lp11703
g11666
ag11666
asg19
(lp11704
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11705
(dp11706
g11
(lp11707
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$1$4'
p11708
sg15
(lp11709
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11710
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11711
asg17
(lp11712
g11666
ag11666
asg19
(lp11713
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11714
(dp11715
g11
(lp11716
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$2'
p11717
sg15
(lp11718
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11719
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11720
asg17
(lp11721
g11666
ag11666
asg19
(lp11722
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11723
(dp11724
g11
(lp11725
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$3'
p11726
sg15
(lp11727
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11728
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11729
asg17
(lp11730
g11666
ag11666
asg19
(lp11731
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11732
(dp11733
g11
(lp11734
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$CustomScheduler'
p11735
sg15
(lp11736
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11737
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11738
asg17
(lp11739
g11666
ag11666
asg19
(lp11740
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11741
(dp11742
g11
(lp11743
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$CustomScheduler$ReschedulableCallable'
p11744
sg15
(lp11745
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11746
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11747
asg17
(lp11748
g11666
ag11666
asg19
(lp11749
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11750
(dp11751
g11
(lp11752
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$CustomScheduler$Schedule'
p11753
sg15
(lp11754
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11755
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11756
asg17
(lp11757
g11666
ag11666
asg19
(lp11758
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11759
(dp11760
g11
(lp11761
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$Scheduler'
p11762
sg15
(lp11763
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11764
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11765
asg17
(lp11766
g11666
ag11666
asg19
(lp11767
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11768
(dp11769
g11
(lp11770
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$Scheduler$1'
p11771
sg15
(lp11772
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11773
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11774
asg17
(lp11775
g11666
ag11666
asg19
(lp11776
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11777
(dp11778
g11
(lp11779
g11660
ag11660
asg13
S'com.google.common.util.concurrent.AbstractScheduledService$Scheduler$2'
p11780
sg15
(lp11781
V(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11782
aV(Source attached below which demonstrates the issue).\u000aI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \u000aThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\u000a\u000aI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\u000a\u000a``` java\u000apublic class Main {\u000a    public static void main(String[] args) throws Exception {\u000a        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\u000a        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\u000a        System.out.println("starting service");\u000a        service.startAsync();\u000a        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\u000a        System.out.println("Stopping service");\u000a        service.stopAsync();\u000a        System.out.println("Bye");\u000a      }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\u000a    private long blockTime;\u000a\u000a    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\u000a        this.blockTime = blockTime;\u000a    }\u000a\u000a    @Override\u000a    protected void runOneIteration() throws Exception {\u000a        System.out.println("runOneIteration()");\u000a    }\u000a\u000a    @Override\u000a    protected Scheduler scheduler() {\u000a        return new CustomScheduler() {\u000a            @Override\u000a            protected Schedule getNextSchedule() throws Exception {\u000a                System.out.println("getNextSchedule()...");\u000a                Thread.sleep(blockTime);\u000a                if (state() == State.STOPPING) {\u000a                    System.out.println("getNextSchedule() - not running anymore so don't return scheduler");\u000a                    throw new Exception("not running anymore so don't return scheduler");\u000a                }\u000a                System.out.println("...getNextSchedule()");\u000a                return new Schedule(0, TimeUnit.NANOSECONDS);\u000a            }\u000a        };\u000a    }\u000a\u000a    @Override\u000a    protected void startUp() throws Exception {\u000a        System.out.println("startUp()");\u000a    }\u000a\u000a    @Override\u000a    protected void shutDown() throws Exception {\u000a        System.out.println("shutDown()");\u000a    }\u000a}\u000a```\u000a\u000a``` java\u000apublic class ServiceStateMonitor {\u000a    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\u000a        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\u000a    }\u000a\u000a    private class PrintOutNewStateServiceListener extends Service.Listener {\u000a        @Override\u000a        public void starting() {\u000a            System.out.println("SERVICE LISTENER : Starting");\u000a        }\u000a\u000a        @Override\u000a        public void running() {\u000a            System.out.println("SERVICE LISTENER : Running");\u000a        }\u000a\u000a        @Override\u000a        public void stopping(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Stopping");\u000a        }\u000a\u000a        @Override\u000a        public void terminated(final Service.State from) {\u000a            System.out.println("SERVICE LISTENER : Terminated");\u000a        }\u000a\u000a        @Override\u000a        public void failed(final Service.State from, final Throwable failure) {\u000a            System.out.println("SERVICE LISTENER : Failed");\u000a        }\u000a    }\u000a}\u000a```\u000a\u000aThe Standard Ouput from running the main()\u000a\u000a```\u000astarting service\u000aSERVICE LISTENER : Starting\u000astartUp()\u000agetNextSchedule()...\u000a...getNextSchedule()\u000aSERVICE LISTENER : Running\u000arunOneIteration()\u000agetNextSchedule()...\u000aStopping service\u000agetNextSchedule() - not running anymore so don't return scheduler\u000a```\u000a\u000anotice that there is no "shutDown()" or "Bye" output line.\u000a
p11783
asg17
(lp11784
g11666
ag11666
asg19
(lp11785
g11668
ag11668
asg21
I0
sba(iArchitecture
Entity
p11786
(dp11787
g11
(lp11788
sg13
S'com.google.common.util.concurrent.AbstractService'
p11789
sg15
(lp11790
sg17
(lp11791
sg19
(lp11792
sg21
I0
sba(iArchitecture
Entity
p11793
(dp11794
g11
(lp11795
sg13
S'com.google.common.util.concurrent.AbstractService$1'
p11796
sg15
(lp11797
sg17
(lp11798
sg19
(lp11799
sg21
I0
sba(iArchitecture
Entity
p11800
(dp11801
g11
(lp11802
sg13
S'com.google.common.util.concurrent.AbstractService$10'
p11803
sg15
(lp11804
sg17
(lp11805
sg19
(lp11806
sg21
I0
sba(iArchitecture
Entity
p11807
(dp11808
g11
(lp11809
sg13
S'com.google.common.util.concurrent.AbstractService$2'
p11810
sg15
(lp11811
sg17
(lp11812
sg19
(lp11813
sg21
I0
sba(iArchitecture
Entity
p11814
(dp11815
g11
(lp11816
sg13
S'com.google.common.util.concurrent.AbstractService$3'
p11817
sg15
(lp11818
sg17
(lp11819
sg19
(lp11820
sg21
I0
sba(iArchitecture
Entity
p11821
(dp11822
g11
(lp11823
sg13
S'com.google.common.util.concurrent.AbstractService$4'
p11824
sg15
(lp11825
sg17
(lp11826
sg19
(lp11827
sg21
I0
sba(iArchitecture
Entity
p11828
(dp11829
g11
(lp11830
sg13
S'com.google.common.util.concurrent.AbstractService$5'
p11831
sg15
(lp11832
sg17
(lp11833
sg19
(lp11834
sg21
I0
sba(iArchitecture
Entity
p11835
(dp11836
g11
(lp11837
sg13
S'com.google.common.util.concurrent.AbstractService$6'
p11838
sg15
(lp11839
sg17
(lp11840
sg19
(lp11841
sg21
I0
sba(iArchitecture
Entity
p11842
(dp11843
g11
(lp11844
sg13
S'com.google.common.util.concurrent.AbstractService$7'
p11845
sg15
(lp11846
sg17
(lp11847
sg19
(lp11848
sg21
I0
sba(iArchitecture
Entity
p11849
(dp11850
g11
(lp11851
sg13
S'com.google.common.util.concurrent.AbstractService$8'
p11852
sg15
(lp11853
sg17
(lp11854
sg19
(lp11855
sg21
I0
sba(iArchitecture
Entity
p11856
(dp11857
g11
(lp11858
sg13
S'com.google.common.util.concurrent.AbstractService$9'
p11859
sg15
(lp11860
sg17
(lp11861
sg19
(lp11862
sg21
I0
sba(iArchitecture
Entity
p11863
(dp11864
g11
(lp11865
sg13
S'com.google.common.util.concurrent.AbstractService$StateSnapshot'
p11866
sg15
(lp11867
sg17
(lp11868
sg19
(lp11869
sg21
I0
sba(iArchitecture
Entity
p11870
(dp11871
g11
(lp11872
sg13
S'com.google.common.util.concurrent.AsyncFunction'
p11873
sg15
(lp11874
sg17
(lp11875
sg19
(lp11876
sg21
I0
sba(iArchitecture
Entity
p11877
(dp11878
g11
(lp11879
sg13
S'com.google.common.util.concurrent.AsyncSettableFuture'
p11880
sg15
(lp11881
sg17
(lp11882
sg19
(lp11883
sg21
I0
sba(iArchitecture
Entity
p11884
(dp11885
g11
(lp11886
sg13
S'com.google.common.util.concurrent.AsyncSettableFuture$1'
p11887
sg15
(lp11888
sg17
(lp11889
sg19
(lp11890
sg21
I0
sba(iArchitecture
Entity
p11891
(dp11892
g11
(lp11893
sg13
S'com.google.common.util.concurrent.AsyncSettableFuture$NestedFuture'
p11894
sg15
(lp11895
sg17
(lp11896
sg19
(lp11897
sg21
I0
sba(iArchitecture
Entity
p11898
(dp11899
g11
(lp11900
sg13
S'com.google.common.util.concurrent.AtomicLongMap'
p11901
sg15
(lp11902
sg17
(lp11903
sg19
(lp11904
sg21
I0
sba(iArchitecture
Entity
p11905
(dp11906
g11
(lp11907
sg13
S'com.google.common.util.concurrent.AtomicLongMap$1'
p11908
sg15
(lp11909
sg17
(lp11910
sg19
(lp11911
sg21
I0
sba(iArchitecture
Entity
p11912
(dp11913
g11
(lp11914
sg13
S'com.google.common.util.concurrent.Callables'
p11915
sg15
(lp11916
sg17
(lp11917
sg19
(lp11918
sg21
I0
sba(iArchitecture
Entity
p11919
(dp11920
g11
(lp11921
sg13
S'com.google.common.util.concurrent.Callables$1'
p11922
sg15
(lp11923
sg17
(lp11924
sg19
(lp11925
sg21
I0
sba(iArchitecture
Entity
p11926
(dp11927
g11
(lp11928
sg13
S'com.google.common.util.concurrent.Callables$2'
p11929
sg15
(lp11930
sg17
(lp11931
sg19
(lp11932
sg21
I0
sba(iArchitecture
Entity
p11933
(dp11934
g11
(lp11935
sg13
S'com.google.common.util.concurrent.Callables$3'
p11936
sg15
(lp11937
sg17
(lp11938
sg19
(lp11939
sg21
I0
sba(iArchitecture
Entity
p11940
(dp11941
g11
(lp11942
sg13
S'com.google.common.util.concurrent.CheckedFuture'
p11943
sg15
(lp11944
sg17
(lp11945
sg19
(lp11946
sg21
I0
sba(iArchitecture
Entity
p11947
(dp11948
g11
(lp11949
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory'
p11950
sg15
(lp11951
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11952
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11953
asg17
(lp11954
g32
ag32
asg19
(lp11955
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p11956
(dp11957
g11
(lp11958
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$1'
p11959
sg15
(lp11960
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11961
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11962
asg17
(lp11963
g32
ag32
asg19
(lp11964
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p11965
(dp11966
g11
(lp11967
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingLock'
p11968
sg15
(lp11969
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11970
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11971
asg17
(lp11972
g32
ag32
asg19
(lp11973
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p11974
(dp11975
g11
(lp11976
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantLock'
p11977
sg15
(lp11978
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11979
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11980
asg17
(lp11981
g32
ag32
asg19
(lp11982
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p11983
(dp11984
g11
(lp11985
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantReadLock'
p11986
sg15
(lp11987
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11988
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11989
asg17
(lp11990
g32
ag32
asg19
(lp11991
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p11992
(dp11993
g11
(lp11994
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantReadWriteLock'
p11995
sg15
(lp11996
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11997
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p11998
asg17
(lp11999
g32
ag32
asg19
(lp12000
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12001
(dp12002
g11
(lp12003
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantWriteLock'
p12004
sg15
(lp12005
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12006
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12007
asg17
(lp12008
g32
ag32
asg19
(lp12009
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12010
(dp12011
g11
(lp12012
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$ExampleStackTrace'
p12013
sg15
(lp12014
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12015
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12016
asg17
(lp12017
g32
ag32
asg19
(lp12018
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12019
(dp12020
g11
(lp12021
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$LockGraphNode'
p12022
sg15
(lp12023
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12024
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12025
asg17
(lp12026
g32
ag32
asg19
(lp12027
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12028
(dp12029
g11
(lp12030
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies'
p12031
sg15
(lp12032
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12033
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12034
asg17
(lp12035
g32
ag32
asg19
(lp12036
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12037
(dp12038
g11
(lp12039
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies$1'
p12040
sg15
(lp12041
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12042
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12043
asg17
(lp12044
g32
ag32
asg19
(lp12045
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12046
(dp12047
g11
(lp12048
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies$2'
p12049
sg15
(lp12050
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12051
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12052
asg17
(lp12053
g32
ag32
asg19
(lp12054
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12055
(dp12056
g11
(lp12057
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies$3'
p12058
sg15
(lp12059
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12060
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12061
asg17
(lp12062
g32
ag32
asg19
(lp12063
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12064
(dp12065
g11
(lp12066
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policy'
p12067
sg15
(lp12068
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12069
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12070
asg17
(lp12071
g32
ag32
asg19
(lp12072
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12073
(dp12074
g11
(lp12075
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$PotentialDeadlockException'
p12076
sg15
(lp12077
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12078
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12079
asg17
(lp12080
g32
ag32
asg19
(lp12081
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12082
(dp12083
g11
(lp12084
g25
ag25
asg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$WithExplicitOrdering'
p12085
sg15
(lp12086
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12087
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12088
asg17
(lp12089
g32
ag32
asg19
(lp12090
g35
ag35
asg21
I0
sba(iArchitecture
Entity
p12091
(dp12092
g11
(lp12093
sg13
S'com.google.common.util.concurrent.ExecutionError'
p12094
sg15
(lp12095
sg17
(lp12096
sg19
(lp12097
sg21
I0
sba(iArchitecture
Entity
p12098
(dp12099
g11
(lp12100
sg13
S'com.google.common.util.concurrent.ExecutionList'
p12101
sg15
(lp12102
sg17
(lp12103
sg19
(lp12104
sg21
I0
sba(iArchitecture
Entity
p12105
(dp12106
g11
(lp12107
sg13
S'com.google.common.util.concurrent.ExecutionList$RunnableExecutorPair'
p12108
sg15
(lp12109
sg17
(lp12110
sg19
(lp12111
sg21
I0
sba(iArchitecture
Entity
p12112
(dp12113
g11
(lp12114
sg13
S'com.google.common.util.concurrent.ForwardingCheckedFuture'
p12115
sg15
(lp12116
sg17
(lp12117
sg19
(lp12118
sg21
I0
sba(iArchitecture
Entity
p12119
(dp12120
g11
(lp12121
sg13
S'com.google.common.util.concurrent.ForwardingCheckedFuture$SimpleForwardingCheckedFuture'
p12122
sg15
(lp12123
sg17
(lp12124
sg19
(lp12125
sg21
I0
sba(iArchitecture
Entity
p12126
(dp12127
g11
(lp12128
sg13
S'com.google.common.util.concurrent.ForwardingExecutorService'
p12129
sg15
(lp12130
sg17
(lp12131
sg19
(lp12132
sg21
I0
sba(iArchitecture
Entity
p12133
(dp12134
g11
(lp12135
sg13
S'com.google.common.util.concurrent.ForwardingFuture'
p12136
sg15
(lp12137
sg17
(lp12138
sg19
(lp12139
sg21
I0
sba(iArchitecture
Entity
p12140
(dp12141
g11
(lp12142
sg13
S'com.google.common.util.concurrent.ForwardingFuture$SimpleForwardingFuture'
p12143
sg15
(lp12144
sg17
(lp12145
sg19
(lp12146
sg21
I0
sba(iArchitecture
Entity
p12147
(dp12148
g11
(lp12149
sg13
S'com.google.common.util.concurrent.ForwardingListenableFuture'
p12150
sg15
(lp12151
sg17
(lp12152
sg19
(lp12153
sg21
I0
sba(iArchitecture
Entity
p12154
(dp12155
g11
(lp12156
sg13
S'com.google.common.util.concurrent.ForwardingListenableFuture$SimpleForwardingListenableFuture'
p12157
sg15
(lp12158
sg17
(lp12159
sg19
(lp12160
sg21
I0
sba(iArchitecture
Entity
p12161
(dp12162
g11
(lp12163
sg13
S'com.google.common.util.concurrent.ForwardingListeningExecutorService'
p12164
sg15
(lp12165
sg17
(lp12166
sg19
(lp12167
sg21
I0
sba(iArchitecture
Entity
p12168
(dp12169
g11
(lp12170
sg13
S'com.google.common.util.concurrent.FutureCallback'
p12171
sg15
(lp12172
sg17
(lp12173
sg19
(lp12174
sg21
I0
sba(iArchitecture
Entity
p12175
(dp12176
g11
(lp12177
sg13
S'com.google.common.util.concurrent.FutureFallback'
p12178
sg15
(lp12179
sg17
(lp12180
sg19
(lp12181
sg21
I0
sba(iArchitecture
Entity
p12182
(dp12183
g11
(lp12184
g11590
ag11590
aV1999
p12185
aV2463
p12186
aV2379
p12187
aV2254
p12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures'
p12189
sg15
(lp12190
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12191
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12192
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12193
aVWe already do in `AbstractFuture`.\u000a
p12194
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12195
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12196
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12197
asg17
(lp12198
g11596
ag11596
a(lp12199
I7
aa(lp12200
I1
aa(lp12201
I2
aa(lp12202
I1
aag12202
asg19
(lp12203
g11598
ag11598
aVRelease a Guava that supports+requires GWT 2.8.0 upon GWT release
p12204
aVWork around Samsung 5.0.x Atomic*FieldUpdater bug in AggregateFutureState and InterruptibleTask
p12205
aVBetter documentation of Futures.catching GWT availability
p12206
aVNesting Futures.transform() eats StackOverflowError and causes the Future to hang forever
p12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12208
(dp12209
g11
(lp12210
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$1'
p12211
sg15
(lp12212
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12213
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12214
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12215
aVWe already do in `AbstractFuture`.\u000a
p12216
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12217
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12218
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12219
asg17
(lp12220
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12221
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12222
(dp12223
g11
(lp12224
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$1$1'
p12225
sg15
(lp12226
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12227
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12228
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12229
aVWe already do in `AbstractFuture`.\u000a
p12230
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12231
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12232
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12233
asg17
(lp12234
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12235
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12236
(dp12237
g11
(lp12238
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$2'
p12239
sg15
(lp12240
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12241
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12242
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12243
aVWe already do in `AbstractFuture`.\u000a
p12244
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12245
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12246
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12247
asg17
(lp12248
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12249
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12250
(dp12251
g11
(lp12252
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$3'
p12253
sg15
(lp12254
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12255
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12256
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12257
aVWe already do in `AbstractFuture`.\u000a
p12258
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12259
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12260
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12261
asg17
(lp12262
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12263
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12264
(dp12265
g11
(lp12266
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$4'
p12267
sg15
(lp12268
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12269
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12270
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12271
aVWe already do in `AbstractFuture`.\u000a
p12272
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12273
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12274
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12275
asg17
(lp12276
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12277
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12278
(dp12279
g11
(lp12280
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$5'
p12281
sg15
(lp12282
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12283
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12284
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12285
aVWe already do in `AbstractFuture`.\u000a
p12286
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12287
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12288
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12289
asg17
(lp12290
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12291
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12292
(dp12293
g11
(lp12294
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$6'
p12295
sg15
(lp12296
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12297
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12298
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12299
aVWe already do in `AbstractFuture`.\u000a
p12300
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12301
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12302
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12303
asg17
(lp12304
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12305
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12306
(dp12307
g11
(lp12308
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$7'
p12309
sg15
(lp12310
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12311
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12312
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12313
aVWe already do in `AbstractFuture`.\u000a
p12314
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12315
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12316
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12317
asg17
(lp12318
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12319
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12320
(dp12321
g11
(lp12322
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$8'
p12323
sg15
(lp12324
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12325
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12326
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12327
aVWe already do in `AbstractFuture`.\u000a
p12328
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12329
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12330
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12331
asg17
(lp12332
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12333
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12334
(dp12335
g11
(lp12336
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$ChainingListenableFuture'
p12337
sg15
(lp12338
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12339
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12340
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12341
aVWe already do in `AbstractFuture`.\u000a
p12342
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12343
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12344
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12345
asg17
(lp12346
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12347
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12348
(dp12349
g11
(lp12350
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$ChainingListenableFuture$1'
p12351
sg15
(lp12352
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12353
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12354
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12355
aVWe already do in `AbstractFuture`.\u000a
p12356
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12357
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12358
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12359
asg17
(lp12360
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12361
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12362
(dp12363
g11
(lp12364
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$CombinedFuture'
p12365
sg15
(lp12366
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12367
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12368
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12369
aVWe already do in `AbstractFuture`.\u000a
p12370
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12371
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12372
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12373
asg17
(lp12374
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12375
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12376
(dp12377
g11
(lp12378
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$CombinedFuture$1'
p12379
sg15
(lp12380
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12381
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12382
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12383
aVWe already do in `AbstractFuture`.\u000a
p12384
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12385
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12386
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12387
asg17
(lp12388
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12389
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12390
(dp12391
g11
(lp12392
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$CombinedFuture$2'
p12393
sg15
(lp12394
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12395
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12396
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12397
aVWe already do in `AbstractFuture`.\u000a
p12398
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12399
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12400
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12401
asg17
(lp12402
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12403
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12404
(dp12405
g11
(lp12406
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$CombinerFuture'
p12407
sg15
(lp12408
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12409
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12410
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12411
aVWe already do in `AbstractFuture`.\u000a
p12412
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12413
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12414
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12415
asg17
(lp12416
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12417
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12418
(dp12419
g11
(lp12420
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$FallbackFuture'
p12421
sg15
(lp12422
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12423
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12424
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12425
aVWe already do in `AbstractFuture`.\u000a
p12426
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12427
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12428
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12429
asg17
(lp12430
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12431
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12432
(dp12433
g11
(lp12434
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$FallbackFuture$1'
p12435
sg15
(lp12436
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12437
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12438
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12439
aVWe already do in `AbstractFuture`.\u000a
p12440
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12441
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12442
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12443
asg17
(lp12444
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12445
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12446
(dp12447
g11
(lp12448
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$FallbackFuture$1$1'
p12449
sg15
(lp12450
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12451
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12452
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12453
aVWe already do in `AbstractFuture`.\u000a
p12454
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12455
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12456
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12457
asg17
(lp12458
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12459
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12460
(dp12461
g11
(lp12462
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$FutureCombiner'
p12463
sg15
(lp12464
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12465
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12466
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12467
aVWe already do in `AbstractFuture`.\u000a
p12468
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12469
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12470
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12471
asg17
(lp12472
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12473
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12474
(dp12475
g11
(lp12476
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$ImmediateCancelledFuture'
p12477
sg15
(lp12478
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12479
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12480
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12481
aVWe already do in `AbstractFuture`.\u000a
p12482
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12483
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12484
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12485
asg17
(lp12486
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12487
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12488
(dp12489
g11
(lp12490
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$ImmediateFailedCheckedFuture'
p12491
sg15
(lp12492
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12493
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12494
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12495
aVWe already do in `AbstractFuture`.\u000a
p12496
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12497
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12498
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12499
asg17
(lp12500
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12501
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12502
(dp12503
g11
(lp12504
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$ImmediateFailedFuture'
p12505
sg15
(lp12506
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12507
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12508
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12509
aVWe already do in `AbstractFuture`.\u000a
p12510
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12511
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12512
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12513
asg17
(lp12514
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12515
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12516
(dp12517
g11
(lp12518
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$ImmediateFuture'
p12519
sg15
(lp12520
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12521
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12522
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12523
aVWe already do in `AbstractFuture`.\u000a
p12524
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12525
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12526
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12527
asg17
(lp12528
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12529
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12530
(dp12531
g11
(lp12532
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$ImmediateSuccessfulCheckedFuture'
p12533
sg15
(lp12534
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12535
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12536
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12537
aVWe already do in `AbstractFuture`.\u000a
p12538
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12539
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12540
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12541
asg17
(lp12542
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12543
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12544
(dp12545
g11
(lp12546
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$ImmediateSuccessfulFuture'
p12547
sg15
(lp12548
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12549
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12550
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12551
aVWe already do in `AbstractFuture`.\u000a
p12552
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12553
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12554
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12555
asg17
(lp12556
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12557
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12558
(dp12559
g11
(lp12560
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$MappingCheckedFuture'
p12561
sg15
(lp12562
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12563
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12564
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12565
aVWe already do in `AbstractFuture`.\u000a
p12566
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12567
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12568
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12569
asg17
(lp12570
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12571
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12572
(dp12573
g11
(lp12574
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$NonCancellationPropagatingFuture'
p12575
sg15
(lp12576
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12577
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12578
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12579
aVWe already do in `AbstractFuture`.\u000a
p12580
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12581
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12582
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12583
asg17
(lp12584
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12585
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12586
(dp12587
g11
(lp12588
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$NonCancellationPropagatingFuture$1'
p12589
sg15
(lp12590
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12591
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12592
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12593
aVWe already do in `AbstractFuture`.\u000a
p12594
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12595
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12596
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12597
asg17
(lp12598
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12599
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12600
(dp12601
g11
(lp12602
g11590
ag11590
ag12185
ag12186
ag12187
ag12188
ag12188
asg13
S'com.google.common.util.concurrent.Futures$WrappedCombiner'
p12603
sg15
(lp12604
VOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12605
aVOn the theory that most things should be a `TrustedFuture` :)\u000a\u000aWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\u000a\u000aBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters ("would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding)," per Luke).\u000a\u000aWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\u000a\u000aAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\u000a
p12606
aV- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\u000a- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\u000a- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\u000a- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\u000a\u000aGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\u000a
p12607
aVWe already do in `AbstractFuture`.\u000a
p12608
aVPreviously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\u000a\u000aFurthermore, even _with_ the reason, I saw multiple people who were confused.\u000a\u000aThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\u000a
p12609
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12610
aVHey!\u000aI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \u000a\u000a``` java\u000a  static final int REPS = 10000;\u000a  @Test\u000a  public void hangs() throws InterruptedException, TimeoutException {\u000a    SettableFuture<Integer> settableFuture = SettableFuture.create();\u000a    ListenableFuture<Integer> chained = settableFuture;\u000a    for (int i = 0; i < REPS; ++i) {\u000a      chained = Futures.transform(chained, Functions.<Integer>identity());\u000a    }\u000a    settableFuture.set(0);\u000a\u000a    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\u000a  }\u000a```\u000a\u000aBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\u000a\u000aMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\u000a
p12611
asg17
(lp12612
g11596
ag11596
ag12199
ag12200
ag12201
ag12202
ag12202
asg19
(lp12613
g11598
ag11598
ag12204
ag12205
ag12206
ag12207
ag12207
asg21
I0
sba(iArchitecture
Entity
p12614
(dp12615
g11
(lp12616
sg13
S'com.google.common.util.concurrent.JdkFutureAdapters'
p12617
sg15
(lp12618
sg17
(lp12619
sg19
(lp12620
sg21
I0
sba(iArchitecture
Entity
p12621
(dp12622
g11
(lp12623
sg13
S'com.google.common.util.concurrent.JdkFutureAdapters$ListenableFutureAdapter'
p12624
sg15
(lp12625
sg17
(lp12626
sg19
(lp12627
sg21
I0
sba(iArchitecture
Entity
p12628
(dp12629
g11
(lp12630
sg13
S'com.google.common.util.concurrent.JdkFutureAdapters$ListenableFutureAdapter$1'
p12631
sg15
(lp12632
sg17
(lp12633
sg19
(lp12634
sg21
I0
sba(iArchitecture
Entity
p12635
(dp12636
g11
(lp12637
sg13
S'com.google.common.util.concurrent.ListenableFuture'
p12638
sg15
(lp12639
sg17
(lp12640
sg19
(lp12641
sg21
I0
sba(iArchitecture
Entity
p12642
(dp12643
g11
(lp12644
sg13
S'com.google.common.util.concurrent.ListenableFutureTask'
p12645
sg15
(lp12646
sg17
(lp12647
sg19
(lp12648
sg21
I0
sba(iArchitecture
Entity
p12649
(dp12650
g11
(lp12651
sg13
S'com.google.common.util.concurrent.ListenableScheduledFuture'
p12652
sg15
(lp12653
sg17
(lp12654
sg19
(lp12655
sg21
I0
sba(iArchitecture
Entity
p12656
(dp12657
g11
(lp12658
sg13
S'com.google.common.util.concurrent.ListenerCallQueue'
p12659
sg15
(lp12660
sg17
(lp12661
sg19
(lp12662
sg21
I0
sba(iArchitecture
Entity
p12663
(dp12664
g11
(lp12665
sg13
S'com.google.common.util.concurrent.ListenerCallQueue$Callback'
p12666
sg15
(lp12667
sg17
(lp12668
sg19
(lp12669
sg21
I0
sba(iArchitecture
Entity
p12670
(dp12671
g11
(lp12672
sg13
S'com.google.common.util.concurrent.ListeningExecutorService'
p12673
sg15
(lp12674
sg17
(lp12675
sg19
(lp12676
sg21
I0
sba(iArchitecture
Entity
p12677
(dp12678
g11
(lp12679
sg13
S'com.google.common.util.concurrent.ListeningScheduledExecutorService'
p12680
sg15
(lp12681
sg17
(lp12682
sg19
(lp12683
sg21
I0
sba(iArchitecture
Entity
p12684
(dp12685
g11
(lp12686
g25
asg13
S'com.google.common.util.concurrent.Monitor'
p12687
sg15
(lp12688
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12689
asg17
(lp12690
g32
asg19
(lp12691
g35
asg21
I0
sba(iArchitecture
Entity
p12692
(dp12693
g11
(lp12694
g25
asg13
S'com.google.common.util.concurrent.Monitor$Guard'
p12695
sg15
(lp12696
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=339) created by **marsh.yeoman** on 2010-03-12 at 04:43 PM_\u000a\u000a---\u000a\u000aMultiple concurrent reads of HashMultimap result in null pointer exception.\u000a\u000aUsing Google collections version 1.0\u000a\u000aProblem\u000acom.google.common.collect.AbstractMultimap.AsMap.entrySet()\u000acan return null when called by multiple threads.\u000a\u000a1311    @\ufeffOverride public Set&lt;Map.Entry&lt;K, Collection&lt;V>>> entrySet() {\u000a1312      Set&lt;Map.Entry&lt;K, Collection&lt;V>>> result = entrySet;\u000a1313      return (entrySet == null) ? entrySet = new AsMapEntries() : result;\u000a1314    }\u000a1. thread 1 executes line 1312\u000a2. thread 2 executes 1312 and 1313\u000a3. thread 1 executes 1313.\u000a\u000aThread 1 will return null.\u000a\u000aFix by\u000a1313      return (result == null) ? entrySet = new AsMapEntries() : result;\u000a
p12697
asg17
(lp12698
g32
asg19
(lp12699
g35
asg21
I0
sba(iArchitecture
Entity
p12700
(dp12701
g11
(lp12702
V2133
p12703
asg13
S'com.google.common.util.concurrent.MoreExecutors'
p12704
sg15
(lp12705
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12706
asg17
(lp12707
(lp12708
I2
aasg19
(lp12709
VBUG: ScheduledListeningDecorator schedule(Callable<V>....) delegates to schedule(Runnable
p12710
asg21
I0
sba(iArchitecture
Entity
p12711
(dp12712
g11
(lp12713
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$1'
p12714
sg15
(lp12715
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12716
asg17
(lp12717
g12708
asg19
(lp12718
g12710
asg21
I0
sba(iArchitecture
Entity
p12719
(dp12720
g11
(lp12721
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$2'
p12722
sg15
(lp12723
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12724
asg17
(lp12725
g12708
asg19
(lp12726
g12710
asg21
I0
sba(iArchitecture
Entity
p12727
(dp12728
g11
(lp12729
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$3'
p12730
sg15
(lp12731
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12732
asg17
(lp12733
g12708
asg19
(lp12734
g12710
asg21
I0
sba(iArchitecture
Entity
p12735
(dp12736
g11
(lp12737
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$4'
p12738
sg15
(lp12739
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12740
asg17
(lp12741
g12708
asg19
(lp12742
g12710
asg21
I0
sba(iArchitecture
Entity
p12743
(dp12744
g11
(lp12745
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$Application'
p12746
sg15
(lp12747
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12748
asg17
(lp12749
g12708
asg19
(lp12750
g12710
asg21
I0
sba(iArchitecture
Entity
p12751
(dp12752
g11
(lp12753
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$Application$1'
p12754
sg15
(lp12755
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12756
asg17
(lp12757
g12708
asg19
(lp12758
g12710
asg21
I0
sba(iArchitecture
Entity
p12759
(dp12760
g11
(lp12761
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$DirectExecutor'
p12762
sg15
(lp12763
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12764
asg17
(lp12765
g12708
asg19
(lp12766
g12710
asg21
I0
sba(iArchitecture
Entity
p12767
(dp12768
g11
(lp12769
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$DirectExecutorService'
p12770
sg15
(lp12771
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12772
asg17
(lp12773
g12708
asg19
(lp12774
g12710
asg21
I0
sba(iArchitecture
Entity
p12775
(dp12776
g11
(lp12777
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$ListeningDecorator'
p12778
sg15
(lp12779
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12780
asg17
(lp12781
g12708
asg19
(lp12782
g12710
asg21
I0
sba(iArchitecture
Entity
p12783
(dp12784
g11
(lp12785
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$ScheduledListeningDecorator'
p12786
sg15
(lp12787
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12788
asg17
(lp12789
g12708
asg19
(lp12790
g12710
asg21
I0
sba(iArchitecture
Entity
p12791
(dp12792
g11
(lp12793
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$ScheduledListeningDecorator$ListenableScheduledTask'
p12794
sg15
(lp12795
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12796
asg17
(lp12797
g12708
asg19
(lp12798
g12710
asg21
I0
sba(iArchitecture
Entity
p12799
(dp12800
g11
(lp12801
g12703
asg13
S'com.google.common.util.concurrent.MoreExecutors$ScheduledListeningDecorator$NeverSuccessfulListenableFutureTask'
p12802
sg15
(lp12803
V`MoreExecutors.java:541`\u000a\u000a``` java\u000a    @Override\u000a    public <V> ListenableScheduledFuture<V> schedule(\u000a        Callable<V> callable, long delay, TimeUnit unit) {\u000a      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\u000a      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\u000a      return new ListenableScheduledTask<V>(task, scheduled);\u000a    }\u000a```\u000a\u000a`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\u000a
p12804
asg17
(lp12805
g12708
asg19
(lp12806
g12710
asg21
I0
sba(iArchitecture
Entity
p12807
(dp12808
g11
(lp12809
g1014
ag1014
asg13
S'com.google.common.util.concurrent.RateLimiter'
p12810
sg15
(lp12811
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12812
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12813
asg17
(lp12814
g1029
ag1029
asg19
(lp12815
g1033
ag1033
asg21
I0
sba(iArchitecture
Entity
p12816
(dp12817
g11
(lp12818
g1014
ag1014
asg13
S'com.google.common.util.concurrent.RateLimiter$SleepingStopwatch'
p12819
sg15
(lp12820
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12821
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12822
asg17
(lp12823
g1029
ag1029
asg19
(lp12824
g1033
ag1033
asg21
I0
sba(iArchitecture
Entity
p12825
(dp12826
g11
(lp12827
g1014
ag1014
asg13
S'com.google.common.util.concurrent.RateLimiter$SleepingStopwatch$1'
p12828
sg15
(lp12829
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12830
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12831
asg17
(lp12832
g1029
ag1029
asg19
(lp12833
g1033
ag1033
asg21
I0
sba(iArchitecture
Entity
p12834
(dp12835
g11
(lp12836
sg13
S'com.google.common.util.concurrent.Runnables'
p12837
sg15
(lp12838
sg17
(lp12839
sg19
(lp12840
sg21
I0
sba(iArchitecture
Entity
p12841
(dp12842
g11
(lp12843
sg13
S'com.google.common.util.concurrent.Runnables$1'
p12844
sg15
(lp12845
sg17
(lp12846
sg19
(lp12847
sg21
I0
sba(iArchitecture
Entity
p12848
(dp12849
g11
(lp12850
sg13
S'com.google.common.util.concurrent.SerializingExecutor'
p12851
sg15
(lp12852
sg17
(lp12853
sg19
(lp12854
sg21
I0
sba(iArchitecture
Entity
p12855
(dp12856
g11
(lp12857
sg13
S'com.google.common.util.concurrent.SerializingExecutor$1'
p12858
sg15
(lp12859
sg17
(lp12860
sg19
(lp12861
sg21
I0
sba(iArchitecture
Entity
p12862
(dp12863
g11
(lp12864
sg13
S'com.google.common.util.concurrent.SerializingExecutor$TaskRunner'
p12865
sg15
(lp12866
sg17
(lp12867
sg19
(lp12868
sg21
I0
sba(iArchitecture
Entity
p12869
(dp12870
g11
(lp12871
g1014
asg13
S'com.google.common.util.concurrent.Service'
p12872
sg15
(lp12873
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12874
asg17
(lp12875
g1029
asg19
(lp12876
g1033
asg21
I0
sba(iArchitecture
Entity
p12877
(dp12878
g11
(lp12879
g1014
asg13
S'com.google.common.util.concurrent.Service$1'
p12880
sg15
(lp12881
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12882
asg17
(lp12883
g1029
asg19
(lp12884
g1033
asg21
I0
sba(iArchitecture
Entity
p12885
(dp12886
g11
(lp12887
g1014
asg13
S'com.google.common.util.concurrent.Service$Listener'
p12888
sg15
(lp12889
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12890
asg17
(lp12891
g1029
asg19
(lp12892
g1033
asg21
I0
sba(iArchitecture
Entity
p12893
(dp12894
g11
(lp12895
g1014
asg13
S'com.google.common.util.concurrent.Service$State'
p12896
sg15
(lp12897
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12898
asg17
(lp12899
g1029
asg19
(lp12900
g1033
asg21
I0
sba(iArchitecture
Entity
p12901
(dp12902
g11
(lp12903
g1014
asg13
S'com.google.common.util.concurrent.Service$State$1'
p12904
sg15
(lp12905
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12906
asg17
(lp12907
g1029
asg19
(lp12908
g1033
asg21
I0
sba(iArchitecture
Entity
p12909
(dp12910
g11
(lp12911
g1014
asg13
S'com.google.common.util.concurrent.Service$State$2'
p12912
sg15
(lp12913
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12914
asg17
(lp12915
g1029
asg19
(lp12916
g1033
asg21
I0
sba(iArchitecture
Entity
p12917
(dp12918
g11
(lp12919
g1014
asg13
S'com.google.common.util.concurrent.Service$State$3'
p12920
sg15
(lp12921
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12922
asg17
(lp12923
g1029
asg19
(lp12924
g1033
asg21
I0
sba(iArchitecture
Entity
p12925
(dp12926
g11
(lp12927
g1014
asg13
S'com.google.common.util.concurrent.Service$State$4'
p12928
sg15
(lp12929
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12930
asg17
(lp12931
g1029
asg19
(lp12932
g1033
asg21
I0
sba(iArchitecture
Entity
p12933
(dp12934
g11
(lp12935
g1014
asg13
S'com.google.common.util.concurrent.Service$State$5'
p12936
sg15
(lp12937
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12938
asg17
(lp12939
g1029
asg19
(lp12940
g1033
asg21
I0
sba(iArchitecture
Entity
p12941
(dp12942
g11
(lp12943
g1014
asg13
S'com.google.common.util.concurrent.Service$State$6'
p12944
sg15
(lp12945
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p12946
asg17
(lp12947
g1029
asg19
(lp12948
g1033
asg21
I0
sba(iArchitecture
Entity
p12949
(dp12950
g11
(lp12951
sg13
S'com.google.common.util.concurrent.ServiceManager'
p12952
sg15
(lp12953
sg17
(lp12954
sg19
(lp12955
sg21
I0
sba(iArchitecture
Entity
p12956
(dp12957
g11
(lp12958
sg13
S'com.google.common.util.concurrent.ServiceManager$1'
p12959
sg15
(lp12960
sg17
(lp12961
sg19
(lp12962
sg21
I0
sba(iArchitecture
Entity
p12963
(dp12964
g11
(lp12965
sg13
S'com.google.common.util.concurrent.ServiceManager$2'
p12966
sg15
(lp12967
sg17
(lp12968
sg19
(lp12969
sg21
I0
sba(iArchitecture
Entity
p12970
(dp12971
g11
(lp12972
sg13
S'com.google.common.util.concurrent.ServiceManager$EmptyServiceManagerWarning'
p12973
sg15
(lp12974
sg17
(lp12975
sg19
(lp12976
sg21
I0
sba(iArchitecture
Entity
p12977
(dp12978
g11
(lp12979
sg13
S'com.google.common.util.concurrent.ServiceManager$Listener'
p12980
sg15
(lp12981
sg17
(lp12982
sg19
(lp12983
sg21
I0
sba(iArchitecture
Entity
p12984
(dp12985
g11
(lp12986
sg13
S'com.google.common.util.concurrent.ServiceManager$NoOpService'
p12987
sg15
(lp12988
sg17
(lp12989
sg19
(lp12990
sg21
I0
sba(iArchitecture
Entity
p12991
(dp12992
g11
(lp12993
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceListener'
p12994
sg15
(lp12995
sg17
(lp12996
sg19
(lp12997
sg21
I0
sba(iArchitecture
Entity
p12998
(dp12999
g11
(lp13000
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState'
p13001
sg15
(lp13002
sg17
(lp13003
sg19
(lp13004
sg21
I0
sba(iArchitecture
Entity
p13005
(dp13006
g11
(lp13007
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$1'
p13008
sg15
(lp13009
sg17
(lp13010
sg19
(lp13011
sg21
I0
sba(iArchitecture
Entity
p13012
(dp13013
g11
(lp13014
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$2'
p13015
sg15
(lp13016
sg17
(lp13017
sg19
(lp13018
sg21
I0
sba(iArchitecture
Entity
p13019
(dp13020
g11
(lp13021
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$3'
p13022
sg15
(lp13023
sg17
(lp13024
sg19
(lp13025
sg21
I0
sba(iArchitecture
Entity
p13026
(dp13027
g11
(lp13028
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$4'
p13029
sg15
(lp13030
sg17
(lp13031
sg19
(lp13032
sg21
I0
sba(iArchitecture
Entity
p13033
(dp13034
g11
(lp13035
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$5'
p13036
sg15
(lp13037
sg17
(lp13038
sg19
(lp13039
sg21
I0
sba(iArchitecture
Entity
p13040
(dp13041
g11
(lp13042
sg13
S'com.google.common.util.concurrent.SimpleTimeLimiter'
p13043
sg15
(lp13044
sg17
(lp13045
sg19
(lp13046
sg21
I0
sba(iArchitecture
Entity
p13047
(dp13048
g11
(lp13049
sg13
S'com.google.common.util.concurrent.SimpleTimeLimiter$1'
p13050
sg15
(lp13051
sg17
(lp13052
sg19
(lp13053
sg21
I0
sba(iArchitecture
Entity
p13054
(dp13055
g11
(lp13056
sg13
S'com.google.common.util.concurrent.SimpleTimeLimiter$1$1'
p13057
sg15
(lp13058
sg17
(lp13059
sg19
(lp13060
sg21
I0
sba(iArchitecture
Entity
p13061
(dp13062
g11
(lp13063
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter'
p13064
sg15
(lp13065
sg17
(lp13066
sg19
(lp13067
sg21
I0
sba(iArchitecture
Entity
p13068
(dp13069
g11
(lp13070
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter$1'
p13071
sg15
(lp13072
sg17
(lp13073
sg19
(lp13074
sg21
I0
sba(iArchitecture
Entity
p13075
(dp13076
g11
(lp13077
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter$SmoothBursty'
p13078
sg15
(lp13079
sg17
(lp13080
sg19
(lp13081
sg21
I0
sba(iArchitecture
Entity
p13082
(dp13083
g11
(lp13084
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter$SmoothWarmingUp'
p13085
sg15
(lp13086
sg17
(lp13087
sg19
(lp13088
sg21
I0
sba(iArchitecture
Entity
p13089
(dp13090
g11
(lp13091
sg13
S'com.google.common.util.concurrent.Striped'
p13092
sg15
(lp13093
sg17
(lp13094
sg19
(lp13095
sg21
I0
sba(iArchitecture
Entity
p13096
(dp13097
g11
(lp13098
sg13
S'com.google.common.util.concurrent.Striped$1'
p13099
sg15
(lp13100
sg17
(lp13101
sg19
(lp13102
sg21
I0
sba(iArchitecture
Entity
p13103
(dp13104
g11
(lp13105
sg13
S'com.google.common.util.concurrent.Striped$2'
p13106
sg15
(lp13107
sg17
(lp13108
sg19
(lp13109
sg21
I0
sba(iArchitecture
Entity
p13110
(dp13111
g11
(lp13112
sg13
S'com.google.common.util.concurrent.Striped$3'
p13113
sg15
(lp13114
sg17
(lp13115
sg19
(lp13116
sg21
I0
sba(iArchitecture
Entity
p13117
(dp13118
g11
(lp13119
sg13
S'com.google.common.util.concurrent.Striped$4'
p13120
sg15
(lp13121
sg17
(lp13122
sg19
(lp13123
sg21
I0
sba(iArchitecture
Entity
p13124
(dp13125
g11
(lp13126
sg13
S'com.google.common.util.concurrent.Striped$5'
p13127
sg15
(lp13128
sg17
(lp13129
sg19
(lp13130
sg21
I0
sba(iArchitecture
Entity
p13131
(dp13132
g11
(lp13133
sg13
S'com.google.common.util.concurrent.Striped$CompactStriped'
p13134
sg15
(lp13135
sg17
(lp13136
sg19
(lp13137
sg21
I0
sba(iArchitecture
Entity
p13138
(dp13139
g11
(lp13140
sg13
S'com.google.common.util.concurrent.Striped$LargeLazyStriped'
p13141
sg15
(lp13142
sg17
(lp13143
sg19
(lp13144
sg21
I0
sba(iArchitecture
Entity
p13145
(dp13146
g11
(lp13147
sg13
S'com.google.common.util.concurrent.Striped$PaddedLock'
p13148
sg15
(lp13149
sg17
(lp13150
sg19
(lp13151
sg21
I0
sba(iArchitecture
Entity
p13152
(dp13153
g11
(lp13154
sg13
S'com.google.common.util.concurrent.Striped$PaddedSemaphore'
p13155
sg15
(lp13156
sg17
(lp13157
sg19
(lp13158
sg21
I0
sba(iArchitecture
Entity
p13159
(dp13160
g11
(lp13161
sg13
S'com.google.common.util.concurrent.Striped$PowerOfTwoStriped'
p13162
sg15
(lp13163
sg17
(lp13164
sg19
(lp13165
sg21
I0
sba(iArchitecture
Entity
p13166
(dp13167
g11
(lp13168
sg13
S'com.google.common.util.concurrent.Striped$SmallLazyStriped'
p13169
sg15
(lp13170
sg17
(lp13171
sg19
(lp13172
sg21
I0
sba(iArchitecture
Entity
p13173
(dp13174
g11
(lp13175
sg13
S'com.google.common.util.concurrent.Striped$SmallLazyStriped$ArrayReference'
p13176
sg15
(lp13177
sg17
(lp13178
sg19
(lp13179
sg21
I0
sba(iArchitecture
Entity
p13180
(dp13181
g11
(lp13182
g1014
ag1014
asg13
S'com.google.common.util.concurrent.ThreadFactoryBuilder'
p13183
sg15
(lp13184
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p13185
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p13186
asg17
(lp13187
g1029
ag1029
asg19
(lp13188
g1033
ag1033
asg21
I0
sba(iArchitecture
Entity
p13189
(dp13190
g11
(lp13191
g1014
ag1014
asg13
S'com.google.common.util.concurrent.ThreadFactoryBuilder$1'
p13192
sg15
(lp13193
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p13194
aV_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p13195
asg17
(lp13196
g1029
ag1029
asg19
(lp13197
g1033
ag1033
asg21
I0
sba(iArchitecture
Entity
p13198
(dp13199
g11
(lp13200
sg13
S'com.google.common.util.concurrent.TimeLimiter'
p13201
sg15
(lp13202
sg17
(lp13203
sg19
(lp13204
sg21
I0
sba(iArchitecture
Entity
p13205
(dp13206
g11
(lp13207
g1014
asg13
S'com.google.common.util.concurrent.UncaughtExceptionHandlers'
p13208
sg15
(lp13209
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p13210
asg17
(lp13211
g1029
asg19
(lp13212
g1033
asg21
I0
sba(iArchitecture
Entity
p13213
(dp13214
g11
(lp13215
g1014
asg13
S'com.google.common.util.concurrent.UncaughtExceptionHandlers$Exiter'
p13216
sg15
(lp13217
V_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1567) created by **sebastian.davids** on 2013-11-04 at 06:57 AM_\u000a\u000a---\u000a\u000aFailed tests: \u000a&nbsp;&nbsp;testToString(com.google.common.base.StopwatchTest): null expected:&lt;0[.]000 ns> but was:&lt;0[,]000 ns>\u000a&nbsp;&nbsp;testSimple(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.20, R0.]20]> but was:<[R0[,00, R0,20, R0,]20]>\u000a&nbsp;&nbsp;testSimpleWithWait(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, U0.20, R0.00, R0.]20]> but was:<[R0[,00, U0,20, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testOneSecondBurst(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U1[.00, U1.00, R0.00, R0.00, R0.00, R0.00, R0.]20]> but was:<[U1[,00, U1,00, R0,00, R0,00, R0,00, R0,00, R0,]20]>\u000a&nbsp;&nbsp;testWarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U4.00, R0.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U0.50, U2.00, R0.00, R0.50, R0.50, R0.50, R0.50, R0.50, R0.50, R0.]50]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U4,00, R0,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U0,50, U2,00, R0,00, R0,50, R0,50, R0,50, R0,50, R0,50, R0,50, R0,]50]>\u000a&nbsp;&nbsp;testWarmUpAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.38, R1.13, R0.88, R0.63, R0.50, R0.50, R0.50, U4.50, R0.00, R1.38, R1.13, R0.88, R0.34, R0.28, R0.25, R0.25, U4.25, R0.00, R0.72, R0.66, R0.59, R0.53, R0.47, R0.41, R0.34, R0.28, R0.25, R0.]25]> but was:<[R0[,00, R1,38, R1,13, R0,88, R0,63, R0,50, R0,50, R0,50, U4,50, R0,00, R1,38, R1,13, R0,88, R0,34, R0,28, R0,25, R0,25, U4,25, R0,00, R0,72, R0,66, R0,59, R0,53, R0,47, R0,41, R0,34, R0,28, R0,25, R0,]25]>\u000a&nbsp;&nbsp;testBursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[U10[.00, R0.00, R1.00, R1.00, U3.00, R0.00, R3.]00]> but was:<[U10[,00, R0,00, R1,00, R1,00, U3,00, R0,00, R3,]00]>\u000a&nbsp;&nbsp;testBurstyAndUpdate(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R0.50, R1.00, R2.]00]> but was:<[R0[,00, R1,00, R1,00, R0,50, R1,00, R2,]00]>\u000a&nbsp;&nbsp;testTimeWrapping(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R1.]00]> but was:<[R0[,00, R1,00, R1,00, R1,]00]>\u000a&nbsp;&nbsp;testSimpleWeights(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R1.00, R1.00, R2.00, R4.00, R8.]00]> but was:<[R0[,00, R1,00, R1,00, R2,00, R4,00, R8,]00]>\u000a&nbsp;&nbsp;testInfinity_Bursty(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a&nbsp;&nbsp;testInfinity_WarmUp(com.google.common.util.concurrent.RateLimiterTest): null expected:<[R0[.00, R0.00, R0.]00]> but was:<[R0[,00, R0,00, R0,]00]>\u000a\u000a@@\u000a\u000aInstead of:\u000a\u000aString.format("%.4g %s", value, abbreviate(unit));\u000a\u000ayou might want to use:\u000a\u000aString.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));\u000a\u000a@@\u000a\u000aYou might want to check the entire codebase for usages of String.format without an explicit Locale.\u000a
p13218
asg17
(lp13219
g1029
asg19
(lp13220
g1033
asg21
I0
sba(iArchitecture
Entity
p13221
(dp13222
g11
(lp13223
sg13
S'com.google.common.util.concurrent.UncheckedExecutionException'
p13224
sg15
(lp13225
sg17
(lp13226
sg19
(lp13227
sg21
I0
sba(iArchitecture
Entity
p13228
(dp13229
g11
(lp13230
sg13
S'com.google.common.util.concurrent.UncheckedTimeoutException'
p13231
sg15
(lp13232
sg17
(lp13233
sg19
(lp13234
sg21
I0
sba(iArchitecture
Entity
p13235
(dp13236
g11
(lp13237
sg13
S'com.google.common.util.concurrent.Uninterruptibles'
p13238
sg15
(lp13239
sg17
(lp13240
sg19
(lp13241
sg21
I0
sba(iArchitecture
Entity
p13242
(dp13243
g11
(lp13244
sg13
S'com.google.common.util.concurrent.WrappingExecutorService'
p13245
sg15
(lp13246
sg17
(lp13247
sg19
(lp13248
sg21
I0
sba(iArchitecture
Entity
p13249
(dp13250
g11
(lp13251
sg13
S'com.google.common.util.concurrent.WrappingExecutorService$1'
p13252
sg15
(lp13253
sg17
(lp13254
sg19
(lp13255
sg21
I0
sba(iArchitecture
Entity
p13256
(dp13257
g11
(lp13258
sg13
S'com.google.common.util.concurrent.WrappingScheduledExecutorService'
p13259
sg15
(lp13260
sg17
(lp13261
sg19
(lp13262
sg21
I0
sbasg1135
(lp13263
g11516
ag11524
ag11534
ag11541
ag11548
ag11555
ag11562
ag11569
ag11576
ag11583
ag11591
ag11602
ag11611
ag11618
ag11625
ag11632
ag11639
ag11646
ag11653
ag11661
ag11672
ag11681
ag11690
ag11699
ag11708
ag11717
ag11726
ag11735
ag11744
ag11753
ag11762
ag11771
ag11780
ag11789
ag11796
ag11803
ag11810
ag11817
ag11824
ag11831
ag11838
ag11845
ag11852
ag11859
ag11866
ag11873
ag11880
ag11887
ag11894
ag11901
ag11908
ag11915
ag11922
ag11929
ag11936
ag11943
ag11950
ag11959
ag11968
ag11977
ag11986
ag11995
ag12004
ag12013
ag12022
ag12031
ag12040
ag12049
ag12058
ag12067
ag12076
ag12085
ag12094
ag12101
ag12108
ag12115
ag12122
ag12129
ag12136
ag12143
ag12150
ag12157
ag12164
ag12171
ag12178
ag12189
ag12211
ag12225
ag12239
ag12253
ag12267
ag12281
ag12295
ag12309
ag12323
ag12337
ag12351
ag12365
ag12379
ag12393
ag12407
ag12421
ag12435
ag12449
ag12463
ag12477
ag12491
ag12505
ag12519
ag12533
ag12547
ag12561
ag12575
ag12589
ag12603
ag12617
ag12624
ag12631
ag12638
ag12645
ag12652
ag12659
ag12666
ag12673
ag12680
ag12687
ag12695
ag12704
ag12714
ag12722
ag12730
ag12738
ag12746
ag12754
ag12762
ag12770
ag12778
ag12786
ag12794
ag12802
ag12810
ag12819
ag12828
ag12837
ag12844
ag12851
ag12858
ag12865
ag12872
ag12880
ag12888
ag12896
ag12904
ag12912
ag12920
ag12928
ag12936
ag12944
ag12952
ag12959
ag12966
ag12973
ag12980
ag12987
ag12994
ag13001
ag13008
ag13015
ag13022
ag13029
ag13036
ag13043
ag13050
ag13057
ag13064
ag13071
ag13078
ag13085
ag13092
ag13099
ag13106
ag13113
ag13120
ag13127
ag13134
ag13141
ag13148
ag13155
ag13162
ag13169
ag13176
ag13183
ag13192
ag13201
ag13208
ag13216
ag13224
ag13231
ag13238
ag13245
ag13252
ag13259
asg1137
I0
sg21
I0
sg1138
S'com.google.common.util.concurrent.ss'
p13264
sbasS'target_sub'
p13265
S''
p13266
sg1135
(lp13267
sS'is_component_arch'
p13268
I00
sg1138
S'v18.0'
p13269
sba(iArchitecture
Architecture
p13270
(dp13271
g3
(lp13272
(iArchitecture
Cluster
p13273
(dp13274
g7
(lp13275
(iArchitecture
Entity
p13276
(dp13277
g11
(lp13278
sg13
S'com.google.common.annotations.GwtIncompatible'
p13279
sg15
(lp13280
sg17
(lp13281
sg19
(lp13282
sg21
I0
sba(iArchitecture
Entity
p13283
(dp13284
g11
(lp13285
sg13
S'com.google.common.base.Absent'
p13286
sg15
(lp13287
sg17
(lp13288
sg19
(lp13289
sg21
I0
sba(iArchitecture
Entity
p13290
(dp13291
g11
(lp13292
sg13
S'com.google.common.base.AbstractIterator'
p13293
sg15
(lp13294
sg17
(lp13295
sg19
(lp13296
sg21
I0
sba(iArchitecture
Entity
p13297
(dp13298
g11
(lp13299
sg13
S'com.google.common.base.AbstractIterator$1'
p13300
sg15
(lp13301
sg17
(lp13302
sg19
(lp13303
sg21
I0
sba(iArchitecture
Entity
p13304
(dp13305
g11
(lp13306
sg13
S'com.google.common.base.AbstractIterator$State'
p13307
sg15
(lp13308
sg17
(lp13309
sg19
(lp13310
sg21
I0
sba(iArchitecture
Entity
p13311
(dp13312
g11
(lp13313
sg13
S'com.google.common.base.Ascii'
p13314
sg15
(lp13315
sg17
(lp13316
sg19
(lp13317
sg21
I0
sba(iArchitecture
Entity
p13318
(dp13319
g11
(lp13320
sg13
S'com.google.common.base.CaseFormat'
p13321
sg15
(lp13322
sg17
(lp13323
sg19
(lp13324
sg21
I0
sba(iArchitecture
Entity
p13325
(dp13326
g11
(lp13327
sg13
S'com.google.common.base.CaseFormat$1'
p13328
sg15
(lp13329
sg17
(lp13330
sg19
(lp13331
sg21
I0
sba(iArchitecture
Entity
p13332
(dp13333
g11
(lp13334
sg13
S'com.google.common.base.CaseFormat$2'
p13335
sg15
(lp13336
sg17
(lp13337
sg19
(lp13338
sg21
I0
sba(iArchitecture
Entity
p13339
(dp13340
g11
(lp13341
sg13
S'com.google.common.base.CaseFormat$3'
p13342
sg15
(lp13343
sg17
(lp13344
sg19
(lp13345
sg21
I0
sba(iArchitecture
Entity
p13346
(dp13347
g11
(lp13348
sg13
S'com.google.common.base.CaseFormat$4'
p13349
sg15
(lp13350
sg17
(lp13351
sg19
(lp13352
sg21
I0
sba(iArchitecture
Entity
p13353
(dp13354
g11
(lp13355
sg13
S'com.google.common.base.CaseFormat$5'
p13356
sg15
(lp13357
sg17
(lp13358
sg19
(lp13359
sg21
I0
sba(iArchitecture
Entity
p13360
(dp13361
g11
(lp13362
sg13
S'com.google.common.base.CaseFormat$StringConverter'
p13363
sg15
(lp13364
sg17
(lp13365
sg19
(lp13366
sg21
I0
sba(iArchitecture
Entity
p13367
(dp13368
g11
(lp13369
sg13
S'com.google.common.base.CharMatcher'
p13370
sg15
(lp13371
sg17
(lp13372
sg19
(lp13373
sg21
I0
sba(iArchitecture
Entity
p13374
(dp13375
g11
(lp13376
sg13
S'com.google.common.base.CharMatcher$1'
p13377
sg15
(lp13378
sg17
(lp13379
sg19
(lp13380
sg21
I0
sba(iArchitecture
Entity
p13381
(dp13382
g11
(lp13383
sg13
S'com.google.common.base.CharMatcher$And'
p13384
sg15
(lp13385
sg17
(lp13386
sg19
(lp13387
sg21
I0
sba(iArchitecture
Entity
p13388
(dp13389
g11
(lp13390
sg13
S'com.google.common.base.CharMatcher$Any'
p13391
sg15
(lp13392
sg17
(lp13393
sg19
(lp13394
sg21
I0
sba(iArchitecture
Entity
p13395
(dp13396
g11
(lp13397
sg13
S'com.google.common.base.CharMatcher$AnyOf'
p13398
sg15
(lp13399
sg17
(lp13400
sg19
(lp13401
sg21
I0
sba(iArchitecture
Entity
p13402
(dp13403
g11
(lp13404
sg13
S'com.google.common.base.CharMatcher$Ascii'
p13405
sg15
(lp13406
sg17
(lp13407
sg19
(lp13408
sg21
I0
sba(iArchitecture
Entity
p13409
(dp13410
g11
(lp13411
sg13
S'com.google.common.base.CharMatcher$BitSetMatcher'
p13412
sg15
(lp13413
sg17
(lp13414
sg19
(lp13415
sg21
I0
sba(iArchitecture
Entity
p13416
(dp13417
g11
(lp13418
sg13
S'com.google.common.base.CharMatcher$BreakingWhitespace'
p13419
sg15
(lp13420
sg17
(lp13421
sg19
(lp13422
sg21
I0
sba(iArchitecture
Entity
p13423
(dp13424
g11
(lp13425
sg13
S'com.google.common.base.CharMatcher$Digit'
p13426
sg15
(lp13427
sg17
(lp13428
sg19
(lp13429
sg21
I0
sba(iArchitecture
Entity
p13430
(dp13431
g11
(lp13432
sg13
S'com.google.common.base.CharMatcher$FastMatcher'
p13433
sg15
(lp13434
sg17
(lp13435
sg19
(lp13436
sg21
I0
sba(iArchitecture
Entity
p13437
(dp13438
g11
(lp13439
sg13
S'com.google.common.base.CharMatcher$ForPredicate'
p13440
sg15
(lp13441
sg17
(lp13442
sg19
(lp13443
sg21
I0
sba(iArchitecture
Entity
p13444
(dp13445
g11
(lp13446
sg13
S'com.google.common.base.CharMatcher$InRange'
p13447
sg15
(lp13448
sg17
(lp13449
sg19
(lp13450
sg21
I0
sba(iArchitecture
Entity
p13451
(dp13452
g11
(lp13453
sg13
S'com.google.common.base.CharMatcher$Invisible'
p13454
sg15
(lp13455
sg17
(lp13456
sg19
(lp13457
sg21
I0
sba(iArchitecture
Entity
p13458
(dp13459
g11
(lp13460
sg13
S'com.google.common.base.CharMatcher$Is'
p13461
sg15
(lp13462
sg17
(lp13463
sg19
(lp13464
sg21
I0
sba(iArchitecture
Entity
p13465
(dp13466
g11
(lp13467
sg13
S'com.google.common.base.CharMatcher$IsEither'
p13468
sg15
(lp13469
sg17
(lp13470
sg19
(lp13471
sg21
I0
sba(iArchitecture
Entity
p13472
(dp13473
g11
(lp13474
sg13
S'com.google.common.base.CharMatcher$IsNot'
p13475
sg15
(lp13476
sg17
(lp13477
sg19
(lp13478
sg21
I0
sba(iArchitecture
Entity
p13479
(dp13480
g11
(lp13481
sg13
S'com.google.common.base.CharMatcher$JavaDigit'
p13482
sg15
(lp13483
sg17
(lp13484
sg19
(lp13485
sg21
I0
sba(iArchitecture
Entity
p13486
(dp13487
g11
(lp13488
sg13
S'com.google.common.base.CharMatcher$JavaIsoControl'
p13489
sg15
(lp13490
sg17
(lp13491
sg19
(lp13492
sg21
I0
sba(iArchitecture
Entity
p13493
(dp13494
g11
(lp13495
sg13
S'com.google.common.base.CharMatcher$JavaLetter'
p13496
sg15
(lp13497
sg17
(lp13498
sg19
(lp13499
sg21
I0
sba(iArchitecture
Entity
p13500
(dp13501
g11
(lp13502
sg13
S'com.google.common.base.CharMatcher$JavaLetterOrDigit'
p13503
sg15
(lp13504
sg17
(lp13505
sg19
(lp13506
sg21
I0
sba(iArchitecture
Entity
p13507
(dp13508
g11
(lp13509
sg13
S'com.google.common.base.CharMatcher$JavaLowerCase'
p13510
sg15
(lp13511
sg17
(lp13512
sg19
(lp13513
sg21
I0
sba(iArchitecture
Entity
p13514
(dp13515
g11
(lp13516
sg13
S'com.google.common.base.CharMatcher$JavaUpperCase'
p13517
sg15
(lp13518
sg17
(lp13519
sg19
(lp13520
sg21
I0
sba(iArchitecture
Entity
p13521
(dp13522
g11
(lp13523
sg13
S'com.google.common.base.CharMatcher$NamedFastMatcher'
p13524
sg15
(lp13525
sg17
(lp13526
sg19
(lp13527
sg21
I0
sba(iArchitecture
Entity
p13528
(dp13529
g11
(lp13530
sg13
S'com.google.common.base.CharMatcher$Negated'
p13531
sg15
(lp13532
sg17
(lp13533
sg19
(lp13534
sg21
I0
sba(iArchitecture
Entity
p13535
(dp13536
g11
(lp13537
sg13
S'com.google.common.base.CharMatcher$NegatedFastMatcher'
p13538
sg15
(lp13539
sg17
(lp13540
sg19
(lp13541
sg21
I0
sba(iArchitecture
Entity
p13542
(dp13543
g11
(lp13544
sg13
S'com.google.common.base.CharMatcher$None'
p13545
sg15
(lp13546
sg17
(lp13547
sg19
(lp13548
sg21
I0
sba(iArchitecture
Entity
p13549
(dp13550
g11
(lp13551
sg13
S'com.google.common.base.CharMatcher$Or'
p13552
sg15
(lp13553
sg17
(lp13554
sg19
(lp13555
sg21
I0
sba(iArchitecture
Entity
p13556
(dp13557
g11
(lp13558
sg13
S'com.google.common.base.CharMatcher$RangesMatcher'
p13559
sg15
(lp13560
sg17
(lp13561
sg19
(lp13562
sg21
I0
sba(iArchitecture
Entity
p13563
(dp13564
g11
(lp13565
sg13
S'com.google.common.base.CharMatcher$SingleWidth'
p13566
sg15
(lp13567
sg17
(lp13568
sg19
(lp13569
sg21
I0
sba(iArchitecture
Entity
p13570
(dp13571
g11
(lp13572
sg13
S'com.google.common.base.CharMatcher$Whitespace'
p13573
sg15
(lp13574
sg17
(lp13575
sg19
(lp13576
sg21
I0
sba(iArchitecture
Entity
p13577
(dp13578
g11
(lp13579
sg13
S'com.google.common.base.CommonMatcher'
p13580
sg15
(lp13581
sg17
(lp13582
sg19
(lp13583
sg21
I0
sba(iArchitecture
Entity
p13584
(dp13585
g11
(lp13586
sg13
S'com.google.common.base.CommonPattern'
p13587
sg15
(lp13588
sg17
(lp13589
sg19
(lp13590
sg21
I0
sba(iArchitecture
Entity
p13591
(dp13592
g11
(lp13593
sg13
S'com.google.common.base.Converter'
p13594
sg15
(lp13595
sg17
(lp13596
sg19
(lp13597
sg21
I0
sba(iArchitecture
Entity
p13598
(dp13599
g11
(lp13600
sg13
S'com.google.common.base.Converter$1'
p13601
sg15
(lp13602
sg17
(lp13603
sg19
(lp13604
sg21
I0
sba(iArchitecture
Entity
p13605
(dp13606
g11
(lp13607
sg13
S'com.google.common.base.Converter$1$1'
p13608
sg15
(lp13609
sg17
(lp13610
sg19
(lp13611
sg21
I0
sba(iArchitecture
Entity
p13612
(dp13613
g11
(lp13614
sg13
S'com.google.common.base.Converter$ConverterComposition'
p13615
sg15
(lp13616
sg17
(lp13617
sg19
(lp13618
sg21
I0
sba(iArchitecture
Entity
p13619
(dp13620
g11
(lp13621
sg13
S'com.google.common.base.Converter$FunctionBasedConverter'
p13622
sg15
(lp13623
sg17
(lp13624
sg19
(lp13625
sg21
I0
sba(iArchitecture
Entity
p13626
(dp13627
g11
(lp13628
sg13
S'com.google.common.base.Converter$IdentityConverter'
p13629
sg15
(lp13630
sg17
(lp13631
sg19
(lp13632
sg21
I0
sba(iArchitecture
Entity
p13633
(dp13634
g11
(lp13635
sg13
S'com.google.common.base.Converter$ReverseConverter'
p13636
sg15
(lp13637
sg17
(lp13638
sg19
(lp13639
sg21
I0
sba(iArchitecture
Entity
p13640
(dp13641
g11
(lp13642
sg13
S'com.google.common.base.Enums'
p13643
sg15
(lp13644
sg17
(lp13645
sg19
(lp13646
sg21
I0
sba(iArchitecture
Entity
p13647
(dp13648
g11
(lp13649
sg13
S'com.google.common.base.Enums$StringConverter'
p13650
sg15
(lp13651
sg17
(lp13652
sg19
(lp13653
sg21
I0
sba(iArchitecture
Entity
p13654
(dp13655
g11
(lp13656
sg13
S'com.google.common.base.Equivalence'
p13657
sg15
(lp13658
sg17
(lp13659
sg19
(lp13660
sg21
I0
sba(iArchitecture
Entity
p13661
(dp13662
g11
(lp13663
sg13
S'com.google.common.base.Equivalence$1'
p13664
sg15
(lp13665
sg17
(lp13666
sg19
(lp13667
sg21
I0
sba(iArchitecture
Entity
p13668
(dp13669
g11
(lp13670
sg13
S'com.google.common.base.Equivalence$Equals'
p13671
sg15
(lp13672
sg17
(lp13673
sg19
(lp13674
sg21
I0
sba(iArchitecture
Entity
p13675
(dp13676
g11
(lp13677
sg13
S'com.google.common.base.Equivalence$EquivalentToPredicate'
p13678
sg15
(lp13679
sg17
(lp13680
sg19
(lp13681
sg21
I0
sba(iArchitecture
Entity
p13682
(dp13683
g11
(lp13684
sg13
S'com.google.common.base.Equivalence$Identity'
p13685
sg15
(lp13686
sg17
(lp13687
sg19
(lp13688
sg21
I0
sba(iArchitecture
Entity
p13689
(dp13690
g11
(lp13691
sg13
S'com.google.common.base.Equivalence$Wrapper'
p13692
sg15
(lp13693
sg17
(lp13694
sg19
(lp13695
sg21
I0
sba(iArchitecture
Entity
p13696
(dp13697
g11
(lp13698
sg13
S'com.google.common.base.ExtraObjectsMethodsForWeb'
p13699
sg15
(lp13700
sg17
(lp13701
sg19
(lp13702
sg21
I0
sba(iArchitecture
Entity
p13703
(dp13704
g11
(lp13705
sg13
S'com.google.common.base.FinalizablePhantomReference'
p13706
sg15
(lp13707
sg17
(lp13708
sg19
(lp13709
sg21
I0
sba(iArchitecture
Entity
p13710
(dp13711
g11
(lp13712
sg13
S'com.google.common.base.FinalizableReference'
p13713
sg15
(lp13714
sg17
(lp13715
sg19
(lp13716
sg21
I0
sba(iArchitecture
Entity
p13717
(dp13718
g11
(lp13719
sg13
S'com.google.common.base.FinalizableReferenceQueue'
p13720
sg15
(lp13721
sg17
(lp13722
sg19
(lp13723
sg21
I0
sba(iArchitecture
Entity
p13724
(dp13725
g11
(lp13726
sg13
S'com.google.common.base.FinalizableReferenceQueue$DecoupledLoader'
p13727
sg15
(lp13728
sg17
(lp13729
sg19
(lp13730
sg21
I0
sba(iArchitecture
Entity
p13731
(dp13732
g11
(lp13733
sg13
S'com.google.common.base.FinalizableReferenceQueue$DirectLoader'
p13734
sg15
(lp13735
sg17
(lp13736
sg19
(lp13737
sg21
I0
sba(iArchitecture
Entity
p13738
(dp13739
g11
(lp13740
sg13
S'com.google.common.base.FinalizableReferenceQueue$FinalizerLoader'
p13741
sg15
(lp13742
sg17
(lp13743
sg19
(lp13744
sg21
I0
sba(iArchitecture
Entity
p13745
(dp13746
g11
(lp13747
sg13
S'com.google.common.base.FinalizableReferenceQueue$SystemLoader'
p13748
sg15
(lp13749
sg17
(lp13750
sg19
(lp13751
sg21
I0
sba(iArchitecture
Entity
p13752
(dp13753
g11
(lp13754
sg13
S'com.google.common.base.FinalizableSoftReference'
p13755
sg15
(lp13756
sg17
(lp13757
sg19
(lp13758
sg21
I0
sba(iArchitecture
Entity
p13759
(dp13760
g11
(lp13761
sg13
S'com.google.common.base.FinalizableWeakReference'
p13762
sg15
(lp13763
sg17
(lp13764
sg19
(lp13765
sg21
I0
sba(iArchitecture
Entity
p13766
(dp13767
g11
(lp13768
sg13
S'com.google.common.base.Function'
p13769
sg15
(lp13770
sg17
(lp13771
sg19
(lp13772
sg21
I0
sba(iArchitecture
Entity
p13773
(dp13774
g11
(lp13775
sg13
S'com.google.common.base.FunctionalEquivalence'
p13776
sg15
(lp13777
sg17
(lp13778
sg19
(lp13779
sg21
I0
sba(iArchitecture
Entity
p13780
(dp13781
g11
(lp13782
sg13
S'com.google.common.base.Functions'
p13783
sg15
(lp13784
sg17
(lp13785
sg19
(lp13786
sg21
I0
sba(iArchitecture
Entity
p13787
(dp13788
g11
(lp13789
sg13
S'com.google.common.base.Functions$1'
p13790
sg15
(lp13791
sg17
(lp13792
sg19
(lp13793
sg21
I0
sba(iArchitecture
Entity
p13794
(dp13795
g11
(lp13796
sg13
S'com.google.common.base.Functions$ConstantFunction'
p13797
sg15
(lp13798
sg17
(lp13799
sg19
(lp13800
sg21
I0
sba(iArchitecture
Entity
p13801
(dp13802
g11
(lp13803
sg13
S'com.google.common.base.Functions$ForMapWithDefault'
p13804
sg15
(lp13805
sg17
(lp13806
sg19
(lp13807
sg21
I0
sba(iArchitecture
Entity
p13808
(dp13809
g11
(lp13810
sg13
S'com.google.common.base.Functions$FunctionComposition'
p13811
sg15
(lp13812
sg17
(lp13813
sg19
(lp13814
sg21
I0
sba(iArchitecture
Entity
p13815
(dp13816
g11
(lp13817
sg13
S'com.google.common.base.Functions$FunctionForMapNoDefault'
p13818
sg15
(lp13819
sg17
(lp13820
sg19
(lp13821
sg21
I0
sba(iArchitecture
Entity
p13822
(dp13823
g11
(lp13824
sg13
S'com.google.common.base.Functions$IdentityFunction'
p13825
sg15
(lp13826
sg17
(lp13827
sg19
(lp13828
sg21
I0
sba(iArchitecture
Entity
p13829
(dp13830
g11
(lp13831
sg13
S'com.google.common.base.Functions$PredicateFunction'
p13832
sg15
(lp13833
sg17
(lp13834
sg19
(lp13835
sg21
I0
sba(iArchitecture
Entity
p13836
(dp13837
g11
(lp13838
sg13
S'com.google.common.base.Functions$SupplierFunction'
p13839
sg15
(lp13840
sg17
(lp13841
sg19
(lp13842
sg21
I0
sba(iArchitecture
Entity
p13843
(dp13844
g11
(lp13845
sg13
S'com.google.common.base.Functions$ToStringFunction'
p13846
sg15
(lp13847
sg17
(lp13848
sg19
(lp13849
sg21
I0
sba(iArchitecture
Entity
p13850
(dp13851
g11
(lp13852
sg13
S'com.google.common.base.JdkPattern'
p13853
sg15
(lp13854
sg17
(lp13855
sg19
(lp13856
sg21
I0
sba(iArchitecture
Entity
p13857
(dp13858
g11
(lp13859
sg13
S'com.google.common.base.JdkPattern$JdkMatcher'
p13860
sg15
(lp13861
sg17
(lp13862
sg19
(lp13863
sg21
I0
sba(iArchitecture
Entity
p13864
(dp13865
g11
(lp13866
sg13
S'com.google.common.base.Joiner'
p13867
sg15
(lp13868
sg17
(lp13869
sg19
(lp13870
sg21
I0
sba(iArchitecture
Entity
p13871
(dp13872
g11
(lp13873
sg13
S'com.google.common.base.Joiner$1'
p13874
sg15
(lp13875
sg17
(lp13876
sg19
(lp13877
sg21
I0
sba(iArchitecture
Entity
p13878
(dp13879
g11
(lp13880
sg13
S'com.google.common.base.Joiner$2'
p13881
sg15
(lp13882
sg17
(lp13883
sg19
(lp13884
sg21
I0
sba(iArchitecture
Entity
p13885
(dp13886
g11
(lp13887
sg13
S'com.google.common.base.Joiner$3'
p13888
sg15
(lp13889
sg17
(lp13890
sg19
(lp13891
sg21
I0
sba(iArchitecture
Entity
p13892
(dp13893
g11
(lp13894
sg13
S'com.google.common.base.Joiner$MapJoiner'
p13895
sg15
(lp13896
sg17
(lp13897
sg19
(lp13898
sg21
I0
sba(iArchitecture
Entity
p13899
(dp13900
g11
(lp13901
sg13
S'com.google.common.base.MoreObjects'
p13902
sg15
(lp13903
sg17
(lp13904
sg19
(lp13905
sg21
I0
sba(iArchitecture
Entity
p13906
(dp13907
g11
(lp13908
sg13
S'com.google.common.base.MoreObjects$1'
p13909
sg15
(lp13910
sg17
(lp13911
sg19
(lp13912
sg21
I0
sba(iArchitecture
Entity
p13913
(dp13914
g11
(lp13915
sg13
S'com.google.common.base.MoreObjects$ToStringHelper'
p13916
sg15
(lp13917
sg17
(lp13918
sg19
(lp13919
sg21
I0
sba(iArchitecture
Entity
p13920
(dp13921
g11
(lp13922
sg13
S'com.google.common.base.MoreObjects$ToStringHelper$ValueHolder'
p13923
sg15
(lp13924
sg17
(lp13925
sg19
(lp13926
sg21
I0
sba(iArchitecture
Entity
p13927
(dp13928
g11
(lp13929
sg13
S'com.google.common.base.Objects'
p13930
sg15
(lp13931
sg17
(lp13932
sg19
(lp13933
sg21
I0
sba(iArchitecture
Entity
p13934
(dp13935
g11
(lp13936
sg13
S'com.google.common.base.Objects$1'
p13937
sg15
(lp13938
sg17
(lp13939
sg19
(lp13940
sg21
I0
sba(iArchitecture
Entity
p13941
(dp13942
g11
(lp13943
sg13
S'com.google.common.base.Objects$ToStringHelper'
p13944
sg15
(lp13945
sg17
(lp13946
sg19
(lp13947
sg21
I0
sba(iArchitecture
Entity
p13948
(dp13949
g11
(lp13950
sg13
S'com.google.common.base.Objects$ToStringHelper$ValueHolder'
p13951
sg15
(lp13952
sg17
(lp13953
sg19
(lp13954
sg21
I0
sba(iArchitecture
Entity
p13955
(dp13956
g11
(lp13957
sg13
S'com.google.common.base.Optional'
p13958
sg15
(lp13959
sg17
(lp13960
sg19
(lp13961
sg21
I0
sba(iArchitecture
Entity
p13962
(dp13963
g11
(lp13964
sg13
S'com.google.common.base.Optional$1'
p13965
sg15
(lp13966
sg17
(lp13967
sg19
(lp13968
sg21
I0
sba(iArchitecture
Entity
p13969
(dp13970
g11
(lp13971
sg13
S'com.google.common.base.Optional$1$1'
p13972
sg15
(lp13973
sg17
(lp13974
sg19
(lp13975
sg21
I0
sba(iArchitecture
Entity
p13976
(dp13977
g11
(lp13978
sg13
S'com.google.common.base.PairwiseEquivalence'
p13979
sg15
(lp13980
sg17
(lp13981
sg19
(lp13982
sg21
I0
sba(iArchitecture
Entity
p13983
(dp13984
g11
(lp13985
sg13
S'com.google.common.base.PatternCompiler'
p13986
sg15
(lp13987
sg17
(lp13988
sg19
(lp13989
sg21
I0
sba(iArchitecture
Entity
p13990
(dp13991
g11
(lp13992
sg13
S'com.google.common.base.Platform'
p13993
sg15
(lp13994
sg17
(lp13995
sg19
(lp13996
sg21
I0
sba(iArchitecture
Entity
p13997
(dp13998
g11
(lp13999
sg13
S'com.google.common.base.Platform$1'
p14000
sg15
(lp14001
sg17
(lp14002
sg19
(lp14003
sg21
I0
sba(iArchitecture
Entity
p14004
(dp14005
g11
(lp14006
sg13
S'com.google.common.base.Platform$JdkPatternCompiler'
p14007
sg15
(lp14008
sg17
(lp14009
sg19
(lp14010
sg21
I0
sba(iArchitecture
Entity
p14011
(dp14012
g11
(lp14013
sg13
S'com.google.common.base.Predicate'
p14014
sg15
(lp14015
sg17
(lp14016
sg19
(lp14017
sg21
I0
sba(iArchitecture
Entity
p14018
(dp14019
g11
(lp14020
sg13
S'com.google.common.base.Predicates'
p14021
sg15
(lp14022
sg17
(lp14023
sg19
(lp14024
sg21
I0
sba(iArchitecture
Entity
p14025
(dp14026
g11
(lp14027
sg13
S'com.google.common.base.Predicates$1'
p14028
sg15
(lp14029
sg17
(lp14030
sg19
(lp14031
sg21
I0
sba(iArchitecture
Entity
p14032
(dp14033
g11
(lp14034
sg13
S'com.google.common.base.Predicates$AndPredicate'
p14035
sg15
(lp14036
sg17
(lp14037
sg19
(lp14038
sg21
I0
sba(iArchitecture
Entity
p14039
(dp14040
g11
(lp14041
sg13
S'com.google.common.base.Predicates$CompositionPredicate'
p14042
sg15
(lp14043
sg17
(lp14044
sg19
(lp14045
sg21
I0
sba(iArchitecture
Entity
p14046
(dp14047
g11
(lp14048
sg13
S'com.google.common.base.Predicates$ContainsPatternFromStringPredicate'
p14049
sg15
(lp14050
sg17
(lp14051
sg19
(lp14052
sg21
I0
sba(iArchitecture
Entity
p14053
(dp14054
g11
(lp14055
sg13
S'com.google.common.base.Predicates$ContainsPatternPredicate'
p14056
sg15
(lp14057
sg17
(lp14058
sg19
(lp14059
sg21
I0
sba(iArchitecture
Entity
p14060
(dp14061
g11
(lp14062
sg13
S'com.google.common.base.Predicates$InPredicate'
p14063
sg15
(lp14064
sg17
(lp14065
sg19
(lp14066
sg21
I0
sba(iArchitecture
Entity
p14067
(dp14068
g11
(lp14069
sg13
S'com.google.common.base.Predicates$InstanceOfPredicate'
p14070
sg15
(lp14071
sg17
(lp14072
sg19
(lp14073
sg21
I0
sba(iArchitecture
Entity
p14074
(dp14075
g11
(lp14076
sg13
S'com.google.common.base.Predicates$IsEqualToPredicate'
p14077
sg15
(lp14078
sg17
(lp14079
sg19
(lp14080
sg21
I0
sba(iArchitecture
Entity
p14081
(dp14082
g11
(lp14083
sg13
S'com.google.common.base.Predicates$NotPredicate'
p14084
sg15
(lp14085
sg17
(lp14086
sg19
(lp14087
sg21
I0
sba(iArchitecture
Entity
p14088
(dp14089
g11
(lp14090
sg13
S'com.google.common.base.Predicates$ObjectPredicate'
p14091
sg15
(lp14092
sg17
(lp14093
sg19
(lp14094
sg21
I0
sba(iArchitecture
Entity
p14095
(dp14096
g11
(lp14097
sg13
S'com.google.common.base.Predicates$ObjectPredicate$1'
p14098
sg15
(lp14099
sg17
(lp14100
sg19
(lp14101
sg21
I0
sba(iArchitecture
Entity
p14102
(dp14103
g11
(lp14104
sg13
S'com.google.common.base.Predicates$ObjectPredicate$2'
p14105
sg15
(lp14106
sg17
(lp14107
sg19
(lp14108
sg21
I0
sba(iArchitecture
Entity
p14109
(dp14110
g11
(lp14111
sg13
S'com.google.common.base.Predicates$ObjectPredicate$3'
p14112
sg15
(lp14113
sg17
(lp14114
sg19
(lp14115
sg21
I0
sba(iArchitecture
Entity
p14116
(dp14117
g11
(lp14118
sg13
S'com.google.common.base.Predicates$ObjectPredicate$4'
p14119
sg15
(lp14120
sg17
(lp14121
sg19
(lp14122
sg21
I0
sba(iArchitecture
Entity
p14123
(dp14124
g11
(lp14125
sg13
S'com.google.common.base.Predicates$OrPredicate'
p14126
sg15
(lp14127
sg17
(lp14128
sg19
(lp14129
sg21
I0
sba(iArchitecture
Entity
p14130
(dp14131
g11
(lp14132
sg13
S'com.google.common.base.Predicates$SubtypeOfPredicate'
p14133
sg15
(lp14134
sg17
(lp14135
sg19
(lp14136
sg21
I0
sba(iArchitecture
Entity
p14137
(dp14138
g11
(lp14139
sg13
S'com.google.common.base.Present'
p14140
sg15
(lp14141
sg17
(lp14142
sg19
(lp14143
sg21
I0
sba(iArchitecture
Entity
p14144
(dp14145
g11
(lp14146
sg13
S'com.google.common.base.SmallCharMatcher'
p14147
sg15
(lp14148
sg17
(lp14149
sg19
(lp14150
sg21
I0
sba(iArchitecture
Entity
p14151
(dp14152
g11
(lp14153
sg13
S'com.google.common.base.Splitter'
p14154
sg15
(lp14155
sg17
(lp14156
sg19
(lp14157
sg21
I0
sba(iArchitecture
Entity
p14158
(dp14159
g11
(lp14160
sg13
S'com.google.common.base.Splitter$1'
p14161
sg15
(lp14162
sg17
(lp14163
sg19
(lp14164
sg21
I0
sba(iArchitecture
Entity
p14165
(dp14166
g11
(lp14167
sg13
S'com.google.common.base.Splitter$1$1'
p14168
sg15
(lp14169
sg17
(lp14170
sg19
(lp14171
sg21
I0
sba(iArchitecture
Entity
p14172
(dp14173
g11
(lp14174
sg13
S'com.google.common.base.Splitter$2'
p14175
sg15
(lp14176
sg17
(lp14177
sg19
(lp14178
sg21
I0
sba(iArchitecture
Entity
p14179
(dp14180
g11
(lp14181
sg13
S'com.google.common.base.Splitter$2$1'
p14182
sg15
(lp14183
sg17
(lp14184
sg19
(lp14185
sg21
I0
sba(iArchitecture
Entity
p14186
(dp14187
g11
(lp14188
sg13
S'com.google.common.base.Splitter$3'
p14189
sg15
(lp14190
sg17
(lp14191
sg19
(lp14192
sg21
I0
sba(iArchitecture
Entity
p14193
(dp14194
g11
(lp14195
sg13
S'com.google.common.base.Splitter$3$1'
p14196
sg15
(lp14197
sg17
(lp14198
sg19
(lp14199
sg21
I0
sba(iArchitecture
Entity
p14200
(dp14201
g11
(lp14202
sg13
S'com.google.common.base.Splitter$4'
p14203
sg15
(lp14204
sg17
(lp14205
sg19
(lp14206
sg21
I0
sba(iArchitecture
Entity
p14207
(dp14208
g11
(lp14209
sg13
S'com.google.common.base.Splitter$4$1'
p14210
sg15
(lp14211
sg17
(lp14212
sg19
(lp14213
sg21
I0
sba(iArchitecture
Entity
p14214
(dp14215
g11
(lp14216
sg13
S'com.google.common.base.Splitter$5'
p14217
sg15
(lp14218
sg17
(lp14219
sg19
(lp14220
sg21
I0
sba(iArchitecture
Entity
p14221
(dp14222
g11
(lp14223
sg13
S'com.google.common.base.Splitter$MapSplitter'
p14224
sg15
(lp14225
sg17
(lp14226
sg19
(lp14227
sg21
I0
sba(iArchitecture
Entity
p14228
(dp14229
g11
(lp14230
sg13
S'com.google.common.base.Splitter$SplittingIterator'
p14231
sg15
(lp14232
sg17
(lp14233
sg19
(lp14234
sg21
I0
sba(iArchitecture
Entity
p14235
(dp14236
g11
(lp14237
sg13
S'com.google.common.base.Splitter$Strategy'
p14238
sg15
(lp14239
sg17
(lp14240
sg19
(lp14241
sg21
I0
sba(iArchitecture
Entity
p14242
(dp14243
g11
(lp14244
sg13
S'com.google.common.base.StandardSystemProperty'
p14245
sg15
(lp14246
sg17
(lp14247
sg19
(lp14248
sg21
I0
sba(iArchitecture
Entity
p14249
(dp14250
g11
(lp14251
sg13
S'com.google.common.base.Stopwatch'
p14252
sg15
(lp14253
sg17
(lp14254
sg19
(lp14255
sg21
I0
sba(iArchitecture
Entity
p14256
(dp14257
g11
(lp14258
sg13
S'com.google.common.base.Stopwatch$1'
p14259
sg15
(lp14260
sg17
(lp14261
sg19
(lp14262
sg21
I0
sba(iArchitecture
Entity
p14263
(dp14264
g11
(lp14265
sg13
S'com.google.common.base.Suppliers'
p14266
sg15
(lp14267
sg17
(lp14268
sg19
(lp14269
sg21
I0
sba(iArchitecture
Entity
p14270
(dp14271
g11
(lp14272
sg13
S'com.google.common.base.Suppliers$ExpiringMemoizingSupplier'
p14273
sg15
(lp14274
sg17
(lp14275
sg19
(lp14276
sg21
I0
sba(iArchitecture
Entity
p14277
(dp14278
g11
(lp14279
sg13
S'com.google.common.base.Suppliers$MemoizingSupplier'
p14280
sg15
(lp14281
sg17
(lp14282
sg19
(lp14283
sg21
I0
sba(iArchitecture
Entity
p14284
(dp14285
g11
(lp14286
sg13
S'com.google.common.base.Suppliers$SupplierComposition'
p14287
sg15
(lp14288
sg17
(lp14289
sg19
(lp14290
sg21
I0
sba(iArchitecture
Entity
p14291
(dp14292
g11
(lp14293
sg13
S'com.google.common.base.Suppliers$SupplierFunction'
p14294
sg15
(lp14295
sg17
(lp14296
sg19
(lp14297
sg21
I0
sba(iArchitecture
Entity
p14298
(dp14299
g11
(lp14300
sg13
S'com.google.common.base.Suppliers$SupplierFunctionImpl'
p14301
sg15
(lp14302
sg17
(lp14303
sg19
(lp14304
sg21
I0
sba(iArchitecture
Entity
p14305
(dp14306
g11
(lp14307
sg13
S'com.google.common.base.Suppliers$SupplierOfInstance'
p14308
sg15
(lp14309
sg17
(lp14310
sg19
(lp14311
sg21
I0
sba(iArchitecture
Entity
p14312
(dp14313
g11
(lp14314
sg13
S'com.google.common.base.Suppliers$ThreadSafeSupplier'
p14315
sg15
(lp14316
sg17
(lp14317
sg19
(lp14318
sg21
I0
sba(iArchitecture
Entity
p14319
(dp14320
g11
(lp14321
sg13
S'com.google.common.base.Throwables'
p14322
sg15
(lp14323
sg17
(lp14324
sg19
(lp14325
sg21
I0
sba(iArchitecture
Entity
p14326
(dp14327
g11
(lp14328
sg13
S'com.google.common.base.Throwables$1'
p14329
sg15
(lp14330
sg17
(lp14331
sg19
(lp14332
sg21
I0
sba(iArchitecture
Entity
p14333
(dp14334
g11
(lp14335
sg13
S'com.google.common.base.Ticker'
p14336
sg15
(lp14337
sg17
(lp14338
sg19
(lp14339
sg21
I0
sba(iArchitecture
Entity
p14340
(dp14341
g11
(lp14342
sg13
S'com.google.common.base.Ticker$1'
p14343
sg15
(lp14344
sg17
(lp14345
sg19
(lp14346
sg21
I0
sba(iArchitecture
Entity
p14347
(dp14348
g11
(lp14349
sg13
S'com.google.common.base.Verify'
p14350
sg15
(lp14351
sg17
(lp14352
sg19
(lp14353
sg21
I0
sba(iArchitecture
Entity
p14354
(dp14355
g11
(lp14356
sg13
S'com.google.common.base.VerifyException'
p14357
sg15
(lp14358
sg17
(lp14359
sg19
(lp14360
sg21
I0
sba(iArchitecture
Entity
p14361
(dp14362
g11
(lp14363
sg13
S'com.google.common.io.Flushables'
p14364
sg15
(lp14365
sg17
(lp14366
sg19
(lp14367
sg21
I0
sba(iArchitecture
Entity
p14368
(dp14369
g11
(lp14370
sg13
S'com.google.common.util.concurrent.AtomicDouble'
p14371
sg15
(lp14372
sg17
(lp14373
sg19
(lp14374
sg21
I0
sba(iArchitecture
Entity
p14375
(dp14376
g11
(lp14377
sg13
S'com.google.common.util.concurrent.AtomicDoubleArray'
p14378
sg15
(lp14379
sg17
(lp14380
sg19
(lp14381
sg21
I0
sba(iArchitecture
Entity
p14382
(dp14383
g11
(lp14384
sg13
S'com.google.common.util.concurrent.Atomics'
p14385
sg15
(lp14386
sg17
(lp14387
sg19
(lp14388
sg21
I0
sba(iArchitecture
Entity
p14389
(dp14390
g11
(lp14391
sg13
S'com.google.common.util.concurrent.ForwardingBlockingQueue'
p14392
sg15
(lp14393
sg17
(lp14394
sg19
(lp14395
sg21
I0
sbasg1135
(lp14396
g13279
ag13286
ag13293
ag13300
ag13307
ag13314
ag13321
ag13328
ag13335
ag13342
ag13349
ag13356
ag13363
ag13370
ag13377
ag13384
ag13391
ag13398
ag13405
ag13412
ag13419
ag13426
ag13433
ag13440
ag13447
ag13454
ag13461
ag13468
ag13475
ag13482
ag13489
ag13496
ag13503
ag13510
ag13517
ag13524
ag13531
ag13538
ag13545
ag13552
ag13559
ag13566
ag13573
ag13580
ag13587
ag13594
ag13601
ag13608
ag13615
ag13622
ag13629
ag13636
ag13643
ag13650
ag13657
ag13664
ag13671
ag13678
ag13685
ag13692
ag13699
ag13706
ag13713
ag13720
ag13727
ag13734
ag13741
ag13748
ag13755
ag13762
ag13769
ag13776
ag13783
ag13790
ag13797
ag13804
ag13811
ag13818
ag13825
ag13832
ag13839
ag13846
ag13853
ag13860
ag13867
ag13874
ag13881
ag13888
ag13895
ag13902
ag13909
ag13916
ag13923
ag13930
ag13937
ag13944
ag13951
ag13958
ag13965
ag13972
ag13979
ag13986
ag13993
ag14000
ag14007
ag14014
ag14021
ag14028
ag14035
ag14042
ag14049
ag14056
ag14063
ag14070
ag14077
ag14084
ag14091
ag14098
ag14105
ag14112
ag14119
ag14126
ag14133
ag14140
ag14147
ag14154
ag14161
ag14168
ag14175
ag14182
ag14189
ag14196
ag14203
ag14210
ag14217
ag14224
ag14231
ag14238
ag14245
ag14252
ag14259
ag14266
ag14273
ag14280
ag14287
ag14294
ag14301
ag14308
ag14315
ag14322
ag14329
ag14336
ag14343
ag14350
ag14357
ag14364
ag14371
ag14378
ag14385
ag14392
asg1137
I0
sg21
I0
sg1138
S'com.google.common.base.ss'
p14397
sba(iArchitecture
Cluster
p14398
(dp14399
g7
(lp14400
(iArchitecture
Entity
p14401
(dp14402
g11
(lp14403
sg13
S'com.google.common.base.Defaults'
p14404
sg15
(lp14405
sg17
(lp14406
sg19
(lp14407
sg21
I0
sba(iArchitecture
Entity
p14408
(dp14409
g11
(lp14410
sg13
S'com.google.common.base.Preconditions'
p14411
sg15
(lp14412
sg17
(lp14413
sg19
(lp14414
sg21
I0
sba(iArchitecture
Entity
p14415
(dp14416
g11
(lp14417
sg13
S'com.google.common.base.Utf8'
p14418
sg15
(lp14419
sg17
(lp14420
sg19
(lp14421
sg21
I0
sba(iArchitecture
Entity
p14422
(dp14423
g11
(lp14424
sg13
S'com.google.common.cache.AbstractCache'
p14425
sg15
(lp14426
sg17
(lp14427
sg19
(lp14428
sg21
I0
sba(iArchitecture
Entity
p14429
(dp14430
g11
(lp14431
sg13
S'com.google.common.cache.AbstractCache$SimpleStatsCounter'
p14432
sg15
(lp14433
sg17
(lp14434
sg19
(lp14435
sg21
I0
sba(iArchitecture
Entity
p14436
(dp14437
g11
(lp14438
sg13
S'com.google.common.cache.AbstractCache$StatsCounter'
p14439
sg15
(lp14440
sg17
(lp14441
sg19
(lp14442
sg21
I0
sba(iArchitecture
Entity
p14443
(dp14444
g11
(lp14445
sg13
S'com.google.common.cache.Cache'
p14446
sg15
(lp14447
sg17
(lp14448
sg19
(lp14449
sg21
I0
sba(iArchitecture
Entity
p14450
(dp14451
g11
(lp14452
sg13
S'com.google.common.cache.CacheBuilder'
p14453
sg15
(lp14454
sg17
(lp14455
sg19
(lp14456
sg21
I0
sba(iArchitecture
Entity
p14457
(dp14458
g11
(lp14459
sg13
S'com.google.common.cache.CacheBuilder$1'
p14460
sg15
(lp14461
sg17
(lp14462
sg19
(lp14463
sg21
I0
sba(iArchitecture
Entity
p14464
(dp14465
g11
(lp14466
sg13
S'com.google.common.cache.CacheBuilder$2'
p14467
sg15
(lp14468
sg17
(lp14469
sg19
(lp14470
sg21
I0
sba(iArchitecture
Entity
p14471
(dp14472
g11
(lp14473
sg13
S'com.google.common.cache.CacheBuilder$3'
p14474
sg15
(lp14475
sg17
(lp14476
sg19
(lp14477
sg21
I0
sba(iArchitecture
Entity
p14478
(dp14479
g11
(lp14480
sg13
S'com.google.common.cache.CacheBuilder$NullListener'
p14481
sg15
(lp14482
sg17
(lp14483
sg19
(lp14484
sg21
I0
sba(iArchitecture
Entity
p14485
(dp14486
g11
(lp14487
sg13
S'com.google.common.cache.CacheBuilder$OneWeigher'
p14488
sg15
(lp14489
sg17
(lp14490
sg19
(lp14491
sg21
I0
sba(iArchitecture
Entity
p14492
(dp14493
g11
(lp14494
sg13
S'com.google.common.cache.CacheBuilderSpec'
p14495
sg15
(lp14496
sg17
(lp14497
sg19
(lp14498
sg21
I0
sba(iArchitecture
Entity
p14499
(dp14500
g11
(lp14501
sg13
S'com.google.common.cache.CacheBuilderSpec$1'
p14502
sg15
(lp14503
sg17
(lp14504
sg19
(lp14505
sg21
I0
sba(iArchitecture
Entity
p14506
(dp14507
g11
(lp14508
sg13
S'com.google.common.cache.CacheBuilderSpec$AccessDurationParser'
p14509
sg15
(lp14510
sg17
(lp14511
sg19
(lp14512
sg21
I0
sba(iArchitecture
Entity
p14513
(dp14514
g11
(lp14515
sg13
S'com.google.common.cache.CacheBuilderSpec$ConcurrencyLevelParser'
p14516
sg15
(lp14517
sg17
(lp14518
sg19
(lp14519
sg21
I0
sba(iArchitecture
Entity
p14520
(dp14521
g11
(lp14522
sg13
S'com.google.common.cache.CacheBuilderSpec$DurationParser'
p14523
sg15
(lp14524
sg17
(lp14525
sg19
(lp14526
sg21
I0
sba(iArchitecture
Entity
p14527
(dp14528
g11
(lp14529
sg13
S'com.google.common.cache.CacheBuilderSpec$InitialCapacityParser'
p14530
sg15
(lp14531
sg17
(lp14532
sg19
(lp14533
sg21
I0
sba(iArchitecture
Entity
p14534
(dp14535
g11
(lp14536
sg13
S'com.google.common.cache.CacheBuilderSpec$IntegerParser'
p14537
sg15
(lp14538
sg17
(lp14539
sg19
(lp14540
sg21
I0
sba(iArchitecture
Entity
p14541
(dp14542
g11
(lp14543
sg13
S'com.google.common.cache.CacheBuilderSpec$KeyStrengthParser'
p14544
sg15
(lp14545
sg17
(lp14546
sg19
(lp14547
sg21
I0
sba(iArchitecture
Entity
p14548
(dp14549
g11
(lp14550
sg13
S'com.google.common.cache.CacheBuilderSpec$LongParser'
p14551
sg15
(lp14552
sg17
(lp14553
sg19
(lp14554
sg21
I0
sba(iArchitecture
Entity
p14555
(dp14556
g11
(lp14557
sg13
S'com.google.common.cache.CacheBuilderSpec$MaximumSizeParser'
p14558
sg15
(lp14559
sg17
(lp14560
sg19
(lp14561
sg21
I0
sba(iArchitecture
Entity
p14562
(dp14563
g11
(lp14564
sg13
S'com.google.common.cache.CacheBuilderSpec$MaximumWeightParser'
p14565
sg15
(lp14566
sg17
(lp14567
sg19
(lp14568
sg21
I0
sba(iArchitecture
Entity
p14569
(dp14570
g11
(lp14571
sg13
S'com.google.common.cache.CacheBuilderSpec$RecordStatsParser'
p14572
sg15
(lp14573
sg17
(lp14574
sg19
(lp14575
sg21
I0
sba(iArchitecture
Entity
p14576
(dp14577
g11
(lp14578
sg13
S'com.google.common.cache.CacheBuilderSpec$RefreshDurationParser'
p14579
sg15
(lp14580
sg17
(lp14581
sg19
(lp14582
sg21
I0
sba(iArchitecture
Entity
p14583
(dp14584
g11
(lp14585
sg13
S'com.google.common.cache.CacheBuilderSpec$ValueParser'
p14586
sg15
(lp14587
sg17
(lp14588
sg19
(lp14589
sg21
I0
sba(iArchitecture
Entity
p14590
(dp14591
g11
(lp14592
sg13
S'com.google.common.cache.CacheBuilderSpec$ValueStrengthParser'
p14593
sg15
(lp14594
sg17
(lp14595
sg19
(lp14596
sg21
I0
sba(iArchitecture
Entity
p14597
(dp14598
g11
(lp14599
sg13
S'com.google.common.cache.CacheBuilderSpec$WriteDurationParser'
p14600
sg15
(lp14601
sg17
(lp14602
sg19
(lp14603
sg21
I0
sba(iArchitecture
Entity
p14604
(dp14605
g11
(lp14606
sg13
S'com.google.common.cache.CacheLoader'
p14607
sg15
(lp14608
sg17
(lp14609
sg19
(lp14610
sg21
I0
sba(iArchitecture
Entity
p14611
(dp14612
g11
(lp14613
sg13
S'com.google.common.cache.CacheLoader$1'
p14614
sg15
(lp14615
sg17
(lp14616
sg19
(lp14617
sg21
I0
sba(iArchitecture
Entity
p14618
(dp14619
g11
(lp14620
sg13
S'com.google.common.cache.CacheLoader$1$1'
p14621
sg15
(lp14622
sg17
(lp14623
sg19
(lp14624
sg21
I0
sba(iArchitecture
Entity
p14625
(dp14626
g11
(lp14627
sg13
S'com.google.common.cache.CacheLoader$FunctionToCacheLoader'
p14628
sg15
(lp14629
sg17
(lp14630
sg19
(lp14631
sg21
I0
sba(iArchitecture
Entity
p14632
(dp14633
g11
(lp14634
sg13
S'com.google.common.cache.CacheLoader$InvalidCacheLoadException'
p14635
sg15
(lp14636
sg17
(lp14637
sg19
(lp14638
sg21
I0
sba(iArchitecture
Entity
p14639
(dp14640
g11
(lp14641
sg13
S'com.google.common.cache.CacheLoader$SupplierToCacheLoader'
p14642
sg15
(lp14643
sg17
(lp14644
sg19
(lp14645
sg21
I0
sba(iArchitecture
Entity
p14646
(dp14647
g11
(lp14648
sg13
S'com.google.common.cache.CacheLoader$UnsupportedLoadingOperationException'
p14649
sg15
(lp14650
sg17
(lp14651
sg19
(lp14652
sg21
I0
sba(iArchitecture
Entity
p14653
(dp14654
g11
(lp14655
sg13
S'com.google.common.cache.CacheStats'
p14656
sg15
(lp14657
sg17
(lp14658
sg19
(lp14659
sg21
I0
sba(iArchitecture
Entity
p14660
(dp14661
g11
(lp14662
sg13
S'com.google.common.cache.ForwardingCache'
p14663
sg15
(lp14664
sg17
(lp14665
sg19
(lp14666
sg21
I0
sba(iArchitecture
Entity
p14667
(dp14668
g11
(lp14669
sg13
S'com.google.common.cache.ForwardingCache$SimpleForwardingCache'
p14670
sg15
(lp14671
sg17
(lp14672
sg19
(lp14673
sg21
I0
sba(iArchitecture
Entity
p14674
(dp14675
g11
(lp14676
sg13
S'com.google.common.cache.ForwardingLoadingCache'
p14677
sg15
(lp14678
sg17
(lp14679
sg19
(lp14680
sg21
I0
sba(iArchitecture
Entity
p14681
(dp14682
g11
(lp14683
sg13
S'com.google.common.cache.ForwardingLoadingCache$SimpleForwardingLoadingCache'
p14684
sg15
(lp14685
sg17
(lp14686
sg19
(lp14687
sg21
I0
sba(iArchitecture
Entity
p14688
(dp14689
g11
(lp14690
sg13
S'com.google.common.cache.LoadingCache'
p14691
sg15
(lp14692
sg17
(lp14693
sg19
(lp14694
sg21
I0
sba(iArchitecture
Entity
p14695
(dp14696
g11
(lp14697
sg13
S'com.google.common.cache.LocalCache'
p14698
sg15
(lp14699
sg17
(lp14700
sg19
(lp14701
sg21
I0
sba(iArchitecture
Entity
p14702
(dp14703
g11
(lp14704
sg13
S'com.google.common.cache.LocalCache$1'
p14705
sg15
(lp14706
sg17
(lp14707
sg19
(lp14708
sg21
I0
sba(iArchitecture
Entity
p14709
(dp14710
g11
(lp14711
sg13
S'com.google.common.cache.LocalCache$2'
p14712
sg15
(lp14713
sg17
(lp14714
sg19
(lp14715
sg21
I0
sba(iArchitecture
Entity
p14716
(dp14717
g11
(lp14718
sg13
S'com.google.common.cache.LocalCache$AbstractCacheSet'
p14719
sg15
(lp14720
sg17
(lp14721
sg19
(lp14722
sg21
I0
sba(iArchitecture
Entity
p14723
(dp14724
g11
(lp14725
sg13
S'com.google.common.cache.LocalCache$AbstractReferenceEntry'
p14726
sg15
(lp14727
sg17
(lp14728
sg19
(lp14729
sg21
I0
sba(iArchitecture
Entity
p14730
(dp14731
g11
(lp14732
sg13
S'com.google.common.cache.LocalCache$AccessQueue'
p14733
sg15
(lp14734
sg17
(lp14735
sg19
(lp14736
sg21
I0
sba(iArchitecture
Entity
p14737
(dp14738
g11
(lp14739
sg13
S'com.google.common.cache.LocalCache$AccessQueue$1'
p14740
sg15
(lp14741
sg17
(lp14742
sg19
(lp14743
sg21
I0
sba(iArchitecture
Entity
p14744
(dp14745
g11
(lp14746
sg13
S'com.google.common.cache.LocalCache$AccessQueue$2'
p14747
sg15
(lp14748
sg17
(lp14749
sg19
(lp14750
sg21
I0
sba(iArchitecture
Entity
p14751
(dp14752
g11
(lp14753
sg13
S'com.google.common.cache.LocalCache$EntryFactory'
p14754
sg15
(lp14755
sg17
(lp14756
sg19
(lp14757
sg21
I0
sba(iArchitecture
Entity
p14758
(dp14759
g11
(lp14760
sg13
S'com.google.common.cache.LocalCache$EntryFactory$1'
p14761
sg15
(lp14762
sg17
(lp14763
sg19
(lp14764
sg21
I0
sba(iArchitecture
Entity
p14765
(dp14766
g11
(lp14767
sg13
S'com.google.common.cache.LocalCache$EntryFactory$2'
p14768
sg15
(lp14769
sg17
(lp14770
sg19
(lp14771
sg21
I0
sba(iArchitecture
Entity
p14772
(dp14773
g11
(lp14774
sg13
S'com.google.common.cache.LocalCache$EntryFactory$3'
p14775
sg15
(lp14776
sg17
(lp14777
sg19
(lp14778
sg21
I0
sba(iArchitecture
Entity
p14779
(dp14780
g11
(lp14781
sg13
S'com.google.common.cache.LocalCache$EntryFactory$4'
p14782
sg15
(lp14783
sg17
(lp14784
sg19
(lp14785
sg21
I0
sba(iArchitecture
Entity
p14786
(dp14787
g11
(lp14788
sg13
S'com.google.common.cache.LocalCache$EntryFactory$5'
p14789
sg15
(lp14790
sg17
(lp14791
sg19
(lp14792
sg21
I0
sba(iArchitecture
Entity
p14793
(dp14794
g11
(lp14795
sg13
S'com.google.common.cache.LocalCache$EntryFactory$6'
p14796
sg15
(lp14797
sg17
(lp14798
sg19
(lp14799
sg21
I0
sba(iArchitecture
Entity
p14800
(dp14801
g11
(lp14802
sg13
S'com.google.common.cache.LocalCache$EntryFactory$7'
p14803
sg15
(lp14804
sg17
(lp14805
sg19
(lp14806
sg21
I0
sba(iArchitecture
Entity
p14807
(dp14808
g11
(lp14809
sg13
S'com.google.common.cache.LocalCache$EntryFactory$8'
p14810
sg15
(lp14811
sg17
(lp14812
sg19
(lp14813
sg21
I0
sba(iArchitecture
Entity
p14814
(dp14815
g11
(lp14816
sg13
S'com.google.common.cache.LocalCache$EntryIterator'
p14817
sg15
(lp14818
sg17
(lp14819
sg19
(lp14820
sg21
I0
sba(iArchitecture
Entity
p14821
(dp14822
g11
(lp14823
sg13
S'com.google.common.cache.LocalCache$EntrySet'
p14824
sg15
(lp14825
sg17
(lp14826
sg19
(lp14827
sg21
I0
sba(iArchitecture
Entity
p14828
(dp14829
g11
(lp14830
sg13
S'com.google.common.cache.LocalCache$HashIterator'
p14831
sg15
(lp14832
sg17
(lp14833
sg19
(lp14834
sg21
I0
sba(iArchitecture
Entity
p14835
(dp14836
g11
(lp14837
sg13
S'com.google.common.cache.LocalCache$KeyIterator'
p14838
sg15
(lp14839
sg17
(lp14840
sg19
(lp14841
sg21
I0
sba(iArchitecture
Entity
p14842
(dp14843
g11
(lp14844
sg13
S'com.google.common.cache.LocalCache$KeySet'
p14845
sg15
(lp14846
sg17
(lp14847
sg19
(lp14848
sg21
I0
sba(iArchitecture
Entity
p14849
(dp14850
g11
(lp14851
sg13
S'com.google.common.cache.LocalCache$LoadingSerializationProxy'
p14852
sg15
(lp14853
sg17
(lp14854
sg19
(lp14855
sg21
I0
sba(iArchitecture
Entity
p14856
(dp14857
g11
(lp14858
sg13
S'com.google.common.cache.LocalCache$LoadingValueReference'
p14859
sg15
(lp14860
sg17
(lp14861
sg19
(lp14862
sg21
I0
sba(iArchitecture
Entity
p14863
(dp14864
g11
(lp14865
sg13
S'com.google.common.cache.LocalCache$LoadingValueReference$1'
p14866
sg15
(lp14867
sg17
(lp14868
sg19
(lp14869
sg21
I0
sba(iArchitecture
Entity
p14870
(dp14871
g11
(lp14872
sg13
S'com.google.common.cache.LocalCache$LocalLoadingCache'
p14873
sg15
(lp14874
sg17
(lp14875
sg19
(lp14876
sg21
I0
sba(iArchitecture
Entity
p14877
(dp14878
g11
(lp14879
sg13
S'com.google.common.cache.LocalCache$LocalManualCache'
p14880
sg15
(lp14881
sg17
(lp14882
sg19
(lp14883
sg21
I0
sba(iArchitecture
Entity
p14884
(dp14885
g11
(lp14886
sg13
S'com.google.common.cache.LocalCache$LocalManualCache$1'
p14887
sg15
(lp14888
sg17
(lp14889
sg19
(lp14890
sg21
I0
sba(iArchitecture
Entity
p14891
(dp14892
g11
(lp14893
sg13
S'com.google.common.cache.LocalCache$ManualSerializationProxy'
p14894
sg15
(lp14895
sg17
(lp14896
sg19
(lp14897
sg21
I0
sba(iArchitecture
Entity
p14898
(dp14899
g11
(lp14900
sg13
S'com.google.common.cache.LocalCache$NullEntry'
p14901
sg15
(lp14902
sg17
(lp14903
sg19
(lp14904
sg21
I0
sba(iArchitecture
Entity
p14905
(dp14906
g11
(lp14907
sg13
S'com.google.common.cache.LocalCache$ReferenceEntry'
p14908
sg15
(lp14909
sg17
(lp14910
sg19
(lp14911
sg21
I0
sba(iArchitecture
Entity
p14912
(dp14913
g11
(lp14914
sg13
S'com.google.common.cache.LocalCache$Segment'
p14915
sg15
(lp14916
sg17
(lp14917
sg19
(lp14918
sg21
I0
sba(iArchitecture
Entity
p14919
(dp14920
g11
(lp14921
sg13
S'com.google.common.cache.LocalCache$Segment$1'
p14922
sg15
(lp14923
sg17
(lp14924
sg19
(lp14925
sg21
I0
sba(iArchitecture
Entity
p14926
(dp14927
g11
(lp14928
sg13
S'com.google.common.cache.LocalCache$SoftValueReference'
p14929
sg15
(lp14930
sg17
(lp14931
sg19
(lp14932
sg21
I0
sba(iArchitecture
Entity
p14933
(dp14934
g11
(lp14935
sg13
S'com.google.common.cache.LocalCache$Strength'
p14936
sg15
(lp14937
sg17
(lp14938
sg19
(lp14939
sg21
I0
sba(iArchitecture
Entity
p14940
(dp14941
g11
(lp14942
sg13
S'com.google.common.cache.LocalCache$Strength$1'
p14943
sg15
(lp14944
sg17
(lp14945
sg19
(lp14946
sg21
I0
sba(iArchitecture
Entity
p14947
(dp14948
g11
(lp14949
sg13
S'com.google.common.cache.LocalCache$Strength$2'
p14950
sg15
(lp14951
sg17
(lp14952
sg19
(lp14953
sg21
I0
sba(iArchitecture
Entity
p14954
(dp14955
g11
(lp14956
sg13
S'com.google.common.cache.LocalCache$Strength$3'
p14957
sg15
(lp14958
sg17
(lp14959
sg19
(lp14960
sg21
I0
sba(iArchitecture
Entity
p14961
(dp14962
g11
(lp14963
sg13
S'com.google.common.cache.LocalCache$StrongAccessEntry'
p14964
sg15
(lp14965
sg17
(lp14966
sg19
(lp14967
sg21
I0
sba(iArchitecture
Entity
p14968
(dp14969
g11
(lp14970
sg13
S'com.google.common.cache.LocalCache$StrongAccessWriteEntry'
p14971
sg15
(lp14972
sg17
(lp14973
sg19
(lp14974
sg21
I0
sba(iArchitecture
Entity
p14975
(dp14976
g11
(lp14977
sg13
S'com.google.common.cache.LocalCache$StrongEntry'
p14978
sg15
(lp14979
sg17
(lp14980
sg19
(lp14981
sg21
I0
sba(iArchitecture
Entity
p14982
(dp14983
g11
(lp14984
sg13
S'com.google.common.cache.LocalCache$StrongValueReference'
p14985
sg15
(lp14986
sg17
(lp14987
sg19
(lp14988
sg21
I0
sba(iArchitecture
Entity
p14989
(dp14990
g11
(lp14991
sg13
S'com.google.common.cache.LocalCache$StrongWriteEntry'
p14992
sg15
(lp14993
sg17
(lp14994
sg19
(lp14995
sg21
I0
sba(iArchitecture
Entity
p14996
(dp14997
g11
(lp14998
sg13
S'com.google.common.cache.LocalCache$ValueIterator'
p14999
sg15
(lp15000
sg17
(lp15001
sg19
(lp15002
sg21
I0
sba(iArchitecture
Entity
p15003
(dp15004
g11
(lp15005
sg13
S'com.google.common.cache.LocalCache$ValueReference'
p15006
sg15
(lp15007
sg17
(lp15008
sg19
(lp15009
sg21
I0
sba(iArchitecture
Entity
p15010
(dp15011
g11
(lp15012
sg13
S'com.google.common.cache.LocalCache$Values'
p15013
sg15
(lp15014
sg17
(lp15015
sg19
(lp15016
sg21
I0
sba(iArchitecture
Entity
p15017
(dp15018
g11
(lp15019
sg13
S'com.google.common.cache.LocalCache$WeakAccessEntry'
p15020
sg15
(lp15021
sg17
(lp15022
sg19
(lp15023
sg21
I0
sba(iArchitecture
Entity
p15024
(dp15025
g11
(lp15026
sg13
S'com.google.common.cache.LocalCache$WeakAccessWriteEntry'
p15027
sg15
(lp15028
sg17
(lp15029
sg19
(lp15030
sg21
I0
sba(iArchitecture
Entity
p15031
(dp15032
g11
(lp15033
sg13
S'com.google.common.cache.LocalCache$WeakEntry'
p15034
sg15
(lp15035
sg17
(lp15036
sg19
(lp15037
sg21
I0
sba(iArchitecture
Entity
p15038
(dp15039
g11
(lp15040
sg13
S'com.google.common.cache.LocalCache$WeakValueReference'
p15041
sg15
(lp15042
sg17
(lp15043
sg19
(lp15044
sg21
I0
sba(iArchitecture
Entity
p15045
(dp15046
g11
(lp15047
sg13
S'com.google.common.cache.LocalCache$WeakWriteEntry'
p15048
sg15
(lp15049
sg17
(lp15050
sg19
(lp15051
sg21
I0
sba(iArchitecture
Entity
p15052
(dp15053
g11
(lp15054
sg13
S'com.google.common.cache.LocalCache$WeightedSoftValueReference'
p15055
sg15
(lp15056
sg17
(lp15057
sg19
(lp15058
sg21
I0
sba(iArchitecture
Entity
p15059
(dp15060
g11
(lp15061
sg13
S'com.google.common.cache.LocalCache$WeightedStrongValueReference'
p15062
sg15
(lp15063
sg17
(lp15064
sg19
(lp15065
sg21
I0
sba(iArchitecture
Entity
p15066
(dp15067
g11
(lp15068
sg13
S'com.google.common.cache.LocalCache$WeightedWeakValueReference'
p15069
sg15
(lp15070
sg17
(lp15071
sg19
(lp15072
sg21
I0
sba(iArchitecture
Entity
p15073
(dp15074
g11
(lp15075
sg13
S'com.google.common.cache.LocalCache$WriteQueue'
p15076
sg15
(lp15077
sg17
(lp15078
sg19
(lp15079
sg21
I0
sba(iArchitecture
Entity
p15080
(dp15081
g11
(lp15082
sg13
S'com.google.common.cache.LocalCache$WriteQueue$1'
p15083
sg15
(lp15084
sg17
(lp15085
sg19
(lp15086
sg21
I0
sba(iArchitecture
Entity
p15087
(dp15088
g11
(lp15089
sg13
S'com.google.common.cache.LocalCache$WriteQueue$2'
p15090
sg15
(lp15091
sg17
(lp15092
sg19
(lp15093
sg21
I0
sba(iArchitecture
Entity
p15094
(dp15095
g11
(lp15096
sg13
S'com.google.common.cache.LocalCache$WriteThroughEntry'
p15097
sg15
(lp15098
sg17
(lp15099
sg19
(lp15100
sg21
I0
sba(iArchitecture
Entity
p15101
(dp15102
g11
(lp15103
sg13
S'com.google.common.cache.LongAddable'
p15104
sg15
(lp15105
sg17
(lp15106
sg19
(lp15107
sg21
I0
sba(iArchitecture
Entity
p15108
(dp15109
g11
(lp15110
sg13
S'com.google.common.cache.LongAddables'
p15111
sg15
(lp15112
sg17
(lp15113
sg19
(lp15114
sg21
I0
sba(iArchitecture
Entity
p15115
(dp15116
g11
(lp15117
sg13
S'com.google.common.cache.LongAddables$1'
p15118
sg15
(lp15119
sg17
(lp15120
sg19
(lp15121
sg21
I0
sba(iArchitecture
Entity
p15122
(dp15123
g11
(lp15124
sg13
S'com.google.common.cache.LongAddables$2'
p15125
sg15
(lp15126
sg17
(lp15127
sg19
(lp15128
sg21
I0
sba(iArchitecture
Entity
p15129
(dp15130
g11
(lp15131
sg13
S'com.google.common.cache.LongAddables$PureJavaLongAddable'
p15132
sg15
(lp15133
sg17
(lp15134
sg19
(lp15135
sg21
I0
sba(iArchitecture
Entity
p15136
(dp15137
g11
(lp15138
sg13
S'com.google.common.cache.LongAdder'
p15139
sg15
(lp15140
sg17
(lp15141
sg19
(lp15142
sg21
I0
sba(iArchitecture
Entity
p15143
(dp15144
g11
(lp15145
sg13
S'com.google.common.cache.RemovalCause'
p15146
sg15
(lp15147
sg17
(lp15148
sg19
(lp15149
sg21
I0
sba(iArchitecture
Entity
p15150
(dp15151
g11
(lp15152
sg13
S'com.google.common.cache.RemovalCause$1'
p15153
sg15
(lp15154
sg17
(lp15155
sg19
(lp15156
sg21
I0
sba(iArchitecture
Entity
p15157
(dp15158
g11
(lp15159
sg13
S'com.google.common.cache.RemovalCause$2'
p15160
sg15
(lp15161
sg17
(lp15162
sg19
(lp15163
sg21
I0
sba(iArchitecture
Entity
p15164
(dp15165
g11
(lp15166
sg13
S'com.google.common.cache.RemovalCause$3'
p15167
sg15
(lp15168
sg17
(lp15169
sg19
(lp15170
sg21
I0
sba(iArchitecture
Entity
p15171
(dp15172
g11
(lp15173
sg13
S'com.google.common.cache.RemovalCause$4'
p15174
sg15
(lp15175
sg17
(lp15176
sg19
(lp15177
sg21
I0
sba(iArchitecture
Entity
p15178
(dp15179
g11
(lp15180
sg13
S'com.google.common.cache.RemovalCause$5'
p15181
sg15
(lp15182
sg17
(lp15183
sg19
(lp15184
sg21
I0
sba(iArchitecture
Entity
p15185
(dp15186
g11
(lp15187
sg13
S'com.google.common.cache.RemovalListener'
p15188
sg15
(lp15189
sg17
(lp15190
sg19
(lp15191
sg21
I0
sba(iArchitecture
Entity
p15192
(dp15193
g11
(lp15194
sg13
S'com.google.common.cache.RemovalListeners'
p15195
sg15
(lp15196
sg17
(lp15197
sg19
(lp15198
sg21
I0
sba(iArchitecture
Entity
p15199
(dp15200
g11
(lp15201
sg13
S'com.google.common.cache.RemovalListeners$1'
p15202
sg15
(lp15203
sg17
(lp15204
sg19
(lp15205
sg21
I0
sba(iArchitecture
Entity
p15206
(dp15207
g11
(lp15208
sg13
S'com.google.common.cache.RemovalListeners$1$1'
p15209
sg15
(lp15210
sg17
(lp15211
sg19
(lp15212
sg21
I0
sba(iArchitecture
Entity
p15213
(dp15214
g11
(lp15215
sg13
S'com.google.common.cache.RemovalNotification'
p15216
sg15
(lp15217
sg17
(lp15218
sg19
(lp15219
sg21
I0
sba(iArchitecture
Entity
p15220
(dp15221
g11
(lp15222
sg13
S'com.google.common.cache.Striped64'
p15223
sg15
(lp15224
sg17
(lp15225
sg19
(lp15226
sg21
I0
sba(iArchitecture
Entity
p15227
(dp15228
g11
(lp15229
sg13
S'com.google.common.cache.Striped64$1'
p15230
sg15
(lp15231
sg17
(lp15232
sg19
(lp15233
sg21
I0
sba(iArchitecture
Entity
p15234
(dp15235
g11
(lp15236
sg13
S'com.google.common.cache.Striped64$Cell'
p15237
sg15
(lp15238
sg17
(lp15239
sg19
(lp15240
sg21
I0
sba(iArchitecture
Entity
p15241
(dp15242
g11
(lp15243
sg13
S'com.google.common.cache.Weigher'
p15244
sg15
(lp15245
sg17
(lp15246
sg19
(lp15247
sg21
I0
sba(iArchitecture
Entity
p15248
(dp15249
g11
(lp15250
sg13
S'com.google.common.escape.ArrayBasedUnicodeEscaper'
p15251
sg15
(lp15252
sg17
(lp15253
sg19
(lp15254
sg21
I0
sba(iArchitecture
Entity
p15255
(dp15256
g11
(lp15257
sg13
S'com.google.common.hash.HashingInputStream'
p15258
sg15
(lp15259
sg17
(lp15260
sg19
(lp15261
sg21
I0
sba(iArchitecture
Entity
p15262
(dp15263
g11
(lp15264
sg13
S'com.google.common.hash.HashingOutputStream'
p15265
sg15
(lp15266
sg17
(lp15267
sg19
(lp15268
sg21
I0
sba(iArchitecture
Entity
p15269
(dp15270
g11
(lp15271
sg13
S'com.google.common.io.CountingInputStream'
p15272
sg15
(lp15273
sg17
(lp15274
sg19
(lp15275
sg21
I0
sba(iArchitecture
Entity
p15276
(dp15277
g11
(lp15278
sg13
S'com.google.common.io.CountingOutputStream'
p15279
sg15
(lp15280
sg17
(lp15281
sg19
(lp15282
sg21
I0
sba(iArchitecture
Entity
p15283
(dp15284
g11
(lp15285
sg13
S'com.google.common.io.PatternFilenameFilter'
p15286
sg15
(lp15287
sg17
(lp15288
sg19
(lp15289
sg21
I0
sba(iArchitecture
Entity
p15290
(dp15291
g11
(lp15292
sg13
S'com.google.common.primitives.UnsignedInteger'
p15293
sg15
(lp15294
sg17
(lp15295
sg19
(lp15296
sg21
I0
sba(iArchitecture
Entity
p15297
(dp15298
g11
(lp15299
sg13
S'com.google.common.util.concurrent.FakeTimeLimiter'
p15300
sg15
(lp15301
sg17
(lp15302
sg19
(lp15303
sg21
I0
sba(iArchitecture
Entity
p15304
(dp15305
g11
(lp15306
sg13
S'com.google.common.util.concurrent.ListenableFutureTask'
p15307
sg15
(lp15308
sg17
(lp15309
sg19
(lp15310
sg21
I0
sbasg1135
(lp15311
g14404
ag14411
ag14418
ag14425
ag14432
ag14439
ag14446
ag14453
ag14460
ag14467
ag14474
ag14481
ag14488
ag14495
ag14502
ag14509
ag14516
ag14523
ag14530
ag14537
ag14544
ag14551
ag14558
ag14565
ag14572
ag14579
ag14586
ag14593
ag14600
ag14607
ag14614
ag14621
ag14628
ag14635
ag14642
ag14649
ag14656
ag14663
ag14670
ag14677
ag14684
ag14691
ag14698
ag14705
ag14712
ag14719
ag14726
ag14733
ag14740
ag14747
ag14754
ag14761
ag14768
ag14775
ag14782
ag14789
ag14796
ag14803
ag14810
ag14817
ag14824
ag14831
ag14838
ag14845
ag14852
ag14859
ag14866
ag14873
ag14880
ag14887
ag14894
ag14901
ag14908
ag14915
ag14922
ag14929
ag14936
ag14943
ag14950
ag14957
ag14964
ag14971
ag14978
ag14985
ag14992
ag14999
ag15006
ag15013
ag15020
ag15027
ag15034
ag15041
ag15048
ag15055
ag15062
ag15069
ag15076
ag15083
ag15090
ag15097
ag15104
ag15111
ag15118
ag15125
ag15132
ag15139
ag15146
ag15153
ag15160
ag15167
ag15174
ag15181
ag15188
ag15195
ag15202
ag15209
ag15216
ag15223
ag15230
ag15237
ag15244
ag15251
ag15258
ag15265
ag15272
ag15279
ag15286
ag15293
ag15300
ag15307
asg1137
I0
sg21
I0
sg1138
S'com.google.common.cache.ss'
p15312
sba(iArchitecture
Cluster
p15313
(dp15314
g7
(lp15315
(iArchitecture
Entity
p15316
(dp15317
g11
(lp15318
sg13
S'com.google.common.annotations.GwtCompatible'
p15319
sg15
(lp15320
sg17
(lp15321
sg19
(lp15322
sg21
I0
sba(iArchitecture
Entity
p15323
(dp15324
g11
(lp15325
sg13
S'com.google.common.annotations.VisibleForTesting'
p15326
sg15
(lp15327
sg17
(lp15328
sg19
(lp15329
sg21
I0
sba(iArchitecture
Entity
p15330
(dp15331
g11
(lp15332
sg13
S'com.google.common.cache.AbstractLoadingCache'
p15333
sg15
(lp15334
sg17
(lp15335
sg19
(lp15336
sg21
I0
sba(iArchitecture
Entity
p15337
(dp15338
g11
(lp15339
sg13
S'com.google.common.collect.AbstractBiMap'
p15340
sg15
(lp15341
sg17
(lp15342
sg19
(lp15343
sg21
I0
sba(iArchitecture
Entity
p15344
(dp15345
g11
(lp15346
sg13
S'com.google.common.collect.AbstractBiMap$1'
p15347
sg15
(lp15348
sg17
(lp15349
sg19
(lp15350
sg21
I0
sba(iArchitecture
Entity
p15351
(dp15352
g11
(lp15353
sg13
S'com.google.common.collect.AbstractBiMap$BiMapEntry'
p15354
sg15
(lp15355
sg17
(lp15356
sg19
(lp15357
sg21
I0
sba(iArchitecture
Entity
p15358
(dp15359
g11
(lp15360
sg13
S'com.google.common.collect.AbstractBiMap$EntrySet'
p15361
sg15
(lp15362
sg17
(lp15363
sg19
(lp15364
sg21
I0
sba(iArchitecture
Entity
p15365
(dp15366
g11
(lp15367
sg13
S'com.google.common.collect.AbstractBiMap$Inverse'
p15368
sg15
(lp15369
sg17
(lp15370
sg19
(lp15371
sg21
I0
sba(iArchitecture
Entity
p15372
(dp15373
g11
(lp15374
sg13
S'com.google.common.collect.AbstractBiMap$KeySet'
p15375
sg15
(lp15376
sg17
(lp15377
sg19
(lp15378
sg21
I0
sba(iArchitecture
Entity
p15379
(dp15380
g11
(lp15381
sg13
S'com.google.common.collect.AbstractBiMap$ValueSet'
p15382
sg15
(lp15383
sg17
(lp15384
sg19
(lp15385
sg21
I0
sba(iArchitecture
Entity
p15386
(dp15387
g11
(lp15388
sg13
S'com.google.common.collect.AbstractIndexedListIterator'
p15389
sg15
(lp15390
sg17
(lp15391
sg19
(lp15392
sg21
I0
sba(iArchitecture
Entity
p15393
(dp15394
g11
(lp15395
sg13
S'com.google.common.collect.AbstractIterator'
p15396
sg15
(lp15397
sg17
(lp15398
sg19
(lp15399
sg21
I0
sba(iArchitecture
Entity
p15400
(dp15401
g11
(lp15402
sg13
S'com.google.common.collect.AbstractIterator$1'
p15403
sg15
(lp15404
sg17
(lp15405
sg19
(lp15406
sg21
I0
sba(iArchitecture
Entity
p15407
(dp15408
g11
(lp15409
sg13
S'com.google.common.collect.AbstractIterator$State'
p15410
sg15
(lp15411
sg17
(lp15412
sg19
(lp15413
sg21
I0
sba(iArchitecture
Entity
p15414
(dp15415
g11
(lp15416
sg13
S'com.google.common.collect.AbstractListMultimap'
p15417
sg15
(lp15418
sg17
(lp15419
sg19
(lp15420
sg21
I0
sba(iArchitecture
Entity
p15421
(dp15422
g11
(lp15423
sg13
S'com.google.common.collect.AbstractMapBasedMultimap'
p15424
sg15
(lp15425
sg17
(lp15426
sg19
(lp15427
sg21
I0
sba(iArchitecture
Entity
p15428
(dp15429
g11
(lp15430
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$1'
p15431
sg15
(lp15432
sg17
(lp15433
sg19
(lp15434
sg21
I0
sba(iArchitecture
Entity
p15435
(dp15436
g11
(lp15437
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$2'
p15438
sg15
(lp15439
sg17
(lp15440
sg19
(lp15441
sg21
I0
sba(iArchitecture
Entity
p15442
(dp15443
g11
(lp15444
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$AsMap'
p15445
sg15
(lp15446
sg17
(lp15447
sg19
(lp15448
sg21
I0
sba(iArchitecture
Entity
p15449
(dp15450
g11
(lp15451
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapEntries'
p15452
sg15
(lp15453
sg17
(lp15454
sg19
(lp15455
sg21
I0
sba(iArchitecture
Entity
p15456
(dp15457
g11
(lp15458
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapIterator'
p15459
sg15
(lp15460
sg17
(lp15461
sg19
(lp15462
sg21
I0
sba(iArchitecture
Entity
p15463
(dp15464
g11
(lp15465
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$Itr'
p15466
sg15
(lp15467
sg17
(lp15468
sg19
(lp15469
sg21
I0
sba(iArchitecture
Entity
p15470
(dp15471
g11
(lp15472
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$KeySet'
p15473
sg15
(lp15474
sg17
(lp15475
sg19
(lp15476
sg21
I0
sba(iArchitecture
Entity
p15477
(dp15478
g11
(lp15479
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$KeySet$1'
p15480
sg15
(lp15481
sg17
(lp15482
sg19
(lp15483
sg21
I0
sba(iArchitecture
Entity
p15484
(dp15485
g11
(lp15486
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$NavigableAsMap'
p15487
sg15
(lp15488
sg17
(lp15489
sg19
(lp15490
sg21
I0
sba(iArchitecture
Entity
p15491
(dp15492
g11
(lp15493
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$NavigableKeySet'
p15494
sg15
(lp15495
sg17
(lp15496
sg19
(lp15497
sg21
I0
sba(iArchitecture
Entity
p15498
(dp15499
g11
(lp15500
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$RandomAccessWrappedList'
p15501
sg15
(lp15502
sg17
(lp15503
sg19
(lp15504
sg21
I0
sba(iArchitecture
Entity
p15505
(dp15506
g11
(lp15507
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$SortedAsMap'
p15508
sg15
(lp15509
sg17
(lp15510
sg19
(lp15511
sg21
I0
sba(iArchitecture
Entity
p15512
(dp15513
g11
(lp15514
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$SortedKeySet'
p15515
sg15
(lp15516
sg17
(lp15517
sg19
(lp15518
sg21
I0
sba(iArchitecture
Entity
p15519
(dp15520
g11
(lp15521
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection'
p15522
sg15
(lp15523
sg17
(lp15524
sg19
(lp15525
sg21
I0
sba(iArchitecture
Entity
p15526
(dp15527
g11
(lp15528
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection$WrappedIterator'
p15529
sg15
(lp15530
sg17
(lp15531
sg19
(lp15532
sg21
I0
sba(iArchitecture
Entity
p15533
(dp15534
g11
(lp15535
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedList'
p15536
sg15
(lp15537
sg17
(lp15538
sg19
(lp15539
sg21
I0
sba(iArchitecture
Entity
p15540
(dp15541
g11
(lp15542
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedList$WrappedListIterator'
p15543
sg15
(lp15544
sg17
(lp15545
sg19
(lp15546
sg21
I0
sba(iArchitecture
Entity
p15547
(dp15548
g11
(lp15549
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedNavigableSet'
p15550
sg15
(lp15551
sg17
(lp15552
sg19
(lp15553
sg21
I0
sba(iArchitecture
Entity
p15554
(dp15555
g11
(lp15556
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedSet'
p15557
sg15
(lp15558
sg17
(lp15559
sg19
(lp15560
sg21
I0
sba(iArchitecture
Entity
p15561
(dp15562
g11
(lp15563
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedSortedSet'
p15564
sg15
(lp15565
sg17
(lp15566
sg19
(lp15567
sg21
I0
sba(iArchitecture
Entity
p15568
(dp15569
g11
(lp15570
sg13
S'com.google.common.collect.AbstractMapBasedMultiset'
p15571
sg15
(lp15572
sg17
(lp15573
sg19
(lp15574
sg21
I0
sba(iArchitecture
Entity
p15575
(dp15576
g11
(lp15577
sg13
S'com.google.common.collect.AbstractMapBasedMultiset$1'
p15578
sg15
(lp15579
sg17
(lp15580
sg19
(lp15581
sg21
I0
sba(iArchitecture
Entity
p15582
(dp15583
g11
(lp15584
sg13
S'com.google.common.collect.AbstractMapBasedMultiset$1$1'
p15585
sg15
(lp15586
sg17
(lp15587
sg19
(lp15588
sg21
I0
sba(iArchitecture
Entity
p15589
(dp15590
g11
(lp15591
sg13
S'com.google.common.collect.AbstractMapBasedMultiset$MapBasedMultisetIterator'
p15592
sg15
(lp15593
sg17
(lp15594
sg19
(lp15595
sg21
I0
sba(iArchitecture
Entity
p15596
(dp15597
g11
(lp15598
sg13
S'com.google.common.collect.AbstractMapEntry'
p15599
sg15
(lp15600
sg17
(lp15601
sg19
(lp15602
sg21
I0
sba(iArchitecture
Entity
p15603
(dp15604
g11
(lp15605
sg13
S'com.google.common.collect.AbstractMultimap'
p15606
sg15
(lp15607
sg17
(lp15608
sg19
(lp15609
sg21
I0
sba(iArchitecture
Entity
p15610
(dp15611
g11
(lp15612
sg13
S'com.google.common.collect.AbstractMultimap$1'
p15613
sg15
(lp15614
sg17
(lp15615
sg19
(lp15616
sg21
I0
sba(iArchitecture
Entity
p15617
(dp15618
g11
(lp15619
sg13
S'com.google.common.collect.AbstractMultimap$Entries'
p15620
sg15
(lp15621
sg17
(lp15622
sg19
(lp15623
sg21
I0
sba(iArchitecture
Entity
p15624
(dp15625
g11
(lp15626
sg13
S'com.google.common.collect.AbstractMultimap$EntrySet'
p15627
sg15
(lp15628
sg17
(lp15629
sg19
(lp15630
sg21
I0
sba(iArchitecture
Entity
p15631
(dp15632
g11
(lp15633
sg13
S'com.google.common.collect.AbstractMultimap$Values'
p15634
sg15
(lp15635
sg17
(lp15636
sg19
(lp15637
sg21
I0
sba(iArchitecture
Entity
p15638
(dp15639
g11
(lp15640
sg13
S'com.google.common.collect.AbstractMultiset'
p15641
sg15
(lp15642
sg17
(lp15643
sg19
(lp15644
sg21
I0
sba(iArchitecture
Entity
p15645
(dp15646
g11
(lp15647
sg13
S'com.google.common.collect.AbstractMultiset$ElementSet'
p15648
sg15
(lp15649
sg17
(lp15650
sg19
(lp15651
sg21
I0
sba(iArchitecture
Entity
p15652
(dp15653
g11
(lp15654
sg13
S'com.google.common.collect.AbstractMultiset$EntrySet'
p15655
sg15
(lp15656
sg17
(lp15657
sg19
(lp15658
sg21
I0
sba(iArchitecture
Entity
p15659
(dp15660
g11
(lp15661
sg13
S'com.google.common.collect.AbstractNavigableMap'
p15662
sg15
(lp15663
sg17
(lp15664
sg19
(lp15665
sg21
I0
sba(iArchitecture
Entity
p15666
(dp15667
g11
(lp15668
sg13
S'com.google.common.collect.AbstractNavigableMap$1'
p15669
sg15
(lp15670
sg17
(lp15671
sg19
(lp15672
sg21
I0
sba(iArchitecture
Entity
p15673
(dp15674
g11
(lp15675
sg13
S'com.google.common.collect.AbstractNavigableMap$DescendingMap'
p15676
sg15
(lp15677
sg17
(lp15678
sg19
(lp15679
sg21
I0
sba(iArchitecture
Entity
p15680
(dp15681
g11
(lp15682
sg13
S'com.google.common.collect.AbstractRangeSet'
p15683
sg15
(lp15684
sg17
(lp15685
sg19
(lp15686
sg21
I0
sba(iArchitecture
Entity
p15687
(dp15688
g11
(lp15689
sg13
S'com.google.common.collect.AbstractSequentialIterator'
p15690
sg15
(lp15691
sg17
(lp15692
sg19
(lp15693
sg21
I0
sba(iArchitecture
Entity
p15694
(dp15695
g11
(lp15696
sg13
S'com.google.common.collect.AbstractSetMultimap'
p15697
sg15
(lp15698
sg17
(lp15699
sg19
(lp15700
sg21
I0
sba(iArchitecture
Entity
p15701
(dp15702
g11
(lp15703
sg13
S'com.google.common.collect.AbstractSortedKeySortedSetMultimap'
p15704
sg15
(lp15705
sg17
(lp15706
sg19
(lp15707
sg21
I0
sba(iArchitecture
Entity
p15708
(dp15709
g11
(lp15710
sg13
S'com.google.common.collect.AbstractSortedMultiset'
p15711
sg15
(lp15712
sg17
(lp15713
sg19
(lp15714
sg21
I0
sba(iArchitecture
Entity
p15715
(dp15716
g11
(lp15717
sg13
S'com.google.common.collect.AbstractSortedMultiset$1DescendingMultisetImpl'
p15718
sg15
(lp15719
sg17
(lp15720
sg19
(lp15721
sg21
I0
sba(iArchitecture
Entity
p15722
(dp15723
g11
(lp15724
sg13
S'com.google.common.collect.AbstractSortedSetMultimap'
p15725
sg15
(lp15726
sg17
(lp15727
sg19
(lp15728
sg21
I0
sba(iArchitecture
Entity
p15729
(dp15730
g11
(lp15731
sg13
S'com.google.common.collect.AbstractTable'
p15732
sg15
(lp15733
sg17
(lp15734
sg19
(lp15735
sg21
I0
sba(iArchitecture
Entity
p15736
(dp15737
g11
(lp15738
sg13
S'com.google.common.collect.AbstractTable$1'
p15739
sg15
(lp15740
sg17
(lp15741
sg19
(lp15742
sg21
I0
sba(iArchitecture
Entity
p15743
(dp15744
g11
(lp15745
sg13
S'com.google.common.collect.AbstractTable$CellSet'
p15746
sg15
(lp15747
sg17
(lp15748
sg19
(lp15749
sg21
I0
sba(iArchitecture
Entity
p15750
(dp15751
g11
(lp15752
sg13
S'com.google.common.collect.AbstractTable$Values'
p15753
sg15
(lp15754
sg17
(lp15755
sg19
(lp15756
sg21
I0
sba(iArchitecture
Entity
p15757
(dp15758
g11
(lp15759
sg13
S'com.google.common.collect.AllEqualOrdering'
p15760
sg15
(lp15761
sg17
(lp15762
sg19
(lp15763
sg21
I0
sba(iArchitecture
Entity
p15764
(dp15765
g11
(lp15766
sg13
S'com.google.common.collect.ArrayListMultimap'
p15767
sg15
(lp15768
sg17
(lp15769
sg19
(lp15770
sg21
I0
sba(iArchitecture
Entity
p15771
(dp15772
g11
(lp15773
sg13
S'com.google.common.collect.ArrayTable'
p15774
sg15
(lp15775
sg17
(lp15776
sg19
(lp15777
sg21
I0
sba(iArchitecture
Entity
p15778
(dp15779
g11
(lp15780
sg13
S'com.google.common.collect.ArrayTable$1'
p15781
sg15
(lp15782
sg17
(lp15783
sg19
(lp15784
sg21
I0
sba(iArchitecture
Entity
p15785
(dp15786
g11
(lp15787
sg13
S'com.google.common.collect.ArrayTable$1$1'
p15788
sg15
(lp15789
sg17
(lp15790
sg19
(lp15791
sg21
I0
sba(iArchitecture
Entity
p15792
(dp15793
g11
(lp15794
sg13
S'com.google.common.collect.ArrayTable$ArrayMap'
p15795
sg15
(lp15796
sg17
(lp15797
sg19
(lp15798
sg21
I0
sba(iArchitecture
Entity
p15799
(dp15800
g11
(lp15801
sg13
S'com.google.common.collect.ArrayTable$ArrayMap$1'
p15802
sg15
(lp15803
sg17
(lp15804
sg19
(lp15805
sg21
I0
sba(iArchitecture
Entity
p15806
(dp15807
g11
(lp15808
sg13
S'com.google.common.collect.ArrayTable$ArrayMap$1$1'
p15809
sg15
(lp15810
sg17
(lp15811
sg19
(lp15812
sg21
I0
sba(iArchitecture
Entity
p15813
(dp15814
g11
(lp15815
sg13
S'com.google.common.collect.ArrayTable$Column'
p15816
sg15
(lp15817
sg17
(lp15818
sg19
(lp15819
sg21
I0
sba(iArchitecture
Entity
p15820
(dp15821
g11
(lp15822
sg13
S'com.google.common.collect.ArrayTable$ColumnMap'
p15823
sg15
(lp15824
sg17
(lp15825
sg19
(lp15826
sg21
I0
sba(iArchitecture
Entity
p15827
(dp15828
g11
(lp15829
sg13
S'com.google.common.collect.ArrayTable$Row'
p15830
sg15
(lp15831
sg17
(lp15832
sg19
(lp15833
sg21
I0
sba(iArchitecture
Entity
p15834
(dp15835
g11
(lp15836
sg13
S'com.google.common.collect.ArrayTable$RowMap'
p15837
sg15
(lp15838
sg17
(lp15839
sg19
(lp15840
sg21
I0
sba(iArchitecture
Entity
p15841
(dp15842
g11
(lp15843
sg13
S'com.google.common.collect.BiMap'
p15844
sg15
(lp15845
sg17
(lp15846
sg19
(lp15847
sg21
I0
sba(iArchitecture
Entity
p15848
(dp15849
g11
(lp15850
sg13
S'com.google.common.collect.BinaryTreeTraverser'
p15851
sg15
(lp15852
sg17
(lp15853
sg19
(lp15854
sg21
I0
sba(iArchitecture
Entity
p15855
(dp15856
g11
(lp15857
sg13
S'com.google.common.collect.BinaryTreeTraverser$1'
p15858
sg15
(lp15859
sg17
(lp15860
sg19
(lp15861
sg21
I0
sba(iArchitecture
Entity
p15862
(dp15863
g11
(lp15864
sg13
S'com.google.common.collect.BinaryTreeTraverser$1$1'
p15865
sg15
(lp15866
sg17
(lp15867
sg19
(lp15868
sg21
I0
sba(iArchitecture
Entity
p15869
(dp15870
g11
(lp15871
sg13
S'com.google.common.collect.BinaryTreeTraverser$2'
p15872
sg15
(lp15873
sg17
(lp15874
sg19
(lp15875
sg21
I0
sba(iArchitecture
Entity
p15876
(dp15877
g11
(lp15878
sg13
S'com.google.common.collect.BinaryTreeTraverser$InOrderIterator'
p15879
sg15
(lp15880
sg17
(lp15881
sg19
(lp15882
sg21
I0
sba(iArchitecture
Entity
p15883
(dp15884
g11
(lp15885
sg13
S'com.google.common.collect.BinaryTreeTraverser$PostOrderIterator'
p15886
sg15
(lp15887
sg17
(lp15888
sg19
(lp15889
sg21
I0
sba(iArchitecture
Entity
p15890
(dp15891
g11
(lp15892
sg13
S'com.google.common.collect.BinaryTreeTraverser$PreOrderIterator'
p15893
sg15
(lp15894
sg17
(lp15895
sg19
(lp15896
sg21
I0
sba(iArchitecture
Entity
p15897
(dp15898
g11
(lp15899
sg13
S'com.google.common.collect.BoundType'
p15900
sg15
(lp15901
sg17
(lp15902
sg19
(lp15903
sg21
I0
sba(iArchitecture
Entity
p15904
(dp15905
g11
(lp15906
sg13
S'com.google.common.collect.BoundType$1'
p15907
sg15
(lp15908
sg17
(lp15909
sg19
(lp15910
sg21
I0
sba(iArchitecture
Entity
p15911
(dp15912
g11
(lp15913
sg13
S'com.google.common.collect.BoundType$2'
p15914
sg15
(lp15915
sg17
(lp15916
sg19
(lp15917
sg21
I0
sba(iArchitecture
Entity
p15918
(dp15919
g11
(lp15920
sg13
S'com.google.common.collect.ByFunctionOrdering'
p15921
sg15
(lp15922
sg17
(lp15923
sg19
(lp15924
sg21
I0
sba(iArchitecture
Entity
p15925
(dp15926
g11
(lp15927
sg13
S'com.google.common.collect.CartesianList'
p15928
sg15
(lp15929
sg17
(lp15930
sg19
(lp15931
sg21
I0
sba(iArchitecture
Entity
p15932
(dp15933
g11
(lp15934
sg13
S'com.google.common.collect.CartesianList$1'
p15935
sg15
(lp15936
sg17
(lp15937
sg19
(lp15938
sg21
I0
sba(iArchitecture
Entity
p15939
(dp15940
g11
(lp15941
sg13
S'com.google.common.collect.ClassToInstanceMap'
p15942
sg15
(lp15943
sg17
(lp15944
sg19
(lp15945
sg21
I0
sba(iArchitecture
Entity
p15946
(dp15947
g11
(lp15948
sg13
S'com.google.common.collect.CollectPreconditions'
p15949
sg15
(lp15950
sg17
(lp15951
sg19
(lp15952
sg21
I0
sba(iArchitecture
Entity
p15953
(dp15954
g11
(lp15955
sg13
S'com.google.common.collect.Collections2'
p15956
sg15
(lp15957
sg17
(lp15958
sg19
(lp15959
sg21
I0
sba(iArchitecture
Entity
p15960
(dp15961
g11
(lp15962
sg13
S'com.google.common.collect.Collections2$1'
p15963
sg15
(lp15964
sg17
(lp15965
sg19
(lp15966
sg21
I0
sba(iArchitecture
Entity
p15967
(dp15968
g11
(lp15969
sg13
S'com.google.common.collect.Collections2$FilteredCollection'
p15970
sg15
(lp15971
sg17
(lp15972
sg19
(lp15973
sg21
I0
sba(iArchitecture
Entity
p15974
(dp15975
g11
(lp15976
sg13
S'com.google.common.collect.Collections2$OrderedPermutationCollection'
p15977
sg15
(lp15978
sg17
(lp15979
sg19
(lp15980
sg21
I0
sba(iArchitecture
Entity
p15981
(dp15982
g11
(lp15983
sg13
S'com.google.common.collect.Collections2$OrderedPermutationIterator'
p15984
sg15
(lp15985
sg17
(lp15986
sg19
(lp15987
sg21
I0
sba(iArchitecture
Entity
p15988
(dp15989
g11
(lp15990
sg13
S'com.google.common.collect.Collections2$PermutationCollection'
p15991
sg15
(lp15992
sg17
(lp15993
sg19
(lp15994
sg21
I0
sba(iArchitecture
Entity
p15995
(dp15996
g11
(lp15997
sg13
S'com.google.common.collect.Collections2$PermutationIterator'
p15998
sg15
(lp15999
sg17
(lp16000
sg19
(lp16001
sg21
I0
sba(iArchitecture
Entity
p16002
(dp16003
g11
(lp16004
sg13
S'com.google.common.collect.Collections2$TransformedCollection'
p16005
sg15
(lp16006
sg17
(lp16007
sg19
(lp16008
sg21
I0
sba(iArchitecture
Entity
p16009
(dp16010
g11
(lp16011
sg13
S'com.google.common.collect.ComparatorOrdering'
p16012
sg15
(lp16013
sg17
(lp16014
sg19
(lp16015
sg21
I0
sba(iArchitecture
Entity
p16016
(dp16017
g11
(lp16018
sg13
S'com.google.common.collect.ComparisonChain'
p16019
sg15
(lp16020
sg17
(lp16021
sg19
(lp16022
sg21
I0
sba(iArchitecture
Entity
p16023
(dp16024
g11
(lp16025
sg13
S'com.google.common.collect.ComparisonChain$1'
p16026
sg15
(lp16027
sg17
(lp16028
sg19
(lp16029
sg21
I0
sba(iArchitecture
Entity
p16030
(dp16031
g11
(lp16032
sg13
S'com.google.common.collect.ComparisonChain$InactiveComparisonChain'
p16033
sg15
(lp16034
sg17
(lp16035
sg19
(lp16036
sg21
I0
sba(iArchitecture
Entity
p16037
(dp16038
g11
(lp16039
sg13
S'com.google.common.collect.CompoundOrdering'
p16040
sg15
(lp16041
sg17
(lp16042
sg19
(lp16043
sg21
I0
sba(iArchitecture
Entity
p16044
(dp16045
g11
(lp16046
sg13
S'com.google.common.collect.ComputationException'
p16047
sg15
(lp16048
sg17
(lp16049
sg19
(lp16050
sg21
I0
sba(iArchitecture
Entity
p16051
(dp16052
g11
(lp16053
sg13
S'com.google.common.collect.ConcurrentHashMultiset'
p16054
sg15
(lp16055
sg17
(lp16056
sg19
(lp16057
sg21
I0
sba(iArchitecture
Entity
p16058
(dp16059
g11
(lp16060
sg13
S'com.google.common.collect.ConcurrentHashMultiset$1'
p16061
sg15
(lp16062
sg17
(lp16063
sg19
(lp16064
sg21
I0
sba(iArchitecture
Entity
p16065
(dp16066
g11
(lp16067
sg13
S'com.google.common.collect.ConcurrentHashMultiset$2'
p16068
sg15
(lp16069
sg17
(lp16070
sg19
(lp16071
sg21
I0
sba(iArchitecture
Entity
p16072
(dp16073
g11
(lp16074
sg13
S'com.google.common.collect.ConcurrentHashMultiset$3'
p16075
sg15
(lp16076
sg17
(lp16077
sg19
(lp16078
sg21
I0
sba(iArchitecture
Entity
p16079
(dp16080
g11
(lp16081
sg13
S'com.google.common.collect.ConcurrentHashMultiset$EntrySet'
p16082
sg15
(lp16083
sg17
(lp16084
sg19
(lp16085
sg21
I0
sba(iArchitecture
Entity
p16086
(dp16087
g11
(lp16088
sg13
S'com.google.common.collect.ConcurrentHashMultiset$FieldSettersHolder'
p16089
sg15
(lp16090
sg17
(lp16091
sg19
(lp16092
sg21
I0
sba(iArchitecture
Entity
p16093
(dp16094
g11
(lp16095
sg13
S'com.google.common.collect.Constraint'
p16096
sg15
(lp16097
sg17
(lp16098
sg19
(lp16099
sg21
I0
sba(iArchitecture
Entity
p16100
(dp16101
g11
(lp16102
sg13
S'com.google.common.collect.Constraints'
p16103
sg15
(lp16104
sg17
(lp16105
sg19
(lp16106
sg21
I0
sba(iArchitecture
Entity
p16107
(dp16108
g11
(lp16109
sg13
S'com.google.common.collect.Constraints$ConstrainedCollection'
p16110
sg15
(lp16111
sg17
(lp16112
sg19
(lp16113
sg21
I0
sba(iArchitecture
Entity
p16114
(dp16115
g11
(lp16116
sg13
S'com.google.common.collect.Constraints$ConstrainedList'
p16117
sg15
(lp16118
sg17
(lp16119
sg19
(lp16120
sg21
I0
sba(iArchitecture
Entity
p16121
(dp16122
g11
(lp16123
sg13
S'com.google.common.collect.Constraints$ConstrainedListIterator'
p16124
sg15
(lp16125
sg17
(lp16126
sg19
(lp16127
sg21
I0
sba(iArchitecture
Entity
p16128
(dp16129
g11
(lp16130
sg13
S'com.google.common.collect.Constraints$ConstrainedRandomAccessList'
p16131
sg15
(lp16132
sg17
(lp16133
sg19
(lp16134
sg21
I0
sba(iArchitecture
Entity
p16135
(dp16136
g11
(lp16137
sg13
S'com.google.common.collect.Constraints$ConstrainedSet'
p16138
sg15
(lp16139
sg17
(lp16140
sg19
(lp16141
sg21
I0
sba(iArchitecture
Entity
p16142
(dp16143
g11
(lp16144
sg13
S'com.google.common.collect.Constraints$ConstrainedSortedSet'
p16145
sg15
(lp16146
sg17
(lp16147
sg19
(lp16148
sg21
I0
sba(iArchitecture
Entity
p16149
(dp16150
g11
(lp16151
sg13
S'com.google.common.collect.ConsumingQueueIterator'
p16152
sg15
(lp16153
sg17
(lp16154
sg19
(lp16155
sg21
I0
sba(iArchitecture
Entity
p16156
(dp16157
g11
(lp16158
sg13
S'com.google.common.collect.ContiguousSet'
p16159
sg15
(lp16160
sg17
(lp16161
sg19
(lp16162
sg21
I0
sba(iArchitecture
Entity
p16163
(dp16164
g11
(lp16165
sg13
S'com.google.common.collect.Count'
p16166
sg15
(lp16167
sg17
(lp16168
sg19
(lp16169
sg21
I0
sba(iArchitecture
Entity
p16170
(dp16171
g11
(lp16172
sg13
S'com.google.common.collect.Cut'
p16173
sg15
(lp16174
sg17
(lp16175
sg19
(lp16176
sg21
I0
sba(iArchitecture
Entity
p16177
(dp16178
g11
(lp16179
sg13
S'com.google.common.collect.Cut$1'
p16180
sg15
(lp16181
sg17
(lp16182
sg19
(lp16183
sg21
I0
sba(iArchitecture
Entity
p16184
(dp16185
g11
(lp16186
sg13
S'com.google.common.collect.Cut$AboveAll'
p16187
sg15
(lp16188
sg17
(lp16189
sg19
(lp16190
sg21
I0
sba(iArchitecture
Entity
p16191
(dp16192
g11
(lp16193
sg13
S'com.google.common.collect.Cut$AboveValue'
p16194
sg15
(lp16195
sg17
(lp16196
sg19
(lp16197
sg21
I0
sba(iArchitecture
Entity
p16198
(dp16199
g11
(lp16200
sg13
S'com.google.common.collect.Cut$BelowAll'
p16201
sg15
(lp16202
sg17
(lp16203
sg19
(lp16204
sg21
I0
sba(iArchitecture
Entity
p16205
(dp16206
g11
(lp16207
sg13
S'com.google.common.collect.Cut$BelowValue'
p16208
sg15
(lp16209
sg17
(lp16210
sg19
(lp16211
sg21
I0
sba(iArchitecture
Entity
p16212
(dp16213
g11
(lp16214
sg13
S'com.google.common.collect.DenseImmutableTable'
p16215
sg15
(lp16216
sg17
(lp16217
sg19
(lp16218
sg21
I0
sba(iArchitecture
Entity
p16219
(dp16220
g11
(lp16221
sg13
S'com.google.common.collect.DenseImmutableTable$1'
p16222
sg15
(lp16223
sg17
(lp16224
sg19
(lp16225
sg21
I0
sba(iArchitecture
Entity
p16226
(dp16227
g11
(lp16228
sg13
S'com.google.common.collect.DenseImmutableTable$Column'
p16229
sg15
(lp16230
sg17
(lp16231
sg19
(lp16232
sg21
I0
sba(iArchitecture
Entity
p16233
(dp16234
g11
(lp16235
sg13
S'com.google.common.collect.DenseImmutableTable$ColumnMap'
p16236
sg15
(lp16237
sg17
(lp16238
sg19
(lp16239
sg21
I0
sba(iArchitecture
Entity
p16240
(dp16241
g11
(lp16242
sg13
S'com.google.common.collect.DenseImmutableTable$ImmutableArrayMap'
p16243
sg15
(lp16244
sg17
(lp16245
sg19
(lp16246
sg21
I0
sba(iArchitecture
Entity
p16247
(dp16248
g11
(lp16249
sg13
S'com.google.common.collect.DenseImmutableTable$ImmutableArrayMap$1'
p16250
sg15
(lp16251
sg17
(lp16252
sg19
(lp16253
sg21
I0
sba(iArchitecture
Entity
p16254
(dp16255
g11
(lp16256
sg13
S'com.google.common.collect.DenseImmutableTable$Row'
p16257
sg15
(lp16258
sg17
(lp16259
sg19
(lp16260
sg21
I0
sba(iArchitecture
Entity
p16261
(dp16262
g11
(lp16263
sg13
S'com.google.common.collect.DenseImmutableTable$RowMap'
p16264
sg15
(lp16265
sg17
(lp16266
sg19
(lp16267
sg21
I0
sba(iArchitecture
Entity
p16268
(dp16269
g11
(lp16270
sg13
S'com.google.common.collect.DescendingImmutableSortedMultiset'
p16271
sg15
(lp16272
sg17
(lp16273
sg19
(lp16274
sg21
I0
sba(iArchitecture
Entity
p16275
(dp16276
g11
(lp16277
sg13
S'com.google.common.collect.DescendingImmutableSortedSet'
p16278
sg15
(lp16279
sg17
(lp16280
sg19
(lp16281
sg21
I0
sba(iArchitecture
Entity
p16282
(dp16283
g11
(lp16284
sg13
S'com.google.common.collect.DescendingMultiset'
p16285
sg15
(lp16286
sg17
(lp16287
sg19
(lp16288
sg21
I0
sba(iArchitecture
Entity
p16289
(dp16290
g11
(lp16291
sg13
S'com.google.common.collect.DescendingMultiset$1EntrySetImpl'
p16292
sg15
(lp16293
sg17
(lp16294
sg19
(lp16295
sg21
I0
sba(iArchitecture
Entity
p16296
(dp16297
g11
(lp16298
sg13
S'com.google.common.collect.DiscreteDomain'
p16299
sg15
(lp16300
sg17
(lp16301
sg19
(lp16302
sg21
I0
sba(iArchitecture
Entity
p16303
(dp16304
g11
(lp16305
sg13
S'com.google.common.collect.DiscreteDomain$BigIntegerDomain'
p16306
sg15
(lp16307
sg17
(lp16308
sg19
(lp16309
sg21
I0
sba(iArchitecture
Entity
p16310
(dp16311
g11
(lp16312
sg13
S'com.google.common.collect.DiscreteDomain$IntegerDomain'
p16313
sg15
(lp16314
sg17
(lp16315
sg19
(lp16316
sg21
I0
sba(iArchitecture
Entity
p16317
(dp16318
g11
(lp16319
sg13
S'com.google.common.collect.DiscreteDomain$LongDomain'
p16320
sg15
(lp16321
sg17
(lp16322
sg19
(lp16323
sg21
I0
sba(iArchitecture
Entity
p16324
(dp16325
g11
(lp16326
sg13
S'com.google.common.collect.EmptyContiguousSet'
p16327
sg15
(lp16328
sg17
(lp16329
sg19
(lp16330
sg21
I0
sba(iArchitecture
Entity
p16331
(dp16332
g11
(lp16333
sg13
S'com.google.common.collect.EmptyContiguousSet$1'
p16334
sg15
(lp16335
sg17
(lp16336
sg19
(lp16337
sg21
I0
sba(iArchitecture
Entity
p16338
(dp16339
g11
(lp16340
sg13
S'com.google.common.collect.EmptyContiguousSet$SerializedForm'
p16341
sg15
(lp16342
sg17
(lp16343
sg19
(lp16344
sg21
I0
sba(iArchitecture
Entity
p16345
(dp16346
g11
(lp16347
sg13
S'com.google.common.collect.EmptyImmutableListMultimap'
p16348
sg15
(lp16349
sg17
(lp16350
sg19
(lp16351
sg21
I0
sba(iArchitecture
Entity
p16352
(dp16353
g11
(lp16354
sg13
S'com.google.common.collect.EmptyImmutableSetMultimap'
p16355
sg15
(lp16356
sg17
(lp16357
sg19
(lp16358
sg21
I0
sba(iArchitecture
Entity
p16359
(dp16360
g11
(lp16361
sg13
S'com.google.common.collect.EnumBiMap'
p16362
sg15
(lp16363
sg17
(lp16364
sg19
(lp16365
sg21
I0
sba(iArchitecture
Entity
p16366
(dp16367
g11
(lp16368
sg13
S'com.google.common.collect.EnumHashBiMap'
p16369
sg15
(lp16370
sg17
(lp16371
sg19
(lp16372
sg21
I0
sba(iArchitecture
Entity
p16373
(dp16374
g11
(lp16375
sg13
S'com.google.common.collect.EnumMultiset'
p16376
sg15
(lp16377
sg17
(lp16378
sg19
(lp16379
sg21
I0
sba(iArchitecture
Entity
p16380
(dp16381
g11
(lp16382
sg13
S'com.google.common.collect.EvictingQueue'
p16383
sg15
(lp16384
sg17
(lp16385
sg19
(lp16386
sg21
I0
sba(iArchitecture
Entity
p16387
(dp16388
g11
(lp16389
sg13
S'com.google.common.collect.ExplicitOrdering'
p16390
sg15
(lp16391
sg17
(lp16392
sg19
(lp16393
sg21
I0
sba(iArchitecture
Entity
p16394
(dp16395
g11
(lp16396
sg13
S'com.google.common.collect.FilteredEntryMultimap'
p16397
sg15
(lp16398
sg17
(lp16399
sg19
(lp16400
sg21
I0
sba(iArchitecture
Entity
p16401
(dp16402
g11
(lp16403
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap'
p16404
sg15
(lp16405
sg17
(lp16406
sg19
(lp16407
sg21
I0
sba(iArchitecture
Entity
p16408
(dp16409
g11
(lp16410
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$1EntrySetImpl'
p16411
sg15
(lp16412
sg17
(lp16413
sg19
(lp16414
sg21
I0
sba(iArchitecture
Entity
p16415
(dp16416
g11
(lp16417
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$1EntrySetImpl$1'
p16418
sg15
(lp16419
sg17
(lp16420
sg19
(lp16421
sg21
I0
sba(iArchitecture
Entity
p16422
(dp16423
g11
(lp16424
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$1KeySetImpl'
p16425
sg15
(lp16426
sg17
(lp16427
sg19
(lp16428
sg21
I0
sba(iArchitecture
Entity
p16429
(dp16430
g11
(lp16431
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$1ValuesImpl'
p16432
sg15
(lp16433
sg17
(lp16434
sg19
(lp16435
sg21
I0
sba(iArchitecture
Entity
p16436
(dp16437
g11
(lp16438
sg13
S'com.google.common.collect.FilteredEntryMultimap$Keys'
p16439
sg15
(lp16440
sg17
(lp16441
sg19
(lp16442
sg21
I0
sba(iArchitecture
Entity
p16443
(dp16444
g11
(lp16445
sg13
S'com.google.common.collect.FilteredEntryMultimap$Keys$1'
p16446
sg15
(lp16447
sg17
(lp16448
sg19
(lp16449
sg21
I0
sba(iArchitecture
Entity
p16450
(dp16451
g11
(lp16452
sg13
S'com.google.common.collect.FilteredEntryMultimap$Keys$1$1'
p16453
sg15
(lp16454
sg17
(lp16455
sg19
(lp16456
sg21
I0
sba(iArchitecture
Entity
p16457
(dp16458
g11
(lp16459
sg13
S'com.google.common.collect.FilteredEntryMultimap$ValuePredicate'
p16460
sg15
(lp16461
sg17
(lp16462
sg19
(lp16463
sg21
I0
sba(iArchitecture
Entity
p16464
(dp16465
g11
(lp16466
sg13
S'com.google.common.collect.FilteredEntrySetMultimap'
p16467
sg15
(lp16468
sg17
(lp16469
sg19
(lp16470
sg21
I0
sba(iArchitecture
Entity
p16471
(dp16472
g11
(lp16473
sg13
S'com.google.common.collect.FilteredKeyListMultimap'
p16474
sg15
(lp16475
sg17
(lp16476
sg19
(lp16477
sg21
I0
sba(iArchitecture
Entity
p16478
(dp16479
g11
(lp16480
sg13
S'com.google.common.collect.FilteredKeyMultimap'
p16481
sg15
(lp16482
sg17
(lp16483
sg19
(lp16484
sg21
I0
sba(iArchitecture
Entity
p16485
(dp16486
g11
(lp16487
sg13
S'com.google.common.collect.FilteredKeyMultimap$AddRejectingList'
p16488
sg15
(lp16489
sg17
(lp16490
sg19
(lp16491
sg21
I0
sba(iArchitecture
Entity
p16492
(dp16493
g11
(lp16494
sg13
S'com.google.common.collect.FilteredKeyMultimap$AddRejectingSet'
p16495
sg15
(lp16496
sg17
(lp16497
sg19
(lp16498
sg21
I0
sba(iArchitecture
Entity
p16499
(dp16500
g11
(lp16501
sg13
S'com.google.common.collect.FilteredKeyMultimap$Entries'
p16502
sg15
(lp16503
sg17
(lp16504
sg19
(lp16505
sg21
I0
sba(iArchitecture
Entity
p16506
(dp16507
g11
(lp16508
sg13
S'com.google.common.collect.FilteredKeySetMultimap'
p16509
sg15
(lp16510
sg17
(lp16511
sg19
(lp16512
sg21
I0
sba(iArchitecture
Entity
p16513
(dp16514
g11
(lp16515
sg13
S'com.google.common.collect.FilteredKeySetMultimap$EntrySet'
p16516
sg15
(lp16517
sg17
(lp16518
sg19
(lp16519
sg21
I0
sba(iArchitecture
Entity
p16520
(dp16521
g11
(lp16522
sg13
S'com.google.common.collect.FilteredMultimap'
p16523
sg15
(lp16524
sg17
(lp16525
sg19
(lp16526
sg21
I0
sba(iArchitecture
Entity
p16527
(dp16528
g11
(lp16529
sg13
S'com.google.common.collect.FilteredMultimapValues'
p16530
sg15
(lp16531
sg17
(lp16532
sg19
(lp16533
sg21
I0
sba(iArchitecture
Entity
p16534
(dp16535
g11
(lp16536
sg13
S'com.google.common.collect.FilteredSetMultimap'
p16537
sg15
(lp16538
sg17
(lp16539
sg19
(lp16540
sg21
I0
sba(iArchitecture
Entity
p16541
(dp16542
g11
(lp16543
sg13
S'com.google.common.collect.FluentIterable'
p16544
sg15
(lp16545
sg17
(lp16546
sg19
(lp16547
sg21
I0
sba(iArchitecture
Entity
p16548
(dp16549
g11
(lp16550
sg13
S'com.google.common.collect.FluentIterable$1'
p16551
sg15
(lp16552
sg17
(lp16553
sg19
(lp16554
sg21
I0
sba(iArchitecture
Entity
p16555
(dp16556
g11
(lp16557
sg13
S'com.google.common.collect.FluentIterable$2'
p16558
sg15
(lp16559
sg17
(lp16560
sg19
(lp16561
sg21
I0
sba(iArchitecture
Entity
p16562
(dp16563
g11
(lp16564
sg13
S'com.google.common.collect.FluentIterable$FromIterableFunction'
p16565
sg15
(lp16566
sg17
(lp16567
sg19
(lp16568
sg21
I0
sba(iArchitecture
Entity
p16569
(dp16570
g11
(lp16571
sg13
S'com.google.common.collect.ForwardingBlockingDeque'
p16572
sg15
(lp16573
sg17
(lp16574
sg19
(lp16575
sg21
I0
sba(iArchitecture
Entity
p16576
(dp16577
g11
(lp16578
sg13
S'com.google.common.collect.ForwardingCollection'
p16579
sg15
(lp16580
sg17
(lp16581
sg19
(lp16582
sg21
I0
sba(iArchitecture
Entity
p16583
(dp16584
g11
(lp16585
sg13
S'com.google.common.collect.ForwardingConcurrentMap'
p16586
sg15
(lp16587
sg17
(lp16588
sg19
(lp16589
sg21
I0
sba(iArchitecture
Entity
p16590
(dp16591
g11
(lp16592
sg13
S'com.google.common.collect.ForwardingDeque'
p16593
sg15
(lp16594
sg17
(lp16595
sg19
(lp16596
sg21
I0
sba(iArchitecture
Entity
p16597
(dp16598
g11
(lp16599
sg13
S'com.google.common.collect.ForwardingImmutableCollection'
p16600
sg15
(lp16601
sg17
(lp16602
sg19
(lp16603
sg21
I0
sba(iArchitecture
Entity
p16604
(dp16605
g11
(lp16606
sg13
S'com.google.common.collect.ForwardingImmutableList'
p16607
sg15
(lp16608
sg17
(lp16609
sg19
(lp16610
sg21
I0
sba(iArchitecture
Entity
p16611
(dp16612
g11
(lp16613
sg13
S'com.google.common.collect.ForwardingImmutableMap'
p16614
sg15
(lp16615
sg17
(lp16616
sg19
(lp16617
sg21
I0
sba(iArchitecture
Entity
p16618
(dp16619
g11
(lp16620
sg13
S'com.google.common.collect.ForwardingImmutableSet'
p16621
sg15
(lp16622
sg17
(lp16623
sg19
(lp16624
sg21
I0
sba(iArchitecture
Entity
p16625
(dp16626
g11
(lp16627
sg13
S'com.google.common.collect.ForwardingIterator'
p16628
sg15
(lp16629
sg17
(lp16630
sg19
(lp16631
sg21
I0
sba(iArchitecture
Entity
p16632
(dp16633
g11
(lp16634
sg13
S'com.google.common.collect.ForwardingList'
p16635
sg15
(lp16636
sg17
(lp16637
sg19
(lp16638
sg21
I0
sba(iArchitecture
Entity
p16639
(dp16640
g11
(lp16641
sg13
S'com.google.common.collect.ForwardingListIterator'
p16642
sg15
(lp16643
sg17
(lp16644
sg19
(lp16645
sg21
I0
sba(iArchitecture
Entity
p16646
(dp16647
g11
(lp16648
sg13
S'com.google.common.collect.ForwardingListMultimap'
p16649
sg15
(lp16650
sg17
(lp16651
sg19
(lp16652
sg21
I0
sba(iArchitecture
Entity
p16653
(dp16654
g11
(lp16655
sg13
S'com.google.common.collect.ForwardingMap'
p16656
sg15
(lp16657
sg17
(lp16658
sg19
(lp16659
sg21
I0
sba(iArchitecture
Entity
p16660
(dp16661
g11
(lp16662
sg13
S'com.google.common.collect.ForwardingMap$StandardEntrySet'
p16663
sg15
(lp16664
sg17
(lp16665
sg19
(lp16666
sg21
I0
sba(iArchitecture
Entity
p16667
(dp16668
g11
(lp16669
sg13
S'com.google.common.collect.ForwardingMap$StandardKeySet'
p16670
sg15
(lp16671
sg17
(lp16672
sg19
(lp16673
sg21
I0
sba(iArchitecture
Entity
p16674
(dp16675
g11
(lp16676
sg13
S'com.google.common.collect.ForwardingMap$StandardValues'
p16677
sg15
(lp16678
sg17
(lp16679
sg19
(lp16680
sg21
I0
sba(iArchitecture
Entity
p16681
(dp16682
g11
(lp16683
sg13
S'com.google.common.collect.ForwardingMultimap'
p16684
sg15
(lp16685
sg17
(lp16686
sg19
(lp16687
sg21
I0
sba(iArchitecture
Entity
p16688
(dp16689
g11
(lp16690
sg13
S'com.google.common.collect.ForwardingMultiset'
p16691
sg15
(lp16692
sg17
(lp16693
sg19
(lp16694
sg21
I0
sba(iArchitecture
Entity
p16695
(dp16696
g11
(lp16697
sg13
S'com.google.common.collect.ForwardingMultiset$StandardElementSet'
p16698
sg15
(lp16699
sg17
(lp16700
sg19
(lp16701
sg21
I0
sba(iArchitecture
Entity
p16702
(dp16703
g11
(lp16704
sg13
S'com.google.common.collect.ForwardingNavigableMap'
p16705
sg15
(lp16706
sg17
(lp16707
sg19
(lp16708
sg21
I0
sba(iArchitecture
Entity
p16709
(dp16710
g11
(lp16711
sg13
S'com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap'
p16712
sg15
(lp16713
sg17
(lp16714
sg19
(lp16715
sg21
I0
sba(iArchitecture
Entity
p16716
(dp16717
g11
(lp16718
sg13
S'com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap$1'
p16719
sg15
(lp16720
sg17
(lp16721
sg19
(lp16722
sg21
I0
sba(iArchitecture
Entity
p16723
(dp16724
g11
(lp16725
sg13
S'com.google.common.collect.ForwardingNavigableMap$StandardNavigableKeySet'
p16726
sg15
(lp16727
sg17
(lp16728
sg19
(lp16729
sg21
I0
sba(iArchitecture
Entity
p16730
(dp16731
g11
(lp16732
sg13
S'com.google.common.collect.ForwardingNavigableSet'
p16733
sg15
(lp16734
sg17
(lp16735
sg19
(lp16736
sg21
I0
sba(iArchitecture
Entity
p16737
(dp16738
g11
(lp16739
sg13
S'com.google.common.collect.ForwardingNavigableSet$StandardDescendingSet'
p16740
sg15
(lp16741
sg17
(lp16742
sg19
(lp16743
sg21
I0
sba(iArchitecture
Entity
p16744
(dp16745
g11
(lp16746
sg13
S'com.google.common.collect.ForwardingQueue'
p16747
sg15
(lp16748
sg17
(lp16749
sg19
(lp16750
sg21
I0
sba(iArchitecture
Entity
p16751
(dp16752
g11
(lp16753
sg13
S'com.google.common.collect.ForwardingSet'
p16754
sg15
(lp16755
sg17
(lp16756
sg19
(lp16757
sg21
I0
sba(iArchitecture
Entity
p16758
(dp16759
g11
(lp16760
sg13
S'com.google.common.collect.ForwardingSetMultimap'
p16761
sg15
(lp16762
sg17
(lp16763
sg19
(lp16764
sg21
I0
sba(iArchitecture
Entity
p16765
(dp16766
g11
(lp16767
sg13
S'com.google.common.collect.ForwardingSortedMap'
p16768
sg15
(lp16769
sg17
(lp16770
sg19
(lp16771
sg21
I0
sba(iArchitecture
Entity
p16772
(dp16773
g11
(lp16774
sg13
S'com.google.common.collect.ForwardingSortedMap$StandardKeySet'
p16775
sg15
(lp16776
sg17
(lp16777
sg19
(lp16778
sg21
I0
sba(iArchitecture
Entity
p16779
(dp16780
g11
(lp16781
sg13
S'com.google.common.collect.ForwardingSortedMultiset'
p16782
sg15
(lp16783
sg17
(lp16784
sg19
(lp16785
sg21
I0
sba(iArchitecture
Entity
p16786
(dp16787
g11
(lp16788
sg13
S'com.google.common.collect.ForwardingSortedMultiset$StandardDescendingMultiset'
p16789
sg15
(lp16790
sg17
(lp16791
sg19
(lp16792
sg21
I0
sba(iArchitecture
Entity
p16793
(dp16794
g11
(lp16795
sg13
S'com.google.common.collect.ForwardingSortedMultiset$StandardElementSet'
p16796
sg15
(lp16797
sg17
(lp16798
sg19
(lp16799
sg21
I0
sba(iArchitecture
Entity
p16800
(dp16801
g11
(lp16802
sg13
S'com.google.common.collect.ForwardingSortedSet'
p16803
sg15
(lp16804
sg17
(lp16805
sg19
(lp16806
sg21
I0
sba(iArchitecture
Entity
p16807
(dp16808
g11
(lp16809
sg13
S'com.google.common.collect.ForwardingSortedSetMultimap'
p16810
sg15
(lp16811
sg17
(lp16812
sg19
(lp16813
sg21
I0
sba(iArchitecture
Entity
p16814
(dp16815
g11
(lp16816
sg13
S'com.google.common.collect.ForwardingTable'
p16817
sg15
(lp16818
sg17
(lp16819
sg19
(lp16820
sg21
I0
sba(iArchitecture
Entity
p16821
(dp16822
g11
(lp16823
sg13
S'com.google.common.collect.GeneralRange'
p16824
sg15
(lp16825
sg17
(lp16826
sg19
(lp16827
sg21
I0
sba(iArchitecture
Entity
p16828
(dp16829
g11
(lp16830
sg13
S'com.google.common.collect.GwtTransient'
p16831
sg15
(lp16832
sg17
(lp16833
sg19
(lp16834
sg21
I0
sba(iArchitecture
Entity
p16835
(dp16836
g11
(lp16837
sg13
S'com.google.common.collect.HashBasedTable'
p16838
sg15
(lp16839
sg17
(lp16840
sg19
(lp16841
sg21
I0
sba(iArchitecture
Entity
p16842
(dp16843
g11
(lp16844
sg13
S'com.google.common.collect.HashBasedTable$Factory'
p16845
sg15
(lp16846
sg17
(lp16847
sg19
(lp16848
sg21
I0
sba(iArchitecture
Entity
p16849
(dp16850
g11
(lp16851
sg13
S'com.google.common.collect.HashBiMap'
p16852
sg15
(lp16853
sg17
(lp16854
sg19
(lp16855
sg21
I0
sba(iArchitecture
Entity
p16856
(dp16857
g11
(lp16858
sg13
S'com.google.common.collect.HashBiMap$1'
p16859
sg15
(lp16860
sg17
(lp16861
sg19
(lp16862
sg21
I0
sba(iArchitecture
Entity
p16863
(dp16864
g11
(lp16865
sg13
S'com.google.common.collect.HashBiMap$1$MapEntry'
p16866
sg15
(lp16867
sg17
(lp16868
sg19
(lp16869
sg21
I0
sba(iArchitecture
Entity
p16870
(dp16871
g11
(lp16872
sg13
S'com.google.common.collect.HashBiMap$1.MapEntry'
p16873
sg15
(lp16874
sg17
(lp16875
sg19
(lp16876
sg21
I0
sba(iArchitecture
Entity
p16877
(dp16878
g11
(lp16879
sg13
S'com.google.common.collect.HashBiMap$BiEntry'
p16880
sg15
(lp16881
sg17
(lp16882
sg19
(lp16883
sg21
I0
sba(iArchitecture
Entity
p16884
(dp16885
g11
(lp16886
sg13
S'com.google.common.collect.HashBiMap$Inverse'
p16887
sg15
(lp16888
sg17
(lp16889
sg19
(lp16890
sg21
I0
sba(iArchitecture
Entity
p16891
(dp16892
g11
(lp16893
sg13
S'com.google.common.collect.HashBiMap$Inverse$1'
p16894
sg15
(lp16895
sg17
(lp16896
sg19
(lp16897
sg21
I0
sba(iArchitecture
Entity
p16898
(dp16899
g11
(lp16900
sg13
S'com.google.common.collect.HashBiMap$Inverse$1$1'
p16901
sg15
(lp16902
sg17
(lp16903
sg19
(lp16904
sg21
I0
sba(iArchitecture
Entity
p16905
(dp16906
g11
(lp16907
sg13
S'com.google.common.collect.HashBiMap$Inverse$1$1$InverseEntry'
p16908
sg15
(lp16909
sg17
(lp16910
sg19
(lp16911
sg21
I0
sba(iArchitecture
Entity
p16912
(dp16913
g11
(lp16914
sg13
S'com.google.common.collect.HashBiMap$Inverse$1$1.InverseEntry'
p16915
sg15
(lp16916
sg17
(lp16917
sg19
(lp16918
sg21
I0
sba(iArchitecture
Entity
p16919
(dp16920
g11
(lp16921
sg13
S'com.google.common.collect.HashBiMap$Inverse$InverseKeySet'
p16922
sg15
(lp16923
sg17
(lp16924
sg19
(lp16925
sg21
I0
sba(iArchitecture
Entity
p16926
(dp16927
g11
(lp16928
sg13
S'com.google.common.collect.HashBiMap$Inverse$InverseKeySet$1'
p16929
sg15
(lp16930
sg17
(lp16931
sg19
(lp16932
sg21
I0
sba(iArchitecture
Entity
p16933
(dp16934
g11
(lp16935
sg13
S'com.google.common.collect.HashBiMap$InverseSerializedForm'
p16936
sg15
(lp16937
sg17
(lp16938
sg19
(lp16939
sg21
I0
sba(iArchitecture
Entity
p16940
(dp16941
g11
(lp16942
sg13
S'com.google.common.collect.HashBiMap$Itr'
p16943
sg15
(lp16944
sg17
(lp16945
sg19
(lp16946
sg21
I0
sba(iArchitecture
Entity
p16947
(dp16948
g11
(lp16949
sg13
S'com.google.common.collect.HashBiMap$KeySet'
p16950
sg15
(lp16951
sg17
(lp16952
sg19
(lp16953
sg21
I0
sba(iArchitecture
Entity
p16954
(dp16955
g11
(lp16956
sg13
S'com.google.common.collect.HashBiMap$KeySet$1'
p16957
sg15
(lp16958
sg17
(lp16959
sg19
(lp16960
sg21
I0
sba(iArchitecture
Entity
p16961
(dp16962
g11
(lp16963
sg13
S'com.google.common.collect.Hashing'
p16964
sg15
(lp16965
sg17
(lp16966
sg19
(lp16967
sg21
I0
sba(iArchitecture
Entity
p16968
(dp16969
g11
(lp16970
sg13
S'com.google.common.collect.ImmutableAsList'
p16971
sg15
(lp16972
sg17
(lp16973
sg19
(lp16974
sg21
I0
sba(iArchitecture
Entity
p16975
(dp16976
g11
(lp16977
sg13
S'com.google.common.collect.ImmutableAsList$SerializedForm'
p16978
sg15
(lp16979
sg17
(lp16980
sg19
(lp16981
sg21
I0
sba(iArchitecture
Entity
p16982
(dp16983
g11
(lp16984
sg13
S'com.google.common.collect.ImmutableBiMap'
p16985
sg15
(lp16986
sg17
(lp16987
sg19
(lp16988
sg21
I0
sba(iArchitecture
Entity
p16989
(dp16990
g11
(lp16991
sg13
S'com.google.common.collect.ImmutableBiMap$Builder'
p16992
sg15
(lp16993
sg17
(lp16994
sg19
(lp16995
sg21
I0
sba(iArchitecture
Entity
p16996
(dp16997
g11
(lp16998
sg13
S'com.google.common.collect.ImmutableBiMap$SerializedForm'
p16999
sg15
(lp17000
sg17
(lp17001
sg19
(lp17002
sg21
I0
sba(iArchitecture
Entity
p17003
(dp17004
g11
(lp17005
sg13
S'com.google.common.collect.ImmutableClassToInstanceMap'
p17006
sg15
(lp17007
sg17
(lp17008
sg19
(lp17009
sg21
I0
sba(iArchitecture
Entity
p17010
(dp17011
g11
(lp17012
sg13
S'com.google.common.collect.ImmutableClassToInstanceMap$1'
p17013
sg15
(lp17014
sg17
(lp17015
sg19
(lp17016
sg21
I0
sba(iArchitecture
Entity
p17017
(dp17018
g11
(lp17019
sg13
S'com.google.common.collect.ImmutableClassToInstanceMap$Builder'
p17020
sg15
(lp17021
sg17
(lp17022
sg19
(lp17023
sg21
I0
sba(iArchitecture
Entity
p17024
(dp17025
g11
(lp17026
sg13
S'com.google.common.collect.ImmutableCollection'
p17027
sg15
(lp17028
sg17
(lp17029
sg19
(lp17030
sg21
I0
sba(iArchitecture
Entity
p17031
(dp17032
g11
(lp17033
sg13
S'com.google.common.collect.ImmutableCollection$ArrayBasedBuilder'
p17034
sg15
(lp17035
sg17
(lp17036
sg19
(lp17037
sg21
I0
sba(iArchitecture
Entity
p17038
(dp17039
g11
(lp17040
sg13
S'com.google.common.collect.ImmutableCollection$Builder'
p17041
sg15
(lp17042
sg17
(lp17043
sg19
(lp17044
sg21
I0
sba(iArchitecture
Entity
p17045
(dp17046
g11
(lp17047
sg13
S'com.google.common.collect.ImmutableEntry'
p17048
sg15
(lp17049
sg17
(lp17050
sg19
(lp17051
sg21
I0
sba(iArchitecture
Entity
p17052
(dp17053
g11
(lp17054
sg13
S'com.google.common.collect.ImmutableEnumMap'
p17055
sg15
(lp17056
sg17
(lp17057
sg19
(lp17058
sg21
I0
sba(iArchitecture
Entity
p17059
(dp17060
g11
(lp17061
sg13
S'com.google.common.collect.ImmutableEnumMap$1'
p17062
sg15
(lp17063
sg17
(lp17064
sg19
(lp17065
sg21
I0
sba(iArchitecture
Entity
p17066
(dp17067
g11
(lp17068
sg13
S'com.google.common.collect.ImmutableEnumMap$EnumSerializedForm'
p17069
sg15
(lp17070
sg17
(lp17071
sg19
(lp17072
sg21
I0
sba(iArchitecture
Entity
p17073
(dp17074
g11
(lp17075
sg13
S'com.google.common.collect.ImmutableEnumSet'
p17076
sg15
(lp17077
sg17
(lp17078
sg19
(lp17079
sg21
I0
sba(iArchitecture
Entity
p17080
(dp17081
g11
(lp17082
sg13
S'com.google.common.collect.ImmutableEnumSet$1'
p17083
sg15
(lp17084
sg17
(lp17085
sg19
(lp17086
sg21
I0
sba(iArchitecture
Entity
p17087
(dp17088
g11
(lp17089
sg13
S'com.google.common.collect.ImmutableEnumSet$EnumSerializedForm'
p17090
sg15
(lp17091
sg17
(lp17092
sg19
(lp17093
sg21
I0
sba(iArchitecture
Entity
p17094
(dp17095
g11
(lp17096
sg13
S'com.google.common.collect.ImmutableList'
p17097
sg15
(lp17098
sg17
(lp17099
sg19
(lp17100
sg21
I0
sba(iArchitecture
Entity
p17101
(dp17102
g11
(lp17103
sg13
S'com.google.common.collect.ImmutableList$1'
p17104
sg15
(lp17105
sg17
(lp17106
sg19
(lp17107
sg21
I0
sba(iArchitecture
Entity
p17108
(dp17109
g11
(lp17110
sg13
S'com.google.common.collect.ImmutableList$Builder'
p17111
sg15
(lp17112
sg17
(lp17113
sg19
(lp17114
sg21
I0
sba(iArchitecture
Entity
p17115
(dp17116
g11
(lp17117
sg13
S'com.google.common.collect.ImmutableList$ReverseImmutableList'
p17118
sg15
(lp17119
sg17
(lp17120
sg19
(lp17121
sg21
I0
sba(iArchitecture
Entity
p17122
(dp17123
g11
(lp17124
sg13
S'com.google.common.collect.ImmutableList$SerializedForm'
p17125
sg15
(lp17126
sg17
(lp17127
sg19
(lp17128
sg21
I0
sba(iArchitecture
Entity
p17129
(dp17130
g11
(lp17131
sg13
S'com.google.common.collect.ImmutableList$SubList'
p17132
sg15
(lp17133
sg17
(lp17134
sg19
(lp17135
sg21
I0
sba(iArchitecture
Entity
p17136
(dp17137
g11
(lp17138
sg13
S'com.google.common.collect.ImmutableListMultimap'
p17139
sg15
(lp17140
sg17
(lp17141
sg19
(lp17142
sg21
I0
sba(iArchitecture
Entity
p17143
(dp17144
g11
(lp17145
sg13
S'com.google.common.collect.ImmutableListMultimap$Builder'
p17146
sg15
(lp17147
sg17
(lp17148
sg19
(lp17149
sg21
I0
sba(iArchitecture
Entity
p17150
(dp17151
g11
(lp17152
sg13
S'com.google.common.collect.ImmutableMap'
p17153
sg15
(lp17154
sg17
(lp17155
sg19
(lp17156
sg21
I0
sba(iArchitecture
Entity
p17157
(dp17158
g11
(lp17159
sg13
S'com.google.common.collect.ImmutableMap$1'
p17160
sg15
(lp17161
sg17
(lp17162
sg19
(lp17163
sg21
I0
sba(iArchitecture
Entity
p17164
(dp17165
g11
(lp17166
sg13
S'com.google.common.collect.ImmutableMap$Builder'
p17167
sg15
(lp17168
sg17
(lp17169
sg19
(lp17170
sg21
I0
sba(iArchitecture
Entity
p17171
(dp17172
g11
(lp17173
sg13
S'com.google.common.collect.ImmutableMap$IteratorBasedImmutableMap'
p17174
sg15
(lp17175
sg17
(lp17176
sg19
(lp17177
sg21
I0
sba(iArchitecture
Entity
p17178
(dp17179
g11
(lp17180
sg13
S'com.google.common.collect.ImmutableMap$IteratorBasedImmutableMap$1EntrySetImpl'
p17181
sg15
(lp17182
sg17
(lp17183
sg19
(lp17184
sg21
I0
sba(iArchitecture
Entity
p17185
(dp17186
g11
(lp17187
sg13
S'com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets'
p17188
sg15
(lp17189
sg17
(lp17190
sg19
(lp17191
sg21
I0
sba(iArchitecture
Entity
p17192
(dp17193
g11
(lp17194
sg13
S'com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1'
p17195
sg15
(lp17196
sg17
(lp17197
sg19
(lp17198
sg21
I0
sba(iArchitecture
Entity
p17199
(dp17200
g11
(lp17201
sg13
S'com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1$1'
p17202
sg15
(lp17203
sg17
(lp17204
sg19
(lp17205
sg21
I0
sba(iArchitecture
Entity
p17206
(dp17207
g11
(lp17208
sg13
S'com.google.common.collect.ImmutableMap$SerializedForm'
p17209
sg15
(lp17210
sg17
(lp17211
sg19
(lp17212
sg21
I0
sba(iArchitecture
Entity
p17213
(dp17214
g11
(lp17215
sg13
S'com.google.common.collect.ImmutableMapEntry'
p17216
sg15
(lp17217
sg17
(lp17218
sg19
(lp17219
sg21
I0
sba(iArchitecture
Entity
p17220
(dp17221
g11
(lp17222
sg13
S'com.google.common.collect.ImmutableMapEntry$NonTerminalImmutableBiMapEntry'
p17223
sg15
(lp17224
sg17
(lp17225
sg19
(lp17226
sg21
I0
sba(iArchitecture
Entity
p17227
(dp17228
g11
(lp17229
sg13
S'com.google.common.collect.ImmutableMapEntry$NonTerminalImmutableMapEntry'
p17230
sg15
(lp17231
sg17
(lp17232
sg19
(lp17233
sg21
I0
sba(iArchitecture
Entity
p17234
(dp17235
g11
(lp17236
sg13
S'com.google.common.collect.ImmutableMapEntrySet'
p17237
sg15
(lp17238
sg17
(lp17239
sg19
(lp17240
sg21
I0
sba(iArchitecture
Entity
p17241
(dp17242
g11
(lp17243
sg13
S'com.google.common.collect.ImmutableMapEntrySet$EntrySetSerializedForm'
p17244
sg15
(lp17245
sg17
(lp17246
sg19
(lp17247
sg21
I0
sba(iArchitecture
Entity
p17248
(dp17249
g11
(lp17250
sg13
S'com.google.common.collect.ImmutableMapEntrySet$RegularEntrySet'
p17251
sg15
(lp17252
sg17
(lp17253
sg19
(lp17254
sg21
I0
sba(iArchitecture
Entity
p17255
(dp17256
g11
(lp17257
sg13
S'com.google.common.collect.ImmutableMapKeySet'
p17258
sg15
(lp17259
sg17
(lp17260
sg19
(lp17261
sg21
I0
sba(iArchitecture
Entity
p17262
(dp17263
g11
(lp17264
sg13
S'com.google.common.collect.ImmutableMapKeySet$KeySetSerializedForm'
p17265
sg15
(lp17266
sg17
(lp17267
sg19
(lp17268
sg21
I0
sba(iArchitecture
Entity
p17269
(dp17270
g11
(lp17271
sg13
S'com.google.common.collect.ImmutableMapValues'
p17272
sg15
(lp17273
sg17
(lp17274
sg19
(lp17275
sg21
I0
sba(iArchitecture
Entity
p17276
(dp17277
g11
(lp17278
sg13
S'com.google.common.collect.ImmutableMapValues$1'
p17279
sg15
(lp17280
sg17
(lp17281
sg19
(lp17282
sg21
I0
sba(iArchitecture
Entity
p17283
(dp17284
g11
(lp17285
sg13
S'com.google.common.collect.ImmutableMapValues$2'
p17286
sg15
(lp17287
sg17
(lp17288
sg19
(lp17289
sg21
I0
sba(iArchitecture
Entity
p17290
(dp17291
g11
(lp17292
sg13
S'com.google.common.collect.ImmutableMapValues$SerializedForm'
p17293
sg15
(lp17294
sg17
(lp17295
sg19
(lp17296
sg21
I0
sba(iArchitecture
Entity
p17297
(dp17298
g11
(lp17299
sg13
S'com.google.common.collect.ImmutableMultimap'
p17300
sg15
(lp17301
sg17
(lp17302
sg19
(lp17303
sg21
I0
sba(iArchitecture
Entity
p17304
(dp17305
g11
(lp17306
sg13
S'com.google.common.collect.ImmutableMultimap$1'
p17307
sg15
(lp17308
sg17
(lp17309
sg19
(lp17310
sg21
I0
sba(iArchitecture
Entity
p17311
(dp17312
g11
(lp17313
sg13
S'com.google.common.collect.ImmutableMultimap$2'
p17314
sg15
(lp17315
sg17
(lp17316
sg19
(lp17317
sg21
I0
sba(iArchitecture
Entity
p17318
(dp17319
g11
(lp17320
sg13
S'com.google.common.collect.ImmutableMultimap$Builder'
p17321
sg15
(lp17322
sg17
(lp17323
sg19
(lp17324
sg21
I0
sba(iArchitecture
Entity
p17325
(dp17326
g11
(lp17327
sg13
S'com.google.common.collect.ImmutableMultimap$EntryCollection'
p17328
sg15
(lp17329
sg17
(lp17330
sg19
(lp17331
sg21
I0
sba(iArchitecture
Entity
p17332
(dp17333
g11
(lp17334
sg13
S'com.google.common.collect.ImmutableMultimap$FieldSettersHolder'
p17335
sg15
(lp17336
sg17
(lp17337
sg19
(lp17338
sg21
I0
sba(iArchitecture
Entity
p17339
(dp17340
g11
(lp17341
sg13
S'com.google.common.collect.ImmutableMultimap$Itr'
p17342
sg15
(lp17343
sg17
(lp17344
sg19
(lp17345
sg21
I0
sba(iArchitecture
Entity
p17346
(dp17347
g11
(lp17348
sg13
S'com.google.common.collect.ImmutableMultimap$Keys'
p17349
sg15
(lp17350
sg17
(lp17351
sg19
(lp17352
sg21
I0
sba(iArchitecture
Entity
p17353
(dp17354
g11
(lp17355
sg13
S'com.google.common.collect.ImmutableMultimap$Values'
p17356
sg15
(lp17357
sg17
(lp17358
sg19
(lp17359
sg21
I0
sba(iArchitecture
Entity
p17360
(dp17361
g11
(lp17362
sg13
S'com.google.common.collect.ImmutableMultiset'
p17363
sg15
(lp17364
sg17
(lp17365
sg19
(lp17366
sg21
I0
sba(iArchitecture
Entity
p17367
(dp17368
g11
(lp17369
sg13
S'com.google.common.collect.ImmutableMultiset$1'
p17370
sg15
(lp17371
sg17
(lp17372
sg19
(lp17373
sg21
I0
sba(iArchitecture
Entity
p17374
(dp17375
g11
(lp17376
sg13
S'com.google.common.collect.ImmutableMultiset$Builder'
p17377
sg15
(lp17378
sg17
(lp17379
sg19
(lp17380
sg21
I0
sba(iArchitecture
Entity
p17381
(dp17382
g11
(lp17383
sg13
S'com.google.common.collect.ImmutableMultiset$EntrySet'
p17384
sg15
(lp17385
sg17
(lp17386
sg19
(lp17387
sg21
I0
sba(iArchitecture
Entity
p17388
(dp17389
g11
(lp17390
sg13
S'com.google.common.collect.ImmutableMultiset$EntrySetSerializedForm'
p17391
sg15
(lp17392
sg17
(lp17393
sg19
(lp17394
sg21
I0
sba(iArchitecture
Entity
p17395
(dp17396
g11
(lp17397
sg13
S'com.google.common.collect.ImmutableMultiset$SerializedForm'
p17398
sg15
(lp17399
sg17
(lp17400
sg19
(lp17401
sg21
I0
sba(iArchitecture
Entity
p17402
(dp17403
g11
(lp17404
sg13
S'com.google.common.collect.ImmutableRangeMap'
p17405
sg15
(lp17406
sg17
(lp17407
sg19
(lp17408
sg21
I0
sba(iArchitecture
Entity
p17409
(dp17410
g11
(lp17411
sg13
S'com.google.common.collect.ImmutableRangeMap$1'
p17412
sg15
(lp17413
sg17
(lp17414
sg19
(lp17415
sg21
I0
sba(iArchitecture
Entity
p17416
(dp17417
g11
(lp17418
sg13
S'com.google.common.collect.ImmutableRangeMap$2'
p17419
sg15
(lp17420
sg17
(lp17421
sg19
(lp17422
sg21
I0
sba(iArchitecture
Entity
p17423
(dp17424
g11
(lp17425
sg13
S'com.google.common.collect.ImmutableRangeMap$Builder'
p17426
sg15
(lp17427
sg17
(lp17428
sg19
(lp17429
sg21
I0
sba(iArchitecture
Entity
p17430
(dp17431
g11
(lp17432
sg13
S'com.google.common.collect.ImmutableRangeMap$SerializedForm'
p17433
sg15
(lp17434
sg17
(lp17435
sg19
(lp17436
sg21
I0
sba(iArchitecture
Entity
p17437
(dp17438
g11
(lp17439
sg13
S'com.google.common.collect.ImmutableRangeSet'
p17440
sg15
(lp17441
sg17
(lp17442
sg19
(lp17443
sg21
I0
sba(iArchitecture
Entity
p17444
(dp17445
g11
(lp17446
sg13
S'com.google.common.collect.ImmutableRangeSet$1'
p17447
sg15
(lp17448
sg17
(lp17449
sg19
(lp17450
sg21
I0
sba(iArchitecture
Entity
p17451
(dp17452
g11
(lp17453
sg13
S'com.google.common.collect.ImmutableRangeSet$AsSet'
p17454
sg15
(lp17455
sg17
(lp17456
sg19
(lp17457
sg21
I0
sba(iArchitecture
Entity
p17458
(dp17459
g11
(lp17460
sg13
S'com.google.common.collect.ImmutableRangeSet$AsSet$1'
p17461
sg15
(lp17462
sg17
(lp17463
sg19
(lp17464
sg21
I0
sba(iArchitecture
Entity
p17465
(dp17466
g11
(lp17467
sg13
S'com.google.common.collect.ImmutableRangeSet$AsSet$2'
p17468
sg15
(lp17469
sg17
(lp17470
sg19
(lp17471
sg21
I0
sba(iArchitecture
Entity
p17472
(dp17473
g11
(lp17474
sg13
S'com.google.common.collect.ImmutableRangeSet$AsSetSerializedForm'
p17475
sg15
(lp17476
sg17
(lp17477
sg19
(lp17478
sg21
I0
sba(iArchitecture
Entity
p17479
(dp17480
g11
(lp17481
sg13
S'com.google.common.collect.ImmutableRangeSet$Builder'
p17482
sg15
(lp17483
sg17
(lp17484
sg19
(lp17485
sg21
I0
sba(iArchitecture
Entity
p17486
(dp17487
g11
(lp17488
sg13
S'com.google.common.collect.ImmutableRangeSet$ComplementRanges'
p17489
sg15
(lp17490
sg17
(lp17491
sg19
(lp17492
sg21
I0
sba(iArchitecture
Entity
p17493
(dp17494
g11
(lp17495
sg13
S'com.google.common.collect.ImmutableRangeSet$SerializedForm'
p17496
sg15
(lp17497
sg17
(lp17498
sg19
(lp17499
sg21
I0
sba(iArchitecture
Entity
p17500
(dp17501
g11
(lp17502
sg13
S'com.google.common.collect.ImmutableSet'
p17503
sg15
(lp17504
sg17
(lp17505
sg19
(lp17506
sg21
I0
sba(iArchitecture
Entity
p17507
(dp17508
g11
(lp17509
sg13
S'com.google.common.collect.ImmutableSet$Indexed'
p17510
sg15
(lp17511
sg17
(lp17512
sg19
(lp17513
sg21
I0
sba(iArchitecture
Entity
p17514
(dp17515
g11
(lp17516
sg13
S'com.google.common.collect.ImmutableSet$Indexed$1'
p17517
sg15
(lp17518
sg17
(lp17519
sg19
(lp17520
sg21
I0
sba(iArchitecture
Entity
p17521
(dp17522
g11
(lp17523
sg13
S'com.google.common.collect.ImmutableSet$SerializedForm'
p17524
sg15
(lp17525
sg17
(lp17526
sg19
(lp17527
sg21
I0
sba(iArchitecture
Entity
p17528
(dp17529
g11
(lp17530
sg13
S'com.google.common.collect.ImmutableSetMultimap'
p17531
sg15
(lp17532
sg17
(lp17533
sg19
(lp17534
sg21
I0
sba(iArchitecture
Entity
p17535
(dp17536
g11
(lp17537
sg13
S'com.google.common.collect.ImmutableSetMultimap$Builder'
p17538
sg15
(lp17539
sg17
(lp17540
sg19
(lp17541
sg21
I0
sba(iArchitecture
Entity
p17542
(dp17543
g11
(lp17544
sg13
S'com.google.common.collect.ImmutableSetMultimap$EntrySet'
p17545
sg15
(lp17546
sg17
(lp17547
sg19
(lp17548
sg21
I0
sba(iArchitecture
Entity
p17549
(dp17550
g11
(lp17551
sg13
S'com.google.common.collect.ImmutableSortedAsList'
p17552
sg15
(lp17553
sg17
(lp17554
sg19
(lp17555
sg21
I0
sba(iArchitecture
Entity
p17556
(dp17557
g11
(lp17558
sg13
S'com.google.common.collect.ImmutableSortedMap'
p17559
sg15
(lp17560
sg17
(lp17561
sg19
(lp17562
sg21
I0
sba(iArchitecture
Entity
p17563
(dp17564
g11
(lp17565
sg13
S'com.google.common.collect.ImmutableSortedMap$1EntrySet'
p17566
sg15
(lp17567
sg17
(lp17568
sg19
(lp17569
sg21
I0
sba(iArchitecture
Entity
p17570
(dp17571
g11
(lp17572
sg13
S'com.google.common.collect.ImmutableSortedMap$1EntrySet$1'
p17573
sg15
(lp17574
sg17
(lp17575
sg19
(lp17576
sg21
I0
sba(iArchitecture
Entity
p17577
(dp17578
g11
(lp17579
sg13
S'com.google.common.collect.ImmutableSortedMap$Builder'
p17580
sg15
(lp17581
sg17
(lp17582
sg19
(lp17583
sg21
I0
sba(iArchitecture
Entity
p17584
(dp17585
g11
(lp17586
sg13
S'com.google.common.collect.ImmutableSortedMap$SerializedForm'
p17587
sg15
(lp17588
sg17
(lp17589
sg19
(lp17590
sg21
I0
sba(iArchitecture
Entity
p17591
(dp17592
g11
(lp17593
sg13
S'com.google.common.collect.ImmutableSortedMapFauxverideShim'
p17594
sg15
(lp17595
sg17
(lp17596
sg19
(lp17597
sg21
I0
sba(iArchitecture
Entity
p17598
(dp17599
g11
(lp17600
sg13
S'com.google.common.collect.ImmutableSortedMultiset'
p17601
sg15
(lp17602
sg17
(lp17603
sg19
(lp17604
sg21
I0
sba(iArchitecture
Entity
p17605
(dp17606
g11
(lp17607
sg13
S'com.google.common.collect.ImmutableSortedMultiset$Builder'
p17608
sg15
(lp17609
sg17
(lp17610
sg19
(lp17611
sg21
I0
sba(iArchitecture
Entity
p17612
(dp17613
g11
(lp17614
sg13
S'com.google.common.collect.ImmutableSortedMultiset$SerializedForm'
p17615
sg15
(lp17616
sg17
(lp17617
sg19
(lp17618
sg21
I0
sba(iArchitecture
Entity
p17619
(dp17620
g11
(lp17621
sg13
S'com.google.common.collect.ImmutableSortedMultisetFauxverideShim'
p17622
sg15
(lp17623
sg17
(lp17624
sg19
(lp17625
sg21
I0
sba(iArchitecture
Entity
p17626
(dp17627
g11
(lp17628
sg13
S'com.google.common.collect.ImmutableSortedSet'
p17629
sg15
(lp17630
sg17
(lp17631
sg19
(lp17632
sg21
I0
sba(iArchitecture
Entity
p17633
(dp17634
g11
(lp17635
sg13
S'com.google.common.collect.ImmutableSortedSet$Builder'
p17636
sg15
(lp17637
sg17
(lp17638
sg19
(lp17639
sg21
I0
sba(iArchitecture
Entity
p17640
(dp17641
g11
(lp17642
sg13
S'com.google.common.collect.ImmutableSortedSet$SerializedForm'
p17643
sg15
(lp17644
sg17
(lp17645
sg19
(lp17646
sg21
I0
sba(iArchitecture
Entity
p17647
(dp17648
g11
(lp17649
sg13
S'com.google.common.collect.ImmutableSortedSetFauxverideShim'
p17650
sg15
(lp17651
sg17
(lp17652
sg19
(lp17653
sg21
I0
sba(iArchitecture
Entity
p17654
(dp17655
g11
(lp17656
sg13
S'com.google.common.collect.ImmutableTable'
p17657
sg15
(lp17658
sg17
(lp17659
sg19
(lp17660
sg21
I0
sba(iArchitecture
Entity
p17661
(dp17662
g11
(lp17663
sg13
S'com.google.common.collect.ImmutableTable$Builder'
p17664
sg15
(lp17665
sg17
(lp17666
sg19
(lp17667
sg21
I0
sba(iArchitecture
Entity
p17668
(dp17669
g11
(lp17670
sg13
S'com.google.common.collect.ImmutableTable$SerializedForm'
p17671
sg15
(lp17672
sg17
(lp17673
sg19
(lp17674
sg21
I0
sba(iArchitecture
Entity
p17675
(dp17676
g11
(lp17677
sg13
S'com.google.common.collect.Interner'
p17678
sg15
(lp17679
sg17
(lp17680
sg19
(lp17681
sg21
I0
sba(iArchitecture
Entity
p17682
(dp17683
g11
(lp17684
sg13
S'com.google.common.collect.Interners'
p17685
sg15
(lp17686
sg17
(lp17687
sg19
(lp17688
sg21
I0
sba(iArchitecture
Entity
p17689
(dp17690
g11
(lp17691
sg13
S'com.google.common.collect.Interners$1'
p17692
sg15
(lp17693
sg17
(lp17694
sg19
(lp17695
sg21
I0
sba(iArchitecture
Entity
p17696
(dp17697
g11
(lp17698
sg13
S'com.google.common.collect.Interners$InternerFunction'
p17699
sg15
(lp17700
sg17
(lp17701
sg19
(lp17702
sg21
I0
sba(iArchitecture
Entity
p17703
(dp17704
g11
(lp17705
sg13
S'com.google.common.collect.Interners$WeakInterner'
p17706
sg15
(lp17707
sg17
(lp17708
sg19
(lp17709
sg21
I0
sba(iArchitecture
Entity
p17710
(dp17711
g11
(lp17712
sg13
S'com.google.common.collect.Interners$WeakInterner$Dummy'
p17713
sg15
(lp17714
sg17
(lp17715
sg19
(lp17716
sg21
I0
sba(iArchitecture
Entity
p17717
(dp17718
g11
(lp17719
sg13
S'com.google.common.collect.Iterables'
p17720
sg15
(lp17721
sg17
(lp17722
sg19
(lp17723
sg21
I0
sba(iArchitecture
Entity
p17724
(dp17725
g11
(lp17726
sg13
S'com.google.common.collect.Iterables$1'
p17727
sg15
(lp17728
sg17
(lp17729
sg19
(lp17730
sg21
I0
sba(iArchitecture
Entity
p17731
(dp17732
g11
(lp17733
sg13
S'com.google.common.collect.Iterables$10'
p17734
sg15
(lp17735
sg17
(lp17736
sg19
(lp17737
sg21
I0
sba(iArchitecture
Entity
p17738
(dp17739
g11
(lp17740
sg13
S'com.google.common.collect.Iterables$11'
p17741
sg15
(lp17742
sg17
(lp17743
sg19
(lp17744
sg21
I0
sba(iArchitecture
Entity
p17745
(dp17746
g11
(lp17747
sg13
S'com.google.common.collect.Iterables$12'
p17748
sg15
(lp17749
sg17
(lp17750
sg19
(lp17751
sg21
I0
sba(iArchitecture
Entity
p17752
(dp17753
g11
(lp17754
sg13
S'com.google.common.collect.Iterables$13'
p17755
sg15
(lp17756
sg17
(lp17757
sg19
(lp17758
sg21
I0
sba(iArchitecture
Entity
p17759
(dp17760
g11
(lp17761
sg13
S'com.google.common.collect.Iterables$2'
p17762
sg15
(lp17763
sg17
(lp17764
sg19
(lp17765
sg21
I0
sba(iArchitecture
Entity
p17766
(dp17767
g11
(lp17768
sg13
S'com.google.common.collect.Iterables$3'
p17769
sg15
(lp17770
sg17
(lp17771
sg19
(lp17772
sg21
I0
sba(iArchitecture
Entity
p17773
(dp17774
g11
(lp17775
sg13
S'com.google.common.collect.Iterables$4'
p17776
sg15
(lp17777
sg17
(lp17778
sg19
(lp17779
sg21
I0
sba(iArchitecture
Entity
p17780
(dp17781
g11
(lp17782
sg13
S'com.google.common.collect.Iterables$5'
p17783
sg15
(lp17784
sg17
(lp17785
sg19
(lp17786
sg21
I0
sba(iArchitecture
Entity
p17787
(dp17788
g11
(lp17789
sg13
S'com.google.common.collect.Iterables$6'
p17790
sg15
(lp17791
sg17
(lp17792
sg19
(lp17793
sg21
I0
sba(iArchitecture
Entity
p17794
(dp17795
g11
(lp17796
sg13
S'com.google.common.collect.Iterables$7'
p17797
sg15
(lp17798
sg17
(lp17799
sg19
(lp17800
sg21
I0
sba(iArchitecture
Entity
p17801
(dp17802
g11
(lp17803
sg13
S'com.google.common.collect.Iterables$8'
p17804
sg15
(lp17805
sg17
(lp17806
sg19
(lp17807
sg21
I0
sba(iArchitecture
Entity
p17808
(dp17809
g11
(lp17810
sg13
S'com.google.common.collect.Iterables$8$1'
p17811
sg15
(lp17812
sg17
(lp17813
sg19
(lp17814
sg21
I0
sba(iArchitecture
Entity
p17815
(dp17816
g11
(lp17817
sg13
S'com.google.common.collect.Iterables$9'
p17818
sg15
(lp17819
sg17
(lp17820
sg19
(lp17821
sg21
I0
sba(iArchitecture
Entity
p17822
(dp17823
g11
(lp17824
sg13
S'com.google.common.collect.Iterables$UnmodifiableIterable'
p17825
sg15
(lp17826
sg17
(lp17827
sg19
(lp17828
sg21
I0
sba(iArchitecture
Entity
p17829
(dp17830
g11
(lp17831
sg13
S'com.google.common.collect.Iterators'
p17832
sg15
(lp17833
sg17
(lp17834
sg19
(lp17835
sg21
I0
sba(iArchitecture
Entity
p17836
(dp17837
g11
(lp17838
sg13
S'com.google.common.collect.Iterators$1'
p17839
sg15
(lp17840
sg17
(lp17841
sg19
(lp17842
sg21
I0
sba(iArchitecture
Entity
p17843
(dp17844
g11
(lp17845
sg13
S'com.google.common.collect.Iterators$10'
p17846
sg15
(lp17847
sg17
(lp17848
sg19
(lp17849
sg21
I0
sba(iArchitecture
Entity
p17850
(dp17851
g11
(lp17852
sg13
S'com.google.common.collect.Iterators$11'
p17853
sg15
(lp17854
sg17
(lp17855
sg19
(lp17856
sg21
I0
sba(iArchitecture
Entity
p17857
(dp17858
g11
(lp17859
sg13
S'com.google.common.collect.Iterators$12'
p17860
sg15
(lp17861
sg17
(lp17862
sg19
(lp17863
sg21
I0
sba(iArchitecture
Entity
p17864
(dp17865
g11
(lp17866
sg13
S'com.google.common.collect.Iterators$13'
p17867
sg15
(lp17868
sg17
(lp17869
sg19
(lp17870
sg21
I0
sba(iArchitecture
Entity
p17871
(dp17872
g11
(lp17873
sg13
S'com.google.common.collect.Iterators$2'
p17874
sg15
(lp17875
sg17
(lp17876
sg19
(lp17877
sg21
I0
sba(iArchitecture
Entity
p17878
(dp17879
g11
(lp17880
sg13
S'com.google.common.collect.Iterators$3'
p17881
sg15
(lp17882
sg17
(lp17883
sg19
(lp17884
sg21
I0
sba(iArchitecture
Entity
p17885
(dp17886
g11
(lp17887
sg13
S'com.google.common.collect.Iterators$4'
p17888
sg15
(lp17889
sg17
(lp17890
sg19
(lp17891
sg21
I0
sba(iArchitecture
Entity
p17892
(dp17893
g11
(lp17894
sg13
S'com.google.common.collect.Iterators$5'
p17895
sg15
(lp17896
sg17
(lp17897
sg19
(lp17898
sg21
I0
sba(iArchitecture
Entity
p17899
(dp17900
g11
(lp17901
sg13
S'com.google.common.collect.Iterators$6'
p17902
sg15
(lp17903
sg17
(lp17904
sg19
(lp17905
sg21
I0
sba(iArchitecture
Entity
p17906
(dp17907
g11
(lp17908
sg13
S'com.google.common.collect.Iterators$7'
p17909
sg15
(lp17910
sg17
(lp17911
sg19
(lp17912
sg21
I0
sba(iArchitecture
Entity
p17913
(dp17914
g11
(lp17915
sg13
S'com.google.common.collect.Iterators$8'
p17916
sg15
(lp17917
sg17
(lp17918
sg19
(lp17919
sg21
I0
sba(iArchitecture
Entity
p17920
(dp17921
g11
(lp17922
sg13
S'com.google.common.collect.Iterators$9'
p17923
sg15
(lp17924
sg17
(lp17925
sg19
(lp17926
sg21
I0
sba(iArchitecture
Entity
p17927
(dp17928
g11
(lp17929
sg13
S'com.google.common.collect.Iterators$ConcatenatedIterator'
p17930
sg15
(lp17931
sg17
(lp17932
sg19
(lp17933
sg21
I0
sba(iArchitecture
Entity
p17934
(dp17935
g11
(lp17936
sg13
S'com.google.common.collect.Iterators$ConcatenatedIterator$1'
p17937
sg15
(lp17938
sg17
(lp17939
sg19
(lp17940
sg21
I0
sba(iArchitecture
Entity
p17941
(dp17942
g11
(lp17943
sg13
S'com.google.common.collect.Iterators$MergingIterator'
p17944
sg15
(lp17945
sg17
(lp17946
sg19
(lp17947
sg21
I0
sba(iArchitecture
Entity
p17948
(dp17949
g11
(lp17950
sg13
S'com.google.common.collect.Iterators$MergingIterator$1'
p17951
sg15
(lp17952
sg17
(lp17953
sg19
(lp17954
sg21
I0
sba(iArchitecture
Entity
p17955
(dp17956
g11
(lp17957
sg13
S'com.google.common.collect.Iterators$PeekingImpl'
p17958
sg15
(lp17959
sg17
(lp17960
sg19
(lp17961
sg21
I0
sba(iArchitecture
Entity
p17962
(dp17963
g11
(lp17964
sg13
S'com.google.common.collect.LexicographicalOrdering'
p17965
sg15
(lp17966
sg17
(lp17967
sg19
(lp17968
sg21
I0
sba(iArchitecture
Entity
p17969
(dp17970
g11
(lp17971
sg13
S'com.google.common.collect.LinkedHashMultimap'
p17972
sg15
(lp17973
sg17
(lp17974
sg19
(lp17975
sg21
I0
sba(iArchitecture
Entity
p17976
(dp17977
g11
(lp17978
sg13
S'com.google.common.collect.LinkedHashMultimap$1'
p17979
sg15
(lp17980
sg17
(lp17981
sg19
(lp17982
sg21
I0
sba(iArchitecture
Entity
p17983
(dp17984
g11
(lp17985
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueEntry'
p17986
sg15
(lp17987
sg17
(lp17988
sg19
(lp17989
sg21
I0
sba(iArchitecture
Entity
p17990
(dp17991
g11
(lp17992
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueSet'
p17993
sg15
(lp17994
sg17
(lp17995
sg19
(lp17996
sg21
I0
sba(iArchitecture
Entity
p17997
(dp17998
g11
(lp17999
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueSet$1'
p18000
sg15
(lp18001
sg17
(lp18002
sg19
(lp18003
sg21
I0
sba(iArchitecture
Entity
p18004
(dp18005
g11
(lp18006
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueSetLink'
p18007
sg15
(lp18008
sg17
(lp18009
sg19
(lp18010
sg21
I0
sba(iArchitecture
Entity
p18011
(dp18012
g11
(lp18013
sg13
S'com.google.common.collect.LinkedHashMultiset'
p18014
sg15
(lp18015
sg17
(lp18016
sg19
(lp18017
sg21
I0
sba(iArchitecture
Entity
p18018
(dp18019
g11
(lp18020
sg13
S'com.google.common.collect.LinkedListMultimap'
p18021
sg15
(lp18022
sg17
(lp18023
sg19
(lp18024
sg21
I0
sba(iArchitecture
Entity
p18025
(dp18026
g11
(lp18027
sg13
S'com.google.common.collect.LinkedListMultimap$1'
p18028
sg15
(lp18029
sg17
(lp18030
sg19
(lp18031
sg21
I0
sba(iArchitecture
Entity
p18032
(dp18033
g11
(lp18034
sg13
S'com.google.common.collect.LinkedListMultimap$1EntriesImpl'
p18035
sg15
(lp18036
sg17
(lp18037
sg19
(lp18038
sg21
I0
sba(iArchitecture
Entity
p18039
(dp18040
g11
(lp18041
sg13
S'com.google.common.collect.LinkedListMultimap$1KeySetImpl'
p18042
sg15
(lp18043
sg17
(lp18044
sg19
(lp18045
sg21
I0
sba(iArchitecture
Entity
p18046
(dp18047
g11
(lp18048
sg13
S'com.google.common.collect.LinkedListMultimap$1ValuesImpl'
p18049
sg15
(lp18050
sg17
(lp18051
sg19
(lp18052
sg21
I0
sba(iArchitecture
Entity
p18053
(dp18054
g11
(lp18055
sg13
S'com.google.common.collect.LinkedListMultimap$1ValuesImpl$1'
p18056
sg15
(lp18057
sg17
(lp18058
sg19
(lp18059
sg21
I0
sba(iArchitecture
Entity
p18060
(dp18061
g11
(lp18062
sg13
S'com.google.common.collect.LinkedListMultimap$DistinctKeyIterator'
p18063
sg15
(lp18064
sg17
(lp18065
sg19
(lp18066
sg21
I0
sba(iArchitecture
Entity
p18067
(dp18068
g11
(lp18069
sg13
S'com.google.common.collect.LinkedListMultimap$KeyList'
p18070
sg15
(lp18071
sg17
(lp18072
sg19
(lp18073
sg21
I0
sba(iArchitecture
Entity
p18074
(dp18075
g11
(lp18076
sg13
S'com.google.common.collect.LinkedListMultimap$Node'
p18077
sg15
(lp18078
sg17
(lp18079
sg19
(lp18080
sg21
I0
sba(iArchitecture
Entity
p18081
(dp18082
g11
(lp18083
sg13
S'com.google.common.collect.LinkedListMultimap$NodeIterator'
p18084
sg15
(lp18085
sg17
(lp18086
sg19
(lp18087
sg21
I0
sba(iArchitecture
Entity
p18088
(dp18089
g11
(lp18090
sg13
S'com.google.common.collect.LinkedListMultimap$ValueForKeyIterator'
p18091
sg15
(lp18092
sg17
(lp18093
sg19
(lp18094
sg21
I0
sba(iArchitecture
Entity
p18095
(dp18096
g11
(lp18097
sg13
S'com.google.common.collect.ListMultimap'
p18098
sg15
(lp18099
sg17
(lp18100
sg19
(lp18101
sg21
I0
sba(iArchitecture
Entity
p18102
(dp18103
g11
(lp18104
sg13
S'com.google.common.collect.Lists'
p18105
sg15
(lp18106
sg17
(lp18107
sg19
(lp18108
sg21
I0
sba(iArchitecture
Entity
p18109
(dp18110
g11
(lp18111
sg13
S'com.google.common.collect.Lists$1'
p18112
sg15
(lp18113
sg17
(lp18114
sg19
(lp18115
sg21
I0
sba(iArchitecture
Entity
p18116
(dp18117
g11
(lp18118
sg13
S'com.google.common.collect.Lists$2'
p18119
sg15
(lp18120
sg17
(lp18121
sg19
(lp18122
sg21
I0
sba(iArchitecture
Entity
p18123
(dp18124
g11
(lp18125
sg13
S'com.google.common.collect.Lists$AbstractListWrapper'
p18126
sg15
(lp18127
sg17
(lp18128
sg19
(lp18129
sg21
I0
sba(iArchitecture
Entity
p18130
(dp18131
g11
(lp18132
sg13
S'com.google.common.collect.Lists$CharSequenceAsList'
p18133
sg15
(lp18134
sg17
(lp18135
sg19
(lp18136
sg21
I0
sba(iArchitecture
Entity
p18137
(dp18138
g11
(lp18139
sg13
S'com.google.common.collect.Lists$OnePlusArrayList'
p18140
sg15
(lp18141
sg17
(lp18142
sg19
(lp18143
sg21
I0
sba(iArchitecture
Entity
p18144
(dp18145
g11
(lp18146
sg13
S'com.google.common.collect.Lists$Partition'
p18147
sg15
(lp18148
sg17
(lp18149
sg19
(lp18150
sg21
I0
sba(iArchitecture
Entity
p18151
(dp18152
g11
(lp18153
sg13
S'com.google.common.collect.Lists$RandomAccessListWrapper'
p18154
sg15
(lp18155
sg17
(lp18156
sg19
(lp18157
sg21
I0
sba(iArchitecture
Entity
p18158
(dp18159
g11
(lp18160
sg13
S'com.google.common.collect.Lists$RandomAccessPartition'
p18161
sg15
(lp18162
sg17
(lp18163
sg19
(lp18164
sg21
I0
sba(iArchitecture
Entity
p18165
(dp18166
g11
(lp18167
sg13
S'com.google.common.collect.Lists$RandomAccessReverseList'
p18168
sg15
(lp18169
sg17
(lp18170
sg19
(lp18171
sg21
I0
sba(iArchitecture
Entity
p18172
(dp18173
g11
(lp18174
sg13
S'com.google.common.collect.Lists$ReverseList'
p18175
sg15
(lp18176
sg17
(lp18177
sg19
(lp18178
sg21
I0
sba(iArchitecture
Entity
p18179
(dp18180
g11
(lp18181
sg13
S'com.google.common.collect.Lists$ReverseList$1'
p18182
sg15
(lp18183
sg17
(lp18184
sg19
(lp18185
sg21
I0
sba(iArchitecture
Entity
p18186
(dp18187
g11
(lp18188
sg13
S'com.google.common.collect.Lists$StringAsImmutableList'
p18189
sg15
(lp18190
sg17
(lp18191
sg19
(lp18192
sg21
I0
sba(iArchitecture
Entity
p18193
(dp18194
g11
(lp18195
sg13
S'com.google.common.collect.Lists$TransformingRandomAccessList'
p18196
sg15
(lp18197
sg17
(lp18198
sg19
(lp18199
sg21
I0
sba(iArchitecture
Entity
p18200
(dp18201
g11
(lp18202
sg13
S'com.google.common.collect.Lists$TransformingRandomAccessList$1'
p18203
sg15
(lp18204
sg17
(lp18205
sg19
(lp18206
sg21
I0
sba(iArchitecture
Entity
p18207
(dp18208
g11
(lp18209
sg13
S'com.google.common.collect.Lists$TransformingSequentialList'
p18210
sg15
(lp18211
sg17
(lp18212
sg19
(lp18213
sg21
I0
sba(iArchitecture
Entity
p18214
(dp18215
g11
(lp18216
sg13
S'com.google.common.collect.Lists$TransformingSequentialList$1'
p18217
sg15
(lp18218
sg17
(lp18219
sg19
(lp18220
sg21
I0
sba(iArchitecture
Entity
p18221
(dp18222
g11
(lp18223
sg13
S'com.google.common.collect.Lists$TwoPlusArrayList'
p18224
sg15
(lp18225
sg17
(lp18226
sg19
(lp18227
sg21
I0
sba(iArchitecture
Entity
p18228
(dp18229
g11
(lp18230
sg13
S'com.google.common.collect.MapConstraint'
p18231
sg15
(lp18232
sg17
(lp18233
sg19
(lp18234
sg21
I0
sba(iArchitecture
Entity
p18235
(dp18236
g11
(lp18237
sg13
S'com.google.common.collect.MapConstraints'
p18238
sg15
(lp18239
sg17
(lp18240
sg19
(lp18241
sg21
I0
sba(iArchitecture
Entity
p18242
(dp18243
g11
(lp18244
sg13
S'com.google.common.collect.MapConstraints$1'
p18245
sg15
(lp18246
sg17
(lp18247
sg19
(lp18248
sg21
I0
sba(iArchitecture
Entity
p18249
(dp18250
g11
(lp18251
sg13
S'com.google.common.collect.MapConstraints$2'
p18252
sg15
(lp18253
sg17
(lp18254
sg19
(lp18255
sg21
I0
sba(iArchitecture
Entity
p18256
(dp18257
g11
(lp18258
sg13
S'com.google.common.collect.MapConstraints$2$1'
p18259
sg15
(lp18260
sg17
(lp18261
sg19
(lp18262
sg21
I0
sba(iArchitecture
Entity
p18263
(dp18264
g11
(lp18265
sg13
S'com.google.common.collect.MapConstraints$ConstrainedAsMapEntries'
p18266
sg15
(lp18267
sg17
(lp18268
sg19
(lp18269
sg21
I0
sba(iArchitecture
Entity
p18270
(dp18271
g11
(lp18272
sg13
S'com.google.common.collect.MapConstraints$ConstrainedAsMapEntries$1'
p18273
sg15
(lp18274
sg17
(lp18275
sg19
(lp18276
sg21
I0
sba(iArchitecture
Entity
p18277
(dp18278
g11
(lp18279
sg13
S'com.google.common.collect.MapConstraints$ConstrainedAsMapValues'
p18280
sg15
(lp18281
sg17
(lp18282
sg19
(lp18283
sg21
I0
sba(iArchitecture
Entity
p18284
(dp18285
g11
(lp18286
sg13
S'com.google.common.collect.MapConstraints$ConstrainedAsMapValues$1'
p18287
sg15
(lp18288
sg17
(lp18289
sg19
(lp18290
sg21
I0
sba(iArchitecture
Entity
p18291
(dp18292
g11
(lp18293
sg13
S'com.google.common.collect.MapConstraints$ConstrainedEntries'
p18294
sg15
(lp18295
sg17
(lp18296
sg19
(lp18297
sg21
I0
sba(iArchitecture
Entity
p18298
(dp18299
g11
(lp18300
sg13
S'com.google.common.collect.MapConstraints$ConstrainedEntries$1'
p18301
sg15
(lp18302
sg17
(lp18303
sg19
(lp18304
sg21
I0
sba(iArchitecture
Entity
p18305
(dp18306
g11
(lp18307
sg13
S'com.google.common.collect.MapConstraints$ConstrainedEntrySet'
p18308
sg15
(lp18309
sg17
(lp18310
sg19
(lp18311
sg21
I0
sba(iArchitecture
Entity
p18312
(dp18313
g11
(lp18314
sg13
S'com.google.common.collect.MapConstraints$ConstrainedListMultimap'
p18315
sg15
(lp18316
sg17
(lp18317
sg19
(lp18318
sg21
I0
sba(iArchitecture
Entity
p18319
(dp18320
g11
(lp18321
sg13
S'com.google.common.collect.MapConstraints$ConstrainedMap'
p18322
sg15
(lp18323
sg17
(lp18324
sg19
(lp18325
sg21
I0
sba(iArchitecture
Entity
p18326
(dp18327
g11
(lp18328
sg13
S'com.google.common.collect.MapConstraints$ConstrainedMultimap'
p18329
sg15
(lp18330
sg17
(lp18331
sg19
(lp18332
sg21
I0
sba(iArchitecture
Entity
p18333
(dp18334
g11
(lp18335
sg13
S'com.google.common.collect.MapConstraints$ConstrainedMultimap$1'
p18336
sg15
(lp18337
sg17
(lp18338
sg19
(lp18339
sg21
I0
sba(iArchitecture
Entity
p18340
(dp18341
g11
(lp18342
sg13
S'com.google.common.collect.MapConstraints$ConstrainedMultimap$1AsMap'
p18343
sg15
(lp18344
sg17
(lp18345
sg19
(lp18346
sg21
I0
sba(iArchitecture
Entity
p18347
(dp18348
g11
(lp18349
sg13
S'com.google.common.collect.MapDifference'
p18350
sg15
(lp18351
sg17
(lp18352
sg19
(lp18353
sg21
I0
sba(iArchitecture
Entity
p18354
(dp18355
g11
(lp18356
sg13
S'com.google.common.collect.MapDifference$ValueDifference'
p18357
sg15
(lp18358
sg17
(lp18359
sg19
(lp18360
sg21
I0
sba(iArchitecture
Entity
p18361
(dp18362
g11
(lp18363
sg13
S'com.google.common.collect.MapMaker'
p18364
sg15
(lp18365
sg17
(lp18366
sg19
(lp18367
sg21
I0
sba(iArchitecture
Entity
p18368
(dp18369
g11
(lp18370
sg13
S'com.google.common.collect.MapMakerInternalMap'
p18371
sg15
(lp18372
sg17
(lp18373
sg19
(lp18374
sg21
I0
sba(iArchitecture
Entity
p18375
(dp18376
g11
(lp18377
sg13
S'com.google.common.collect.MapMakerInternalMap$1'
p18378
sg15
(lp18379
sg17
(lp18380
sg19
(lp18381
sg21
I0
sba(iArchitecture
Entity
p18382
(dp18383
g11
(lp18384
sg13
S'com.google.common.collect.MapMakerInternalMap$AbstractSerializationProxy'
p18385
sg15
(lp18386
sg17
(lp18387
sg19
(lp18388
sg21
I0
sba(iArchitecture
Entity
p18389
(dp18390
g11
(lp18391
sg13
S'com.google.common.collect.MapMakerInternalMap$AbstractStrongKeyEntry'
p18392
sg15
(lp18393
sg17
(lp18394
sg19
(lp18395
sg21
I0
sba(iArchitecture
Entity
p18396
(dp18397
g11
(lp18398
sg13
S'com.google.common.collect.MapMakerInternalMap$AbstractWeakKeyEntry'
p18399
sg15
(lp18400
sg17
(lp18401
sg19
(lp18402
sg21
I0
sba(iArchitecture
Entity
p18403
(dp18404
g11
(lp18405
sg13
S'com.google.common.collect.MapMakerInternalMap$CleanupMapTask'
p18406
sg15
(lp18407
sg17
(lp18408
sg19
(lp18409
sg21
I0
sba(iArchitecture
Entity
p18410
(dp18411
g11
(lp18412
sg13
S'com.google.common.collect.MapMakerInternalMap$DummyInternalEntry'
p18413
sg15
(lp18414
sg17
(lp18415
sg19
(lp18416
sg21
I0
sba(iArchitecture
Entity
p18417
(dp18418
g11
(lp18419
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryIterator'
p18420
sg15
(lp18421
sg17
(lp18422
sg19
(lp18423
sg21
I0
sba(iArchitecture
Entity
p18424
(dp18425
g11
(lp18426
sg13
S'com.google.common.collect.MapMakerInternalMap$EntrySet'
p18427
sg15
(lp18428
sg17
(lp18429
sg19
(lp18430
sg21
I0
sba(iArchitecture
Entity
p18431
(dp18432
g11
(lp18433
sg13
S'com.google.common.collect.MapMakerInternalMap$HashIterator'
p18434
sg15
(lp18435
sg17
(lp18436
sg19
(lp18437
sg21
I0
sba(iArchitecture
Entity
p18438
(dp18439
g11
(lp18440
sg13
S'com.google.common.collect.MapMakerInternalMap$InternalEntry'
p18441
sg15
(lp18442
sg17
(lp18443
sg19
(lp18444
sg21
I0
sba(iArchitecture
Entity
p18445
(dp18446
g11
(lp18447
sg13
S'com.google.common.collect.MapMakerInternalMap$InternalEntryHelper'
p18448
sg15
(lp18449
sg17
(lp18450
sg19
(lp18451
sg21
I0
sba(iArchitecture
Entity
p18452
(dp18453
g11
(lp18454
sg13
S'com.google.common.collect.MapMakerInternalMap$KeyIterator'
p18455
sg15
(lp18456
sg17
(lp18457
sg19
(lp18458
sg21
I0
sba(iArchitecture
Entity
p18459
(dp18460
g11
(lp18461
sg13
S'com.google.common.collect.MapMakerInternalMap$KeySet'
p18462
sg15
(lp18463
sg17
(lp18464
sg19
(lp18465
sg21
I0
sba(iArchitecture
Entity
p18466
(dp18467
g11
(lp18468
sg13
S'com.google.common.collect.MapMakerInternalMap$SafeToArraySet'
p18469
sg15
(lp18470
sg17
(lp18471
sg19
(lp18472
sg21
I0
sba(iArchitecture
Entity
p18473
(dp18474
g11
(lp18475
sg13
S'com.google.common.collect.MapMakerInternalMap$Segment'
p18476
sg15
(lp18477
sg17
(lp18478
sg19
(lp18479
sg21
I0
sba(iArchitecture
Entity
p18480
(dp18481
g11
(lp18482
sg13
S'com.google.common.collect.MapMakerInternalMap$SerializationProxy'
p18483
sg15
(lp18484
sg17
(lp18485
sg19
(lp18486
sg21
I0
sba(iArchitecture
Entity
p18487
(dp18488
g11
(lp18489
sg13
S'com.google.common.collect.MapMakerInternalMap$Strength'
p18490
sg15
(lp18491
sg17
(lp18492
sg19
(lp18493
sg21
I0
sba(iArchitecture
Entity
p18494
(dp18495
g11
(lp18496
sg13
S'com.google.common.collect.MapMakerInternalMap$Strength$1'
p18497
sg15
(lp18498
sg17
(lp18499
sg19
(lp18500
sg21
I0
sba(iArchitecture
Entity
p18501
(dp18502
g11
(lp18503
sg13
S'com.google.common.collect.MapMakerInternalMap$Strength$2'
p18504
sg15
(lp18505
sg17
(lp18506
sg19
(lp18507
sg21
I0
sba(iArchitecture
Entity
p18508
(dp18509
g11
(lp18510
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyStrongValueEntry'
p18511
sg15
(lp18512
sg17
(lp18513
sg19
(lp18514
sg21
I0
sba(iArchitecture
Entity
p18515
(dp18516
g11
(lp18517
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyStrongValueEntry$Helper'
p18518
sg15
(lp18519
sg17
(lp18520
sg19
(lp18521
sg21
I0
sba(iArchitecture
Entity
p18522
(dp18523
g11
(lp18524
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyStrongValueSegment'
p18525
sg15
(lp18526
sg17
(lp18527
sg19
(lp18528
sg21
I0
sba(iArchitecture
Entity
p18529
(dp18530
g11
(lp18531
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyWeakValueEntry'
p18532
sg15
(lp18533
sg17
(lp18534
sg19
(lp18535
sg21
I0
sba(iArchitecture
Entity
p18536
(dp18537
g11
(lp18538
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyWeakValueEntry$Helper'
p18539
sg15
(lp18540
sg17
(lp18541
sg19
(lp18542
sg21
I0
sba(iArchitecture
Entity
p18543
(dp18544
g11
(lp18545
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyWeakValueSegment'
p18546
sg15
(lp18547
sg17
(lp18548
sg19
(lp18549
sg21
I0
sba(iArchitecture
Entity
p18550
(dp18551
g11
(lp18552
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongValueEntry'
p18553
sg15
(lp18554
sg17
(lp18555
sg19
(lp18556
sg21
I0
sba(iArchitecture
Entity
p18557
(dp18558
g11
(lp18559
sg13
S'com.google.common.collect.MapMakerInternalMap$ValueIterator'
p18560
sg15
(lp18561
sg17
(lp18562
sg19
(lp18563
sg21
I0
sba(iArchitecture
Entity
p18564
(dp18565
g11
(lp18566
sg13
S'com.google.common.collect.MapMakerInternalMap$Values'
p18567
sg15
(lp18568
sg17
(lp18569
sg19
(lp18570
sg21
I0
sba(iArchitecture
Entity
p18571
(dp18572
g11
(lp18573
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyStrongValueEntry'
p18574
sg15
(lp18575
sg17
(lp18576
sg19
(lp18577
sg21
I0
sba(iArchitecture
Entity
p18578
(dp18579
g11
(lp18580
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyStrongValueEntry$Helper'
p18581
sg15
(lp18582
sg17
(lp18583
sg19
(lp18584
sg21
I0
sba(iArchitecture
Entity
p18585
(dp18586
g11
(lp18587
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyStrongValueSegment'
p18588
sg15
(lp18589
sg17
(lp18590
sg19
(lp18591
sg21
I0
sba(iArchitecture
Entity
p18592
(dp18593
g11
(lp18594
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyWeakValueEntry'
p18595
sg15
(lp18596
sg17
(lp18597
sg19
(lp18598
sg21
I0
sba(iArchitecture
Entity
p18599
(dp18600
g11
(lp18601
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyWeakValueEntry$Helper'
p18602
sg15
(lp18603
sg17
(lp18604
sg19
(lp18605
sg21
I0
sba(iArchitecture
Entity
p18606
(dp18607
g11
(lp18608
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyWeakValueSegment'
p18609
sg15
(lp18610
sg17
(lp18611
sg19
(lp18612
sg21
I0
sba(iArchitecture
Entity
p18613
(dp18614
g11
(lp18615
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakValueEntry'
p18616
sg15
(lp18617
sg17
(lp18618
sg19
(lp18619
sg21
I0
sba(iArchitecture
Entity
p18620
(dp18621
g11
(lp18622
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakValueReference'
p18623
sg15
(lp18624
sg17
(lp18625
sg19
(lp18626
sg21
I0
sba(iArchitecture
Entity
p18627
(dp18628
g11
(lp18629
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakValueReferenceImpl'
p18630
sg15
(lp18631
sg17
(lp18632
sg19
(lp18633
sg21
I0
sba(iArchitecture
Entity
p18634
(dp18635
g11
(lp18636
sg13
S'com.google.common.collect.MapMakerInternalMap$WriteThroughEntry'
p18637
sg15
(lp18638
sg17
(lp18639
sg19
(lp18640
sg21
I0
sba(iArchitecture
Entity
p18641
(dp18642
g11
(lp18643
sg13
S'com.google.common.collect.Maps'
p18644
sg15
(lp18645
sg17
(lp18646
sg19
(lp18647
sg21
I0
sba(iArchitecture
Entity
p18648
(dp18649
g11
(lp18650
sg13
S'com.google.common.collect.Maps$1'
p18651
sg15
(lp18652
sg17
(lp18653
sg19
(lp18654
sg21
I0
sba(iArchitecture
Entity
p18655
(dp18656
g11
(lp18657
sg13
S'com.google.common.collect.Maps$10'
p18658
sg15
(lp18659
sg17
(lp18660
sg19
(lp18661
sg21
I0
sba(iArchitecture
Entity
p18662
(dp18663
g11
(lp18664
sg13
S'com.google.common.collect.Maps$11'
p18665
sg15
(lp18666
sg17
(lp18667
sg19
(lp18668
sg21
I0
sba(iArchitecture
Entity
p18669
(dp18670
g11
(lp18671
sg13
S'com.google.common.collect.Maps$2'
p18672
sg15
(lp18673
sg17
(lp18674
sg19
(lp18675
sg21
I0
sba(iArchitecture
Entity
p18676
(dp18677
g11
(lp18678
sg13
S'com.google.common.collect.Maps$3'
p18679
sg15
(lp18680
sg17
(lp18681
sg19
(lp18682
sg21
I0
sba(iArchitecture
Entity
p18683
(dp18684
g11
(lp18685
sg13
S'com.google.common.collect.Maps$4'
p18686
sg15
(lp18687
sg17
(lp18688
sg19
(lp18689
sg21
I0
sba(iArchitecture
Entity
p18690
(dp18691
g11
(lp18692
sg13
S'com.google.common.collect.Maps$5'
p18693
sg15
(lp18694
sg17
(lp18695
sg19
(lp18696
sg21
I0
sba(iArchitecture
Entity
p18697
(dp18698
g11
(lp18699
sg13
S'com.google.common.collect.Maps$6'
p18700
sg15
(lp18701
sg17
(lp18702
sg19
(lp18703
sg21
I0
sba(iArchitecture
Entity
p18704
(dp18705
g11
(lp18706
sg13
S'com.google.common.collect.Maps$7'
p18707
sg15
(lp18708
sg17
(lp18709
sg19
(lp18710
sg21
I0
sba(iArchitecture
Entity
p18711
(dp18712
g11
(lp18713
sg13
S'com.google.common.collect.Maps$8'
p18714
sg15
(lp18715
sg17
(lp18716
sg19
(lp18717
sg21
I0
sba(iArchitecture
Entity
p18718
(dp18719
g11
(lp18720
sg13
S'com.google.common.collect.Maps$9'
p18721
sg15
(lp18722
sg17
(lp18723
sg19
(lp18724
sg21
I0
sba(iArchitecture
Entity
p18725
(dp18726
g11
(lp18727
sg13
S'com.google.common.collect.Maps$AbstractFilteredMap'
p18728
sg15
(lp18729
sg17
(lp18730
sg19
(lp18731
sg21
I0
sba(iArchitecture
Entity
p18732
(dp18733
g11
(lp18734
sg13
S'com.google.common.collect.Maps$AsMapView'
p18735
sg15
(lp18736
sg17
(lp18737
sg19
(lp18738
sg21
I0
sba(iArchitecture
Entity
p18739
(dp18740
g11
(lp18741
sg13
S'com.google.common.collect.Maps$AsMapView$1EntrySetImpl'
p18742
sg15
(lp18743
sg17
(lp18744
sg19
(lp18745
sg21
I0
sba(iArchitecture
Entity
p18746
(dp18747
g11
(lp18748
sg13
S'com.google.common.collect.Maps$BiMapConverter'
p18749
sg15
(lp18750
sg17
(lp18751
sg19
(lp18752
sg21
I0
sba(iArchitecture
Entity
p18753
(dp18754
g11
(lp18755
sg13
S'com.google.common.collect.Maps$DescendingMap'
p18756
sg15
(lp18757
sg17
(lp18758
sg19
(lp18759
sg21
I0
sba(iArchitecture
Entity
p18760
(dp18761
g11
(lp18762
sg13
S'com.google.common.collect.Maps$DescendingMap$1EntrySetImpl'
p18763
sg15
(lp18764
sg17
(lp18765
sg19
(lp18766
sg21
I0
sba(iArchitecture
Entity
p18767
(dp18768
g11
(lp18769
sg13
S'com.google.common.collect.Maps$EntryFunction'
p18770
sg15
(lp18771
sg17
(lp18772
sg19
(lp18773
sg21
I0
sba(iArchitecture
Entity
p18774
(dp18775
g11
(lp18776
sg13
S'com.google.common.collect.Maps$EntryFunction$1'
p18777
sg15
(lp18778
sg17
(lp18779
sg19
(lp18780
sg21
I0
sba(iArchitecture
Entity
p18781
(dp18782
g11
(lp18783
sg13
S'com.google.common.collect.Maps$EntryFunction$2'
p18784
sg15
(lp18785
sg17
(lp18786
sg19
(lp18787
sg21
I0
sba(iArchitecture
Entity
p18788
(dp18789
g11
(lp18790
sg13
S'com.google.common.collect.Maps$EntrySet'
p18791
sg15
(lp18792
sg17
(lp18793
sg19
(lp18794
sg21
I0
sba(iArchitecture
Entity
p18795
(dp18796
g11
(lp18797
sg13
S'com.google.common.collect.Maps$EntryTransformer'
p18798
sg15
(lp18799
sg17
(lp18800
sg19
(lp18801
sg21
I0
sba(iArchitecture
Entity
p18802
(dp18803
g11
(lp18804
sg13
S'com.google.common.collect.Maps$FilteredEntryBiMap'
p18805
sg15
(lp18806
sg17
(lp18807
sg19
(lp18808
sg21
I0
sba(iArchitecture
Entity
p18809
(dp18810
g11
(lp18811
sg13
S'com.google.common.collect.Maps$FilteredEntryBiMap$1'
p18812
sg15
(lp18813
sg17
(lp18814
sg19
(lp18815
sg21
I0
sba(iArchitecture
Entity
p18816
(dp18817
g11
(lp18818
sg13
S'com.google.common.collect.Maps$FilteredEntryMap'
p18819
sg15
(lp18820
sg17
(lp18821
sg19
(lp18822
sg21
I0
sba(iArchitecture
Entity
p18823
(dp18824
g11
(lp18825
sg13
S'com.google.common.collect.Maps$FilteredEntryMap$EntrySet'
p18826
sg15
(lp18827
sg17
(lp18828
sg19
(lp18829
sg21
I0
sba(iArchitecture
Entity
p18830
(dp18831
g11
(lp18832
sg13
S'com.google.common.collect.Maps$FilteredEntryMap$EntrySet$1'
p18833
sg15
(lp18834
sg17
(lp18835
sg19
(lp18836
sg21
I0
sba(iArchitecture
Entity
p18837
(dp18838
g11
(lp18839
sg13
S'com.google.common.collect.Maps$FilteredEntryMap$EntrySet$1$1'
p18840
sg15
(lp18841
sg17
(lp18842
sg19
(lp18843
sg21
I0
sba(iArchitecture
Entity
p18844
(dp18845
g11
(lp18846
sg13
S'com.google.common.collect.Maps$FilteredEntryMap$KeySet'
p18847
sg15
(lp18848
sg17
(lp18849
sg19
(lp18850
sg21
I0
sba(iArchitecture
Entity
p18851
(dp18852
g11
(lp18853
sg13
S'com.google.common.collect.Maps$FilteredEntryNavigableMap'
p18854
sg15
(lp18855
sg17
(lp18856
sg19
(lp18857
sg21
I0
sba(iArchitecture
Entity
p18858
(dp18859
g11
(lp18860
sg13
S'com.google.common.collect.Maps$FilteredEntryNavigableMap$1'
p18861
sg15
(lp18862
sg17
(lp18863
sg19
(lp18864
sg21
I0
sba(iArchitecture
Entity
p18865
(dp18866
g11
(lp18867
sg13
S'com.google.common.collect.Maps$FilteredEntrySortedMap'
p18868
sg15
(lp18869
sg17
(lp18870
sg19
(lp18871
sg21
I0
sba(iArchitecture
Entity
p18872
(dp18873
g11
(lp18874
sg13
S'com.google.common.collect.Maps$FilteredEntrySortedMap$SortedKeySet'
p18875
sg15
(lp18876
sg17
(lp18877
sg19
(lp18878
sg21
I0
sba(iArchitecture
Entity
p18879
(dp18880
g11
(lp18881
sg13
S'com.google.common.collect.Maps$FilteredKeyMap'
p18882
sg15
(lp18883
sg17
(lp18884
sg19
(lp18885
sg21
I0
sba(iArchitecture
Entity
p18886
(dp18887
g11
(lp18888
sg13
S'com.google.common.collect.Maps$FilteredMapValues'
p18889
sg15
(lp18890
sg17
(lp18891
sg19
(lp18892
sg21
I0
sba(iArchitecture
Entity
p18893
(dp18894
g11
(lp18895
sg13
S'com.google.common.collect.Maps$IteratorBasedAbstractMap'
p18896
sg15
(lp18897
sg17
(lp18898
sg19
(lp18899
sg21
I0
sba(iArchitecture
Entity
p18900
(dp18901
g11
(lp18902
sg13
S'com.google.common.collect.Maps$IteratorBasedAbstractMap$1'
p18903
sg15
(lp18904
sg17
(lp18905
sg19
(lp18906
sg21
I0
sba(iArchitecture
Entity
p18907
(dp18908
g11
(lp18909
sg13
S'com.google.common.collect.Maps$KeySet'
p18910
sg15
(lp18911
sg17
(lp18912
sg19
(lp18913
sg21
I0
sba(iArchitecture
Entity
p18914
(dp18915
g11
(lp18916
sg13
S'com.google.common.collect.Maps$MapDifferenceImpl'
p18917
sg15
(lp18918
sg17
(lp18919
sg19
(lp18920
sg21
I0
sba(iArchitecture
Entity
p18921
(dp18922
g11
(lp18923
sg13
S'com.google.common.collect.Maps$NavigableAsMapView'
p18924
sg15
(lp18925
sg17
(lp18926
sg19
(lp18927
sg21
I0
sba(iArchitecture
Entity
p18928
(dp18929
g11
(lp18930
sg13
S'com.google.common.collect.Maps$NavigableKeySet'
p18931
sg15
(lp18932
sg17
(lp18933
sg19
(lp18934
sg21
I0
sba(iArchitecture
Entity
p18935
(dp18936
g11
(lp18937
sg13
S'com.google.common.collect.Maps$SortedAsMapView'
p18938
sg15
(lp18939
sg17
(lp18940
sg19
(lp18941
sg21
I0
sba(iArchitecture
Entity
p18942
(dp18943
g11
(lp18944
sg13
S'com.google.common.collect.Maps$SortedKeySet'
p18945
sg15
(lp18946
sg17
(lp18947
sg19
(lp18948
sg21
I0
sba(iArchitecture
Entity
p18949
(dp18950
g11
(lp18951
sg13
S'com.google.common.collect.Maps$SortedMapDifferenceImpl'
p18952
sg15
(lp18953
sg17
(lp18954
sg19
(lp18955
sg21
I0
sba(iArchitecture
Entity
p18956
(dp18957
g11
(lp18958
sg13
S'com.google.common.collect.Maps$TransformedEntriesMap'
p18959
sg15
(lp18960
sg17
(lp18961
sg19
(lp18962
sg21
I0
sba(iArchitecture
Entity
p18963
(dp18964
g11
(lp18965
sg13
S'com.google.common.collect.Maps$TransformedEntriesNavigableMap'
p18966
sg15
(lp18967
sg17
(lp18968
sg19
(lp18969
sg21
I0
sba(iArchitecture
Entity
p18970
(dp18971
g11
(lp18972
sg13
S'com.google.common.collect.Maps$TransformedEntriesSortedMap'
p18973
sg15
(lp18974
sg17
(lp18975
sg19
(lp18976
sg21
I0
sba(iArchitecture
Entity
p18977
(dp18978
g11
(lp18979
sg13
S'com.google.common.collect.Maps$UnmodifiableBiMap'
p18980
sg15
(lp18981
sg17
(lp18982
sg19
(lp18983
sg21
I0
sba(iArchitecture
Entity
p18984
(dp18985
g11
(lp18986
sg13
S'com.google.common.collect.Maps$UnmodifiableEntries'
p18987
sg15
(lp18988
sg17
(lp18989
sg19
(lp18990
sg21
I0
sba(iArchitecture
Entity
p18991
(dp18992
g11
(lp18993
sg13
S'com.google.common.collect.Maps$UnmodifiableEntrySet'
p18994
sg15
(lp18995
sg17
(lp18996
sg19
(lp18997
sg21
I0
sba(iArchitecture
Entity
p18998
(dp18999
g11
(lp19000
sg13
S'com.google.common.collect.Maps$UnmodifiableNavigableMap'
p19001
sg15
(lp19002
sg17
(lp19003
sg19
(lp19004
sg21
I0
sba(iArchitecture
Entity
p19005
(dp19006
g11
(lp19007
sg13
S'com.google.common.collect.Maps$ValueDifferenceImpl'
p19008
sg15
(lp19009
sg17
(lp19010
sg19
(lp19011
sg21
I0
sba(iArchitecture
Entity
p19012
(dp19013
g11
(lp19014
sg13
S'com.google.common.collect.Maps$Values'
p19015
sg15
(lp19016
sg17
(lp19017
sg19
(lp19018
sg21
I0
sba(iArchitecture
Entity
p19019
(dp19020
g11
(lp19021
sg13
S'com.google.common.collect.Maps$ViewCachingAbstractMap'
p19022
sg15
(lp19023
sg17
(lp19024
sg19
(lp19025
sg21
I0
sba(iArchitecture
Entity
p19026
(dp19027
g11
(lp19028
V2658
p19029
ag19029
ag19029
asg13
S'com.google.common.collect.MinMaxPriorityQueue'
p19030
sg15
(lp19031
VA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19032
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19033
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19034
asg17
(lp19035
(lp19036
I1
aag19036
ag19036
asg19
(lp19037
Vremove() in MinMaxPriorityQueue<Double> not removing the correct object
p19038
ag19038
ag19038
asg21
I0
sba(iArchitecture
Entity
p19039
(dp19040
g11
(lp19041
g19029
ag19029
ag19029
asg13
S'com.google.common.collect.MinMaxPriorityQueue$1'
p19042
sg15
(lp19043
VA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19044
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19045
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19046
asg17
(lp19047
g19036
ag19036
ag19036
asg19
(lp19048
g19038
ag19038
ag19038
asg21
I0
sba(iArchitecture
Entity
p19049
(dp19050
g11
(lp19051
g19029
ag19029
ag19029
asg13
S'com.google.common.collect.MinMaxPriorityQueue$Builder'
p19052
sg15
(lp19053
VA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19054
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19055
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19056
asg17
(lp19057
g19036
ag19036
ag19036
asg19
(lp19058
g19038
ag19038
ag19038
asg21
I0
sba(iArchitecture
Entity
p19059
(dp19060
g11
(lp19061
g19029
ag19029
ag19029
asg13
S'com.google.common.collect.MinMaxPriorityQueue$Heap'
p19062
sg15
(lp19063
VA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19064
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19065
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19066
asg17
(lp19067
g19036
ag19036
ag19036
asg19
(lp19068
g19038
ag19038
ag19038
asg21
I0
sba(iArchitecture
Entity
p19069
(dp19070
g11
(lp19071
g19029
ag19029
ag19029
asg13
S'com.google.common.collect.MinMaxPriorityQueue$MoveDesc'
p19072
sg15
(lp19073
VA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19074
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19075
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19076
asg17
(lp19077
g19036
ag19036
ag19036
asg19
(lp19078
g19038
ag19038
ag19038
asg21
I0
sba(iArchitecture
Entity
p19079
(dp19080
g11
(lp19081
g19029
ag19029
ag19029
asg13
S'com.google.common.collect.MinMaxPriorityQueue$QueueIterator'
p19082
sg15
(lp19083
VA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19084
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19085
aVA MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\u000a\u000a> [5.6, 6.0, 5.7, 5.9]\u000aTry to remove 5.7 :\u000a[5.6, 6.0, 5.7]\u000a\u000aObtained from :\u000a\u000a> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\u000a			values.add(6.2);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.1);\u000a			values.pollLast();\u000a			values.add(5.7);\u000a			values.pollFirst();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollFirst();\u000a			values.add(6.2);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.0);\u000a			values.remove(6.2);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.add(5.7);\u000a			values.pollLast();\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(6.4);\u000a			values.pollFirst();\u000a			values.remove(6.3);\u000a			values.add(5.8);\u000a			values.remove(5.8);\u000a			values.add(6.4);\u000a			values.remove(6.0);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(6.3);\u000a			values.pollLast();\u000a			values.add(6.3);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.5);\u000a			values.pollLast();\u000a			values.pollLast();\u000a			values.add(5.4);\u000a			values.remove(5.4);\u000a			values.add(5.7);\u000a			values.remove(6.1);\u000a			values.add(5.6);\u000a			values.add(5.4);\u000a			values.pollLast();\u000a			values.remove(5.5);\u000a			values.add(5.8);\u000a			values.pollLast();\u000a			values.add(5.6);\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(5.8);\u000a			values.pollFirst();\u000a			values.remove(5.8);\u000a			values.add(5.6);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.pollFirst();\u000a			values.add(5.7);\u000a			values.add(6.0);\u000a			values.pollFirst();\u000a			values.remove(5.7);\u000a			values.add(6.1);\u000a			values.pollLast();\u000a			values.add(5.9);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(6.1);\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.remove(6.1);\u000a			values.add(6.0);\u000a			values.add(6.0);\u000a			values.pollLast();\u000a			values.remove(6.0);\u000a			values.add(5.9);\u000a			values.remove(6.0);\u000a			values.add(5.7);\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			values.add(6.1);\u000a			values.pollFirst();\u000a			values.add(5.6);\u000a			values.pollLast();\u000a			System.out.println(values);\u000a			System.out.println("Try to remove 5.7 :");\u000a			values.remove(5.7);\u000a			System.out.println(values);
p19086
asg17
(lp19087
g19036
ag19036
ag19036
asg19
(lp19088
g19038
ag19038
ag19038
asg21
I0
sba(iArchitecture
Entity
p19089
(dp19090
g11
(lp19091
sg13
S'com.google.common.collect.Multimap'
p19092
sg15
(lp19093
sg17
(lp19094
sg19
(lp19095
sg21
I0
sba(iArchitecture
Entity
p19096
(dp19097
g11
(lp19098
sg13
S'com.google.common.collect.MultimapBuilder'
p19099
sg15
(lp19100
sg17
(lp19101
sg19
(lp19102
sg21
I0
sba(iArchitecture
Entity
p19103
(dp19104
g11
(lp19105
sg13
S'com.google.common.collect.MultimapBuilder$1'
p19106
sg15
(lp19107
sg17
(lp19108
sg19
(lp19109
sg21
I0
sba(iArchitecture
Entity
p19110
(dp19111
g11
(lp19112
sg13
S'com.google.common.collect.MultimapBuilder$2'
p19113
sg15
(lp19114
sg17
(lp19115
sg19
(lp19116
sg21
I0
sba(iArchitecture
Entity
p19117
(dp19118
g11
(lp19119
sg13
S'com.google.common.collect.MultimapBuilder$3'
p19120
sg15
(lp19121
sg17
(lp19122
sg19
(lp19123
sg21
I0
sba(iArchitecture
Entity
p19124
(dp19125
g11
(lp19126
sg13
S'com.google.common.collect.MultimapBuilder$4'
p19127
sg15
(lp19128
sg17
(lp19129
sg19
(lp19130
sg21
I0
sba(iArchitecture
Entity
p19131
(dp19132
g11
(lp19133
sg13
S'com.google.common.collect.MultimapBuilder$ArrayListSupplier'
p19134
sg15
(lp19135
sg17
(lp19136
sg19
(lp19137
sg21
I0
sba(iArchitecture
Entity
p19138
(dp19139
g11
(lp19140
sg13
S'com.google.common.collect.MultimapBuilder$EnumSetSupplier'
p19141
sg15
(lp19142
sg17
(lp19143
sg19
(lp19144
sg21
I0
sba(iArchitecture
Entity
p19145
(dp19146
g11
(lp19147
sg13
S'com.google.common.collect.MultimapBuilder$HashSetSupplier'
p19148
sg15
(lp19149
sg17
(lp19150
sg19
(lp19151
sg21
I0
sba(iArchitecture
Entity
p19152
(dp19153
g11
(lp19154
sg13
S'com.google.common.collect.MultimapBuilder$LinkedHashSetSupplier'
p19155
sg15
(lp19156
sg17
(lp19157
sg19
(lp19158
sg21
I0
sba(iArchitecture
Entity
p19159
(dp19160
g11
(lp19161
sg13
S'com.google.common.collect.MultimapBuilder$LinkedListSupplier'
p19162
sg15
(lp19163
sg17
(lp19164
sg19
(lp19165
sg21
I0
sba(iArchitecture
Entity
p19166
(dp19167
g11
(lp19168
sg13
S'com.google.common.collect.MultimapBuilder$ListMultimapBuilder'
p19169
sg15
(lp19170
sg17
(lp19171
sg19
(lp19172
sg21
I0
sba(iArchitecture
Entity
p19173
(dp19174
g11
(lp19175
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys'
p19176
sg15
(lp19177
sg17
(lp19178
sg19
(lp19179
sg21
I0
sba(iArchitecture
Entity
p19180
(dp19181
g11
(lp19182
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$1'
p19183
sg15
(lp19184
sg17
(lp19185
sg19
(lp19186
sg21
I0
sba(iArchitecture
Entity
p19187
(dp19188
g11
(lp19189
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$2'
p19190
sg15
(lp19191
sg17
(lp19192
sg19
(lp19193
sg21
I0
sba(iArchitecture
Entity
p19194
(dp19195
g11
(lp19196
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$3'
p19197
sg15
(lp19198
sg17
(lp19199
sg19
(lp19200
sg21
I0
sba(iArchitecture
Entity
p19201
(dp19202
g11
(lp19203
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$4'
p19204
sg15
(lp19205
sg17
(lp19206
sg19
(lp19207
sg21
I0
sba(iArchitecture
Entity
p19208
(dp19209
g11
(lp19210
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$5'
p19211
sg15
(lp19212
sg17
(lp19213
sg19
(lp19214
sg21
I0
sba(iArchitecture
Entity
p19215
(dp19216
g11
(lp19217
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$6'
p19218
sg15
(lp19219
sg17
(lp19220
sg19
(lp19221
sg21
I0
sba(iArchitecture
Entity
p19222
(dp19223
g11
(lp19224
sg13
S'com.google.common.collect.MultimapBuilder$SetMultimapBuilder'
p19225
sg15
(lp19226
sg17
(lp19227
sg19
(lp19228
sg21
I0
sba(iArchitecture
Entity
p19229
(dp19230
g11
(lp19231
sg13
S'com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder'
p19232
sg15
(lp19233
sg17
(lp19234
sg19
(lp19235
sg21
I0
sba(iArchitecture
Entity
p19236
(dp19237
g11
(lp19238
sg13
S'com.google.common.collect.MultimapBuilder$TreeSetSupplier'
p19239
sg15
(lp19240
sg17
(lp19241
sg19
(lp19242
sg21
I0
sba(iArchitecture
Entity
p19243
(dp19244
g11
(lp19245
sg13
S'com.google.common.collect.Multimaps'
p19246
sg15
(lp19247
sg17
(lp19248
sg19
(lp19249
sg21
I0
sba(iArchitecture
Entity
p19250
(dp19251
g11
(lp19252
sg13
S'com.google.common.collect.Multimaps$AsMap'
p19253
sg15
(lp19254
sg17
(lp19255
sg19
(lp19256
sg21
I0
sba(iArchitecture
Entity
p19257
(dp19258
g11
(lp19259
sg13
S'com.google.common.collect.Multimaps$AsMap$EntrySet'
p19260
sg15
(lp19261
sg17
(lp19262
sg19
(lp19263
sg21
I0
sba(iArchitecture
Entity
p19264
(dp19265
g11
(lp19266
sg13
S'com.google.common.collect.Multimaps$AsMap$EntrySet$1'
p19267
sg15
(lp19268
sg17
(lp19269
sg19
(lp19270
sg21
I0
sba(iArchitecture
Entity
p19271
(dp19272
g11
(lp19273
sg13
S'com.google.common.collect.Multimaps$CustomListMultimap'
p19274
sg15
(lp19275
sg17
(lp19276
sg19
(lp19277
sg21
I0
sba(iArchitecture
Entity
p19278
(dp19279
g11
(lp19280
sg13
S'com.google.common.collect.Multimaps$CustomMultimap'
p19281
sg15
(lp19282
sg17
(lp19283
sg19
(lp19284
sg21
I0
sba(iArchitecture
Entity
p19285
(dp19286
g11
(lp19287
sg13
S'com.google.common.collect.Multimaps$CustomSetMultimap'
p19288
sg15
(lp19289
sg17
(lp19290
sg19
(lp19291
sg21
I0
sba(iArchitecture
Entity
p19292
(dp19293
g11
(lp19294
sg13
S'com.google.common.collect.Multimaps$CustomSortedSetMultimap'
p19295
sg15
(lp19296
sg17
(lp19297
sg19
(lp19298
sg21
I0
sba(iArchitecture
Entity
p19299
(dp19300
g11
(lp19301
sg13
S'com.google.common.collect.Multimaps$Entries'
p19302
sg15
(lp19303
sg17
(lp19304
sg19
(lp19305
sg21
I0
sba(iArchitecture
Entity
p19306
(dp19307
g11
(lp19308
sg13
S'com.google.common.collect.Multimaps$Keys'
p19309
sg15
(lp19310
sg17
(lp19311
sg19
(lp19312
sg21
I0
sba(iArchitecture
Entity
p19313
(dp19314
g11
(lp19315
sg13
S'com.google.common.collect.Multimaps$Keys$1'
p19316
sg15
(lp19317
sg17
(lp19318
sg19
(lp19319
sg21
I0
sba(iArchitecture
Entity
p19320
(dp19321
g11
(lp19322
sg13
S'com.google.common.collect.Multimaps$Keys$1$1'
p19323
sg15
(lp19324
sg17
(lp19325
sg19
(lp19326
sg21
I0
sba(iArchitecture
Entity
p19327
(dp19328
g11
(lp19329
sg13
S'com.google.common.collect.Multimaps$Keys$KeysEntrySet'
p19330
sg15
(lp19331
sg17
(lp19332
sg19
(lp19333
sg21
I0
sba(iArchitecture
Entity
p19334
(dp19335
g11
(lp19336
sg13
S'com.google.common.collect.Multimaps$MapMultimap'
p19337
sg15
(lp19338
sg17
(lp19339
sg19
(lp19340
sg21
I0
sba(iArchitecture
Entity
p19341
(dp19342
g11
(lp19343
sg13
S'com.google.common.collect.Multimaps$MapMultimap$1'
p19344
sg15
(lp19345
sg17
(lp19346
sg19
(lp19347
sg21
I0
sba(iArchitecture
Entity
p19348
(dp19349
g11
(lp19350
sg13
S'com.google.common.collect.Multimaps$MapMultimap$1$1'
p19351
sg15
(lp19352
sg17
(lp19353
sg19
(lp19354
sg21
I0
sba(iArchitecture
Entity
p19355
(dp19356
g11
(lp19357
sg13
S'com.google.common.collect.Multimaps$TransformedEntriesListMultimap'
p19358
sg15
(lp19359
sg17
(lp19360
sg19
(lp19361
sg21
I0
sba(iArchitecture
Entity
p19362
(dp19363
g11
(lp19364
sg13
S'com.google.common.collect.Multimaps$TransformedEntriesMultimap'
p19365
sg15
(lp19366
sg17
(lp19367
sg19
(lp19368
sg21
I0
sba(iArchitecture
Entity
p19369
(dp19370
g11
(lp19371
sg13
S'com.google.common.collect.Multimaps$TransformedEntriesMultimap$1'
p19372
sg15
(lp19373
sg17
(lp19374
sg19
(lp19375
sg21
I0
sba(iArchitecture
Entity
p19376
(dp19377
g11
(lp19378
sg13
S'com.google.common.collect.Multimaps$UnmodifiableListMultimap'
p19379
sg15
(lp19380
sg17
(lp19381
sg19
(lp19382
sg21
I0
sba(iArchitecture
Entity
p19383
(dp19384
g11
(lp19385
sg13
S'com.google.common.collect.Multimaps$UnmodifiableMultimap'
p19386
sg15
(lp19387
sg17
(lp19388
sg19
(lp19389
sg21
I0
sba(iArchitecture
Entity
p19390
(dp19391
g11
(lp19392
sg13
S'com.google.common.collect.Multimaps$UnmodifiableMultimap$1'
p19393
sg15
(lp19394
sg17
(lp19395
sg19
(lp19396
sg21
I0
sba(iArchitecture
Entity
p19397
(dp19398
g11
(lp19399
sg13
S'com.google.common.collect.Multimaps$UnmodifiableSetMultimap'
p19400
sg15
(lp19401
sg17
(lp19402
sg19
(lp19403
sg21
I0
sba(iArchitecture
Entity
p19404
(dp19405
g11
(lp19406
sg13
S'com.google.common.collect.Multimaps$UnmodifiableSortedSetMultimap'
p19407
sg15
(lp19408
sg17
(lp19409
sg19
(lp19410
sg21
I0
sba(iArchitecture
Entity
p19411
(dp19412
g11
(lp19413
sg13
S'com.google.common.collect.Multiset'
p19414
sg15
(lp19415
sg17
(lp19416
sg19
(lp19417
sg21
I0
sba(iArchitecture
Entity
p19418
(dp19419
g11
(lp19420
sg13
S'com.google.common.collect.Multiset$Entry'
p19421
sg15
(lp19422
sg17
(lp19423
sg19
(lp19424
sg21
I0
sba(iArchitecture
Entity
p19425
(dp19426
g11
(lp19427
sg13
S'com.google.common.collect.Multisets'
p19428
sg15
(lp19429
sg17
(lp19430
sg19
(lp19431
sg21
I0
sba(iArchitecture
Entity
p19432
(dp19433
g11
(lp19434
sg13
S'com.google.common.collect.Multisets$1'
p19435
sg15
(lp19436
sg17
(lp19437
sg19
(lp19438
sg21
I0
sba(iArchitecture
Entity
p19439
(dp19440
g11
(lp19441
sg13
S'com.google.common.collect.Multisets$1$1'
p19442
sg15
(lp19443
sg17
(lp19444
sg19
(lp19445
sg21
I0
sba(iArchitecture
Entity
p19446
(dp19447
g11
(lp19448
sg13
S'com.google.common.collect.Multisets$2'
p19449
sg15
(lp19450
sg17
(lp19451
sg19
(lp19452
sg21
I0
sba(iArchitecture
Entity
p19453
(dp19454
g11
(lp19455
sg13
S'com.google.common.collect.Multisets$2$1'
p19456
sg15
(lp19457
sg17
(lp19458
sg19
(lp19459
sg21
I0
sba(iArchitecture
Entity
p19460
(dp19461
g11
(lp19462
sg13
S'com.google.common.collect.Multisets$3'
p19463
sg15
(lp19464
sg17
(lp19465
sg19
(lp19466
sg21
I0
sba(iArchitecture
Entity
p19467
(dp19468
g11
(lp19469
sg13
S'com.google.common.collect.Multisets$3$1'
p19470
sg15
(lp19471
sg17
(lp19472
sg19
(lp19473
sg21
I0
sba(iArchitecture
Entity
p19474
(dp19475
g11
(lp19476
sg13
S'com.google.common.collect.Multisets$4'
p19477
sg15
(lp19478
sg17
(lp19479
sg19
(lp19480
sg21
I0
sba(iArchitecture
Entity
p19481
(dp19482
g11
(lp19483
sg13
S'com.google.common.collect.Multisets$4$1'
p19484
sg15
(lp19485
sg17
(lp19486
sg19
(lp19487
sg21
I0
sba(iArchitecture
Entity
p19488
(dp19489
g11
(lp19490
sg13
S'com.google.common.collect.Multisets$5'
p19491
sg15
(lp19492
sg17
(lp19493
sg19
(lp19494
sg21
I0
sba(iArchitecture
Entity
p19495
(dp19496
g11
(lp19497
sg13
S'com.google.common.collect.Multisets$AbstractEntry'
p19498
sg15
(lp19499
sg17
(lp19500
sg19
(lp19501
sg21
I0
sba(iArchitecture
Entity
p19502
(dp19503
g11
(lp19504
sg13
S'com.google.common.collect.Multisets$ElementSet'
p19505
sg15
(lp19506
sg17
(lp19507
sg19
(lp19508
sg21
I0
sba(iArchitecture
Entity
p19509
(dp19510
g11
(lp19511
sg13
S'com.google.common.collect.Multisets$ElementSet$1'
p19512
sg15
(lp19513
sg17
(lp19514
sg19
(lp19515
sg21
I0
sba(iArchitecture
Entity
p19516
(dp19517
g11
(lp19518
sg13
S'com.google.common.collect.Multisets$EntrySet'
p19519
sg15
(lp19520
sg17
(lp19521
sg19
(lp19522
sg21
I0
sba(iArchitecture
Entity
p19523
(dp19524
g11
(lp19525
sg13
S'com.google.common.collect.Multisets$FilteredMultiset'
p19526
sg15
(lp19527
sg17
(lp19528
sg19
(lp19529
sg21
I0
sba(iArchitecture
Entity
p19530
(dp19531
g11
(lp19532
sg13
S'com.google.common.collect.Multisets$FilteredMultiset$1'
p19533
sg15
(lp19534
sg17
(lp19535
sg19
(lp19536
sg21
I0
sba(iArchitecture
Entity
p19537
(dp19538
g11
(lp19539
sg13
S'com.google.common.collect.Multisets$ImmutableEntry'
p19540
sg15
(lp19541
sg17
(lp19542
sg19
(lp19543
sg21
I0
sba(iArchitecture
Entity
p19544
(dp19545
g11
(lp19546
sg13
S'com.google.common.collect.Multisets$MultisetIteratorImpl'
p19547
sg15
(lp19548
sg17
(lp19549
sg19
(lp19550
sg21
I0
sba(iArchitecture
Entity
p19551
(dp19552
g11
(lp19553
sg13
S'com.google.common.collect.Multisets$UnmodifiableMultiset'
p19554
sg15
(lp19555
sg17
(lp19556
sg19
(lp19557
sg21
I0
sba(iArchitecture
Entity
p19558
(dp19559
g11
(lp19560
sg13
S'com.google.common.collect.MultitransformedIterator'
p19561
sg15
(lp19562
sg17
(lp19563
sg19
(lp19564
sg21
I0
sba(iArchitecture
Entity
p19565
(dp19566
g11
(lp19567
sg13
S'com.google.common.collect.MutableClassToInstanceMap'
p19568
sg15
(lp19569
sg17
(lp19570
sg19
(lp19571
sg21
I0
sba(iArchitecture
Entity
p19572
(dp19573
g11
(lp19574
sg13
S'com.google.common.collect.MutableClassToInstanceMap$1'
p19575
sg15
(lp19576
sg17
(lp19577
sg19
(lp19578
sg21
I0
sba(iArchitecture
Entity
p19579
(dp19580
g11
(lp19581
sg13
S'com.google.common.collect.MutableClassToInstanceMap$SerializedForm'
p19582
sg15
(lp19583
sg17
(lp19584
sg19
(lp19585
sg21
I0
sba(iArchitecture
Entity
p19586
(dp19587
g11
(lp19588
sg13
S'com.google.common.collect.NaturalOrdering'
p19589
sg15
(lp19590
sg17
(lp19591
sg19
(lp19592
sg21
I0
sba(iArchitecture
Entity
p19593
(dp19594
g11
(lp19595
sg13
S'com.google.common.collect.NullsFirstOrdering'
p19596
sg15
(lp19597
sg17
(lp19598
sg19
(lp19599
sg21
I0
sba(iArchitecture
Entity
p19600
(dp19601
g11
(lp19602
sg13
S'com.google.common.collect.NullsLastOrdering'
p19603
sg15
(lp19604
sg17
(lp19605
sg19
(lp19606
sg21
I0
sba(iArchitecture
Entity
p19607
(dp19608
g11
(lp19609
sg13
S'com.google.common.collect.ObjectArrays'
p19610
sg15
(lp19611
sg17
(lp19612
sg19
(lp19613
sg21
I0
sba(iArchitecture
Entity
p19614
(dp19615
g11
(lp19616
sg13
S'com.google.common.collect.Ordering'
p19617
sg15
(lp19618
sg17
(lp19619
sg19
(lp19620
sg21
I0
sba(iArchitecture
Entity
p19621
(dp19622
g11
(lp19623
sg13
S'com.google.common.collect.Ordering$ArbitraryOrdering'
p19624
sg15
(lp19625
sg17
(lp19626
sg19
(lp19627
sg21
I0
sba(iArchitecture
Entity
p19628
(dp19629
g11
(lp19630
sg13
S'com.google.common.collect.Ordering$ArbitraryOrderingHolder'
p19631
sg15
(lp19632
sg17
(lp19633
sg19
(lp19634
sg21
I0
sba(iArchitecture
Entity
p19635
(dp19636
g11
(lp19637
sg13
S'com.google.common.collect.Ordering$IncomparableValueException'
p19638
sg15
(lp19639
sg17
(lp19640
sg19
(lp19641
sg21
I0
sba(iArchitecture
Entity
p19642
(dp19643
g11
(lp19644
sg13
S'com.google.common.collect.PeekingIterator'
p19645
sg15
(lp19646
sg17
(lp19647
sg19
(lp19648
sg21
I0
sba(iArchitecture
Entity
p19649
(dp19650
g11
(lp19651
sg13
S'com.google.common.collect.Platform'
p19652
sg15
(lp19653
sg17
(lp19654
sg19
(lp19655
sg21
I0
sba(iArchitecture
Entity
p19656
(dp19657
g11
(lp19658
sg13
S'com.google.common.collect.Range'
p19659
sg15
(lp19660
sg17
(lp19661
sg19
(lp19662
sg21
I0
sba(iArchitecture
Entity
p19663
(dp19664
g11
(lp19665
sg13
S'com.google.common.collect.Range$1'
p19666
sg15
(lp19667
sg17
(lp19668
sg19
(lp19669
sg21
I0
sba(iArchitecture
Entity
p19670
(dp19671
g11
(lp19672
sg13
S'com.google.common.collect.Range$2'
p19673
sg15
(lp19674
sg17
(lp19675
sg19
(lp19676
sg21
I0
sba(iArchitecture
Entity
p19677
(dp19678
g11
(lp19679
sg13
S'com.google.common.collect.Range$3'
p19680
sg15
(lp19681
sg17
(lp19682
sg19
(lp19683
sg21
I0
sba(iArchitecture
Entity
p19684
(dp19685
g11
(lp19686
sg13
S'com.google.common.collect.Range$RangeLexOrdering'
p19687
sg15
(lp19688
sg17
(lp19689
sg19
(lp19690
sg21
I0
sba(iArchitecture
Entity
p19691
(dp19692
g11
(lp19693
sg13
S'com.google.common.collect.RangeMap'
p19694
sg15
(lp19695
sg17
(lp19696
sg19
(lp19697
sg21
I0
sba(iArchitecture
Entity
p19698
(dp19699
g11
(lp19700
sg13
S'com.google.common.collect.RangeSet'
p19701
sg15
(lp19702
sg17
(lp19703
sg19
(lp19704
sg21
I0
sba(iArchitecture
Entity
p19705
(dp19706
g11
(lp19707
sg13
S'com.google.common.collect.RegularContiguousSet'
p19708
sg15
(lp19709
sg17
(lp19710
sg19
(lp19711
sg21
I0
sba(iArchitecture
Entity
p19712
(dp19713
g11
(lp19714
sg13
S'com.google.common.collect.RegularContiguousSet$1'
p19715
sg15
(lp19716
sg17
(lp19717
sg19
(lp19718
sg21
I0
sba(iArchitecture
Entity
p19719
(dp19720
g11
(lp19721
sg13
S'com.google.common.collect.RegularContiguousSet$2'
p19722
sg15
(lp19723
sg17
(lp19724
sg19
(lp19725
sg21
I0
sba(iArchitecture
Entity
p19726
(dp19727
g11
(lp19728
sg13
S'com.google.common.collect.RegularContiguousSet$SerializedForm'
p19729
sg15
(lp19730
sg17
(lp19731
sg19
(lp19732
sg21
I0
sba(iArchitecture
Entity
p19733
(dp19734
g11
(lp19735
sg13
S'com.google.common.collect.RegularImmutableAsList'
p19736
sg15
(lp19737
sg17
(lp19738
sg19
(lp19739
sg21
I0
sba(iArchitecture
Entity
p19740
(dp19741
g11
(lp19742
sg13
S'com.google.common.collect.RegularImmutableBiMap'
p19743
sg15
(lp19744
sg17
(lp19745
sg19
(lp19746
sg21
I0
sba(iArchitecture
Entity
p19747
(dp19748
g11
(lp19749
sg13
S'com.google.common.collect.RegularImmutableBiMap$1'
p19750
sg15
(lp19751
sg17
(lp19752
sg19
(lp19753
sg21
I0
sba(iArchitecture
Entity
p19754
(dp19755
g11
(lp19756
sg13
S'com.google.common.collect.RegularImmutableBiMap$Inverse'
p19757
sg15
(lp19758
sg17
(lp19759
sg19
(lp19760
sg21
I0
sba(iArchitecture
Entity
p19761
(dp19762
g11
(lp19763
sg13
S'com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet'
p19764
sg15
(lp19765
sg17
(lp19766
sg19
(lp19767
sg21
I0
sba(iArchitecture
Entity
p19768
(dp19769
g11
(lp19770
sg13
S'com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet$1'
p19771
sg15
(lp19772
sg17
(lp19773
sg19
(lp19774
sg21
I0
sba(iArchitecture
Entity
p19775
(dp19776
g11
(lp19777
sg13
S'com.google.common.collect.RegularImmutableBiMap$InverseSerializedForm'
p19778
sg15
(lp19779
sg17
(lp19780
sg19
(lp19781
sg21
I0
sba(iArchitecture
Entity
p19782
(dp19783
g11
(lp19784
sg13
S'com.google.common.collect.RegularImmutableList'
p19785
sg15
(lp19786
sg17
(lp19787
sg19
(lp19788
sg21
I0
sba(iArchitecture
Entity
p19789
(dp19790
g11
(lp19791
sg13
S'com.google.common.collect.RegularImmutableMap'
p19792
sg15
(lp19793
sg17
(lp19794
sg19
(lp19795
sg21
I0
sba(iArchitecture
Entity
p19796
(dp19797
g11
(lp19798
sg13
S'com.google.common.collect.RegularImmutableMap$KeySet'
p19799
sg15
(lp19800
sg17
(lp19801
sg19
(lp19802
sg21
I0
sba(iArchitecture
Entity
p19803
(dp19804
g11
(lp19805
sg13
S'com.google.common.collect.RegularImmutableMap$KeySet$SerializedForm'
p19806
sg15
(lp19807
sg17
(lp19808
sg19
(lp19809
sg21
I0
sba(iArchitecture
Entity
p19810
(dp19811
g11
(lp19812
sg13
S'com.google.common.collect.RegularImmutableMap$Values'
p19813
sg15
(lp19814
sg17
(lp19815
sg19
(lp19816
sg21
I0
sba(iArchitecture
Entity
p19817
(dp19818
g11
(lp19819
sg13
S'com.google.common.collect.RegularImmutableMap$Values$SerializedForm'
p19820
sg15
(lp19821
sg17
(lp19822
sg19
(lp19823
sg21
I0
sba(iArchitecture
Entity
p19824
(dp19825
g11
(lp19826
sg13
S'com.google.common.collect.RegularImmutableMultiset'
p19827
sg15
(lp19828
sg17
(lp19829
sg19
(lp19830
sg21
I0
sba(iArchitecture
Entity
p19831
(dp19832
g11
(lp19833
sg13
S'com.google.common.collect.RegularImmutableMultiset$1'
p19834
sg15
(lp19835
sg17
(lp19836
sg19
(lp19837
sg21
I0
sba(iArchitecture
Entity
p19838
(dp19839
g11
(lp19840
sg13
S'com.google.common.collect.RegularImmutableMultiset$ElementSet'
p19841
sg15
(lp19842
sg17
(lp19843
sg19
(lp19844
sg21
I0
sba(iArchitecture
Entity
p19845
(dp19846
g11
(lp19847
sg13
S'com.google.common.collect.RegularImmutableMultiset$NonTerminalEntry'
p19848
sg15
(lp19849
sg17
(lp19850
sg19
(lp19851
sg21
I0
sba(iArchitecture
Entity
p19852
(dp19853
g11
(lp19854
sg13
S'com.google.common.collect.RegularImmutableSet'
p19855
sg15
(lp19856
sg17
(lp19857
sg19
(lp19858
sg21
I0
sba(iArchitecture
Entity
p19859
(dp19860
g11
(lp19861
sg13
S'com.google.common.collect.RegularImmutableSortedMultiset'
p19862
sg15
(lp19863
sg17
(lp19864
sg19
(lp19865
sg21
I0
sba(iArchitecture
Entity
p19866
(dp19867
g11
(lp19868
sg13
S'com.google.common.collect.RegularImmutableSortedSet'
p19869
sg15
(lp19870
sg17
(lp19871
sg19
(lp19872
sg21
I0
sba(iArchitecture
Entity
p19873
(dp19874
g11
(lp19875
sg13
S'com.google.common.collect.RegularImmutableTable'
p19876
sg15
(lp19877
sg17
(lp19878
sg19
(lp19879
sg21
I0
sba(iArchitecture
Entity
p19880
(dp19881
g11
(lp19882
sg13
S'com.google.common.collect.RegularImmutableTable$1'
p19883
sg15
(lp19884
sg17
(lp19885
sg19
(lp19886
sg21
I0
sba(iArchitecture
Entity
p19887
(dp19888
g11
(lp19889
sg13
S'com.google.common.collect.RegularImmutableTable$CellSet'
p19890
sg15
(lp19891
sg17
(lp19892
sg19
(lp19893
sg21
I0
sba(iArchitecture
Entity
p19894
(dp19895
g11
(lp19896
sg13
S'com.google.common.collect.RegularImmutableTable$Values'
p19897
sg15
(lp19898
sg17
(lp19899
sg19
(lp19900
sg21
I0
sba(iArchitecture
Entity
p19901
(dp19902
g11
(lp19903
sg13
S'com.google.common.collect.ReverseNaturalOrdering'
p19904
sg15
(lp19905
sg17
(lp19906
sg19
(lp19907
sg21
I0
sba(iArchitecture
Entity
p19908
(dp19909
g11
(lp19910
sg13
S'com.google.common.collect.ReverseOrdering'
p19911
sg15
(lp19912
sg17
(lp19913
sg19
(lp19914
sg21
I0
sba(iArchitecture
Entity
p19915
(dp19916
g11
(lp19917
sg13
S'com.google.common.collect.RowSortedTable'
p19918
sg15
(lp19919
sg17
(lp19920
sg19
(lp19921
sg21
I0
sba(iArchitecture
Entity
p19922
(dp19923
g11
(lp19924
sg13
S'com.google.common.collect.Serialization'
p19925
sg15
(lp19926
sg17
(lp19927
sg19
(lp19928
sg21
I0
sba(iArchitecture
Entity
p19929
(dp19930
g11
(lp19931
sg13
S'com.google.common.collect.Serialization$1'
p19932
sg15
(lp19933
sg17
(lp19934
sg19
(lp19935
sg21
I0
sba(iArchitecture
Entity
p19936
(dp19937
g11
(lp19938
sg13
S'com.google.common.collect.Serialization$FieldSetter'
p19939
sg15
(lp19940
sg17
(lp19941
sg19
(lp19942
sg21
I0
sba(iArchitecture
Entity
p19943
(dp19944
g11
(lp19945
sg13
S'com.google.common.collect.SetMultimap'
p19946
sg15
(lp19947
sg17
(lp19948
sg19
(lp19949
sg21
I0
sba(iArchitecture
Entity
p19950
(dp19951
g11
(lp19952
sg13
S'com.google.common.collect.Sets'
p19953
sg15
(lp19954
sg17
(lp19955
sg19
(lp19956
sg21
I0
sba(iArchitecture
Entity
p19957
(dp19958
g11
(lp19959
sg13
S'com.google.common.collect.Sets$1'
p19960
sg15
(lp19961
sg17
(lp19962
sg19
(lp19963
sg21
I0
sba(iArchitecture
Entity
p19964
(dp19965
g11
(lp19966
sg13
S'com.google.common.collect.Sets$2'
p19967
sg15
(lp19968
sg17
(lp19969
sg19
(lp19970
sg21
I0
sba(iArchitecture
Entity
p19971
(dp19972
g11
(lp19973
sg13
S'com.google.common.collect.Sets$3'
p19974
sg15
(lp19975
sg17
(lp19976
sg19
(lp19977
sg21
I0
sba(iArchitecture
Entity
p19978
(dp19979
g11
(lp19980
sg13
S'com.google.common.collect.Sets$4'
p19981
sg15
(lp19982
sg17
(lp19983
sg19
(lp19984
sg21
I0
sba(iArchitecture
Entity
p19985
(dp19986
g11
(lp19987
sg13
S'com.google.common.collect.Sets$4$1'
p19988
sg15
(lp19989
sg17
(lp19990
sg19
(lp19991
sg21
I0
sba(iArchitecture
Entity
p19992
(dp19993
g11
(lp19994
sg13
S'com.google.common.collect.Sets$CartesianSet'
p19995
sg15
(lp19996
sg17
(lp19997
sg19
(lp19998
sg21
I0
sba(iArchitecture
Entity
p19999
(dp20000
g11
(lp20001
sg13
S'com.google.common.collect.Sets$CartesianSet$1'
p20002
sg15
(lp20003
sg17
(lp20004
sg19
(lp20005
sg21
I0
sba(iArchitecture
Entity
p20006
(dp20007
g11
(lp20008
sg13
S'com.google.common.collect.Sets$DescendingSet'
p20009
sg15
(lp20010
sg17
(lp20011
sg19
(lp20012
sg21
I0
sba(iArchitecture
Entity
p20013
(dp20014
g11
(lp20015
sg13
S'com.google.common.collect.Sets$FilteredNavigableSet'
p20016
sg15
(lp20017
sg17
(lp20018
sg19
(lp20019
sg21
I0
sba(iArchitecture
Entity
p20020
(dp20021
g11
(lp20022
sg13
S'com.google.common.collect.Sets$FilteredSet'
p20023
sg15
(lp20024
sg17
(lp20025
sg19
(lp20026
sg21
I0
sba(iArchitecture
Entity
p20027
(dp20028
g11
(lp20029
sg13
S'com.google.common.collect.Sets$FilteredSortedSet'
p20030
sg15
(lp20031
sg17
(lp20032
sg19
(lp20033
sg21
I0
sba(iArchitecture
Entity
p20034
(dp20035
g11
(lp20036
sg13
S'com.google.common.collect.Sets$ImprovedAbstractSet'
p20037
sg15
(lp20038
sg17
(lp20039
sg19
(lp20040
sg21
I0
sba(iArchitecture
Entity
p20041
(dp20042
g11
(lp20043
sg13
S'com.google.common.collect.Sets$PowerSet'
p20044
sg15
(lp20045
sg17
(lp20046
sg19
(lp20047
sg21
I0
sba(iArchitecture
Entity
p20048
(dp20049
g11
(lp20050
sg13
S'com.google.common.collect.Sets$PowerSet$1'
p20051
sg15
(lp20052
sg17
(lp20053
sg19
(lp20054
sg21
I0
sba(iArchitecture
Entity
p20055
(dp20056
g11
(lp20057
sg13
S'com.google.common.collect.Sets$SetView'
p20058
sg15
(lp20059
sg17
(lp20060
sg19
(lp20061
sg21
I0
sba(iArchitecture
Entity
p20062
(dp20063
g11
(lp20064
sg13
S'com.google.common.collect.Sets$SubSet'
p20065
sg15
(lp20066
sg17
(lp20067
sg19
(lp20068
sg21
I0
sba(iArchitecture
Entity
p20069
(dp20070
g11
(lp20071
sg13
S'com.google.common.collect.Sets$SubSet$1'
p20072
sg15
(lp20073
sg17
(lp20074
sg19
(lp20075
sg21
I0
sba(iArchitecture
Entity
p20076
(dp20077
g11
(lp20078
sg13
S'com.google.common.collect.Sets$UnmodifiableNavigableSet'
p20079
sg15
(lp20080
sg17
(lp20081
sg19
(lp20082
sg21
I0
sba(iArchitecture
Entity
p20083
(dp20084
g11
(lp20085
sg13
S'com.google.common.collect.SingletonImmutableBiMap'
p20086
sg15
(lp20087
sg17
(lp20088
sg19
(lp20089
sg21
I0
sba(iArchitecture
Entity
p20090
(dp20091
g11
(lp20092
sg13
S'com.google.common.collect.SingletonImmutableList'
p20093
sg15
(lp20094
sg17
(lp20095
sg19
(lp20096
sg21
I0
sba(iArchitecture
Entity
p20097
(dp20098
g11
(lp20099
sg13
S'com.google.common.collect.SingletonImmutableSet'
p20100
sg15
(lp20101
sg17
(lp20102
sg19
(lp20103
sg21
I0
sba(iArchitecture
Entity
p20104
(dp20105
g11
(lp20106
sg13
S'com.google.common.collect.SingletonImmutableTable'
p20107
sg15
(lp20108
sg17
(lp20109
sg19
(lp20110
sg21
I0
sba(iArchitecture
Entity
p20111
(dp20112
g11
(lp20113
sg13
S'com.google.common.collect.SortedIterable'
p20114
sg15
(lp20115
sg17
(lp20116
sg19
(lp20117
sg21
I0
sba(iArchitecture
Entity
p20118
(dp20119
g11
(lp20120
sg13
S'com.google.common.collect.SortedIterables'
p20121
sg15
(lp20122
sg17
(lp20123
sg19
(lp20124
sg21
I0
sba(iArchitecture
Entity
p20125
(dp20126
g11
(lp20127
sg13
S'com.google.common.collect.SortedLists'
p20128
sg15
(lp20129
sg17
(lp20130
sg19
(lp20131
sg21
I0
sba(iArchitecture
Entity
p20132
(dp20133
g11
(lp20134
sg13
S'com.google.common.collect.SortedLists$1'
p20135
sg15
(lp20136
sg17
(lp20137
sg19
(lp20138
sg21
I0
sba(iArchitecture
Entity
p20139
(dp20140
g11
(lp20141
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior'
p20142
sg15
(lp20143
sg17
(lp20144
sg19
(lp20145
sg21
I0
sba(iArchitecture
Entity
p20146
(dp20147
g11
(lp20148
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior$1'
p20149
sg15
(lp20150
sg17
(lp20151
sg19
(lp20152
sg21
I0
sba(iArchitecture
Entity
p20153
(dp20154
g11
(lp20155
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior$2'
p20156
sg15
(lp20157
sg17
(lp20158
sg19
(lp20159
sg21
I0
sba(iArchitecture
Entity
p20160
(dp20161
g11
(lp20162
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior$3'
p20163
sg15
(lp20164
sg17
(lp20165
sg19
(lp20166
sg21
I0
sba(iArchitecture
Entity
p20167
(dp20168
g11
(lp20169
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior'
p20170
sg15
(lp20171
sg17
(lp20172
sg19
(lp20173
sg21
I0
sba(iArchitecture
Entity
p20174
(dp20175
g11
(lp20176
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$1'
p20177
sg15
(lp20178
sg17
(lp20179
sg19
(lp20180
sg21
I0
sba(iArchitecture
Entity
p20181
(dp20182
g11
(lp20183
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$2'
p20184
sg15
(lp20185
sg17
(lp20186
sg19
(lp20187
sg21
I0
sba(iArchitecture
Entity
p20188
(dp20189
g11
(lp20190
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$3'
p20191
sg15
(lp20192
sg17
(lp20193
sg19
(lp20194
sg21
I0
sba(iArchitecture
Entity
p20195
(dp20196
g11
(lp20197
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$4'
p20198
sg15
(lp20199
sg17
(lp20200
sg19
(lp20201
sg21
I0
sba(iArchitecture
Entity
p20202
(dp20203
g11
(lp20204
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$5'
p20205
sg15
(lp20206
sg17
(lp20207
sg19
(lp20208
sg21
I0
sba(iArchitecture
Entity
p20209
(dp20210
g11
(lp20211
sg13
S'com.google.common.collect.SortedMapDifference'
p20212
sg15
(lp20213
sg17
(lp20214
sg19
(lp20215
sg21
I0
sba(iArchitecture
Entity
p20216
(dp20217
g11
(lp20218
sg13
S'com.google.common.collect.SortedMultiset'
p20219
sg15
(lp20220
sg17
(lp20221
sg19
(lp20222
sg21
I0
sba(iArchitecture
Entity
p20223
(dp20224
g11
(lp20225
sg13
S'com.google.common.collect.SortedMultisetBridge'
p20226
sg15
(lp20227
sg17
(lp20228
sg19
(lp20229
sg21
I0
sba(iArchitecture
Entity
p20230
(dp20231
g11
(lp20232
sg13
S'com.google.common.collect.SortedMultisets'
p20233
sg15
(lp20234
sg17
(lp20235
sg19
(lp20236
sg21
I0
sba(iArchitecture
Entity
p20237
(dp20238
g11
(lp20239
sg13
S'com.google.common.collect.SortedMultisets$ElementSet'
p20240
sg15
(lp20241
sg17
(lp20242
sg19
(lp20243
sg21
I0
sba(iArchitecture
Entity
p20244
(dp20245
g11
(lp20246
sg13
S'com.google.common.collect.SortedMultisets$NavigableElementSet'
p20247
sg15
(lp20248
sg17
(lp20249
sg19
(lp20250
sg21
I0
sba(iArchitecture
Entity
p20251
(dp20252
g11
(lp20253
sg13
S'com.google.common.collect.SortedSetMultimap'
p20254
sg15
(lp20255
sg17
(lp20256
sg19
(lp20257
sg21
I0
sba(iArchitecture
Entity
p20258
(dp20259
g11
(lp20260
sg13
S'com.google.common.collect.SparseImmutableTable'
p20261
sg15
(lp20262
sg17
(lp20263
sg19
(lp20264
sg21
I0
sba(iArchitecture
Entity
p20265
(dp20266
g11
(lp20267
sg13
S'com.google.common.collect.StandardRowSortedTable'
p20268
sg15
(lp20269
sg17
(lp20270
sg19
(lp20271
sg21
I0
sba(iArchitecture
Entity
p20272
(dp20273
g11
(lp20274
sg13
S'com.google.common.collect.StandardRowSortedTable$1'
p20275
sg15
(lp20276
sg17
(lp20277
sg19
(lp20278
sg21
I0
sba(iArchitecture
Entity
p20279
(dp20280
g11
(lp20281
sg13
S'com.google.common.collect.StandardRowSortedTable$RowSortedMap'
p20282
sg15
(lp20283
sg17
(lp20284
sg19
(lp20285
sg21
I0
sba(iArchitecture
Entity
p20286
(dp20287
g11
(lp20288
sg13
S'com.google.common.collect.StandardTable'
p20289
sg15
(lp20290
sg17
(lp20291
sg19
(lp20292
sg21
I0
sba(iArchitecture
Entity
p20293
(dp20294
g11
(lp20295
sg13
S'com.google.common.collect.StandardTable$1'
p20296
sg15
(lp20297
sg17
(lp20298
sg19
(lp20299
sg21
I0
sba(iArchitecture
Entity
p20300
(dp20301
g11
(lp20302
sg13
S'com.google.common.collect.StandardTable$CellIterator'
p20303
sg15
(lp20304
sg17
(lp20305
sg19
(lp20306
sg21
I0
sba(iArchitecture
Entity
p20307
(dp20308
g11
(lp20309
sg13
S'com.google.common.collect.StandardTable$Column'
p20310
sg15
(lp20311
sg17
(lp20312
sg19
(lp20313
sg21
I0
sba(iArchitecture
Entity
p20314
(dp20315
g11
(lp20316
sg13
S'com.google.common.collect.StandardTable$Column$EntrySet'
p20317
sg15
(lp20318
sg17
(lp20319
sg19
(lp20320
sg21
I0
sba(iArchitecture
Entity
p20321
(dp20322
g11
(lp20323
sg13
S'com.google.common.collect.StandardTable$Column$EntrySetIterator'
p20324
sg15
(lp20325
sg17
(lp20326
sg19
(lp20327
sg21
I0
sba(iArchitecture
Entity
p20328
(dp20329
g11
(lp20330
sg13
S'com.google.common.collect.StandardTable$Column$EntrySetIterator$1EntryImpl'
p20331
sg15
(lp20332
sg17
(lp20333
sg19
(lp20334
sg21
I0
sba(iArchitecture
Entity
p20335
(dp20336
g11
(lp20337
sg13
S'com.google.common.collect.StandardTable$Column$KeySet'
p20338
sg15
(lp20339
sg17
(lp20340
sg19
(lp20341
sg21
I0
sba(iArchitecture
Entity
p20342
(dp20343
g11
(lp20344
sg13
S'com.google.common.collect.StandardTable$Column$Values'
p20345
sg15
(lp20346
sg17
(lp20347
sg19
(lp20348
sg21
I0
sba(iArchitecture
Entity
p20349
(dp20350
g11
(lp20351
sg13
S'com.google.common.collect.StandardTable$ColumnKeyIterator'
p20352
sg15
(lp20353
sg17
(lp20354
sg19
(lp20355
sg21
I0
sba(iArchitecture
Entity
p20356
(dp20357
g11
(lp20358
sg13
S'com.google.common.collect.StandardTable$ColumnKeySet'
p20359
sg15
(lp20360
sg17
(lp20361
sg19
(lp20362
sg21
I0
sba(iArchitecture
Entity
p20363
(dp20364
g11
(lp20365
sg13
S'com.google.common.collect.StandardTable$ColumnMap'
p20366
sg15
(lp20367
sg17
(lp20368
sg19
(lp20369
sg21
I0
sba(iArchitecture
Entity
p20370
(dp20371
g11
(lp20372
sg13
S'com.google.common.collect.StandardTable$ColumnMap$ColumnMapEntrySet'
p20373
sg15
(lp20374
sg17
(lp20375
sg19
(lp20376
sg21
I0
sba(iArchitecture
Entity
p20377
(dp20378
g11
(lp20379
sg13
S'com.google.common.collect.StandardTable$ColumnMap$ColumnMapEntrySet$1'
p20380
sg15
(lp20381
sg17
(lp20382
sg19
(lp20383
sg21
I0
sba(iArchitecture
Entity
p20384
(dp20385
g11
(lp20386
sg13
S'com.google.common.collect.StandardTable$ColumnMap$ColumnMapValues'
p20387
sg15
(lp20388
sg17
(lp20389
sg19
(lp20390
sg21
I0
sba(iArchitecture
Entity
p20391
(dp20392
g11
(lp20393
sg13
S'com.google.common.collect.StandardTable$Row'
p20394
sg15
(lp20395
sg17
(lp20396
sg19
(lp20397
sg21
I0
sba(iArchitecture
Entity
p20398
(dp20399
g11
(lp20400
sg13
S'com.google.common.collect.StandardTable$Row$1'
p20401
sg15
(lp20402
sg17
(lp20403
sg19
(lp20404
sg21
I0
sba(iArchitecture
Entity
p20405
(dp20406
g11
(lp20407
sg13
S'com.google.common.collect.StandardTable$Row$1$1'
p20408
sg15
(lp20409
sg17
(lp20410
sg19
(lp20411
sg21
I0
sba(iArchitecture
Entity
p20412
(dp20413
g11
(lp20414
sg13
S'com.google.common.collect.StandardTable$RowMap'
p20415
sg15
(lp20416
sg17
(lp20417
sg19
(lp20418
sg21
I0
sba(iArchitecture
Entity
p20419
(dp20420
g11
(lp20421
sg13
S'com.google.common.collect.StandardTable$RowMap$EntrySet'
p20422
sg15
(lp20423
sg17
(lp20424
sg19
(lp20425
sg21
I0
sba(iArchitecture
Entity
p20426
(dp20427
g11
(lp20428
sg13
S'com.google.common.collect.StandardTable$RowMap$EntrySet$1'
p20429
sg15
(lp20430
sg17
(lp20431
sg19
(lp20432
sg21
I0
sba(iArchitecture
Entity
p20433
(dp20434
g11
(lp20435
sg13
S'com.google.common.collect.StandardTable$TableSet'
p20436
sg15
(lp20437
sg17
(lp20438
sg19
(lp20439
sg21
I0
sba(iArchitecture
Entity
p20440
(dp20441
g11
(lp20442
sg13
S'com.google.common.collect.Synchronized'
p20443
sg15
(lp20444
sg17
(lp20445
sg19
(lp20446
sg21
I0
sba(iArchitecture
Entity
p20447
(dp20448
g11
(lp20449
sg13
S'com.google.common.collect.Synchronized$1'
p20450
sg15
(lp20451
sg17
(lp20452
sg19
(lp20453
sg21
I0
sba(iArchitecture
Entity
p20454
(dp20455
g11
(lp20456
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMap'
p20457
sg15
(lp20458
sg17
(lp20459
sg19
(lp20460
sg21
I0
sba(iArchitecture
Entity
p20461
(dp20462
g11
(lp20463
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapEntries'
p20464
sg15
(lp20465
sg17
(lp20466
sg19
(lp20467
sg21
I0
sba(iArchitecture
Entity
p20468
(dp20469
g11
(lp20470
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapEntries$1'
p20471
sg15
(lp20472
sg17
(lp20473
sg19
(lp20474
sg21
I0
sba(iArchitecture
Entity
p20475
(dp20476
g11
(lp20477
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapEntries$1$1'
p20478
sg15
(lp20479
sg17
(lp20480
sg19
(lp20481
sg21
I0
sba(iArchitecture
Entity
p20482
(dp20483
g11
(lp20484
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapValues'
p20485
sg15
(lp20486
sg17
(lp20487
sg19
(lp20488
sg21
I0
sba(iArchitecture
Entity
p20489
(dp20490
g11
(lp20491
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapValues$1'
p20492
sg15
(lp20493
sg17
(lp20494
sg19
(lp20495
sg21
I0
sba(iArchitecture
Entity
p20496
(dp20497
g11
(lp20498
sg13
S'com.google.common.collect.Synchronized$SynchronizedBiMap'
p20499
sg15
(lp20500
sg17
(lp20501
sg19
(lp20502
sg21
I0
sba(iArchitecture
Entity
p20503
(dp20504
g11
(lp20505
sg13
S'com.google.common.collect.Synchronized$SynchronizedCollection'
p20506
sg15
(lp20507
sg17
(lp20508
sg19
(lp20509
sg21
I0
sba(iArchitecture
Entity
p20510
(dp20511
g11
(lp20512
sg13
S'com.google.common.collect.Synchronized$SynchronizedDeque'
p20513
sg15
(lp20514
sg17
(lp20515
sg19
(lp20516
sg21
I0
sba(iArchitecture
Entity
p20517
(dp20518
g11
(lp20519
sg13
S'com.google.common.collect.Synchronized$SynchronizedEntry'
p20520
sg15
(lp20521
sg17
(lp20522
sg19
(lp20523
sg21
I0
sba(iArchitecture
Entity
p20524
(dp20525
g11
(lp20526
sg13
S'com.google.common.collect.Synchronized$SynchronizedList'
p20527
sg15
(lp20528
sg17
(lp20529
sg19
(lp20530
sg21
I0
sba(iArchitecture
Entity
p20531
(dp20532
g11
(lp20533
sg13
S'com.google.common.collect.Synchronized$SynchronizedListMultimap'
p20534
sg15
(lp20535
sg17
(lp20536
sg19
(lp20537
sg21
I0
sba(iArchitecture
Entity
p20538
(dp20539
g11
(lp20540
sg13
S'com.google.common.collect.Synchronized$SynchronizedMap'
p20541
sg15
(lp20542
sg17
(lp20543
sg19
(lp20544
sg21
I0
sba(iArchitecture
Entity
p20545
(dp20546
g11
(lp20547
sg13
S'com.google.common.collect.Synchronized$SynchronizedMultimap'
p20548
sg15
(lp20549
sg17
(lp20550
sg19
(lp20551
sg21
I0
sba(iArchitecture
Entity
p20552
(dp20553
g11
(lp20554
sg13
S'com.google.common.collect.Synchronized$SynchronizedMultiset'
p20555
sg15
(lp20556
sg17
(lp20557
sg19
(lp20558
sg21
I0
sba(iArchitecture
Entity
p20559
(dp20560
g11
(lp20561
sg13
S'com.google.common.collect.Synchronized$SynchronizedNavigableMap'
p20562
sg15
(lp20563
sg17
(lp20564
sg19
(lp20565
sg21
I0
sba(iArchitecture
Entity
p20566
(dp20567
g11
(lp20568
sg13
S'com.google.common.collect.Synchronized$SynchronizedNavigableSet'
p20569
sg15
(lp20570
sg17
(lp20571
sg19
(lp20572
sg21
I0
sba(iArchitecture
Entity
p20573
(dp20574
g11
(lp20575
sg13
S'com.google.common.collect.Synchronized$SynchronizedObject'
p20576
sg15
(lp20577
sg17
(lp20578
sg19
(lp20579
sg21
I0
sba(iArchitecture
Entity
p20580
(dp20581
g11
(lp20582
sg13
S'com.google.common.collect.Synchronized$SynchronizedQueue'
p20583
sg15
(lp20584
sg17
(lp20585
sg19
(lp20586
sg21
I0
sba(iArchitecture
Entity
p20587
(dp20588
g11
(lp20589
sg13
S'com.google.common.collect.Synchronized$SynchronizedRandomAccessList'
p20590
sg15
(lp20591
sg17
(lp20592
sg19
(lp20593
sg21
I0
sba(iArchitecture
Entity
p20594
(dp20595
g11
(lp20596
sg13
S'com.google.common.collect.Synchronized$SynchronizedSet'
p20597
sg15
(lp20598
sg17
(lp20599
sg19
(lp20600
sg21
I0
sba(iArchitecture
Entity
p20601
(dp20602
g11
(lp20603
sg13
S'com.google.common.collect.Synchronized$SynchronizedSetMultimap'
p20604
sg15
(lp20605
sg17
(lp20606
sg19
(lp20607
sg21
I0
sba(iArchitecture
Entity
p20608
(dp20609
g11
(lp20610
sg13
S'com.google.common.collect.Synchronized$SynchronizedSortedMap'
p20611
sg15
(lp20612
sg17
(lp20613
sg19
(lp20614
sg21
I0
sba(iArchitecture
Entity
p20615
(dp20616
g11
(lp20617
sg13
S'com.google.common.collect.Synchronized$SynchronizedSortedSet'
p20618
sg15
(lp20619
sg17
(lp20620
sg19
(lp20621
sg21
I0
sba(iArchitecture
Entity
p20622
(dp20623
g11
(lp20624
sg13
S'com.google.common.collect.Synchronized$SynchronizedSortedSetMultimap'
p20625
sg15
(lp20626
sg17
(lp20627
sg19
(lp20628
sg21
I0
sba(iArchitecture
Entity
p20629
(dp20630
g11
(lp20631
sg13
S'com.google.common.collect.Table'
p20632
sg15
(lp20633
sg17
(lp20634
sg19
(lp20635
sg21
I0
sba(iArchitecture
Entity
p20636
(dp20637
g11
(lp20638
sg13
S'com.google.common.collect.Table$Cell'
p20639
sg15
(lp20640
sg17
(lp20641
sg19
(lp20642
sg21
I0
sba(iArchitecture
Entity
p20643
(dp20644
g11
(lp20645
sg13
S'com.google.common.collect.Tables'
p20646
sg15
(lp20647
sg17
(lp20648
sg19
(lp20649
sg21
I0
sba(iArchitecture
Entity
p20650
(dp20651
g11
(lp20652
sg13
S'com.google.common.collect.Tables$1'
p20653
sg15
(lp20654
sg17
(lp20655
sg19
(lp20656
sg21
I0
sba(iArchitecture
Entity
p20657
(dp20658
g11
(lp20659
sg13
S'com.google.common.collect.Tables$AbstractCell'
p20660
sg15
(lp20661
sg17
(lp20662
sg19
(lp20663
sg21
I0
sba(iArchitecture
Entity
p20664
(dp20665
g11
(lp20666
sg13
S'com.google.common.collect.Tables$ImmutableCell'
p20667
sg15
(lp20668
sg17
(lp20669
sg19
(lp20670
sg21
I0
sba(iArchitecture
Entity
p20671
(dp20672
g11
(lp20673
sg13
S'com.google.common.collect.Tables$TransformedTable'
p20674
sg15
(lp20675
sg17
(lp20676
sg19
(lp20677
sg21
I0
sba(iArchitecture
Entity
p20678
(dp20679
g11
(lp20680
sg13
S'com.google.common.collect.Tables$TransformedTable$1'
p20681
sg15
(lp20682
sg17
(lp20683
sg19
(lp20684
sg21
I0
sba(iArchitecture
Entity
p20685
(dp20686
g11
(lp20687
sg13
S'com.google.common.collect.Tables$TransformedTable$2'
p20688
sg15
(lp20689
sg17
(lp20690
sg19
(lp20691
sg21
I0
sba(iArchitecture
Entity
p20692
(dp20693
g11
(lp20694
sg13
S'com.google.common.collect.Tables$TransformedTable$3'
p20695
sg15
(lp20696
sg17
(lp20697
sg19
(lp20698
sg21
I0
sba(iArchitecture
Entity
p20699
(dp20700
g11
(lp20701
sg13
S'com.google.common.collect.Tables$TransposeTable'
p20702
sg15
(lp20703
sg17
(lp20704
sg19
(lp20705
sg21
I0
sba(iArchitecture
Entity
p20706
(dp20707
g11
(lp20708
sg13
S'com.google.common.collect.Tables$TransposeTable$1'
p20709
sg15
(lp20710
sg17
(lp20711
sg19
(lp20712
sg21
I0
sba(iArchitecture
Entity
p20713
(dp20714
g11
(lp20715
sg13
S'com.google.common.collect.Tables$UnmodifiableRowSortedMap'
p20716
sg15
(lp20717
sg17
(lp20718
sg19
(lp20719
sg21
I0
sba(iArchitecture
Entity
p20720
(dp20721
g11
(lp20722
sg13
S'com.google.common.collect.Tables$UnmodifiableTable'
p20723
sg15
(lp20724
sg17
(lp20725
sg19
(lp20726
sg21
I0
sba(iArchitecture
Entity
p20727
(dp20728
g11
(lp20729
sg13
S'com.google.common.collect.TopKSelector'
p20730
sg15
(lp20731
sg17
(lp20732
sg19
(lp20733
sg21
I0
sba(iArchitecture
Entity
p20734
(dp20735
g11
(lp20736
sg13
S'com.google.common.collect.TransformedIterator'
p20737
sg15
(lp20738
sg17
(lp20739
sg19
(lp20740
sg21
I0
sba(iArchitecture
Entity
p20741
(dp20742
g11
(lp20743
sg13
S'com.google.common.collect.TransformedListIterator'
p20744
sg15
(lp20745
sg17
(lp20746
sg19
(lp20747
sg21
I0
sba(iArchitecture
Entity
p20748
(dp20749
g11
(lp20750
sg13
S'com.google.common.collect.TreeBasedTable'
p20751
sg15
(lp20752
sg17
(lp20753
sg19
(lp20754
sg21
I0
sba(iArchitecture
Entity
p20755
(dp20756
g11
(lp20757
sg13
S'com.google.common.collect.TreeBasedTable$1'
p20758
sg15
(lp20759
sg17
(lp20760
sg19
(lp20761
sg21
I0
sba(iArchitecture
Entity
p20762
(dp20763
g11
(lp20764
sg13
S'com.google.common.collect.TreeBasedTable$2'
p20765
sg15
(lp20766
sg17
(lp20767
sg19
(lp20768
sg21
I0
sba(iArchitecture
Entity
p20769
(dp20770
g11
(lp20771
sg13
S'com.google.common.collect.TreeBasedTable$Factory'
p20772
sg15
(lp20773
sg17
(lp20774
sg19
(lp20775
sg21
I0
sba(iArchitecture
Entity
p20776
(dp20777
g11
(lp20778
sg13
S'com.google.common.collect.TreeBasedTable$TreeRow'
p20779
sg15
(lp20780
sg17
(lp20781
sg19
(lp20782
sg21
I0
sba(iArchitecture
Entity
p20783
(dp20784
g11
(lp20785
sg13
S'com.google.common.collect.TreeMultimap'
p20786
sg15
(lp20787
sg17
(lp20788
sg19
(lp20789
sg21
I0
sba(iArchitecture
Entity
p20790
(dp20791
g11
(lp20792
sg13
S'com.google.common.collect.TreeMultiset'
p20793
sg15
(lp20794
sg17
(lp20795
sg19
(lp20796
sg21
I0
sba(iArchitecture
Entity
p20797
(dp20798
g11
(lp20799
sg13
S'com.google.common.collect.TreeMultiset$1'
p20800
sg15
(lp20801
sg17
(lp20802
sg19
(lp20803
sg21
I0
sba(iArchitecture
Entity
p20804
(dp20805
g11
(lp20806
sg13
S'com.google.common.collect.TreeMultiset$2'
p20807
sg15
(lp20808
sg17
(lp20809
sg19
(lp20810
sg21
I0
sba(iArchitecture
Entity
p20811
(dp20812
g11
(lp20813
sg13
S'com.google.common.collect.TreeMultiset$3'
p20814
sg15
(lp20815
sg17
(lp20816
sg19
(lp20817
sg21
I0
sba(iArchitecture
Entity
p20818
(dp20819
g11
(lp20820
sg13
S'com.google.common.collect.TreeMultiset$4'
p20821
sg15
(lp20822
sg17
(lp20823
sg19
(lp20824
sg21
I0
sba(iArchitecture
Entity
p20825
(dp20826
g11
(lp20827
sg13
S'com.google.common.collect.TreeMultiset$Aggregate'
p20828
sg15
(lp20829
sg17
(lp20830
sg19
(lp20831
sg21
I0
sba(iArchitecture
Entity
p20832
(dp20833
g11
(lp20834
sg13
S'com.google.common.collect.TreeMultiset$Aggregate$1'
p20835
sg15
(lp20836
sg17
(lp20837
sg19
(lp20838
sg21
I0
sba(iArchitecture
Entity
p20839
(dp20840
g11
(lp20841
sg13
S'com.google.common.collect.TreeMultiset$Aggregate$2'
p20842
sg15
(lp20843
sg17
(lp20844
sg19
(lp20845
sg21
I0
sba(iArchitecture
Entity
p20846
(dp20847
g11
(lp20848
sg13
S'com.google.common.collect.TreeMultiset$AvlNode'
p20849
sg15
(lp20850
sg17
(lp20851
sg19
(lp20852
sg21
I0
sba(iArchitecture
Entity
p20853
(dp20854
g11
(lp20855
sg13
S'com.google.common.collect.TreeMultiset$Reference'
p20856
sg15
(lp20857
sg17
(lp20858
sg19
(lp20859
sg21
I0
sba(iArchitecture
Entity
p20860
(dp20861
g11
(lp20862
sg13
S'com.google.common.collect.TreeRangeMap'
p20863
sg15
(lp20864
sg17
(lp20865
sg19
(lp20866
sg21
I0
sba(iArchitecture
Entity
p20867
(dp20868
g11
(lp20869
sg13
S'com.google.common.collect.TreeRangeMap$1'
p20870
sg15
(lp20871
sg17
(lp20872
sg19
(lp20873
sg21
I0
sba(iArchitecture
Entity
p20874
(dp20875
g11
(lp20876
sg13
S'com.google.common.collect.TreeRangeMap$AsMapOfRanges'
p20877
sg15
(lp20878
sg17
(lp20879
sg19
(lp20880
sg21
I0
sba(iArchitecture
Entity
p20881
(dp20882
g11
(lp20883
sg13
S'com.google.common.collect.TreeRangeMap$RangeMapEntry'
p20884
sg15
(lp20885
sg17
(lp20886
sg19
(lp20887
sg21
I0
sba(iArchitecture
Entity
p20888
(dp20889
g11
(lp20890
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap'
p20891
sg15
(lp20892
sg17
(lp20893
sg19
(lp20894
sg21
I0
sba(iArchitecture
Entity
p20895
(dp20896
g11
(lp20897
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$1'
p20898
sg15
(lp20899
sg17
(lp20900
sg19
(lp20901
sg21
I0
sba(iArchitecture
Entity
p20902
(dp20903
g11
(lp20904
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$1$1'
p20905
sg15
(lp20906
sg17
(lp20907
sg19
(lp20908
sg21
I0
sba(iArchitecture
Entity
p20909
(dp20910
g11
(lp20911
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap'
p20912
sg15
(lp20913
sg17
(lp20914
sg19
(lp20915
sg21
I0
sba(iArchitecture
Entity
p20916
(dp20917
g11
(lp20918
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$1'
p20919
sg15
(lp20920
sg17
(lp20921
sg19
(lp20922
sg21
I0
sba(iArchitecture
Entity
p20923
(dp20924
g11
(lp20925
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$2'
p20926
sg15
(lp20927
sg17
(lp20928
sg19
(lp20929
sg21
I0
sba(iArchitecture
Entity
p20930
(dp20931
g11
(lp20932
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$3'
p20933
sg15
(lp20934
sg17
(lp20935
sg19
(lp20936
sg21
I0
sba(iArchitecture
Entity
p20937
(dp20938
g11
(lp20939
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$4'
p20940
sg15
(lp20941
sg17
(lp20942
sg19
(lp20943
sg21
I0
sba(iArchitecture
Entity
p20944
(dp20945
g11
(lp20946
sg13
S'com.google.common.collect.TreeRangeSet'
p20947
sg15
(lp20948
sg17
(lp20949
sg19
(lp20950
sg21
I0
sba(iArchitecture
Entity
p20951
(dp20952
g11
(lp20953
sg13
S'com.google.common.collect.TreeRangeSet$1'
p20954
sg15
(lp20955
sg17
(lp20956
sg19
(lp20957
sg21
I0
sba(iArchitecture
Entity
p20958
(dp20959
g11
(lp20960
sg13
S'com.google.common.collect.TreeRangeSet$AsRanges'
p20961
sg15
(lp20962
sg17
(lp20963
sg19
(lp20964
sg21
I0
sba(iArchitecture
Entity
p20965
(dp20966
g11
(lp20967
sg13
S'com.google.common.collect.TreeRangeSet$Complement'
p20968
sg15
(lp20969
sg17
(lp20970
sg19
(lp20971
sg21
I0
sba(iArchitecture
Entity
p20972
(dp20973
g11
(lp20974
sg13
S'com.google.common.collect.TreeRangeSet$ComplementRangesByLowerBound'
p20975
sg15
(lp20976
sg17
(lp20977
sg19
(lp20978
sg21
I0
sba(iArchitecture
Entity
p20979
(dp20980
g11
(lp20981
sg13
S'com.google.common.collect.TreeRangeSet$ComplementRangesByLowerBound$1'
p20982
sg15
(lp20983
sg17
(lp20984
sg19
(lp20985
sg21
I0
sba(iArchitecture
Entity
p20986
(dp20987
g11
(lp20988
sg13
S'com.google.common.collect.TreeRangeSet$ComplementRangesByLowerBound$2'
p20989
sg15
(lp20990
sg17
(lp20991
sg19
(lp20992
sg21
I0
sba(iArchitecture
Entity
p20993
(dp20994
g11
(lp20995
sg13
S'com.google.common.collect.TreeRangeSet$RangesByUpperBound'
p20996
sg15
(lp20997
sg17
(lp20998
sg19
(lp20999
sg21
I0
sba(iArchitecture
Entity
p21000
(dp21001
g11
(lp21002
sg13
S'com.google.common.collect.TreeRangeSet$RangesByUpperBound$1'
p21003
sg15
(lp21004
sg17
(lp21005
sg19
(lp21006
sg21
I0
sba(iArchitecture
Entity
p21007
(dp21008
g11
(lp21009
sg13
S'com.google.common.collect.TreeRangeSet$RangesByUpperBound$2'
p21010
sg15
(lp21011
sg17
(lp21012
sg19
(lp21013
sg21
I0
sba(iArchitecture
Entity
p21014
(dp21015
g11
(lp21016
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSet'
p21017
sg15
(lp21018
sg17
(lp21019
sg19
(lp21020
sg21
I0
sba(iArchitecture
Entity
p21021
(dp21022
g11
(lp21023
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSetRangesByLowerBound'
p21024
sg15
(lp21025
sg17
(lp21026
sg19
(lp21027
sg21
I0
sba(iArchitecture
Entity
p21028
(dp21029
g11
(lp21030
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSetRangesByLowerBound$1'
p21031
sg15
(lp21032
sg17
(lp21033
sg19
(lp21034
sg21
I0
sba(iArchitecture
Entity
p21035
(dp21036
g11
(lp21037
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSetRangesByLowerBound$2'
p21038
sg15
(lp21039
sg17
(lp21040
sg19
(lp21041
sg21
I0
sba(iArchitecture
Entity
p21042
(dp21043
g11
(lp21044
sg13
S'com.google.common.collect.TreeTraverser'
p21045
sg15
(lp21046
sg17
(lp21047
sg19
(lp21048
sg21
I0
sba(iArchitecture
Entity
p21049
(dp21050
g11
(lp21051
sg13
S'com.google.common.collect.TreeTraverser$1'
p21052
sg15
(lp21053
sg17
(lp21054
sg19
(lp21055
sg21
I0
sba(iArchitecture
Entity
p21056
(dp21057
g11
(lp21058
sg13
S'com.google.common.collect.TreeTraverser$2'
p21059
sg15
(lp21060
sg17
(lp21061
sg19
(lp21062
sg21
I0
sba(iArchitecture
Entity
p21063
(dp21064
g11
(lp21065
sg13
S'com.google.common.collect.TreeTraverser$3'
p21066
sg15
(lp21067
sg17
(lp21068
sg19
(lp21069
sg21
I0
sba(iArchitecture
Entity
p21070
(dp21071
g11
(lp21072
sg13
S'com.google.common.collect.TreeTraverser$4'
p21073
sg15
(lp21074
sg17
(lp21075
sg19
(lp21076
sg21
I0
sba(iArchitecture
Entity
p21077
(dp21078
g11
(lp21079
sg13
S'com.google.common.collect.TreeTraverser$BreadthFirstIterator'
p21080
sg15
(lp21081
sg17
(lp21082
sg19
(lp21083
sg21
I0
sba(iArchitecture
Entity
p21084
(dp21085
g11
(lp21086
sg13
S'com.google.common.collect.TreeTraverser$PostOrderIterator'
p21087
sg15
(lp21088
sg17
(lp21089
sg19
(lp21090
sg21
I0
sba(iArchitecture
Entity
p21091
(dp21092
g11
(lp21093
sg13
S'com.google.common.collect.TreeTraverser$PostOrderNode'
p21094
sg15
(lp21095
sg17
(lp21096
sg19
(lp21097
sg21
I0
sba(iArchitecture
Entity
p21098
(dp21099
g11
(lp21100
sg13
S'com.google.common.collect.TreeTraverser$PreOrderIterator'
p21101
sg15
(lp21102
sg17
(lp21103
sg19
(lp21104
sg21
I0
sba(iArchitecture
Entity
p21105
(dp21106
g11
(lp21107
sg13
S'com.google.common.collect.UnmodifiableIterator'
p21108
sg15
(lp21109
sg17
(lp21110
sg19
(lp21111
sg21
I0
sba(iArchitecture
Entity
p21112
(dp21113
g11
(lp21114
sg13
S'com.google.common.collect.UnmodifiableListIterator'
p21115
sg15
(lp21116
sg17
(lp21117
sg19
(lp21118
sg21
I0
sba(iArchitecture
Entity
p21119
(dp21120
g11
(lp21121
sg13
S'com.google.common.collect.UnmodifiableSortedMultiset'
p21122
sg15
(lp21123
sg17
(lp21124
sg19
(lp21125
sg21
I0
sba(iArchitecture
Entity
p21126
(dp21127
g11
(lp21128
sg13
S'com.google.common.collect.UsingToStringOrdering'
p21129
sg15
(lp21130
sg17
(lp21131
sg19
(lp21132
sg21
I0
sba(iArchitecture
Entity
p21133
(dp21134
g11
(lp21135
sg13
S'com.google.common.collect.WellBehavedMap'
p21136
sg15
(lp21137
sg17
(lp21138
sg19
(lp21139
sg21
I0
sba(iArchitecture
Entity
p21140
(dp21141
g11
(lp21142
sg13
S'com.google.common.collect.WellBehavedMap$1'
p21143
sg15
(lp21144
sg17
(lp21145
sg19
(lp21146
sg21
I0
sba(iArchitecture
Entity
p21147
(dp21148
g11
(lp21149
sg13
S'com.google.common.collect.WellBehavedMap$EntrySet'
p21150
sg15
(lp21151
sg17
(lp21152
sg19
(lp21153
sg21
I0
sba(iArchitecture
Entity
p21154
(dp21155
g11
(lp21156
sg13
S'com.google.common.collect.WellBehavedMap$EntrySet$1'
p21157
sg15
(lp21158
sg17
(lp21159
sg19
(lp21160
sg21
I0
sba(iArchitecture
Entity
p21161
(dp21162
g11
(lp21163
sg13
S'com.google.common.collect.WellBehavedMap$EntrySet$1$1'
p21164
sg15
(lp21165
sg17
(lp21166
sg19
(lp21167
sg21
I0
sba(iArchitecture
Entity
p21168
(dp21169
g11
(lp21170
sg13
S'com.google.common.net.HttpHeaders'
p21171
sg15
(lp21172
sg17
(lp21173
sg19
(lp21174
sg21
I0
sba(iArchitecture
Entity
p21175
(dp21176
g11
(lp21177
sg13
S'com.google.errorprone.annotations.CanIgnoreReturnValue'
p21178
sg15
(lp21179
sg17
(lp21180
sg19
(lp21181
sg21
I0
sba(iArchitecture
Entity
p21182
(dp21183
g11
(lp21184
sg13
S'com.google.errorprone.annotations.concurrent.LazyInit'
p21185
sg15
(lp21186
sg17
(lp21187
sg19
(lp21188
sg21
I0
sba(iArchitecture
Entity
p21189
(dp21190
g11
(lp21191
sg13
S'com.google.j2objc.annotations.RetainedWith'
p21192
sg15
(lp21193
sg17
(lp21194
sg19
(lp21195
sg21
I0
sba(iArchitecture
Entity
p21196
(dp21197
g11
(lp21198
sg13
S'com.google.j2objc.annotations.Weak'
p21199
sg15
(lp21200
sg17
(lp21201
sg19
(lp21202
sg21
I0
sbasg1135
(lp21203
g15319
ag15326
ag15333
ag15340
ag15347
ag15354
ag15361
ag15368
ag15375
ag15382
ag15389
ag15396
ag15403
ag15410
ag15417
ag15424
ag15431
ag15438
ag15445
ag15452
ag15459
ag15466
ag15473
ag15480
ag15487
ag15494
ag15501
ag15508
ag15515
ag15522
ag15529
ag15536
ag15543
ag15550
ag15557
ag15564
ag15571
ag15578
ag15585
ag15592
ag15599
ag15606
ag15613
ag15620
ag15627
ag15634
ag15641
ag15648
ag15655
ag15662
ag15669
ag15676
ag15683
ag15690
ag15697
ag15704
ag15711
ag15718
ag15725
ag15732
ag15739
ag15746
ag15753
ag15760
ag15767
ag15774
ag15781
ag15788
ag15795
ag15802
ag15809
ag15816
ag15823
ag15830
ag15837
ag15844
ag15851
ag15858
ag15865
ag15872
ag15879
ag15886
ag15893
ag15900
ag15907
ag15914
ag15921
ag15928
ag15935
ag15942
ag15949
ag15956
ag15963
ag15970
ag15977
ag15984
ag15991
ag15998
ag16005
ag16012
ag16019
ag16026
ag16033
ag16040
ag16047
ag16054
ag16061
ag16068
ag16075
ag16082
ag16089
ag16096
ag16103
ag16110
ag16117
ag16124
ag16131
ag16138
ag16145
ag16152
ag16159
ag16166
ag16173
ag16180
ag16187
ag16194
ag16201
ag16208
ag16215
ag16222
ag16229
ag16236
ag16243
ag16250
ag16257
ag16264
ag16271
ag16278
ag16285
ag16292
ag16299
ag16306
ag16313
ag16320
ag16327
ag16334
ag16341
ag16348
ag16355
ag16362
ag16369
ag16376
ag16383
ag16390
ag16397
ag16404
ag16411
ag16418
ag16425
ag16432
ag16439
ag16446
ag16453
ag16460
ag16467
ag16474
ag16481
ag16488
ag16495
ag16502
ag16509
ag16516
ag16523
ag16530
ag16537
ag16544
ag16551
ag16558
ag16565
ag16572
ag16579
ag16586
ag16593
ag16600
ag16607
ag16614
ag16621
ag16628
ag16635
ag16642
ag16649
ag16656
ag16663
ag16670
ag16677
ag16684
ag16691
ag16698
ag16705
ag16712
ag16719
ag16726
ag16733
ag16740
ag16747
ag16754
ag16761
ag16768
ag16775
ag16782
ag16789
ag16796
ag16803
ag16810
ag16817
ag16824
ag16831
ag16838
ag16845
ag16852
ag16859
ag16866
ag16873
ag16880
ag16887
ag16894
ag16901
ag16908
ag16915
ag16922
ag16929
ag16936
ag16943
ag16950
ag16957
ag16964
ag16971
ag16978
ag16985
ag16992
ag16999
ag17006
ag17013
ag17020
ag17027
ag17034
ag17041
ag17048
ag17055
ag17062
ag17069
ag17076
ag17083
ag17090
ag17097
ag17104
ag17111
ag17118
ag17125
ag17132
ag17139
ag17146
ag17153
ag17160
ag17167
ag17174
ag17181
ag17188
ag17195
ag17202
ag17209
ag17216
ag17223
ag17230
ag17237
ag17244
ag17251
ag17258
ag17265
ag17272
ag17279
ag17286
ag17293
ag17300
ag17307
ag17314
ag17321
ag17328
ag17335
ag17342
ag17349
ag17356
ag17363
ag17370
ag17377
ag17384
ag17391
ag17398
ag17405
ag17412
ag17419
ag17426
ag17433
ag17440
ag17447
ag17454
ag17461
ag17468
ag17475
ag17482
ag17489
ag17496
ag17503
ag17510
ag17517
ag17524
ag17531
ag17538
ag17545
ag17552
ag17559
ag17566
ag17573
ag17580
ag17587
ag17594
ag17601
ag17608
ag17615
ag17622
ag17629
ag17636
ag17643
ag17650
ag17657
ag17664
ag17671
ag17678
ag17685
ag17692
ag17699
ag17706
ag17713
ag17720
ag17727
ag17734
ag17741
ag17748
ag17755
ag17762
ag17769
ag17776
ag17783
ag17790
ag17797
ag17804
ag17811
ag17818
ag17825
ag17832
ag17839
ag17846
ag17853
ag17860
ag17867
ag17874
ag17881
ag17888
ag17895
ag17902
ag17909
ag17916
ag17923
ag17930
ag17937
ag17944
ag17951
ag17958
ag17965
ag17972
ag17979
ag17986
ag17993
ag18000
ag18007
ag18014
ag18021
ag18028
ag18035
ag18042
ag18049
ag18056
ag18063
ag18070
ag18077
ag18084
ag18091
ag18098
ag18105
ag18112
ag18119
ag18126
ag18133
ag18140
ag18147
ag18154
ag18161
ag18168
ag18175
ag18182
ag18189
ag18196
ag18203
ag18210
ag18217
ag18224
ag18231
ag18238
ag18245
ag18252
ag18259
ag18266
ag18273
ag18280
ag18287
ag18294
ag18301
ag18308
ag18315
ag18322
ag18329
ag18336
ag18343
ag18350
ag18357
ag18364
ag18371
ag18378
ag18385
ag18392
ag18399
ag18406
ag18413
ag18420
ag18427
ag18434
ag18441
ag18448
ag18455
ag18462
ag18469
ag18476
ag18483
ag18490
ag18497
ag18504
ag18511
ag18518
ag18525
ag18532
ag18539
ag18546
ag18553
ag18560
ag18567
ag18574
ag18581
ag18588
ag18595
ag18602
ag18609
ag18616
ag18623
ag18630
ag18637
ag18644
ag18651
ag18658
ag18665
ag18672
ag18679
ag18686
ag18693
ag18700
ag18707
ag18714
ag18721
ag18728
ag18735
ag18742
ag18749
ag18756
ag18763
ag18770
ag18777
ag18784
ag18791
ag18798
ag18805
ag18812
ag18819
ag18826
ag18833
ag18840
ag18847
ag18854
ag18861
ag18868
ag18875
ag18882
ag18889
ag18896
ag18903
ag18910
ag18917
ag18924
ag18931
ag18938
ag18945
ag18952
ag18959
ag18966
ag18973
ag18980
ag18987
ag18994
ag19001
ag19008
ag19015
ag19022
ag19030
ag19042
ag19052
ag19062
ag19072
ag19082
ag19092
ag19099
ag19106
ag19113
ag19120
ag19127
ag19134
ag19141
ag19148
ag19155
ag19162
ag19169
ag19176
ag19183
ag19190
ag19197
ag19204
ag19211
ag19218
ag19225
ag19232
ag19239
ag19246
ag19253
ag19260
ag19267
ag19274
ag19281
ag19288
ag19295
ag19302
ag19309
ag19316
ag19323
ag19330
ag19337
ag19344
ag19351
ag19358
ag19365
ag19372
ag19379
ag19386
ag19393
ag19400
ag19407
ag19414
ag19421
ag19428
ag19435
ag19442
ag19449
ag19456
ag19463
ag19470
ag19477
ag19484
ag19491
ag19498
ag19505
ag19512
ag19519
ag19526
ag19533
ag19540
ag19547
ag19554
ag19561
ag19568
ag19575
ag19582
ag19589
ag19596
ag19603
ag19610
ag19617
ag19624
ag19631
ag19638
ag19645
ag19652
ag19659
ag19666
ag19673
ag19680
ag19687
ag19694
ag19701
ag19708
ag19715
ag19722
ag19729
ag19736
ag19743
ag19750
ag19757
ag19764
ag19771
ag19778
ag19785
ag19792
ag19799
ag19806
ag19813
ag19820
ag19827
ag19834
ag19841
ag19848
ag19855
ag19862
ag19869
ag19876
ag19883
ag19890
ag19897
ag19904
ag19911
ag19918
ag19925
ag19932
ag19939
ag19946
ag19953
ag19960
ag19967
ag19974
ag19981
ag19988
ag19995
ag20002
ag20009
ag20016
ag20023
ag20030
ag20037
ag20044
ag20051
ag20058
ag20065
ag20072
ag20079
ag20086
ag20093
ag20100
ag20107
ag20114
ag20121
ag20128
ag20135
ag20142
ag20149
ag20156
ag20163
ag20170
ag20177
ag20184
ag20191
ag20198
ag20205
ag20212
ag20219
ag20226
ag20233
ag20240
ag20247
ag20254
ag20261
ag20268
ag20275
ag20282
ag20289
ag20296
ag20303
ag20310
ag20317
ag20324
ag20331
ag20338
ag20345
ag20352
ag20359
ag20366
ag20373
ag20380
ag20387
ag20394
ag20401
ag20408
ag20415
ag20422
ag20429
ag20436
ag20443
ag20450
ag20457
ag20464
ag20471
ag20478
ag20485
ag20492
ag20499
ag20506
ag20513
ag20520
ag20527
ag20534
ag20541
ag20548
ag20555
ag20562
ag20569
ag20576
ag20583
ag20590
ag20597
ag20604
ag20611
ag20618
ag20625
ag20632
ag20639
ag20646
ag20653
ag20660
ag20667
ag20674
ag20681
ag20688
ag20695
ag20702
ag20709
ag20716
ag20723
ag20730
ag20737
ag20744
ag20751
ag20758
ag20765
ag20772
ag20779
ag20786
ag20793
ag20800
ag20807
ag20814
ag20821
ag20828
ag20835
ag20842
ag20849
ag20856
ag20863
ag20870
ag20877
ag20884
ag20891
ag20898
ag20905
ag20912
ag20919
ag20926
ag20933
ag20940
ag20947
ag20954
ag20961
ag20968
ag20975
ag20982
ag20989
ag20996
ag21003
ag21010
ag21017
ag21024
ag21031
ag21038
ag21045
ag21052
ag21059
ag21066
ag21073
ag21080
ag21087
ag21094
ag21101
ag21108
ag21115
ag21122
ag21129
ag21136
ag21143
ag21150
ag21157
ag21164
ag21171
ag21178
ag21185
ag21192
ag21199
asg1137
I0
sg21
I0
sg1138
S'com.google.common.collect.ss'
p21204
sba(iArchitecture
Cluster
p21205
(dp21206
g7
(lp21207
(iArchitecture
Entity
p21208
(dp21209
g11
(lp21210
sg13
S'com.google.common.escape.ArrayBasedCharEscaper'
p21211
sg15
(lp21212
sg17
(lp21213
sg19
(lp21214
sg21
I0
sba(iArchitecture
Entity
p21215
(dp21216
g11
(lp21217
sg13
S'com.google.common.escape.ArrayBasedEscaperMap'
p21218
sg15
(lp21219
sg17
(lp21220
sg19
(lp21221
sg21
I0
sba(iArchitecture
Entity
p21222
(dp21223
g11
(lp21224
sg13
S'com.google.common.escape.CharEscaper'
p21225
sg15
(lp21226
sg17
(lp21227
sg19
(lp21228
sg21
I0
sba(iArchitecture
Entity
p21229
(dp21230
g11
(lp21231
sg13
S'com.google.common.escape.CharEscaperBuilder'
p21232
sg15
(lp21233
sg17
(lp21234
sg19
(lp21235
sg21
I0
sba(iArchitecture
Entity
p21236
(dp21237
g11
(lp21238
sg13
S'com.google.common.escape.CharEscaperBuilder$CharArrayDecorator'
p21239
sg15
(lp21240
sg17
(lp21241
sg19
(lp21242
sg21
I0
sba(iArchitecture
Entity
p21243
(dp21244
g11
(lp21245
sg13
S'com.google.common.escape.Escaper'
p21246
sg15
(lp21247
sg17
(lp21248
sg19
(lp21249
sg21
I0
sba(iArchitecture
Entity
p21250
(dp21251
g11
(lp21252
sg13
S'com.google.common.escape.Escaper$1'
p21253
sg15
(lp21254
sg17
(lp21255
sg19
(lp21256
sg21
I0
sba(iArchitecture
Entity
p21257
(dp21258
g11
(lp21259
sg13
S'com.google.common.escape.Escapers'
p21260
sg15
(lp21261
sg17
(lp21262
sg19
(lp21263
sg21
I0
sba(iArchitecture
Entity
p21264
(dp21265
g11
(lp21266
sg13
S'com.google.common.escape.Escapers$1'
p21267
sg15
(lp21268
sg17
(lp21269
sg19
(lp21270
sg21
I0
sba(iArchitecture
Entity
p21271
(dp21272
g11
(lp21273
sg13
S'com.google.common.escape.Escapers$2'
p21274
sg15
(lp21275
sg17
(lp21276
sg19
(lp21277
sg21
I0
sba(iArchitecture
Entity
p21278
(dp21279
g11
(lp21280
sg13
S'com.google.common.escape.Escapers$Builder'
p21281
sg15
(lp21282
sg17
(lp21283
sg19
(lp21284
sg21
I0
sba(iArchitecture
Entity
p21285
(dp21286
g11
(lp21287
sg13
S'com.google.common.escape.Escapers$Builder$1'
p21288
sg15
(lp21289
sg17
(lp21290
sg19
(lp21291
sg21
I0
sba(iArchitecture
Entity
p21292
(dp21293
g11
(lp21294
sg13
S'com.google.common.escape.Platform'
p21295
sg15
(lp21296
sg17
(lp21297
sg19
(lp21298
sg21
I0
sba(iArchitecture
Entity
p21299
(dp21300
g11
(lp21301
sg13
S'com.google.common.escape.Platform$1'
p21302
sg15
(lp21303
sg17
(lp21304
sg19
(lp21305
sg21
I0
sba(iArchitecture
Entity
p21306
(dp21307
g11
(lp21308
sg13
S'com.google.common.escape.UnicodeEscaper'
p21309
sg15
(lp21310
sg17
(lp21311
sg19
(lp21312
sg21
I0
sba(iArchitecture
Entity
p21313
(dp21314
g11
(lp21315
sg13
S'com.google.common.html.HtmlEscapers'
p21316
sg15
(lp21317
sg17
(lp21318
sg19
(lp21319
sg21
I0
sba(iArchitecture
Entity
p21320
(dp21321
g11
(lp21322
sg13
S'com.google.common.xml.XmlEscapers'
p21323
sg15
(lp21324
sg17
(lp21325
sg19
(lp21326
sg21
I0
sbasg1135
(lp21327
g21211
ag21218
ag21225
ag21232
ag21239
ag21246
ag21253
ag21260
ag21267
ag21274
ag21281
ag21288
ag21295
ag21302
ag21309
ag21316
ag21323
asg1137
I0
sg21
I0
sg1138
S'com.google.common.escape.ss'
p21328
sba(iArchitecture
Cluster
p21329
(dp21330
g7
(lp21331
(iArchitecture
Entity
p21332
(dp21333
g11
(lp21334
sg13
S'com.google.common.collect.HashMultimap'
p21335
sg15
(lp21336
sg17
(lp21337
sg19
(lp21338
sg21
I0
sba(iArchitecture
Entity
p21339
(dp21340
g11
(lp21341
sg13
S'com.google.common.eventbus.AllowConcurrentEvents'
p21342
sg15
(lp21343
sg17
(lp21344
sg19
(lp21345
sg21
I0
sba(iArchitecture
Entity
p21346
(dp21347
g11
(lp21348
sg13
S'com.google.common.eventbus.AsyncEventBus'
p21349
sg15
(lp21350
sg17
(lp21351
sg19
(lp21352
sg21
I0
sba(iArchitecture
Entity
p21353
(dp21354
g11
(lp21355
sg13
S'com.google.common.eventbus.DeadEvent'
p21356
sg15
(lp21357
sg17
(lp21358
sg19
(lp21359
sg21
I0
sba(iArchitecture
Entity
p21360
(dp21361
g11
(lp21362
sg13
S'com.google.common.eventbus.Dispatcher'
p21363
sg15
(lp21364
sg17
(lp21365
sg19
(lp21366
sg21
I0
sba(iArchitecture
Entity
p21367
(dp21368
g11
(lp21369
sg13
S'com.google.common.eventbus.Dispatcher$1'
p21370
sg15
(lp21371
sg17
(lp21372
sg19
(lp21373
sg21
I0
sba(iArchitecture
Entity
p21374
(dp21375
g11
(lp21376
sg13
S'com.google.common.eventbus.Dispatcher$ImmediateDispatcher'
p21377
sg15
(lp21378
sg17
(lp21379
sg19
(lp21380
sg21
I0
sba(iArchitecture
Entity
p21381
(dp21382
g11
(lp21383
sg13
S'com.google.common.eventbus.Dispatcher$LegacyAsyncDispatcher'
p21384
sg15
(lp21385
sg17
(lp21386
sg19
(lp21387
sg21
I0
sba(iArchitecture
Entity
p21388
(dp21389
g11
(lp21390
sg13
S'com.google.common.eventbus.Dispatcher$LegacyAsyncDispatcher$EventWithSubscriber'
p21391
sg15
(lp21392
sg17
(lp21393
sg19
(lp21394
sg21
I0
sba(iArchitecture
Entity
p21395
(dp21396
g11
(lp21397
sg13
S'com.google.common.eventbus.Dispatcher$PerThreadQueuedDispatcher'
p21398
sg15
(lp21399
sg17
(lp21400
sg19
(lp21401
sg21
I0
sba(iArchitecture
Entity
p21402
(dp21403
g11
(lp21404
sg13
S'com.google.common.eventbus.Dispatcher$PerThreadQueuedDispatcher$1'
p21405
sg15
(lp21406
sg17
(lp21407
sg19
(lp21408
sg21
I0
sba(iArchitecture
Entity
p21409
(dp21410
g11
(lp21411
sg13
S'com.google.common.eventbus.Dispatcher$PerThreadQueuedDispatcher$2'
p21412
sg15
(lp21413
sg17
(lp21414
sg19
(lp21415
sg21
I0
sba(iArchitecture
Entity
p21416
(dp21417
g11
(lp21418
sg13
S'com.google.common.eventbus.Dispatcher$PerThreadQueuedDispatcher$Event'
p21419
sg15
(lp21420
sg17
(lp21421
sg19
(lp21422
sg21
I0
sba(iArchitecture
Entity
p21423
(dp21424
g11
(lp21425
sg13
S'com.google.common.eventbus.EventBus'
p21426
sg15
(lp21427
sg17
(lp21428
sg19
(lp21429
sg21
I0
sba(iArchitecture
Entity
p21430
(dp21431
g11
(lp21432
sg13
S'com.google.common.eventbus.EventBus$LoggingHandler'
p21433
sg15
(lp21434
sg17
(lp21435
sg19
(lp21436
sg21
I0
sba(iArchitecture
Entity
p21437
(dp21438
g11
(lp21439
sg13
S'com.google.common.eventbus.Subscribe'
p21440
sg15
(lp21441
sg17
(lp21442
sg19
(lp21443
sg21
I0
sba(iArchitecture
Entity
p21444
(dp21445
g11
(lp21446
sg13
S'com.google.common.eventbus.Subscriber'
p21447
sg15
(lp21448
sg17
(lp21449
sg19
(lp21450
sg21
I0
sba(iArchitecture
Entity
p21451
(dp21452
g11
(lp21453
sg13
S'com.google.common.eventbus.Subscriber$1'
p21454
sg15
(lp21455
sg17
(lp21456
sg19
(lp21457
sg21
I0
sba(iArchitecture
Entity
p21458
(dp21459
g11
(lp21460
sg13
S'com.google.common.eventbus.Subscriber$SynchronizedSubscriber'
p21461
sg15
(lp21462
sg17
(lp21463
sg19
(lp21464
sg21
I0
sba(iArchitecture
Entity
p21465
(dp21466
g11
(lp21467
sg13
S'com.google.common.eventbus.SubscriberExceptionContext'
p21468
sg15
(lp21469
sg17
(lp21470
sg19
(lp21471
sg21
I0
sba(iArchitecture
Entity
p21472
(dp21473
g11
(lp21474
sg13
S'com.google.common.eventbus.SubscriberExceptionHandler'
p21475
sg15
(lp21476
sg17
(lp21477
sg19
(lp21478
sg21
I0
sba(iArchitecture
Entity
p21479
(dp21480
g11
(lp21481
sg13
S'com.google.common.eventbus.SubscriberRegistry'
p21482
sg15
(lp21483
sg17
(lp21484
sg19
(lp21485
sg21
I0
sba(iArchitecture
Entity
p21486
(dp21487
g11
(lp21488
sg13
S'com.google.common.eventbus.SubscriberRegistry$1'
p21489
sg15
(lp21490
sg17
(lp21491
sg19
(lp21492
sg21
I0
sba(iArchitecture
Entity
p21493
(dp21494
g11
(lp21495
sg13
S'com.google.common.eventbus.SubscriberRegistry$2'
p21496
sg15
(lp21497
sg17
(lp21498
sg19
(lp21499
sg21
I0
sba(iArchitecture
Entity
p21500
(dp21501
g11
(lp21502
sg13
S'com.google.common.eventbus.SubscriberRegistry$MethodIdentifier'
p21503
sg15
(lp21504
sg17
(lp21505
sg19
(lp21506
sg21
I0
sba(iArchitecture
Entity
p21507
(dp21508
g11
(lp21509
sg13
S'com.google.common.reflect.TypeToken$ClassSet'
p21510
sg15
(lp21511
sg17
(lp21512
sg19
(lp21513
sg21
I0
sba(iArchitecture
Entity
p21514
(dp21515
g11
(lp21516
sg13
S'com.google.common.reflect.TypeToken$TypeSet'
p21517
sg15
(lp21518
sg17
(lp21519
sg19
(lp21520
sg21
I0
sbasg1135
(lp21521
g21335
ag21342
ag21349
ag21356
ag21363
ag21370
ag21377
ag21384
ag21391
ag21398
ag21405
ag21412
ag21419
ag21426
ag21433
ag21440
ag21447
ag21454
ag21461
ag21468
ag21475
ag21482
ag21489
ag21496
ag21503
ag21510
ag21517
asg1137
I0
sg21
I0
sg1138
S'com.google.common.eventbus.ss'
p21522
sba(iArchitecture
Cluster
p21523
(dp21524
g7
(lp21525
(iArchitecture
Entity
p21526
(dp21527
g11
(lp21528
sg13
S'com.google.common.collect.HashMultiset'
p21529
sg15
(lp21530
sg17
(lp21531
sg19
(lp21532
sg21
I0
sba(iArchitecture
Entity
p21533
(dp21534
g11
(lp21535
sg13
S'com.google.common.graph.AbstractDirectedNetworkConnections'
p21536
sg15
(lp21537
sg17
(lp21538
sg19
(lp21539
sg21
I0
sba(iArchitecture
Entity
p21540
(dp21541
g11
(lp21542
sg13
S'com.google.common.graph.AbstractDirectedNetworkConnections$1'
p21543
sg15
(lp21544
sg17
(lp21545
sg19
(lp21546
sg21
I0
sba(iArchitecture
Entity
p21547
(dp21548
g11
(lp21549
sg13
S'com.google.common.graph.AbstractGraph'
p21550
sg15
(lp21551
sg17
(lp21552
sg19
(lp21553
sg21
I0
sba(iArchitecture
Entity
p21554
(dp21555
g11
(lp21556
sg13
S'com.google.common.graph.AbstractGraph$1'
p21557
sg15
(lp21558
sg17
(lp21559
sg19
(lp21560
sg21
I0
sba(iArchitecture
Entity
p21561
(dp21562
g11
(lp21563
sg13
S'com.google.common.graph.AbstractGraphBuilder'
p21564
sg15
(lp21565
sg17
(lp21566
sg19
(lp21567
sg21
I0
sba(iArchitecture
Entity
p21568
(dp21569
g11
(lp21570
sg13
S'com.google.common.graph.AbstractNetwork'
p21571
sg15
(lp21572
sg17
(lp21573
sg19
(lp21574
sg21
I0
sba(iArchitecture
Entity
p21575
(dp21576
g11
(lp21577
sg13
S'com.google.common.graph.AbstractNetwork$1'
p21578
sg15
(lp21579
sg17
(lp21580
sg19
(lp21581
sg21
I0
sba(iArchitecture
Entity
p21582
(dp21583
g11
(lp21584
sg13
S'com.google.common.graph.AbstractNetwork$1$1'
p21585
sg15
(lp21586
sg17
(lp21587
sg19
(lp21588
sg21
I0
sba(iArchitecture
Entity
p21589
(dp21590
g11
(lp21591
sg13
S'com.google.common.graph.AbstractNetwork$1$1$1'
p21592
sg15
(lp21593
sg17
(lp21594
sg19
(lp21595
sg21
I0
sba(iArchitecture
Entity
p21596
(dp21597
g11
(lp21598
sg13
S'com.google.common.graph.AbstractNetwork$2'
p21599
sg15
(lp21600
sg17
(lp21601
sg19
(lp21602
sg21
I0
sba(iArchitecture
Entity
p21603
(dp21604
g11
(lp21605
sg13
S'com.google.common.graph.AbstractUndirectedNetworkConnections'
p21606
sg15
(lp21607
sg17
(lp21608
sg19
(lp21609
sg21
I0
sba(iArchitecture
Entity
p21610
(dp21611
g11
(lp21612
sg13
S'com.google.common.graph.AbstractValueGraph'
p21613
sg15
(lp21614
sg17
(lp21615
sg19
(lp21616
sg21
I0
sba(iArchitecture
Entity
p21617
(dp21618
g11
(lp21619
sg13
S'com.google.common.graph.AbstractValueGraph$1'
p21620
sg15
(lp21621
sg17
(lp21622
sg19
(lp21623
sg21
I0
sba(iArchitecture
Entity
p21624
(dp21625
g11
(lp21626
sg13
S'com.google.common.graph.ConfigurableMutableGraph'
p21627
sg15
(lp21628
sg17
(lp21629
sg19
(lp21630
sg21
I0
sba(iArchitecture
Entity
p21631
(dp21632
g11
(lp21633
sg13
S'com.google.common.graph.ConfigurableMutableNetwork'
p21634
sg15
(lp21635
sg17
(lp21636
sg19
(lp21637
sg21
I0
sba(iArchitecture
Entity
p21638
(dp21639
g11
(lp21640
sg13
S'com.google.common.graph.ConfigurableMutableValueGraph'
p21641
sg15
(lp21642
sg17
(lp21643
sg19
(lp21644
sg21
I0
sba(iArchitecture
Entity
p21645
(dp21646
g11
(lp21647
sg13
S'com.google.common.graph.ConfigurableNetwork'
p21648
sg15
(lp21649
sg17
(lp21650
sg19
(lp21651
sg21
I0
sba(iArchitecture
Entity
p21652
(dp21653
g11
(lp21654
sg13
S'com.google.common.graph.ConfigurableValueGraph'
p21655
sg15
(lp21656
sg17
(lp21657
sg19
(lp21658
sg21
I0
sba(iArchitecture
Entity
p21659
(dp21660
g11
(lp21661
sg13
S'com.google.common.graph.DirectedGraphConnections'
p21662
sg15
(lp21663
sg17
(lp21664
sg19
(lp21665
sg21
I0
sba(iArchitecture
Entity
p21666
(dp21667
g11
(lp21668
sg13
S'com.google.common.graph.DirectedGraphConnections$1'
p21669
sg15
(lp21670
sg17
(lp21671
sg19
(lp21672
sg21
I0
sba(iArchitecture
Entity
p21673
(dp21674
g11
(lp21675
sg13
S'com.google.common.graph.DirectedGraphConnections$1$1'
p21676
sg15
(lp21677
sg17
(lp21678
sg19
(lp21679
sg21
I0
sba(iArchitecture
Entity
p21680
(dp21681
g11
(lp21682
sg13
S'com.google.common.graph.DirectedGraphConnections$2'
p21683
sg15
(lp21684
sg17
(lp21685
sg19
(lp21686
sg21
I0
sba(iArchitecture
Entity
p21687
(dp21688
g11
(lp21689
sg13
S'com.google.common.graph.DirectedGraphConnections$2$1'
p21690
sg15
(lp21691
sg17
(lp21692
sg19
(lp21693
sg21
I0
sba(iArchitecture
Entity
p21694
(dp21695
g11
(lp21696
sg13
S'com.google.common.graph.DirectedGraphConnections$PredAndSucc'
p21697
sg15
(lp21698
sg17
(lp21699
sg19
(lp21700
sg21
I0
sba(iArchitecture
Entity
p21701
(dp21702
g11
(lp21703
sg13
S'com.google.common.graph.DirectedMultiNetworkConnections'
p21704
sg15
(lp21705
sg17
(lp21706
sg19
(lp21707
sg21
I0
sba(iArchitecture
Entity
p21708
(dp21709
g11
(lp21710
sg13
S'com.google.common.graph.DirectedMultiNetworkConnections$1'
p21711
sg15
(lp21712
sg17
(lp21713
sg19
(lp21714
sg21
I0
sba(iArchitecture
Entity
p21715
(dp21716
g11
(lp21717
sg13
S'com.google.common.graph.DirectedNetworkConnections'
p21718
sg15
(lp21719
sg17
(lp21720
sg19
(lp21721
sg21
I0
sba(iArchitecture
Entity
p21722
(dp21723
g11
(lp21724
sg13
S'com.google.common.graph.EdgesConnecting'
p21725
sg15
(lp21726
sg17
(lp21727
sg19
(lp21728
sg21
I0
sba(iArchitecture
Entity
p21729
(dp21730
g11
(lp21731
sg13
S'com.google.common.graph.ElementOrder'
p21732
sg15
(lp21733
sg17
(lp21734
sg19
(lp21735
sg21
I0
sba(iArchitecture
Entity
p21736
(dp21737
g11
(lp21738
sg13
S'com.google.common.graph.ElementOrder$1'
p21739
sg15
(lp21740
sg17
(lp21741
sg19
(lp21742
sg21
I0
sba(iArchitecture
Entity
p21743
(dp21744
g11
(lp21745
sg13
S'com.google.common.graph.ElementOrder$Type'
p21746
sg15
(lp21747
sg17
(lp21748
sg19
(lp21749
sg21
I0
sba(iArchitecture
Entity
p21750
(dp21751
g11
(lp21752
sg13
S'com.google.common.graph.EndpointPair'
p21753
sg15
(lp21754
sg17
(lp21755
sg19
(lp21756
sg21
I0
sba(iArchitecture
Entity
p21757
(dp21758
g11
(lp21759
sg13
S'com.google.common.graph.EndpointPair$1'
p21760
sg15
(lp21761
sg17
(lp21762
sg19
(lp21763
sg21
I0
sba(iArchitecture
Entity
p21764
(dp21765
g11
(lp21766
sg13
S'com.google.common.graph.EndpointPair$Ordered'
p21767
sg15
(lp21768
sg17
(lp21769
sg19
(lp21770
sg21
I0
sba(iArchitecture
Entity
p21771
(dp21772
g11
(lp21773
sg13
S'com.google.common.graph.EndpointPair$Unordered'
p21774
sg15
(lp21775
sg17
(lp21776
sg19
(lp21777
sg21
I0
sba(iArchitecture
Entity
p21778
(dp21779
g11
(lp21780
sg13
S'com.google.common.graph.EndpointPairIterator'
p21781
sg15
(lp21782
sg17
(lp21783
sg19
(lp21784
sg21
I0
sba(iArchitecture
Entity
p21785
(dp21786
g11
(lp21787
sg13
S'com.google.common.graph.EndpointPairIterator$1'
p21788
sg15
(lp21789
sg17
(lp21790
sg19
(lp21791
sg21
I0
sba(iArchitecture
Entity
p21792
(dp21793
g11
(lp21794
sg13
S'com.google.common.graph.EndpointPairIterator$Directed'
p21795
sg15
(lp21796
sg17
(lp21797
sg19
(lp21798
sg21
I0
sba(iArchitecture
Entity
p21799
(dp21800
g11
(lp21801
sg13
S'com.google.common.graph.EndpointPairIterator$Undirected'
p21802
sg15
(lp21803
sg17
(lp21804
sg19
(lp21805
sg21
I0
sba(iArchitecture
Entity
p21806
(dp21807
g11
(lp21808
sg13
S'com.google.common.graph.ForwardingGraph'
p21809
sg15
(lp21810
sg17
(lp21811
sg19
(lp21812
sg21
I0
sba(iArchitecture
Entity
p21813
(dp21814
g11
(lp21815
sg13
S'com.google.common.graph.Graph'
p21816
sg15
(lp21817
sg17
(lp21818
sg19
(lp21819
sg21
I0
sba(iArchitecture
Entity
p21820
(dp21821
g11
(lp21822
sg13
S'com.google.common.graph.GraphBuilder'
p21823
sg15
(lp21824
sg17
(lp21825
sg19
(lp21826
sg21
I0
sba(iArchitecture
Entity
p21827
(dp21828
g11
(lp21829
sg13
S'com.google.common.graph.GraphConnections'
p21830
sg15
(lp21831
sg17
(lp21832
sg19
(lp21833
sg21
I0
sba(iArchitecture
Entity
p21834
(dp21835
g11
(lp21836
sg13
S'com.google.common.graph.GraphConstants'
p21837
sg15
(lp21838
sg17
(lp21839
sg19
(lp21840
sg21
I0
sba(iArchitecture
Entity
p21841
(dp21842
g11
(lp21843
sg13
S'com.google.common.graph.GraphConstants$Presence'
p21844
sg15
(lp21845
sg17
(lp21846
sg19
(lp21847
sg21
I0
sba(iArchitecture
Entity
p21848
(dp21849
g11
(lp21850
sg13
S'com.google.common.graph.Graphs'
p21851
sg15
(lp21852
sg17
(lp21853
sg19
(lp21854
sg21
I0
sba(iArchitecture
Entity
p21855
(dp21856
g11
(lp21857
sg13
S'com.google.common.graph.Graphs$NodeVisitState'
p21858
sg15
(lp21859
sg17
(lp21860
sg19
(lp21861
sg21
I0
sba(iArchitecture
Entity
p21862
(dp21863
g11
(lp21864
sg13
S'com.google.common.graph.Graphs$TransposedGraph'
p21865
sg15
(lp21866
sg17
(lp21867
sg19
(lp21868
sg21
I0
sba(iArchitecture
Entity
p21869
(dp21870
g11
(lp21871
sg13
S'com.google.common.graph.Graphs$TransposedNetwork'
p21872
sg15
(lp21873
sg17
(lp21874
sg19
(lp21875
sg21
I0
sba(iArchitecture
Entity
p21876
(dp21877
g11
(lp21878
sg13
S'com.google.common.graph.Graphs$TransposedValueGraph'
p21879
sg15
(lp21880
sg17
(lp21881
sg19
(lp21882
sg21
I0
sba(iArchitecture
Entity
p21883
(dp21884
g11
(lp21885
sg13
S'com.google.common.graph.ImmutableGraph'
p21886
sg15
(lp21887
sg17
(lp21888
sg19
(lp21889
sg21
I0
sba(iArchitecture
Entity
p21890
(dp21891
g11
(lp21892
sg13
S'com.google.common.graph.ImmutableGraph$ValueBackedImpl'
p21893
sg15
(lp21894
sg17
(lp21895
sg19
(lp21896
sg21
I0
sba(iArchitecture
Entity
p21897
(dp21898
g11
(lp21899
sg13
S'com.google.common.graph.ImmutableNetwork'
p21900
sg15
(lp21901
sg17
(lp21902
sg19
(lp21903
sg21
I0
sba(iArchitecture
Entity
p21904
(dp21905
g11
(lp21906
sg13
S'com.google.common.graph.ImmutableNetwork$1'
p21907
sg15
(lp21908
sg17
(lp21909
sg19
(lp21910
sg21
I0
sba(iArchitecture
Entity
p21911
(dp21912
g11
(lp21913
sg13
S'com.google.common.graph.ImmutableNetwork$2'
p21914
sg15
(lp21915
sg17
(lp21916
sg19
(lp21917
sg21
I0
sba(iArchitecture
Entity
p21918
(dp21919
g11
(lp21920
sg13
S'com.google.common.graph.ImmutableNetwork$3'
p21921
sg15
(lp21922
sg17
(lp21923
sg19
(lp21924
sg21
I0
sba(iArchitecture
Entity
p21925
(dp21926
g11
(lp21927
sg13
S'com.google.common.graph.ImmutableNetwork$4'
p21928
sg15
(lp21929
sg17
(lp21930
sg19
(lp21931
sg21
I0
sba(iArchitecture
Entity
p21932
(dp21933
g11
(lp21934
sg13
S'com.google.common.graph.ImmutableValueGraph'
p21935
sg15
(lp21936
sg17
(lp21937
sg19
(lp21938
sg21
I0
sba(iArchitecture
Entity
p21939
(dp21940
g11
(lp21941
sg13
S'com.google.common.graph.ImmutableValueGraph$1'
p21942
sg15
(lp21943
sg17
(lp21944
sg19
(lp21945
sg21
I0
sba(iArchitecture
Entity
p21946
(dp21947
g11
(lp21948
sg13
S'com.google.common.graph.MapIteratorCache'
p21949
sg15
(lp21950
sg17
(lp21951
sg19
(lp21952
sg21
I0
sba(iArchitecture
Entity
p21953
(dp21954
g11
(lp21955
sg13
S'com.google.common.graph.MapIteratorCache$1'
p21956
sg15
(lp21957
sg17
(lp21958
sg19
(lp21959
sg21
I0
sba(iArchitecture
Entity
p21960
(dp21961
g11
(lp21962
sg13
S'com.google.common.graph.MapIteratorCache$1$1'
p21963
sg15
(lp21964
sg17
(lp21965
sg19
(lp21966
sg21
I0
sba(iArchitecture
Entity
p21967
(dp21968
g11
(lp21969
sg13
S'com.google.common.graph.MapRetrievalCache'
p21970
sg15
(lp21971
sg17
(lp21972
sg19
(lp21973
sg21
I0
sba(iArchitecture
Entity
p21974
(dp21975
g11
(lp21976
sg13
S'com.google.common.graph.MapRetrievalCache$CacheEntry'
p21977
sg15
(lp21978
sg17
(lp21979
sg19
(lp21980
sg21
I0
sba(iArchitecture
Entity
p21981
(dp21982
g11
(lp21983
sg13
S'com.google.common.graph.MultiEdgesConnecting'
p21984
sg15
(lp21985
sg17
(lp21986
sg19
(lp21987
sg21
I0
sba(iArchitecture
Entity
p21988
(dp21989
g11
(lp21990
sg13
S'com.google.common.graph.MultiEdgesConnecting$1'
p21991
sg15
(lp21992
sg17
(lp21993
sg19
(lp21994
sg21
I0
sba(iArchitecture
Entity
p21995
(dp21996
g11
(lp21997
sg13
S'com.google.common.graph.MutableGraph'
p21998
sg15
(lp21999
sg17
(lp22000
sg19
(lp22001
sg21
I0
sba(iArchitecture
Entity
p22002
(dp22003
g11
(lp22004
sg13
S'com.google.common.graph.MutableNetwork'
p22005
sg15
(lp22006
sg17
(lp22007
sg19
(lp22008
sg21
I0
sba(iArchitecture
Entity
p22009
(dp22010
g11
(lp22011
sg13
S'com.google.common.graph.MutableValueGraph'
p22012
sg15
(lp22013
sg17
(lp22014
sg19
(lp22015
sg21
I0
sba(iArchitecture
Entity
p22016
(dp22017
g11
(lp22018
sg13
S'com.google.common.graph.Network'
p22019
sg15
(lp22020
sg17
(lp22021
sg19
(lp22022
sg21
I0
sba(iArchitecture
Entity
p22023
(dp22024
g11
(lp22025
sg13
S'com.google.common.graph.NetworkBuilder'
p22026
sg15
(lp22027
sg17
(lp22028
sg19
(lp22029
sg21
I0
sba(iArchitecture
Entity
p22030
(dp22031
g11
(lp22032
sg13
S'com.google.common.graph.NetworkConnections'
p22033
sg15
(lp22034
sg17
(lp22035
sg19
(lp22036
sg21
I0
sba(iArchitecture
Entity
p22037
(dp22038
g11
(lp22039
sg13
S'com.google.common.graph.UndirectedGraphConnections'
p22040
sg15
(lp22041
sg17
(lp22042
sg19
(lp22043
sg21
I0
sba(iArchitecture
Entity
p22044
(dp22045
g11
(lp22046
sg13
S'com.google.common.graph.UndirectedMultiNetworkConnections'
p22047
sg15
(lp22048
sg17
(lp22049
sg19
(lp22050
sg21
I0
sba(iArchitecture
Entity
p22051
(dp22052
g11
(lp22053
sg13
S'com.google.common.graph.UndirectedMultiNetworkConnections$1'
p22054
sg15
(lp22055
sg17
(lp22056
sg19
(lp22057
sg21
I0
sba(iArchitecture
Entity
p22058
(dp22059
g11
(lp22060
sg13
S'com.google.common.graph.UndirectedNetworkConnections'
p22061
sg15
(lp22062
sg17
(lp22063
sg19
(lp22064
sg21
I0
sba(iArchitecture
Entity
p22065
(dp22066
g11
(lp22067
sg13
S'com.google.common.graph.ValueGraph'
p22068
sg15
(lp22069
sg17
(lp22070
sg19
(lp22071
sg21
I0
sba(iArchitecture
Entity
p22072
(dp22073
g11
(lp22074
sg13
S'com.google.common.graph.ValueGraphBuilder'
p22075
sg15
(lp22076
sg17
(lp22077
sg19
(lp22078
sg21
I0
sbasg1135
(lp22079
g21529
ag21536
ag21543
ag21550
ag21557
ag21564
ag21571
ag21578
ag21585
ag21592
ag21599
ag21606
ag21613
ag21620
ag21627
ag21634
ag21641
ag21648
ag21655
ag21662
ag21669
ag21676
ag21683
ag21690
ag21697
ag21704
ag21711
ag21718
ag21725
ag21732
ag21739
ag21746
ag21753
ag21760
ag21767
ag21774
ag21781
ag21788
ag21795
ag21802
ag21809
ag21816
ag21823
ag21830
ag21837
ag21844
ag21851
ag21858
ag21865
ag21872
ag21879
ag21886
ag21893
ag21900
ag21907
ag21914
ag21921
ag21928
ag21935
ag21942
ag21949
ag21956
ag21963
ag21970
ag21977
ag21984
ag21991
ag21998
ag22005
ag22012
ag22019
ag22026
ag22033
ag22040
ag22047
ag22054
ag22061
ag22068
ag22075
asg1137
I0
sg21
I0
sg1138
S'com.google.common.graph.ss'
p22080
sba(iArchitecture
Cluster
p22081
(dp22082
g7
(lp22083
(iArchitecture
Entity
p22084
(dp22085
g11
(lp22086
sg13
S'com.google.common.hash.AbstractByteHasher'
p22087
sg15
(lp22088
sg17
(lp22089
sg19
(lp22090
sg21
I0
sba(iArchitecture
Entity
p22091
(dp22092
g11
(lp22093
sg13
S'com.google.common.hash.AbstractCompositeHashFunction'
p22094
sg15
(lp22095
sg17
(lp22096
sg19
(lp22097
sg21
I0
sba(iArchitecture
Entity
p22098
(dp22099
g11
(lp22100
sg13
S'com.google.common.hash.AbstractCompositeHashFunction$1'
p22101
sg15
(lp22102
sg17
(lp22103
sg19
(lp22104
sg21
I0
sba(iArchitecture
Entity
p22105
(dp22106
g11
(lp22107
sg13
S'com.google.common.hash.AbstractHasher'
p22108
sg15
(lp22109
sg17
(lp22110
sg19
(lp22111
sg21
I0
sba(iArchitecture
Entity
p22112
(dp22113
g11
(lp22114
sg13
S'com.google.common.hash.AbstractNonStreamingHashFunction'
p22115
sg15
(lp22116
sg17
(lp22117
sg19
(lp22118
sg21
I0
sba(iArchitecture
Entity
p22119
(dp22120
g11
(lp22121
sg13
S'com.google.common.hash.AbstractNonStreamingHashFunction$BufferingHasher'
p22122
sg15
(lp22123
sg17
(lp22124
sg19
(lp22125
sg21
I0
sba(iArchitecture
Entity
p22126
(dp22127
g11
(lp22128
sg13
S'com.google.common.hash.AbstractNonStreamingHashFunction$ExposedByteArrayOutputStream'
p22129
sg15
(lp22130
sg17
(lp22131
sg19
(lp22132
sg21
I0
sba(iArchitecture
Entity
p22133
(dp22134
g11
(lp22135
sg13
S'com.google.common.hash.AbstractStreamingHashFunction'
p22136
sg15
(lp22137
sg17
(lp22138
sg19
(lp22139
sg21
I0
sba(iArchitecture
Entity
p22140
(dp22141
g11
(lp22142
sg13
S'com.google.common.hash.AbstractStreamingHashFunction$AbstractStreamingHasher'
p22143
sg15
(lp22144
sg17
(lp22145
sg19
(lp22146
sg21
I0
sba(iArchitecture
Entity
p22147
(dp22148
g11
(lp22149
sg13
S'com.google.common.hash.BloomFilter'
p22150
sg15
(lp22151
sg17
(lp22152
sg19
(lp22153
sg21
I0
sba(iArchitecture
Entity
p22154
(dp22155
g11
(lp22156
sg13
S'com.google.common.hash.BloomFilter$1'
p22157
sg15
(lp22158
sg17
(lp22159
sg19
(lp22160
sg21
I0
sba(iArchitecture
Entity
p22161
(dp22162
g11
(lp22163
sg13
S'com.google.common.hash.BloomFilter$SerialForm'
p22164
sg15
(lp22165
sg17
(lp22166
sg19
(lp22167
sg21
I0
sba(iArchitecture
Entity
p22168
(dp22169
g11
(lp22170
sg13
S'com.google.common.hash.BloomFilter$Strategy'
p22171
sg15
(lp22172
sg17
(lp22173
sg19
(lp22174
sg21
I0
sba(iArchitecture
Entity
p22175
(dp22176
g11
(lp22177
sg13
S'com.google.common.hash.BloomFilterStrategies'
p22178
sg15
(lp22179
sg17
(lp22180
sg19
(lp22181
sg21
I0
sba(iArchitecture
Entity
p22182
(dp22183
g11
(lp22184
sg13
S'com.google.common.hash.BloomFilterStrategies$1'
p22185
sg15
(lp22186
sg17
(lp22187
sg19
(lp22188
sg21
I0
sba(iArchitecture
Entity
p22189
(dp22190
g11
(lp22191
sg13
S'com.google.common.hash.BloomFilterStrategies$2'
p22192
sg15
(lp22193
sg17
(lp22194
sg19
(lp22195
sg21
I0
sba(iArchitecture
Entity
p22196
(dp22197
g11
(lp22198
sg13
S'com.google.common.hash.BloomFilterStrategies$BitArray'
p22199
sg15
(lp22200
sg17
(lp22201
sg19
(lp22202
sg21
I0
sba(iArchitecture
Entity
p22203
(dp22204
g11
(lp22205
sg13
S'com.google.common.hash.ChecksumHashFunction'
p22206
sg15
(lp22207
sg17
(lp22208
sg19
(lp22209
sg21
I0
sba(iArchitecture
Entity
p22210
(dp22211
g11
(lp22212
sg13
S'com.google.common.hash.ChecksumHashFunction$1'
p22213
sg15
(lp22214
sg17
(lp22215
sg19
(lp22216
sg21
I0
sba(iArchitecture
Entity
p22217
(dp22218
g11
(lp22219
sg13
S'com.google.common.hash.ChecksumHashFunction$ChecksumHasher'
p22220
sg15
(lp22221
sg17
(lp22222
sg19
(lp22223
sg21
I0
sba(iArchitecture
Entity
p22224
(dp22225
g11
(lp22226
sg13
S'com.google.common.hash.Crc32cHashFunction'
p22227
sg15
(lp22228
sg17
(lp22229
sg19
(lp22230
sg21
I0
sba(iArchitecture
Entity
p22231
(dp22232
g11
(lp22233
sg13
S'com.google.common.hash.Crc32cHashFunction$Crc32cHasher'
p22234
sg15
(lp22235
sg17
(lp22236
sg19
(lp22237
sg21
I0
sba(iArchitecture
Entity
p22238
(dp22239
g11
(lp22240
sg13
S'com.google.common.hash.FarmHashFingerprint64'
p22241
sg15
(lp22242
sg17
(lp22243
sg19
(lp22244
sg21
I0
sba(iArchitecture
Entity
p22245
(dp22246
g11
(lp22247
sg13
S'com.google.common.hash.Funnel'
p22248
sg15
(lp22249
sg17
(lp22250
sg19
(lp22251
sg21
I0
sba(iArchitecture
Entity
p22252
(dp22253
g11
(lp22254
sg13
S'com.google.common.hash.Funnels'
p22255
sg15
(lp22256
sg17
(lp22257
sg19
(lp22258
sg21
I0
sba(iArchitecture
Entity
p22259
(dp22260
g11
(lp22261
sg13
S'com.google.common.hash.Funnels$ByteArrayFunnel'
p22262
sg15
(lp22263
sg17
(lp22264
sg19
(lp22265
sg21
I0
sba(iArchitecture
Entity
p22266
(dp22267
g11
(lp22268
sg13
S'com.google.common.hash.Funnels$IntegerFunnel'
p22269
sg15
(lp22270
sg17
(lp22271
sg19
(lp22272
sg21
I0
sba(iArchitecture
Entity
p22273
(dp22274
g11
(lp22275
sg13
S'com.google.common.hash.Funnels$LongFunnel'
p22276
sg15
(lp22277
sg17
(lp22278
sg19
(lp22279
sg21
I0
sba(iArchitecture
Entity
p22280
(dp22281
g11
(lp22282
sg13
S'com.google.common.hash.Funnels$SequentialFunnel'
p22283
sg15
(lp22284
sg17
(lp22285
sg19
(lp22286
sg21
I0
sba(iArchitecture
Entity
p22287
(dp22288
g11
(lp22289
sg13
S'com.google.common.hash.Funnels$SinkAsStream'
p22290
sg15
(lp22291
sg17
(lp22292
sg19
(lp22293
sg21
I0
sba(iArchitecture
Entity
p22294
(dp22295
g11
(lp22296
sg13
S'com.google.common.hash.Funnels$StringCharsetFunnel'
p22297
sg15
(lp22298
sg17
(lp22299
sg19
(lp22300
sg21
I0
sba(iArchitecture
Entity
p22301
(dp22302
g11
(lp22303
sg13
S'com.google.common.hash.Funnels$StringCharsetFunnel$SerializedForm'
p22304
sg15
(lp22305
sg17
(lp22306
sg19
(lp22307
sg21
I0
sba(iArchitecture
Entity
p22308
(dp22309
g11
(lp22310
sg13
S'com.google.common.hash.Funnels$UnencodedCharsFunnel'
p22311
sg15
(lp22312
sg17
(lp22313
sg19
(lp22314
sg21
I0
sba(iArchitecture
Entity
p22315
(dp22316
g11
(lp22317
sg13
S'com.google.common.hash.HashCode'
p22318
sg15
(lp22319
sg17
(lp22320
sg19
(lp22321
sg21
I0
sba(iArchitecture
Entity
p22322
(dp22323
g11
(lp22324
sg13
S'com.google.common.hash.HashCode$BytesHashCode'
p22325
sg15
(lp22326
sg17
(lp22327
sg19
(lp22328
sg21
I0
sba(iArchitecture
Entity
p22329
(dp22330
g11
(lp22331
sg13
S'com.google.common.hash.HashCode$IntHashCode'
p22332
sg15
(lp22333
sg17
(lp22334
sg19
(lp22335
sg21
I0
sba(iArchitecture
Entity
p22336
(dp22337
g11
(lp22338
sg13
S'com.google.common.hash.HashCode$LongHashCode'
p22339
sg15
(lp22340
sg17
(lp22341
sg19
(lp22342
sg21
I0
sba(iArchitecture
Entity
p22343
(dp22344
g11
(lp22345
sg13
S'com.google.common.hash.HashFunction'
p22346
sg15
(lp22347
sg17
(lp22348
sg19
(lp22349
sg21
I0
sba(iArchitecture
Entity
p22350
(dp22351
g11
(lp22352
sg13
S'com.google.common.hash.Hasher'
p22353
sg15
(lp22354
sg17
(lp22355
sg19
(lp22356
sg21
I0
sba(iArchitecture
Entity
p22357
(dp22358
g11
(lp22359
sg13
S'com.google.common.hash.Hashing'
p22360
sg15
(lp22361
sg17
(lp22362
sg19
(lp22363
sg21
I0
sba(iArchitecture
Entity
p22364
(dp22365
g11
(lp22366
sg13
S'com.google.common.hash.Hashing$1'
p22367
sg15
(lp22368
sg17
(lp22369
sg19
(lp22370
sg21
I0
sba(iArchitecture
Entity
p22371
(dp22372
g11
(lp22373
sg13
S'com.google.common.hash.Hashing$Adler32Holder'
p22374
sg15
(lp22375
sg17
(lp22376
sg19
(lp22377
sg21
I0
sba(iArchitecture
Entity
p22378
(dp22379
g11
(lp22380
sg13
S'com.google.common.hash.Hashing$ChecksumType'
p22381
sg15
(lp22382
sg17
(lp22383
sg19
(lp22384
sg21
I0
sba(iArchitecture
Entity
p22385
(dp22386
g11
(lp22387
sg13
S'com.google.common.hash.Hashing$ChecksumType$1'
p22388
sg15
(lp22389
sg17
(lp22390
sg19
(lp22391
sg21
I0
sba(iArchitecture
Entity
p22392
(dp22393
g11
(lp22394
sg13
S'com.google.common.hash.Hashing$ChecksumType$2'
p22395
sg15
(lp22396
sg17
(lp22397
sg19
(lp22398
sg21
I0
sba(iArchitecture
Entity
p22399
(dp22400
g11
(lp22401
sg13
S'com.google.common.hash.Hashing$ConcatenatedHashFunction'
p22402
sg15
(lp22403
sg17
(lp22404
sg19
(lp22405
sg21
I0
sba(iArchitecture
Entity
p22406
(dp22407
g11
(lp22408
sg13
S'com.google.common.hash.Hashing$Crc32Holder'
p22409
sg15
(lp22410
sg17
(lp22411
sg19
(lp22412
sg21
I0
sba(iArchitecture
Entity
p22413
(dp22414
g11
(lp22415
sg13
S'com.google.common.hash.Hashing$Crc32cHolder'
p22416
sg15
(lp22417
sg17
(lp22418
sg19
(lp22419
sg21
I0
sba(iArchitecture
Entity
p22420
(dp22421
g11
(lp22422
sg13
S'com.google.common.hash.Hashing$FarmHashFingerprint64Holder'
p22423
sg15
(lp22424
sg17
(lp22425
sg19
(lp22426
sg21
I0
sba(iArchitecture
Entity
p22427
(dp22428
g11
(lp22429
sg13
S'com.google.common.hash.Hashing$LinearCongruentialGenerator'
p22430
sg15
(lp22431
sg17
(lp22432
sg19
(lp22433
sg21
I0
sba(iArchitecture
Entity
p22434
(dp22435
g11
(lp22436
sg13
S'com.google.common.hash.Hashing$Md5Holder'
p22437
sg15
(lp22438
sg17
(lp22439
sg19
(lp22440
sg21
I0
sba(iArchitecture
Entity
p22441
(dp22442
g11
(lp22443
sg13
S'com.google.common.hash.Hashing$Murmur3_128Holder'
p22444
sg15
(lp22445
sg17
(lp22446
sg19
(lp22447
sg21
I0
sba(iArchitecture
Entity
p22448
(dp22449
g11
(lp22450
sg13
S'com.google.common.hash.Hashing$Murmur3_32Holder'
p22451
sg15
(lp22452
sg17
(lp22453
sg19
(lp22454
sg21
I0
sba(iArchitecture
Entity
p22455
(dp22456
g11
(lp22457
sg13
S'com.google.common.hash.Hashing$Sha1Holder'
p22458
sg15
(lp22459
sg17
(lp22460
sg19
(lp22461
sg21
I0
sba(iArchitecture
Entity
p22462
(dp22463
g11
(lp22464
sg13
S'com.google.common.hash.Hashing$Sha256Holder'
p22465
sg15
(lp22466
sg17
(lp22467
sg19
(lp22468
sg21
I0
sba(iArchitecture
Entity
p22469
(dp22470
g11
(lp22471
sg13
S'com.google.common.hash.Hashing$Sha384Holder'
p22472
sg15
(lp22473
sg17
(lp22474
sg19
(lp22475
sg21
I0
sba(iArchitecture
Entity
p22476
(dp22477
g11
(lp22478
sg13
S'com.google.common.hash.Hashing$Sha512Holder'
p22479
sg15
(lp22480
sg17
(lp22481
sg19
(lp22482
sg21
I0
sba(iArchitecture
Entity
p22483
(dp22484
g11
(lp22485
sg13
S'com.google.common.hash.Hashing$SipHash24Holder'
p22486
sg15
(lp22487
sg17
(lp22488
sg19
(lp22489
sg21
I0
sba(iArchitecture
Entity
p22490
(dp22491
g11
(lp22492
sg13
S'com.google.common.hash.LittleEndianByteArray'
p22493
sg15
(lp22494
sg17
(lp22495
sg19
(lp22496
sg21
I0
sba(iArchitecture
Entity
p22497
(dp22498
g11
(lp22499
sg13
S'com.google.common.hash.LittleEndianByteArray$1'
p22500
sg15
(lp22501
sg17
(lp22502
sg19
(lp22503
sg21
I0
sba(iArchitecture
Entity
p22504
(dp22505
g11
(lp22506
sg13
S'com.google.common.hash.LittleEndianByteArray$JavaLittleEndianBytes'
p22507
sg15
(lp22508
sg17
(lp22509
sg19
(lp22510
sg21
I0
sba(iArchitecture
Entity
p22511
(dp22512
g11
(lp22513
sg13
S'com.google.common.hash.LittleEndianByteArray$JavaLittleEndianBytes$1'
p22514
sg15
(lp22515
sg17
(lp22516
sg19
(lp22517
sg21
I0
sba(iArchitecture
Entity
p22518
(dp22519
g11
(lp22520
sg13
S'com.google.common.hash.LittleEndianByteArray$LittleEndianBytes'
p22521
sg15
(lp22522
sg17
(lp22523
sg19
(lp22524
sg21
I0
sba(iArchitecture
Entity
p22525
(dp22526
g11
(lp22527
sg13
S'com.google.common.hash.LittleEndianByteArray$UnsafeByteArray'
p22528
sg15
(lp22529
sg17
(lp22530
sg19
(lp22531
sg21
I0
sba(iArchitecture
Entity
p22532
(dp22533
g11
(lp22534
sg13
S'com.google.common.hash.LittleEndianByteArray$UnsafeByteArray$1'
p22535
sg15
(lp22536
sg17
(lp22537
sg19
(lp22538
sg21
I0
sba(iArchitecture
Entity
p22539
(dp22540
g11
(lp22541
sg13
S'com.google.common.hash.LittleEndianByteArray$UnsafeByteArray$2'
p22542
sg15
(lp22543
sg17
(lp22544
sg19
(lp22545
sg21
I0
sba(iArchitecture
Entity
p22546
(dp22547
g11
(lp22548
sg13
S'com.google.common.hash.LittleEndianByteArray$UnsafeByteArray$3'
p22549
sg15
(lp22550
sg17
(lp22551
sg19
(lp22552
sg21
I0
sba(iArchitecture
Entity
p22553
(dp22554
g11
(lp22555
sg13
S'com.google.common.hash.MacHashFunction'
p22556
sg15
(lp22557
sg17
(lp22558
sg19
(lp22559
sg21
I0
sba(iArchitecture
Entity
p22560
(dp22561
g11
(lp22562
sg13
S'com.google.common.hash.MacHashFunction$1'
p22563
sg15
(lp22564
sg17
(lp22565
sg19
(lp22566
sg21
I0
sba(iArchitecture
Entity
p22567
(dp22568
g11
(lp22569
sg13
S'com.google.common.hash.MacHashFunction$MacHasher'
p22570
sg15
(lp22571
sg17
(lp22572
sg19
(lp22573
sg21
I0
sba(iArchitecture
Entity
p22574
(dp22575
g11
(lp22576
sg13
S'com.google.common.hash.MessageDigestHashFunction'
p22577
sg15
(lp22578
sg17
(lp22579
sg19
(lp22580
sg21
I0
sba(iArchitecture
Entity
p22581
(dp22582
g11
(lp22583
sg13
S'com.google.common.hash.MessageDigestHashFunction$1'
p22584
sg15
(lp22585
sg17
(lp22586
sg19
(lp22587
sg21
I0
sba(iArchitecture
Entity
p22588
(dp22589
g11
(lp22590
sg13
S'com.google.common.hash.MessageDigestHashFunction$MessageDigestHasher'
p22591
sg15
(lp22592
sg17
(lp22593
sg19
(lp22594
sg21
I0
sba(iArchitecture
Entity
p22595
(dp22596
g11
(lp22597
sg13
S'com.google.common.hash.MessageDigestHashFunction$SerializedForm'
p22598
sg15
(lp22599
sg17
(lp22600
sg19
(lp22601
sg21
I0
sba(iArchitecture
Entity
p22602
(dp22603
g11
(lp22604
sg13
S'com.google.common.hash.Murmur3_128HashFunction'
p22605
sg15
(lp22606
sg17
(lp22607
sg19
(lp22608
sg21
I0
sba(iArchitecture
Entity
p22609
(dp22610
g11
(lp22611
sg13
S'com.google.common.hash.Murmur3_128HashFunction$Murmur3_128Hasher'
p22612
sg15
(lp22613
sg17
(lp22614
sg19
(lp22615
sg21
I0
sba(iArchitecture
Entity
p22616
(dp22617
g11
(lp22618
sg13
S'com.google.common.hash.Murmur3_32HashFunction'
p22619
sg15
(lp22620
sg17
(lp22621
sg19
(lp22622
sg21
I0
sba(iArchitecture
Entity
p22623
(dp22624
g11
(lp22625
sg13
S'com.google.common.hash.Murmur3_32HashFunction$Murmur3_32Hasher'
p22626
sg15
(lp22627
sg17
(lp22628
sg19
(lp22629
sg21
I0
sba(iArchitecture
Entity
p22630
(dp22631
g11
(lp22632
sg13
S'com.google.common.hash.PrimitiveSink'
p22633
sg15
(lp22634
sg17
(lp22635
sg19
(lp22636
sg21
I0
sba(iArchitecture
Entity
p22637
(dp22638
g11
(lp22639
sg13
S'com.google.common.hash.SipHashFunction'
p22640
sg15
(lp22641
sg17
(lp22642
sg19
(lp22643
sg21
I0
sba(iArchitecture
Entity
p22644
(dp22645
g11
(lp22646
sg13
S'com.google.common.hash.SipHashFunction$SipHasher'
p22647
sg15
(lp22648
sg17
(lp22649
sg19
(lp22650
sg21
I0
sba(iArchitecture
Entity
p22651
(dp22652
g11
(lp22653
sg13
S'sun.misc.Unsafe'
p22654
sg15
(lp22655
sg17
(lp22656
sg19
(lp22657
sg21
I0
sbasg1135
(lp22658
g22087
ag22094
ag22101
ag22108
ag22115
ag22122
ag22129
ag22136
ag22143
ag22150
ag22157
ag22164
ag22171
ag22178
ag22185
ag22192
ag22199
ag22206
ag22213
ag22220
ag22227
ag22234
ag22241
ag22248
ag22255
ag22262
ag22269
ag22276
ag22283
ag22290
ag22297
ag22304
ag22311
ag22318
ag22325
ag22332
ag22339
ag22346
ag22353
ag22360
ag22367
ag22374
ag22381
ag22388
ag22395
ag22402
ag22409
ag22416
ag22423
ag22430
ag22437
ag22444
ag22451
ag22458
ag22465
ag22472
ag22479
ag22486
ag22493
ag22500
ag22507
ag22514
ag22521
ag22528
ag22535
ag22542
ag22549
ag22556
ag22563
ag22570
ag22577
ag22584
ag22591
ag22598
ag22605
ag22612
ag22619
ag22626
ag22633
ag22640
ag22647
ag22654
asg1137
I0
sg21
I0
sg1138
S'com.google.common.hash.ss'
p22659
sba(iArchitecture
Cluster
p22660
(dp22661
g7
(lp22662
(iArchitecture
Entity
p22663
(dp22664
g11
(lp22665
sg13
S'com.google.common.io.AppendableWriter'
p22666
sg15
(lp22667
sg17
(lp22668
sg19
(lp22669
sg21
I0
sba(iArchitecture
Entity
p22670
(dp22671
g11
(lp22672
sg13
S'com.google.common.io.BaseEncoding'
p22673
sg15
(lp22674
sg17
(lp22675
sg19
(lp22676
sg21
I0
sba(iArchitecture
Entity
p22677
(dp22678
g11
(lp22679
sg13
S'com.google.common.io.BaseEncoding$1'
p22680
sg15
(lp22681
sg17
(lp22682
sg19
(lp22683
sg21
I0
sba(iArchitecture
Entity
p22684
(dp22685
g11
(lp22686
sg13
S'com.google.common.io.BaseEncoding$2'
p22687
sg15
(lp22688
sg17
(lp22689
sg19
(lp22690
sg21
I0
sba(iArchitecture
Entity
p22691
(dp22692
g11
(lp22693
sg13
S'com.google.common.io.BaseEncoding$3'
p22694
sg15
(lp22695
sg17
(lp22696
sg19
(lp22697
sg21
I0
sba(iArchitecture
Entity
p22698
(dp22699
g11
(lp22700
sg13
S'com.google.common.io.BaseEncoding$4'
p22701
sg15
(lp22702
sg17
(lp22703
sg19
(lp22704
sg21
I0
sba(iArchitecture
Entity
p22705
(dp22706
g11
(lp22707
sg13
S'com.google.common.io.BaseEncoding$5'
p22708
sg15
(lp22709
sg17
(lp22710
sg19
(lp22711
sg21
I0
sba(iArchitecture
Entity
p22712
(dp22713
g11
(lp22714
sg13
S'com.google.common.io.BaseEncoding$Alphabet'
p22715
sg15
(lp22716
sg17
(lp22717
sg19
(lp22718
sg21
I0
sba(iArchitecture
Entity
p22719
(dp22720
g11
(lp22721
sg13
S'com.google.common.io.BaseEncoding$Base16Encoding'
p22722
sg15
(lp22723
sg17
(lp22724
sg19
(lp22725
sg21
I0
sba(iArchitecture
Entity
p22726
(dp22727
g11
(lp22728
sg13
S'com.google.common.io.BaseEncoding$Base64Encoding'
p22729
sg15
(lp22730
sg17
(lp22731
sg19
(lp22732
sg21
I0
sba(iArchitecture
Entity
p22733
(dp22734
g11
(lp22735
sg13
S'com.google.common.io.BaseEncoding$DecodingException'
p22736
sg15
(lp22737
sg17
(lp22738
sg19
(lp22739
sg21
I0
sba(iArchitecture
Entity
p22740
(dp22741
g11
(lp22742
sg13
S'com.google.common.io.BaseEncoding$SeparatedBaseEncoding'
p22743
sg15
(lp22744
sg17
(lp22745
sg19
(lp22746
sg21
I0
sba(iArchitecture
Entity
p22747
(dp22748
g11
(lp22749
sg13
S'com.google.common.io.BaseEncoding$StandardBaseEncoding'
p22750
sg15
(lp22751
sg17
(lp22752
sg19
(lp22753
sg21
I0
sba(iArchitecture
Entity
p22754
(dp22755
g11
(lp22756
sg13
S'com.google.common.io.BaseEncoding$StandardBaseEncoding$1'
p22757
sg15
(lp22758
sg17
(lp22759
sg19
(lp22760
sg21
I0
sba(iArchitecture
Entity
p22761
(dp22762
g11
(lp22763
sg13
S'com.google.common.io.BaseEncoding$StandardBaseEncoding$2'
p22764
sg15
(lp22765
sg17
(lp22766
sg19
(lp22767
sg21
I0
sba(iArchitecture
Entity
p22768
(dp22769
g11
(lp22770
sg13
S'com.google.common.io.ByteArrayDataInput'
p22771
sg15
(lp22772
sg17
(lp22773
sg19
(lp22774
sg21
I0
sba(iArchitecture
Entity
p22775
(dp22776
g11
(lp22777
sg13
S'com.google.common.io.ByteArrayDataOutput'
p22778
sg15
(lp22779
sg17
(lp22780
sg19
(lp22781
sg21
I0
sba(iArchitecture
Entity
p22782
(dp22783
g11
(lp22784
sg13
S'com.google.common.io.ByteProcessor'
p22785
sg15
(lp22786
sg17
(lp22787
sg19
(lp22788
sg21
I0
sba(iArchitecture
Entity
p22789
(dp22790
g11
(lp22791
V2693
p22792
asg13
S'com.google.common.io.ByteSink'
p22793
sg15
(lp22794
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22795
asg17
(lp22796
(lp22797
I5
aasg19
(lp22798
VAdd Stream<String> lines() to CharSource
p22799
asg21
I0
sba(iArchitecture
Entity
p22800
(dp22801
g11
(lp22802
g22792
asg13
S'com.google.common.io.ByteSink$1'
p22803
sg15
(lp22804
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22805
asg17
(lp22806
g22797
asg19
(lp22807
g22799
asg21
I0
sba(iArchitecture
Entity
p22808
(dp22809
g11
(lp22810
g22792
asg13
S'com.google.common.io.ByteSink$AsCharSink'
p22811
sg15
(lp22812
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22813
asg17
(lp22814
g22797
asg19
(lp22815
g22799
asg21
I0
sba(iArchitecture
Entity
p22816
(dp22817
g11
(lp22818
g22792
asg13
S'com.google.common.io.ByteSource'
p22819
sg15
(lp22820
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22821
asg17
(lp22822
g22797
asg19
(lp22823
g22799
asg21
I0
sba(iArchitecture
Entity
p22824
(dp22825
g11
(lp22826
g22792
asg13
S'com.google.common.io.ByteSource$AsCharSource'
p22827
sg15
(lp22828
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22829
asg17
(lp22830
g22797
asg19
(lp22831
g22799
asg21
I0
sba(iArchitecture
Entity
p22832
(dp22833
g11
(lp22834
g22792
asg13
S'com.google.common.io.ByteSource$ByteArrayByteSource'
p22835
sg15
(lp22836
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22837
asg17
(lp22838
g22797
asg19
(lp22839
g22799
asg21
I0
sba(iArchitecture
Entity
p22840
(dp22841
g11
(lp22842
g22792
asg13
S'com.google.common.io.ByteSource$ConcatenatedByteSource'
p22843
sg15
(lp22844
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22845
asg17
(lp22846
g22797
asg19
(lp22847
g22799
asg21
I0
sba(iArchitecture
Entity
p22848
(dp22849
g11
(lp22850
g22792
asg13
S'com.google.common.io.ByteSource$EmptyByteSource'
p22851
sg15
(lp22852
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22853
asg17
(lp22854
g22797
asg19
(lp22855
g22799
asg21
I0
sba(iArchitecture
Entity
p22856
(dp22857
g11
(lp22858
g22792
asg13
S'com.google.common.io.ByteSource$SlicedByteSource'
p22859
sg15
(lp22860
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22861
asg17
(lp22862
g22797
asg19
(lp22863
g22799
asg21
I0
sba(iArchitecture
Entity
p22864
(dp22865
g11
(lp22866
sg13
S'com.google.common.io.ByteStreams'
p22867
sg15
(lp22868
sg17
(lp22869
sg19
(lp22870
sg21
I0
sba(iArchitecture
Entity
p22871
(dp22872
g11
(lp22873
sg13
S'com.google.common.io.ByteStreams$1'
p22874
sg15
(lp22875
sg17
(lp22876
sg19
(lp22877
sg21
I0
sba(iArchitecture
Entity
p22878
(dp22879
g11
(lp22880
sg13
S'com.google.common.io.ByteStreams$ByteArrayDataInputStream'
p22881
sg15
(lp22882
sg17
(lp22883
sg19
(lp22884
sg21
I0
sba(iArchitecture
Entity
p22885
(dp22886
g11
(lp22887
sg13
S'com.google.common.io.ByteStreams$ByteArrayDataOutputStream'
p22888
sg15
(lp22889
sg17
(lp22890
sg19
(lp22891
sg21
I0
sba(iArchitecture
Entity
p22892
(dp22893
g11
(lp22894
sg13
S'com.google.common.io.ByteStreams$FastByteArrayOutputStream'
p22895
sg15
(lp22896
sg17
(lp22897
sg19
(lp22898
sg21
I0
sba(iArchitecture
Entity
p22899
(dp22900
g11
(lp22901
sg13
S'com.google.common.io.ByteStreams$LimitedInputStream'
p22902
sg15
(lp22903
sg17
(lp22904
sg19
(lp22905
sg21
I0
sba(iArchitecture
Entity
p22906
(dp22907
g11
(lp22908
sg13
S'com.google.common.io.CharSequenceReader'
p22909
sg15
(lp22910
sg17
(lp22911
sg19
(lp22912
sg21
I0
sba(iArchitecture
Entity
p22913
(dp22914
g11
(lp22915
g22792
asg13
S'com.google.common.io.CharSink'
p22916
sg15
(lp22917
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22918
asg17
(lp22919
g22797
asg19
(lp22920
g22799
asg21
I0
sba(iArchitecture
Entity
p22921
(dp22922
g11
(lp22923
g22792
ag22792
ag22792
asg13
S'com.google.common.io.CharSource'
p22924
sg15
(lp22925
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22926
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22927
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22928
asg17
(lp22929
g22797
ag22797
ag22797
asg19
(lp22930
g22799
ag22799
ag22799
asg21
I0
sba(iArchitecture
Entity
p22931
(dp22932
g11
(lp22933
g22792
ag22792
ag22792
asg13
S'com.google.common.io.CharSource$AsByteSource'
p22934
sg15
(lp22935
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22936
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22937
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22938
asg17
(lp22939
g22797
ag22797
ag22797
asg19
(lp22940
g22799
ag22799
ag22799
asg21
I0
sba(iArchitecture
Entity
p22941
(dp22942
g11
(lp22943
g22792
ag22792
ag22792
asg13
S'com.google.common.io.CharSource$CharSequenceCharSource'
p22944
sg15
(lp22945
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22946
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22947
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22948
asg17
(lp22949
g22797
ag22797
ag22797
asg19
(lp22950
g22799
ag22799
ag22799
asg21
I0
sba(iArchitecture
Entity
p22951
(dp22952
g11
(lp22953
g22792
ag22792
ag22792
asg13
S'com.google.common.io.CharSource$CharSequenceCharSource$1'
p22954
sg15
(lp22955
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22956
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22957
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22958
asg17
(lp22959
g22797
ag22797
ag22797
asg19
(lp22960
g22799
ag22799
ag22799
asg21
I0
sba(iArchitecture
Entity
p22961
(dp22962
g11
(lp22963
g22792
ag22792
ag22792
asg13
S'com.google.common.io.CharSource$CharSequenceCharSource$1$1'
p22964
sg15
(lp22965
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22966
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22967
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22968
asg17
(lp22969
g22797
ag22797
ag22797
asg19
(lp22970
g22799
ag22799
ag22799
asg21
I0
sba(iArchitecture
Entity
p22971
(dp22972
g11
(lp22973
g22792
ag22792
ag22792
asg13
S'com.google.common.io.CharSource$ConcatenatedCharSource'
p22974
sg15
(lp22975
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22976
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22977
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22978
asg17
(lp22979
g22797
ag22797
ag22797
asg19
(lp22980
g22799
ag22799
ag22799
asg21
I0
sba(iArchitecture
Entity
p22981
(dp22982
g11
(lp22983
g22792
ag22792
ag22792
asg13
S'com.google.common.io.CharSource$EmptyCharSource'
p22984
sg15
(lp22985
VJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22986
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22987
aVJust like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\u000a\u000aOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\u000a\u000aBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\u000a\u000aFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\u000a\u000aAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\u000a\u000aPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)
p22988
asg17
(lp22989
g22797
ag22797
ag22797
asg19
(lp22990
g22799
ag22799
ag22799
asg21
I0
sba(iArchitecture
Entity
p22991
(dp22992
g11
(lp22993
sg13
S'com.google.common.io.CharStreams'
p22994
sg15
(lp22995
sg17
(lp22996
sg19
(lp22997
sg21
I0
sba(iArchitecture
Entity
p22998
(dp22999
g11
(lp23000
sg13
S'com.google.common.io.CharStreams$NullWriter'
p23001
sg15
(lp23002
sg17
(lp23003
sg19
(lp23004
sg21
I0
sba(iArchitecture
Entity
p23005
(dp23006
g11
(lp23007
sg13
S'com.google.common.io.Closeables'
p23008
sg15
(lp23009
sg17
(lp23010
sg19
(lp23011
sg21
I0
sba(iArchitecture
Entity
p23012
(dp23013
g11
(lp23014
sg13
S'com.google.common.io.Closer'
p23015
sg15
(lp23016
sg17
(lp23017
sg19
(lp23018
sg21
I0
sba(iArchitecture
Entity
p23019
(dp23020
g11
(lp23021
sg13
S'com.google.common.io.Closer$LoggingSuppressor'
p23022
sg15
(lp23023
sg17
(lp23024
sg19
(lp23025
sg21
I0
sba(iArchitecture
Entity
p23026
(dp23027
g11
(lp23028
sg13
S'com.google.common.io.Closer$SuppressingSuppressor'
p23029
sg15
(lp23030
sg17
(lp23031
sg19
(lp23032
sg21
I0
sba(iArchitecture
Entity
p23033
(dp23034
g11
(lp23035
sg13
S'com.google.common.io.Closer$Suppressor'
p23036
sg15
(lp23037
sg17
(lp23038
sg19
(lp23039
sg21
I0
sba(iArchitecture
Entity
p23040
(dp23041
g11
(lp23042
sg13
S'com.google.common.io.FileBackedOutputStream'
p23043
sg15
(lp23044
sg17
(lp23045
sg19
(lp23046
sg21
I0
sba(iArchitecture
Entity
p23047
(dp23048
g11
(lp23049
sg13
S'com.google.common.io.FileBackedOutputStream$1'
p23050
sg15
(lp23051
sg17
(lp23052
sg19
(lp23053
sg21
I0
sba(iArchitecture
Entity
p23054
(dp23055
g11
(lp23056
sg13
S'com.google.common.io.FileBackedOutputStream$2'
p23057
sg15
(lp23058
sg17
(lp23059
sg19
(lp23060
sg21
I0
sba(iArchitecture
Entity
p23061
(dp23062
g11
(lp23063
sg13
S'com.google.common.io.FileBackedOutputStream$MemoryOutput'
p23064
sg15
(lp23065
sg17
(lp23066
sg19
(lp23067
sg21
I0
sba(iArchitecture
Entity
p23068
(dp23069
g11
(lp23070
sg13
S'com.google.common.io.FileWriteMode'
p23071
sg15
(lp23072
sg17
(lp23073
sg19
(lp23074
sg21
I0
sba(iArchitecture
Entity
p23075
(dp23076
g11
(lp23077
sg13
S'com.google.common.io.Files'
p23078
sg15
(lp23079
sg17
(lp23080
sg19
(lp23081
sg21
I0
sba(iArchitecture
Entity
p23082
(dp23083
g11
(lp23084
sg13
S'com.google.common.io.Files$1'
p23085
sg15
(lp23086
sg17
(lp23087
sg19
(lp23088
sg21
I0
sba(iArchitecture
Entity
p23089
(dp23090
g11
(lp23091
sg13
S'com.google.common.io.Files$2'
p23092
sg15
(lp23093
sg17
(lp23094
sg19
(lp23095
sg21
I0
sba(iArchitecture
Entity
p23096
(dp23097
g11
(lp23098
sg13
S'com.google.common.io.Files$FileByteSink'
p23099
sg15
(lp23100
sg17
(lp23101
sg19
(lp23102
sg21
I0
sba(iArchitecture
Entity
p23103
(dp23104
g11
(lp23105
sg13
S'com.google.common.io.Files$FileByteSource'
p23106
sg15
(lp23107
sg17
(lp23108
sg19
(lp23109
sg21
I0
sba(iArchitecture
Entity
p23110
(dp23111
g11
(lp23112
sg13
S'com.google.common.io.Files$FilePredicate'
p23113
sg15
(lp23114
sg17
(lp23115
sg19
(lp23116
sg21
I0
sba(iArchitecture
Entity
p23117
(dp23118
g11
(lp23119
sg13
S'com.google.common.io.Files$FilePredicate$1'
p23120
sg15
(lp23121
sg17
(lp23122
sg19
(lp23123
sg21
I0
sba(iArchitecture
Entity
p23124
(dp23125
g11
(lp23126
sg13
S'com.google.common.io.Files$FilePredicate$2'
p23127
sg15
(lp23128
sg17
(lp23129
sg19
(lp23130
sg21
I0
sba(iArchitecture
Entity
p23131
(dp23132
g11
(lp23133
sg13
S'com.google.common.io.LineBuffer'
p23134
sg15
(lp23135
sg17
(lp23136
sg19
(lp23137
sg21
I0
sba(iArchitecture
Entity
p23138
(dp23139
g11
(lp23140
sg13
S'com.google.common.io.LineProcessor'
p23141
sg15
(lp23142
sg17
(lp23143
sg19
(lp23144
sg21
I0
sba(iArchitecture
Entity
p23145
(dp23146
g11
(lp23147
sg13
S'com.google.common.io.LineReader'
p23148
sg15
(lp23149
sg17
(lp23150
sg19
(lp23151
sg21
I0
sba(iArchitecture
Entity
p23152
(dp23153
g11
(lp23154
sg13
S'com.google.common.io.LineReader$1'
p23155
sg15
(lp23156
sg17
(lp23157
sg19
(lp23158
sg21
I0
sba(iArchitecture
Entity
p23159
(dp23160
g11
(lp23161
sg13
S'com.google.common.io.MultiInputStream'
p23162
sg15
(lp23163
sg17
(lp23164
sg19
(lp23165
sg21
I0
sba(iArchitecture
Entity
p23166
(dp23167
g11
(lp23168
sg13
S'com.google.common.io.MultiReader'
p23169
sg15
(lp23170
sg17
(lp23171
sg19
(lp23172
sg21
I0
sba(iArchitecture
Entity
p23173
(dp23174
g11
(lp23175
sg13
S'com.google.common.io.ReaderInputStream'
p23176
sg15
(lp23177
sg17
(lp23178
sg19
(lp23179
sg21
I0
sba(iArchitecture
Entity
p23180
(dp23181
g11
(lp23182
sg13
S'com.google.common.io.Resources'
p23183
sg15
(lp23184
sg17
(lp23185
sg19
(lp23186
sg21
I0
sba(iArchitecture
Entity
p23187
(dp23188
g11
(lp23189
sg13
S'com.google.common.io.Resources$1'
p23190
sg15
(lp23191
sg17
(lp23192
sg19
(lp23193
sg21
I0
sba(iArchitecture
Entity
p23194
(dp23195
g11
(lp23196
sg13
S'com.google.common.io.Resources$UrlByteSource'
p23197
sg15
(lp23198
sg17
(lp23199
sg19
(lp23200
sg21
I0
sbasg1135
(lp23201
g22666
ag22673
ag22680
ag22687
ag22694
ag22701
ag22708
ag22715
ag22722
ag22729
ag22736
ag22743
ag22750
ag22757
ag22764
ag22771
ag22778
ag22785
ag22793
ag22803
ag22811
ag22819
ag22827
ag22835
ag22843
ag22851
ag22859
ag22867
ag22874
ag22881
ag22888
ag22895
ag22902
ag22909
ag22916
ag22924
ag22934
ag22944
ag22954
ag22964
ag22974
ag22984
ag22994
ag23001
ag23008
ag23015
ag23022
ag23029
ag23036
ag23043
ag23050
ag23057
ag23064
ag23071
ag23078
ag23085
ag23092
ag23099
ag23106
ag23113
ag23120
ag23127
ag23134
ag23141
ag23148
ag23155
ag23162
ag23169
ag23176
ag23183
ag23190
ag23197
asg1137
I0
sg21
I0
sg1138
S'com.google.common.io.ss'
p23202
sba(iArchitecture
Cluster
p23203
(dp23204
g7
(lp23205
(iArchitecture
Entity
p23206
(dp23207
g11
(lp23208
sg13
S'com.google.common.annotations.Beta'
p23209
sg15
(lp23210
sg17
(lp23211
sg19
(lp23212
sg21
I0
sba(iArchitecture
Entity
p23213
(dp23214
g11
(lp23215
sg13
S'com.google.common.math.BigIntegerMath'
p23216
sg15
(lp23217
sg17
(lp23218
sg19
(lp23219
sg21
I0
sba(iArchitecture
Entity
p23220
(dp23221
g11
(lp23222
sg13
S'com.google.common.math.BigIntegerMath$1'
p23223
sg15
(lp23224
sg17
(lp23225
sg19
(lp23226
sg21
I0
sba(iArchitecture
Entity
p23227
(dp23228
g11
(lp23229
sg13
S'com.google.common.math.DoubleMath'
p23230
sg15
(lp23231
sg17
(lp23232
sg19
(lp23233
sg21
I0
sba(iArchitecture
Entity
p23234
(dp23235
g11
(lp23236
sg13
S'com.google.common.math.DoubleMath$1'
p23237
sg15
(lp23238
sg17
(lp23239
sg19
(lp23240
sg21
I0
sba(iArchitecture
Entity
p23241
(dp23242
g11
(lp23243
sg13
S'com.google.common.math.DoubleUtils'
p23244
sg15
(lp23245
sg17
(lp23246
sg19
(lp23247
sg21
I0
sba(iArchitecture
Entity
p23248
(dp23249
g11
(lp23250
sg13
S'com.google.common.math.IntMath'
p23251
sg15
(lp23252
sg17
(lp23253
sg19
(lp23254
sg21
I0
sba(iArchitecture
Entity
p23255
(dp23256
g11
(lp23257
sg13
S'com.google.common.math.IntMath$1'
p23258
sg15
(lp23259
sg17
(lp23260
sg19
(lp23261
sg21
I0
sba(iArchitecture
Entity
p23262
(dp23263
g11
(lp23264
sg13
S'com.google.common.math.LinearTransformation'
p23265
sg15
(lp23266
sg17
(lp23267
sg19
(lp23268
sg21
I0
sba(iArchitecture
Entity
p23269
(dp23270
g11
(lp23271
sg13
S'com.google.common.math.LinearTransformation$1'
p23272
sg15
(lp23273
sg17
(lp23274
sg19
(lp23275
sg21
I0
sba(iArchitecture
Entity
p23276
(dp23277
g11
(lp23278
sg13
S'com.google.common.math.LinearTransformation$LinearTransformationBuilder'
p23279
sg15
(lp23280
sg17
(lp23281
sg19
(lp23282
sg21
I0
sba(iArchitecture
Entity
p23283
(dp23284
g11
(lp23285
sg13
S'com.google.common.math.LinearTransformation$NaNLinearTransformation'
p23286
sg15
(lp23287
sg17
(lp23288
sg19
(lp23289
sg21
I0
sba(iArchitecture
Entity
p23290
(dp23291
g11
(lp23292
sg13
S'com.google.common.math.LinearTransformation$RegularLinearTransformation'
p23293
sg15
(lp23294
sg17
(lp23295
sg19
(lp23296
sg21
I0
sba(iArchitecture
Entity
p23297
(dp23298
g11
(lp23299
sg13
S'com.google.common.math.LinearTransformation$VerticalLinearTransformation'
p23300
sg15
(lp23301
sg17
(lp23302
sg19
(lp23303
sg21
I0
sba(iArchitecture
Entity
p23304
(dp23305
g11
(lp23306
sg13
S'com.google.common.math.LongMath'
p23307
sg15
(lp23308
sg17
(lp23309
sg19
(lp23310
sg21
I0
sba(iArchitecture
Entity
p23311
(dp23312
g11
(lp23313
sg13
S'com.google.common.math.LongMath$1'
p23314
sg15
(lp23315
sg17
(lp23316
sg19
(lp23317
sg21
I0
sba(iArchitecture
Entity
p23318
(dp23319
g11
(lp23320
sg13
S'com.google.common.math.LongMath$MillerRabinTester'
p23321
sg15
(lp23322
sg17
(lp23323
sg19
(lp23324
sg21
I0
sba(iArchitecture
Entity
p23325
(dp23326
g11
(lp23327
sg13
S'com.google.common.math.LongMath$MillerRabinTester$1'
p23328
sg15
(lp23329
sg17
(lp23330
sg19
(lp23331
sg21
I0
sba(iArchitecture
Entity
p23332
(dp23333
g11
(lp23334
sg13
S'com.google.common.math.LongMath$MillerRabinTester$2'
p23335
sg15
(lp23336
sg17
(lp23337
sg19
(lp23338
sg21
I0
sba(iArchitecture
Entity
p23339
(dp23340
g11
(lp23341
sg13
S'com.google.common.math.MathPreconditions'
p23342
sg15
(lp23343
sg17
(lp23344
sg19
(lp23345
sg21
I0
sba(iArchitecture
Entity
p23346
(dp23347
g11
(lp23348
sg13
S'com.google.common.math.PairedStats'
p23349
sg15
(lp23350
sg17
(lp23351
sg19
(lp23352
sg21
I0
sba(iArchitecture
Entity
p23353
(dp23354
g11
(lp23355
sg13
S'com.google.common.math.PairedStatsAccumulator'
p23356
sg15
(lp23357
sg17
(lp23358
sg19
(lp23359
sg21
I0
sba(iArchitecture
Entity
p23360
(dp23361
g11
(lp23362
sg13
S'com.google.common.math.Quantiles'
p23363
sg15
(lp23364
sg17
(lp23365
sg19
(lp23366
sg21
I0
sba(iArchitecture
Entity
p23367
(dp23368
g11
(lp23369
sg13
S'com.google.common.math.Quantiles$1'
p23370
sg15
(lp23371
sg17
(lp23372
sg19
(lp23373
sg21
I0
sba(iArchitecture
Entity
p23374
(dp23375
g11
(lp23376
sg13
S'com.google.common.math.Quantiles$Scale'
p23377
sg15
(lp23378
sg17
(lp23379
sg19
(lp23380
sg21
I0
sba(iArchitecture
Entity
p23381
(dp23382
g11
(lp23383
sg13
S'com.google.common.math.Quantiles$ScaleAndIndex'
p23384
sg15
(lp23385
sg17
(lp23386
sg19
(lp23387
sg21
I0
sba(iArchitecture
Entity
p23388
(dp23389
g11
(lp23390
sg13
S'com.google.common.math.Quantiles$ScaleAndIndexes'
p23391
sg15
(lp23392
sg17
(lp23393
sg19
(lp23394
sg21
I0
sba(iArchitecture
Entity
p23395
(dp23396
g11
(lp23397
sg13
S'com.google.common.math.Stats'
p23398
sg15
(lp23399
sg17
(lp23400
sg19
(lp23401
sg21
I0
sba(iArchitecture
Entity
p23402
(dp23403
g11
(lp23404
sg13
S'com.google.common.math.StatsAccumulator'
p23405
sg15
(lp23406
sg17
(lp23407
sg19
(lp23408
sg21
I0
sba(iArchitecture
Entity
p23409
(dp23410
g11
(lp23411
sg13
S'com.google.common.reflect.AbstractInvocationHandler'
p23412
sg15
(lp23413
sg17
(lp23414
sg19
(lp23415
sg21
I0
sbasg1135
(lp23416
g23209
ag23216
ag23223
ag23230
ag23237
ag23244
ag23251
ag23258
ag23265
ag23272
ag23279
ag23286
ag23293
ag23300
ag23307
ag23314
ag23321
ag23328
ag23335
ag23342
ag23349
ag23356
ag23363
ag23370
ag23377
ag23384
ag23391
ag23398
ag23405
ag23412
asg1137
I0
sg21
I0
sg1138
S'com.google.common.math.ss'
p23417
sba(iArchitecture
Cluster
p23418
(dp23419
g7
(lp23420
(iArchitecture
Entity
p23421
(dp23422
g11
(lp23423
sg13
S'com.google.common.base.Charsets'
p23424
sg15
(lp23425
sg17
(lp23426
sg19
(lp23427
sg21
I0
sba(iArchitecture
Entity
p23428
(dp23429
g11
(lp23430
sg13
S'com.google.common.base.Strings'
p23431
sg15
(lp23432
sg17
(lp23433
sg19
(lp23434
sg21
I0
sba(iArchitecture
Entity
p23435
(dp23436
g11
(lp23437
sg13
S'com.google.common.net.HostAndPort'
p23438
sg15
(lp23439
sg17
(lp23440
sg19
(lp23441
sg21
I0
sba(iArchitecture
Entity
p23442
(dp23443
g11
(lp23444
sg13
S'com.google.common.net.HostSpecifier'
p23445
sg15
(lp23446
sg17
(lp23447
sg19
(lp23448
sg21
I0
sba(iArchitecture
Entity
p23449
(dp23450
g11
(lp23451
sg13
S'com.google.common.net.InetAddresses'
p23452
sg15
(lp23453
sg17
(lp23454
sg19
(lp23455
sg21
I0
sba(iArchitecture
Entity
p23456
(dp23457
g11
(lp23458
sg13
S'com.google.common.net.InetAddresses$TeredoInfo'
p23459
sg15
(lp23460
sg17
(lp23461
sg19
(lp23462
sg21
I0
sba(iArchitecture
Entity
p23463
(dp23464
g11
(lp23465
sg13
S'com.google.common.net.InternetDomainName'
p23466
sg15
(lp23467
sg17
(lp23468
sg19
(lp23469
sg21
I0
sba(iArchitecture
Entity
p23470
(dp23471
g11
(lp23472
sg13
S'com.google.common.net.MediaType'
p23473
sg15
(lp23474
sg17
(lp23475
sg19
(lp23476
sg21
I0
sba(iArchitecture
Entity
p23477
(dp23478
g11
(lp23479
sg13
S'com.google.common.net.MediaType$1'
p23480
sg15
(lp23481
sg17
(lp23482
sg19
(lp23483
sg21
I0
sba(iArchitecture
Entity
p23484
(dp23485
g11
(lp23486
sg13
S'com.google.common.net.MediaType$2'
p23487
sg15
(lp23488
sg17
(lp23489
sg19
(lp23490
sg21
I0
sba(iArchitecture
Entity
p23491
(dp23492
g11
(lp23493
sg13
S'com.google.common.net.MediaType$Tokenizer'
p23494
sg15
(lp23495
sg17
(lp23496
sg19
(lp23497
sg21
I0
sba(iArchitecture
Entity
p23498
(dp23499
g11
(lp23500
sg13
S'com.google.common.net.PercentEscaper'
p23501
sg15
(lp23502
sg17
(lp23503
sg19
(lp23504
sg21
I0
sba(iArchitecture
Entity
p23505
(dp23506
g11
(lp23507
sg13
S'com.google.common.net.UrlEscapers'
p23508
sg15
(lp23509
sg17
(lp23510
sg19
(lp23511
sg21
I0
sbasg1135
(lp23512
g23424
ag23431
ag23438
ag23445
ag23452
ag23459
ag23466
ag23473
ag23480
ag23487
ag23494
ag23501
ag23508
asg1137
I0
sg21
I0
sg1138
S'com.google.common.net.ss'
p23513
sba(iArchitecture
Cluster
p23514
(dp23515
g7
(lp23516
(iArchitecture
Entity
p23517
(dp23518
g11
(lp23519
sg13
S'com.google.common.io.LittleEndianDataInputStream'
p23520
sg15
(lp23521
sg17
(lp23522
sg19
(lp23523
sg21
I0
sba(iArchitecture
Entity
p23524
(dp23525
g11
(lp23526
sg13
S'com.google.common.io.LittleEndianDataOutputStream'
p23527
sg15
(lp23528
sg17
(lp23529
sg19
(lp23530
sg21
I0
sba(iArchitecture
Entity
p23531
(dp23532
g11
(lp23533
sg13
S'com.google.common.primitives.Booleans'
p23534
sg15
(lp23535
sg17
(lp23536
sg19
(lp23537
sg21
I0
sba(iArchitecture
Entity
p23538
(dp23539
g11
(lp23540
sg13
S'com.google.common.primitives.Booleans$BooleanArrayAsList'
p23541
sg15
(lp23542
sg17
(lp23543
sg19
(lp23544
sg21
I0
sba(iArchitecture
Entity
p23545
(dp23546
g11
(lp23547
sg13
S'com.google.common.primitives.Booleans$LexicographicalComparator'
p23548
sg15
(lp23549
sg17
(lp23550
sg19
(lp23551
sg21
I0
sba(iArchitecture
Entity
p23552
(dp23553
g11
(lp23554
sg13
S'com.google.common.primitives.Bytes'
p23555
sg15
(lp23556
sg17
(lp23557
sg19
(lp23558
sg21
I0
sba(iArchitecture
Entity
p23559
(dp23560
g11
(lp23561
sg13
S'com.google.common.primitives.Bytes$ByteArrayAsList'
p23562
sg15
(lp23563
sg17
(lp23564
sg19
(lp23565
sg21
I0
sba(iArchitecture
Entity
p23566
(dp23567
g11
(lp23568
sg13
S'com.google.common.primitives.Chars'
p23569
sg15
(lp23570
sg17
(lp23571
sg19
(lp23572
sg21
I0
sba(iArchitecture
Entity
p23573
(dp23574
g11
(lp23575
sg13
S'com.google.common.primitives.Chars$CharArrayAsList'
p23576
sg15
(lp23577
sg17
(lp23578
sg19
(lp23579
sg21
I0
sba(iArchitecture
Entity
p23580
(dp23581
g11
(lp23582
sg13
S'com.google.common.primitives.Chars$LexicographicalComparator'
p23583
sg15
(lp23584
sg17
(lp23585
sg19
(lp23586
sg21
I0
sba(iArchitecture
Entity
p23587
(dp23588
g11
(lp23589
sg13
S'com.google.common.primitives.Doubles'
p23590
sg15
(lp23591
sg17
(lp23592
sg19
(lp23593
sg21
I0
sba(iArchitecture
Entity
p23594
(dp23595
g11
(lp23596
sg13
S'com.google.common.primitives.Doubles$DoubleArrayAsList'
p23597
sg15
(lp23598
sg17
(lp23599
sg19
(lp23600
sg21
I0
sba(iArchitecture
Entity
p23601
(dp23602
g11
(lp23603
sg13
S'com.google.common.primitives.Doubles$DoubleConverter'
p23604
sg15
(lp23605
sg17
(lp23606
sg19
(lp23607
sg21
I0
sba(iArchitecture
Entity
p23608
(dp23609
g11
(lp23610
sg13
S'com.google.common.primitives.Doubles$LexicographicalComparator'
p23611
sg15
(lp23612
sg17
(lp23613
sg19
(lp23614
sg21
I0
sba(iArchitecture
Entity
p23615
(dp23616
g11
(lp23617
sg13
S'com.google.common.primitives.Floats'
p23618
sg15
(lp23619
sg17
(lp23620
sg19
(lp23621
sg21
I0
sba(iArchitecture
Entity
p23622
(dp23623
g11
(lp23624
sg13
S'com.google.common.primitives.Floats$FloatArrayAsList'
p23625
sg15
(lp23626
sg17
(lp23627
sg19
(lp23628
sg21
I0
sba(iArchitecture
Entity
p23629
(dp23630
g11
(lp23631
sg13
S'com.google.common.primitives.Floats$FloatConverter'
p23632
sg15
(lp23633
sg17
(lp23634
sg19
(lp23635
sg21
I0
sba(iArchitecture
Entity
p23636
(dp23637
g11
(lp23638
sg13
S'com.google.common.primitives.Floats$LexicographicalComparator'
p23639
sg15
(lp23640
sg17
(lp23641
sg19
(lp23642
sg21
I0
sba(iArchitecture
Entity
p23643
(dp23644
g11
(lp23645
sg13
S'com.google.common.primitives.Ints'
p23646
sg15
(lp23647
sg17
(lp23648
sg19
(lp23649
sg21
I0
sba(iArchitecture
Entity
p23650
(dp23651
g11
(lp23652
sg13
S'com.google.common.primitives.Ints$IntArrayAsList'
p23653
sg15
(lp23654
sg17
(lp23655
sg19
(lp23656
sg21
I0
sba(iArchitecture
Entity
p23657
(dp23658
g11
(lp23659
sg13
S'com.google.common.primitives.Ints$IntConverter'
p23660
sg15
(lp23661
sg17
(lp23662
sg19
(lp23663
sg21
I0
sba(iArchitecture
Entity
p23664
(dp23665
g11
(lp23666
sg13
S'com.google.common.primitives.Ints$LexicographicalComparator'
p23667
sg15
(lp23668
sg17
(lp23669
sg19
(lp23670
sg21
I0
sba(iArchitecture
Entity
p23671
(dp23672
g11
(lp23673
sg13
S'com.google.common.primitives.Longs'
p23674
sg15
(lp23675
sg17
(lp23676
sg19
(lp23677
sg21
I0
sba(iArchitecture
Entity
p23678
(dp23679
g11
(lp23680
sg13
S'com.google.common.primitives.Longs$LexicographicalComparator'
p23681
sg15
(lp23682
sg17
(lp23683
sg19
(lp23684
sg21
I0
sba(iArchitecture
Entity
p23685
(dp23686
g11
(lp23687
sg13
S'com.google.common.primitives.Longs$LongArrayAsList'
p23688
sg15
(lp23689
sg17
(lp23690
sg19
(lp23691
sg21
I0
sba(iArchitecture
Entity
p23692
(dp23693
g11
(lp23694
sg13
S'com.google.common.primitives.Longs$LongConverter'
p23695
sg15
(lp23696
sg17
(lp23697
sg19
(lp23698
sg21
I0
sba(iArchitecture
Entity
p23699
(dp23700
g11
(lp23701
sg13
S'com.google.common.primitives.ParseRequest'
p23702
sg15
(lp23703
sg17
(lp23704
sg19
(lp23705
sg21
I0
sba(iArchitecture
Entity
p23706
(dp23707
g11
(lp23708
sg13
S'com.google.common.primitives.Shorts'
p23709
sg15
(lp23710
sg17
(lp23711
sg19
(lp23712
sg21
I0
sba(iArchitecture
Entity
p23713
(dp23714
g11
(lp23715
sg13
S'com.google.common.primitives.Shorts$LexicographicalComparator'
p23716
sg15
(lp23717
sg17
(lp23718
sg19
(lp23719
sg21
I0
sba(iArchitecture
Entity
p23720
(dp23721
g11
(lp23722
sg13
S'com.google.common.primitives.Shorts$ShortArrayAsList'
p23723
sg15
(lp23724
sg17
(lp23725
sg19
(lp23726
sg21
I0
sba(iArchitecture
Entity
p23727
(dp23728
g11
(lp23729
sg13
S'com.google.common.primitives.Shorts$ShortConverter'
p23730
sg15
(lp23731
sg17
(lp23732
sg19
(lp23733
sg21
I0
sba(iArchitecture
Entity
p23734
(dp23735
g11
(lp23736
sg13
S'com.google.common.primitives.SignedBytes'
p23737
sg15
(lp23738
sg17
(lp23739
sg19
(lp23740
sg21
I0
sba(iArchitecture
Entity
p23741
(dp23742
g11
(lp23743
sg13
S'com.google.common.primitives.SignedBytes$LexicographicalComparator'
p23744
sg15
(lp23745
sg17
(lp23746
sg19
(lp23747
sg21
I0
sba(iArchitecture
Entity
p23748
(dp23749
g11
(lp23750
sg13
S'com.google.common.primitives.UnsignedBytes'
p23751
sg15
(lp23752
sg17
(lp23753
sg19
(lp23754
sg21
I0
sba(iArchitecture
Entity
p23755
(dp23756
g11
(lp23757
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder'
p23758
sg15
(lp23759
sg17
(lp23760
sg19
(lp23761
sg21
I0
sba(iArchitecture
Entity
p23762
(dp23763
g11
(lp23764
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder$PureJavaComparator'
p23765
sg15
(lp23766
sg17
(lp23767
sg19
(lp23768
sg21
I0
sba(iArchitecture
Entity
p23769
(dp23770
g11
(lp23771
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator'
p23772
sg15
(lp23773
sg17
(lp23774
sg19
(lp23775
sg21
I0
sba(iArchitecture
Entity
p23776
(dp23777
g11
(lp23778
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator$1'
p23779
sg15
(lp23780
sg17
(lp23781
sg19
(lp23782
sg21
I0
sba(iArchitecture
Entity
p23783
(dp23784
g11
(lp23785
sg13
S'com.google.common.primitives.UnsignedInts'
p23786
sg15
(lp23787
sg17
(lp23788
sg19
(lp23789
sg21
I0
sba(iArchitecture
Entity
p23790
(dp23791
g11
(lp23792
sg13
S'com.google.common.primitives.UnsignedInts$LexicographicalComparator'
p23793
sg15
(lp23794
sg17
(lp23795
sg19
(lp23796
sg21
I0
sba(iArchitecture
Entity
p23797
(dp23798
g11
(lp23799
sg13
S'com.google.common.primitives.UnsignedLong'
p23800
sg15
(lp23801
sg17
(lp23802
sg19
(lp23803
sg21
I0
sba(iArchitecture
Entity
p23804
(dp23805
g11
(lp23806
sg13
S'com.google.common.primitives.UnsignedLongs'
p23807
sg15
(lp23808
sg17
(lp23809
sg19
(lp23810
sg21
I0
sba(iArchitecture
Entity
p23811
(dp23812
g11
(lp23813
sg13
S'com.google.common.primitives.UnsignedLongs$LexicographicalComparator'
p23814
sg15
(lp23815
sg17
(lp23816
sg19
(lp23817
sg21
I0
sbasg1135
(lp23818
g23520
ag23527
ag23534
ag23541
ag23548
ag23555
ag23562
ag23569
ag23576
ag23583
ag23590
ag23597
ag23604
ag23611
ag23618
ag23625
ag23632
ag23639
ag23646
ag23653
ag23660
ag23667
ag23674
ag23681
ag23688
ag23695
ag23702
ag23709
ag23716
ag23723
ag23730
ag23737
ag23744
ag23751
ag23758
ag23765
ag23772
ag23779
ag23786
ag23793
ag23800
ag23807
ag23814
asg1137
I0
sg21
I0
sg1138
S'com.google.common.primitives.ss'
p23819
sba(iArchitecture
Cluster
p23820
(dp23821
g7
(lp23822
(iArchitecture
Entity
p23823
(dp23824
g11
(lp23825
sg13
S'com.google.common.collect.ForwardingMapEntry'
p23826
sg15
(lp23827
sg17
(lp23828
sg19
(lp23829
sg21
I0
sba(iArchitecture
Entity
p23830
(dp23831
g11
(lp23832
sg13
S'com.google.common.collect.ImmutableSet$Builder'
p23833
sg15
(lp23834
sg17
(lp23835
sg19
(lp23836
sg21
I0
sba(iArchitecture
Entity
p23837
(dp23838
g11
(lp23839
sg13
S'com.google.common.primitives.Primitives'
p23840
sg15
(lp23841
sg17
(lp23842
sg19
(lp23843
sg21
I0
sba(iArchitecture
Entity
p23844
(dp23845
g11
(lp23846
sg13
S'com.google.common.reflect.ClassPath'
p23847
sg15
(lp23848
sg17
(lp23849
sg19
(lp23850
sg21
I0
sba(iArchitecture
Entity
p23851
(dp23852
g11
(lp23853
sg13
S'com.google.common.reflect.ClassPath$1'
p23854
sg15
(lp23855
sg17
(lp23856
sg19
(lp23857
sg21
I0
sba(iArchitecture
Entity
p23858
(dp23859
g11
(lp23860
sg13
S'com.google.common.reflect.ClassPath$ClassInfo'
p23861
sg15
(lp23862
sg17
(lp23863
sg19
(lp23864
sg21
I0
sba(iArchitecture
Entity
p23865
(dp23866
g11
(lp23867
sg13
S'com.google.common.reflect.ClassPath$DefaultScanner'
p23868
sg15
(lp23869
sg17
(lp23870
sg19
(lp23871
sg21
I0
sba(iArchitecture
Entity
p23872
(dp23873
g11
(lp23874
sg13
S'com.google.common.reflect.ClassPath$ResourceInfo'
p23875
sg15
(lp23876
sg17
(lp23877
sg19
(lp23878
sg21
I0
sba(iArchitecture
Entity
p23879
(dp23880
g11
(lp23881
sg13
S'com.google.common.reflect.ClassPath$Scanner'
p23882
sg15
(lp23883
sg17
(lp23884
sg19
(lp23885
sg21
I0
sba(iArchitecture
Entity
p23886
(dp23887
g11
(lp23888
sg13
S'com.google.common.reflect.Element'
p23889
sg15
(lp23890
sg17
(lp23891
sg19
(lp23892
sg21
I0
sba(iArchitecture
Entity
p23893
(dp23894
g11
(lp23895
sg13
S'com.google.common.reflect.ImmutableTypeToInstanceMap'
p23896
sg15
(lp23897
sg17
(lp23898
sg19
(lp23899
sg21
I0
sba(iArchitecture
Entity
p23900
(dp23901
g11
(lp23902
sg13
S'com.google.common.reflect.ImmutableTypeToInstanceMap$1'
p23903
sg15
(lp23904
sg17
(lp23905
sg19
(lp23906
sg21
I0
sba(iArchitecture
Entity
p23907
(dp23908
g11
(lp23909
sg13
S'com.google.common.reflect.ImmutableTypeToInstanceMap$Builder'
p23910
sg15
(lp23911
sg17
(lp23912
sg19
(lp23913
sg21
I0
sba(iArchitecture
Entity
p23914
(dp23915
g11
(lp23916
sg13
S'com.google.common.reflect.Invokable'
p23917
sg15
(lp23918
sg17
(lp23919
sg19
(lp23920
sg21
I0
sba(iArchitecture
Entity
p23921
(dp23922
g11
(lp23923
sg13
S'com.google.common.reflect.Invokable$ConstructorInvokable'
p23924
sg15
(lp23925
sg17
(lp23926
sg19
(lp23927
sg21
I0
sba(iArchitecture
Entity
p23928
(dp23929
g11
(lp23930
sg13
S'com.google.common.reflect.Invokable$MethodInvokable'
p23931
sg15
(lp23932
sg17
(lp23933
sg19
(lp23934
sg21
I0
sba(iArchitecture
Entity
p23935
(dp23936
g11
(lp23937
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap'
p23938
sg15
(lp23939
sg17
(lp23940
sg19
(lp23941
sg21
I0
sba(iArchitecture
Entity
p23942
(dp23943
g11
(lp23944
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$1'
p23945
sg15
(lp23946
sg17
(lp23947
sg19
(lp23948
sg21
I0
sba(iArchitecture
Entity
p23949
(dp23950
g11
(lp23951
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry'
p23952
sg15
(lp23953
sg17
(lp23954
sg19
(lp23955
sg21
I0
sba(iArchitecture
Entity
p23956
(dp23957
g11
(lp23958
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry$1'
p23959
sg15
(lp23960
sg17
(lp23961
sg19
(lp23962
sg21
I0
sba(iArchitecture
Entity
p23963
(dp23964
g11
(lp23965
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry$2'
p23966
sg15
(lp23967
sg17
(lp23968
sg19
(lp23969
sg21
I0
sba(iArchitecture
Entity
p23970
(dp23971
g11
(lp23972
sg13
S'com.google.common.reflect.Parameter'
p23973
sg15
(lp23974
sg17
(lp23975
sg19
(lp23976
sg21
I0
sba(iArchitecture
Entity
p23977
(dp23978
g11
(lp23979
sg13
S'com.google.common.reflect.Reflection'
p23980
sg15
(lp23981
sg17
(lp23982
sg19
(lp23983
sg21
I0
sba(iArchitecture
Entity
p23984
(dp23985
g11
(lp23986
sg13
S'com.google.common.reflect.TypeCapture'
p23987
sg15
(lp23988
sg17
(lp23989
sg19
(lp23990
sg21
I0
sba(iArchitecture
Entity
p23991
(dp23992
g11
(lp23993
sg13
S'com.google.common.reflect.TypeParameter'
p23994
sg15
(lp23995
sg17
(lp23996
sg19
(lp23997
sg21
I0
sba(iArchitecture
Entity
p23998
(dp23999
g11
(lp24000
sg13
S'com.google.common.reflect.TypeResolver'
p24001
sg15
(lp24002
sg17
(lp24003
sg19
(lp24004
sg21
I0
sba(iArchitecture
Entity
p24005
(dp24006
g11
(lp24007
sg13
S'com.google.common.reflect.TypeResolver$1'
p24008
sg15
(lp24009
sg17
(lp24010
sg19
(lp24011
sg21
I0
sba(iArchitecture
Entity
p24012
(dp24013
g11
(lp24014
sg13
S'com.google.common.reflect.TypeResolver$TypeMappingIntrospector'
p24015
sg15
(lp24016
sg17
(lp24017
sg19
(lp24018
sg21
I0
sba(iArchitecture
Entity
p24019
(dp24020
g11
(lp24021
sg13
S'com.google.common.reflect.TypeResolver$TypeTable'
p24022
sg15
(lp24023
sg17
(lp24024
sg19
(lp24025
sg21
I0
sba(iArchitecture
Entity
p24026
(dp24027
g11
(lp24028
sg13
S'com.google.common.reflect.TypeResolver$TypeTable$1'
p24029
sg15
(lp24030
sg17
(lp24031
sg19
(lp24032
sg21
I0
sba(iArchitecture
Entity
p24033
(dp24034
g11
(lp24035
sg13
S'com.google.common.reflect.TypeResolver$TypeVariableKey'
p24036
sg15
(lp24037
sg17
(lp24038
sg19
(lp24039
sg21
I0
sba(iArchitecture
Entity
p24040
(dp24041
g11
(lp24042
sg13
S'com.google.common.reflect.TypeResolver$WildcardCapturer'
p24043
sg15
(lp24044
sg17
(lp24045
sg19
(lp24046
sg21
I0
sba(iArchitecture
Entity
p24047
(dp24048
g11
(lp24049
sg13
S'com.google.common.reflect.TypeToInstanceMap'
p24050
sg15
(lp24051
sg17
(lp24052
sg19
(lp24053
sg21
I0
sba(iArchitecture
Entity
p24054
(dp24055
g11
(lp24056
sg13
S'com.google.common.reflect.TypeToken'
p24057
sg15
(lp24058
sg17
(lp24059
sg19
(lp24060
sg21
I0
sba(iArchitecture
Entity
p24061
(dp24062
g11
(lp24063
sg13
S'com.google.common.reflect.TypeToken$1'
p24064
sg15
(lp24065
sg17
(lp24066
sg19
(lp24067
sg21
I0
sba(iArchitecture
Entity
p24068
(dp24069
g11
(lp24070
sg13
S'com.google.common.reflect.TypeToken$2'
p24071
sg15
(lp24072
sg17
(lp24073
sg19
(lp24074
sg21
I0
sba(iArchitecture
Entity
p24075
(dp24076
g11
(lp24077
sg13
S'com.google.common.reflect.TypeToken$3'
p24078
sg15
(lp24079
sg17
(lp24080
sg19
(lp24081
sg21
I0
sba(iArchitecture
Entity
p24082
(dp24083
g11
(lp24084
sg13
S'com.google.common.reflect.TypeToken$4'
p24085
sg15
(lp24086
sg17
(lp24087
sg19
(lp24088
sg21
I0
sba(iArchitecture
Entity
p24089
(dp24090
g11
(lp24091
sg13
S'com.google.common.reflect.TypeToken$Bounds'
p24092
sg15
(lp24093
sg17
(lp24094
sg19
(lp24095
sg21
I0
sba(iArchitecture
Entity
p24096
(dp24097
g11
(lp24098
sg13
S'com.google.common.reflect.TypeToken$InterfaceSet'
p24099
sg15
(lp24100
sg17
(lp24101
sg19
(lp24102
sg21
I0
sba(iArchitecture
Entity
p24103
(dp24104
g11
(lp24105
sg13
S'com.google.common.reflect.TypeToken$InterfaceSet$1'
p24106
sg15
(lp24107
sg17
(lp24108
sg19
(lp24109
sg21
I0
sba(iArchitecture
Entity
p24110
(dp24111
g11
(lp24112
sg13
S'com.google.common.reflect.TypeToken$SimpleTypeToken'
p24113
sg15
(lp24114
sg17
(lp24115
sg19
(lp24116
sg21
I0
sba(iArchitecture
Entity
p24117
(dp24118
g11
(lp24119
sg13
S'com.google.common.reflect.TypeToken$TypeCollector'
p24120
sg15
(lp24121
sg17
(lp24122
sg19
(lp24123
sg21
I0
sba(iArchitecture
Entity
p24124
(dp24125
g11
(lp24126
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$1'
p24127
sg15
(lp24128
sg17
(lp24129
sg19
(lp24130
sg21
I0
sba(iArchitecture
Entity
p24131
(dp24132
g11
(lp24133
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$2'
p24134
sg15
(lp24135
sg17
(lp24136
sg19
(lp24137
sg21
I0
sba(iArchitecture
Entity
p24138
(dp24139
g11
(lp24140
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$3'
p24141
sg15
(lp24142
sg17
(lp24143
sg19
(lp24144
sg21
I0
sba(iArchitecture
Entity
p24145
(dp24146
g11
(lp24147
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$4'
p24148
sg15
(lp24149
sg17
(lp24150
sg19
(lp24151
sg21
I0
sba(iArchitecture
Entity
p24152
(dp24153
g11
(lp24154
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$ForwardingTypeCollector'
p24155
sg15
(lp24156
sg17
(lp24157
sg19
(lp24158
sg21
I0
sba(iArchitecture
Entity
p24159
(dp24160
g11
(lp24161
sg13
S'com.google.common.reflect.TypeToken$TypeFilter'
p24162
sg15
(lp24163
sg17
(lp24164
sg19
(lp24165
sg21
I0
sba(iArchitecture
Entity
p24166
(dp24167
g11
(lp24168
sg13
S'com.google.common.reflect.TypeToken$TypeFilter$1'
p24169
sg15
(lp24170
sg17
(lp24171
sg19
(lp24172
sg21
I0
sba(iArchitecture
Entity
p24173
(dp24174
g11
(lp24175
sg13
S'com.google.common.reflect.TypeToken$TypeFilter$2'
p24176
sg15
(lp24177
sg17
(lp24178
sg19
(lp24179
sg21
I0
sba(iArchitecture
Entity
p24180
(dp24181
g11
(lp24182
sg13
S'com.google.common.reflect.TypeVisitor'
p24183
sg15
(lp24184
sg17
(lp24185
sg19
(lp24186
sg21
I0
sba(iArchitecture
Entity
p24187
(dp24188
g11
(lp24189
sg13
S'com.google.common.reflect.Types'
p24190
sg15
(lp24191
sg17
(lp24192
sg19
(lp24193
sg21
I0
sba(iArchitecture
Entity
p24194
(dp24195
g11
(lp24196
sg13
S'com.google.common.reflect.Types$1'
p24197
sg15
(lp24198
sg17
(lp24199
sg19
(lp24200
sg21
I0
sba(iArchitecture
Entity
p24201
(dp24202
g11
(lp24203
sg13
S'com.google.common.reflect.Types$2'
p24204
sg15
(lp24205
sg17
(lp24206
sg19
(lp24207
sg21
I0
sba(iArchitecture
Entity
p24208
(dp24209
g11
(lp24210
sg13
S'com.google.common.reflect.Types$ClassOwnership'
p24211
sg15
(lp24212
sg17
(lp24213
sg19
(lp24214
sg21
I0
sba(iArchitecture
Entity
p24215
(dp24216
g11
(lp24217
sg13
S'com.google.common.reflect.Types$ClassOwnership$1'
p24218
sg15
(lp24219
sg17
(lp24220
sg19
(lp24221
sg21
I0
sba(iArchitecture
Entity
p24222
(dp24223
g11
(lp24224
sg13
S'com.google.common.reflect.Types$ClassOwnership$1LocalClass'
p24225
sg15
(lp24226
sg17
(lp24227
sg19
(lp24228
sg21
I0
sba(iArchitecture
Entity
p24229
(dp24230
g11
(lp24231
sg13
S'com.google.common.reflect.Types$ClassOwnership$2'
p24232
sg15
(lp24233
sg17
(lp24234
sg19
(lp24235
sg21
I0
sba(iArchitecture
Entity
p24236
(dp24237
g11
(lp24238
sg13
S'com.google.common.reflect.Types$ClassOwnership$3'
p24239
sg15
(lp24240
sg17
(lp24241
sg19
(lp24242
sg21
I0
sba(iArchitecture
Entity
p24243
(dp24244
g11
(lp24245
sg13
S'com.google.common.reflect.Types$GenericArrayTypeImpl'
p24246
sg15
(lp24247
sg17
(lp24248
sg19
(lp24249
sg21
I0
sba(iArchitecture
Entity
p24250
(dp24251
g11
(lp24252
sg13
S'com.google.common.reflect.Types$JavaVersion'
p24253
sg15
(lp24254
sg17
(lp24255
sg19
(lp24256
sg21
I0
sba(iArchitecture
Entity
p24257
(dp24258
g11
(lp24259
sg13
S'com.google.common.reflect.Types$JavaVersion$1'
p24260
sg15
(lp24261
sg17
(lp24262
sg19
(lp24263
sg21
I0
sba(iArchitecture
Entity
p24264
(dp24265
g11
(lp24266
sg13
S'com.google.common.reflect.Types$JavaVersion$2'
p24267
sg15
(lp24268
sg17
(lp24269
sg19
(lp24270
sg21
I0
sba(iArchitecture
Entity
p24271
(dp24272
g11
(lp24273
sg13
S'com.google.common.reflect.Types$JavaVersion$3'
p24274
sg15
(lp24275
sg17
(lp24276
sg19
(lp24277
sg21
I0
sba(iArchitecture
Entity
p24278
(dp24279
g11
(lp24280
sg13
S'com.google.common.reflect.Types$JavaVersion$4'
p24281
sg15
(lp24282
sg17
(lp24283
sg19
(lp24284
sg21
I0
sba(iArchitecture
Entity
p24285
(dp24286
g11
(lp24287
sg13
S'com.google.common.reflect.Types$NativeTypeVariableEquals'
p24288
sg15
(lp24289
sg17
(lp24290
sg19
(lp24291
sg21
I0
sba(iArchitecture
Entity
p24292
(dp24293
g11
(lp24294
sg13
S'com.google.common.reflect.Types$ParameterizedTypeImpl'
p24295
sg15
(lp24296
sg17
(lp24297
sg19
(lp24298
sg21
I0
sba(iArchitecture
Entity
p24299
(dp24300
g11
(lp24301
sg13
S'com.google.common.reflect.Types$TypeVariableImpl'
p24302
sg15
(lp24303
sg17
(lp24304
sg19
(lp24305
sg21
I0
sba(iArchitecture
Entity
p24306
(dp24307
g11
(lp24308
sg13
S'com.google.common.reflect.Types$TypeVariableInvocationHandler'
p24309
sg15
(lp24310
sg17
(lp24311
sg19
(lp24312
sg21
I0
sba(iArchitecture
Entity
p24313
(dp24314
g11
(lp24315
sg13
S'com.google.common.reflect.Types$WildcardTypeImpl'
p24316
sg15
(lp24317
sg17
(lp24318
sg19
(lp24319
sg21
I0
sbasg1135
(lp24320
g23826
ag23833
ag23840
ag23847
ag23854
ag23861
ag23868
ag23875
ag23882
ag23889
ag23896
ag23903
ag23910
ag23917
ag23924
ag23931
ag23938
ag23945
ag23952
ag23959
ag23966
ag23973
ag23980
ag23987
ag23994
ag24001
ag24008
ag24015
ag24022
ag24029
ag24036
ag24043
ag24050
ag24057
ag24064
ag24071
ag24078
ag24085
ag24092
ag24099
ag24106
ag24113
ag24120
ag24127
ag24134
ag24141
ag24148
ag24155
ag24162
ag24169
ag24176
ag24183
ag24190
ag24197
ag24204
ag24211
ag24218
ag24225
ag24232
ag24239
ag24246
ag24253
ag24260
ag24267
ag24274
ag24281
ag24288
ag24295
ag24302
ag24309
ag24316
asg1137
I0
sg21
I0
sg1138
S'com.google.common.reflect.ss'
p24321
sba(iArchitecture
Cluster
p24322
(dp24323
g7
(lp24324
(iArchitecture
Entity
p24325
(dp24326
g11
(lp24327
sg13
S'com.google.common.base.Supplier'
p24328
sg15
(lp24329
sg17
(lp24330
sg19
(lp24331
sg21
I0
sba(iArchitecture
Entity
p24332
(dp24333
g11
(lp24334
sg13
S'com.google.common.collect.ForwardingObject'
p24335
sg15
(lp24336
sg17
(lp24337
sg19
(lp24338
sg21
I0
sba(iArchitecture
Entity
p24339
(dp24340
g11
(lp24341
sg13
S'com.google.common.collect.Queues'
p24342
sg15
(lp24343
sg17
(lp24344
sg19
(lp24345
sg21
I0
sba(iArchitecture
Entity
p24346
(dp24347
g11
(lp24348
sg13
S'com.google.common.util.concurrent.AbstractCatchingFuture'
p24349
sg15
(lp24350
sg17
(lp24351
sg19
(lp24352
sg21
I0
sba(iArchitecture
Entity
p24353
(dp24354
g11
(lp24355
sg13
S'com.google.common.util.concurrent.AbstractCatchingFuture$AsyncCatchingFuture'
p24356
sg15
(lp24357
sg17
(lp24358
sg19
(lp24359
sg21
I0
sba(iArchitecture
Entity
p24360
(dp24361
g11
(lp24362
sg13
S'com.google.common.util.concurrent.AbstractCatchingFuture$CatchingFuture'
p24363
sg15
(lp24364
sg17
(lp24365
sg19
(lp24366
sg21
I0
sba(iArchitecture
Entity
p24367
(dp24368
g11
(lp24369
sg13
S'com.google.common.util.concurrent.AbstractCheckedFuture'
p24370
sg15
(lp24371
sg17
(lp24372
sg19
(lp24373
sg21
I0
sba(iArchitecture
Entity
p24374
(dp24375
g11
(lp24376
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService'
p24377
sg15
(lp24378
sg17
(lp24379
sg19
(lp24380
sg21
I0
sba(iArchitecture
Entity
p24381
(dp24382
g11
(lp24383
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$1'
p24384
sg15
(lp24385
sg17
(lp24386
sg19
(lp24387
sg21
I0
sba(iArchitecture
Entity
p24388
(dp24389
g11
(lp24390
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$1$1'
p24391
sg15
(lp24392
sg17
(lp24393
sg19
(lp24394
sg21
I0
sba(iArchitecture
Entity
p24395
(dp24396
g11
(lp24397
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$1$2'
p24398
sg15
(lp24399
sg17
(lp24400
sg19
(lp24401
sg21
I0
sba(iArchitecture
Entity
p24402
(dp24403
g11
(lp24404
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$2'
p24405
sg15
(lp24406
sg17
(lp24407
sg19
(lp24408
sg21
I0
sba(iArchitecture
Entity
p24409
(dp24410
g11
(lp24411
sg13
S'com.google.common.util.concurrent.AbstractFuture'
p24412
sg15
(lp24413
sg17
(lp24414
sg19
(lp24415
sg21
I0
sba(iArchitecture
Entity
p24416
(dp24417
g11
(lp24418
sg13
S'com.google.common.util.concurrent.AbstractFuture$1'
p24419
sg15
(lp24420
sg17
(lp24421
sg19
(lp24422
sg21
I0
sba(iArchitecture
Entity
p24423
(dp24424
g11
(lp24425
sg13
S'com.google.common.util.concurrent.AbstractFuture$AtomicHelper'
p24426
sg15
(lp24427
sg17
(lp24428
sg19
(lp24429
sg21
I0
sba(iArchitecture
Entity
p24430
(dp24431
g11
(lp24432
sg13
S'com.google.common.util.concurrent.AbstractFuture$Cancellation'
p24433
sg15
(lp24434
sg17
(lp24435
sg19
(lp24436
sg21
I0
sba(iArchitecture
Entity
p24437
(dp24438
g11
(lp24439
sg13
S'com.google.common.util.concurrent.AbstractFuture$Failure'
p24440
sg15
(lp24441
sg17
(lp24442
sg19
(lp24443
sg21
I0
sba(iArchitecture
Entity
p24444
(dp24445
g11
(lp24446
sg13
S'com.google.common.util.concurrent.AbstractFuture$Failure$1'
p24447
sg15
(lp24448
sg17
(lp24449
sg19
(lp24450
sg21
I0
sba(iArchitecture
Entity
p24451
(dp24452
g11
(lp24453
sg13
S'com.google.common.util.concurrent.AbstractFuture$Listener'
p24454
sg15
(lp24455
sg17
(lp24456
sg19
(lp24457
sg21
I0
sba(iArchitecture
Entity
p24458
(dp24459
g11
(lp24460
sg13
S'com.google.common.util.concurrent.AbstractFuture$SafeAtomicHelper'
p24461
sg15
(lp24462
sg17
(lp24463
sg19
(lp24464
sg21
I0
sba(iArchitecture
Entity
p24465
(dp24466
g11
(lp24467
sg13
S'com.google.common.util.concurrent.AbstractFuture$SetFuture'
p24468
sg15
(lp24469
sg17
(lp24470
sg19
(lp24471
sg21
I0
sba(iArchitecture
Entity
p24472
(dp24473
g11
(lp24474
sg13
S'com.google.common.util.concurrent.AbstractFuture$SynchronizedHelper'
p24475
sg15
(lp24476
sg17
(lp24477
sg19
(lp24478
sg21
I0
sba(iArchitecture
Entity
p24479
(dp24480
g11
(lp24481
sg13
S'com.google.common.util.concurrent.AbstractFuture$TrustedFuture'
p24482
sg15
(lp24483
sg17
(lp24484
sg19
(lp24485
sg21
I0
sba(iArchitecture
Entity
p24486
(dp24487
g11
(lp24488
sg13
S'com.google.common.util.concurrent.AbstractFuture$UnsafeAtomicHelper'
p24489
sg15
(lp24490
sg17
(lp24491
sg19
(lp24492
sg21
I0
sba(iArchitecture
Entity
p24493
(dp24494
g11
(lp24495
sg13
S'com.google.common.util.concurrent.AbstractFuture$UnsafeAtomicHelper$1'
p24496
sg15
(lp24497
sg17
(lp24498
sg19
(lp24499
sg21
I0
sba(iArchitecture
Entity
p24500
(dp24501
g11
(lp24502
sg13
S'com.google.common.util.concurrent.AbstractFuture$Waiter'
p24503
sg15
(lp24504
sg17
(lp24505
sg19
(lp24506
sg21
I0
sba(iArchitecture
Entity
p24507
(dp24508
g11
(lp24509
sg13
S'com.google.common.util.concurrent.AbstractIdleService'
p24510
sg15
(lp24511
sg17
(lp24512
sg19
(lp24513
sg21
I0
sba(iArchitecture
Entity
p24514
(dp24515
g11
(lp24516
sg13
S'com.google.common.util.concurrent.AbstractIdleService$1'
p24517
sg15
(lp24518
sg17
(lp24519
sg19
(lp24520
sg21
I0
sba(iArchitecture
Entity
p24521
(dp24522
g11
(lp24523
sg13
S'com.google.common.util.concurrent.AbstractIdleService$DelegateService'
p24524
sg15
(lp24525
sg17
(lp24526
sg19
(lp24527
sg21
I0
sba(iArchitecture
Entity
p24528
(dp24529
g11
(lp24530
sg13
S'com.google.common.util.concurrent.AbstractIdleService$DelegateService$1'
p24531
sg15
(lp24532
sg17
(lp24533
sg19
(lp24534
sg21
I0
sba(iArchitecture
Entity
p24535
(dp24536
g11
(lp24537
sg13
S'com.google.common.util.concurrent.AbstractIdleService$DelegateService$2'
p24538
sg15
(lp24539
sg17
(lp24540
sg19
(lp24541
sg21
I0
sba(iArchitecture
Entity
p24542
(dp24543
g11
(lp24544
sg13
S'com.google.common.util.concurrent.AbstractIdleService$ThreadNameSupplier'
p24545
sg15
(lp24546
sg17
(lp24547
sg19
(lp24548
sg21
I0
sba(iArchitecture
Entity
p24549
(dp24550
g11
(lp24551
sg13
S'com.google.common.util.concurrent.AbstractListeningExecutorService'
p24552
sg15
(lp24553
sg17
(lp24554
sg19
(lp24555
sg21
I0
sba(iArchitecture
Entity
p24556
(dp24557
g11
(lp24558
sg13
S'com.google.common.util.concurrent.AbstractScheduledService'
p24559
sg15
(lp24560
sg17
(lp24561
sg19
(lp24562
sg21
I0
sba(iArchitecture
Entity
p24563
(dp24564
g11
(lp24565
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$1'
p24566
sg15
(lp24567
sg17
(lp24568
sg19
(lp24569
sg21
I0
sba(iArchitecture
Entity
p24570
(dp24571
g11
(lp24572
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$1ThreadFactoryImpl'
p24573
sg15
(lp24574
sg17
(lp24575
sg19
(lp24576
sg21
I0
sba(iArchitecture
Entity
p24577
(dp24578
g11
(lp24579
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$CustomScheduler'
p24580
sg15
(lp24581
sg17
(lp24582
sg19
(lp24583
sg21
I0
sba(iArchitecture
Entity
p24584
(dp24585
g11
(lp24586
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$CustomScheduler$ReschedulableCallable'
p24587
sg15
(lp24588
sg17
(lp24589
sg19
(lp24590
sg21
I0
sba(iArchitecture
Entity
p24591
(dp24592
g11
(lp24593
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$CustomScheduler$Schedule'
p24594
sg15
(lp24595
sg17
(lp24596
sg19
(lp24597
sg21
I0
sba(iArchitecture
Entity
p24598
(dp24599
g11
(lp24600
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$Scheduler'
p24601
sg15
(lp24602
sg17
(lp24603
sg19
(lp24604
sg21
I0
sba(iArchitecture
Entity
p24605
(dp24606
g11
(lp24607
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$Scheduler$1'
p24608
sg15
(lp24609
sg17
(lp24610
sg19
(lp24611
sg21
I0
sba(iArchitecture
Entity
p24612
(dp24613
g11
(lp24614
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$Scheduler$2'
p24615
sg15
(lp24616
sg17
(lp24617
sg19
(lp24618
sg21
I0
sba(iArchitecture
Entity
p24619
(dp24620
g11
(lp24621
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$ServiceDelegate'
p24622
sg15
(lp24623
sg17
(lp24624
sg19
(lp24625
sg21
I0
sba(iArchitecture
Entity
p24626
(dp24627
g11
(lp24628
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$ServiceDelegate$1'
p24629
sg15
(lp24630
sg17
(lp24631
sg19
(lp24632
sg21
I0
sba(iArchitecture
Entity
p24633
(dp24634
g11
(lp24635
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$ServiceDelegate$2'
p24636
sg15
(lp24637
sg17
(lp24638
sg19
(lp24639
sg21
I0
sba(iArchitecture
Entity
p24640
(dp24641
g11
(lp24642
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$ServiceDelegate$3'
p24643
sg15
(lp24644
sg17
(lp24645
sg19
(lp24646
sg21
I0
sba(iArchitecture
Entity
p24647
(dp24648
g11
(lp24649
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$ServiceDelegate$Task'
p24650
sg15
(lp24651
sg17
(lp24652
sg19
(lp24653
sg21
I0
sba(iArchitecture
Entity
p24654
(dp24655
g11
(lp24656
sg13
S'com.google.common.util.concurrent.AbstractService'
p24657
sg15
(lp24658
sg17
(lp24659
sg19
(lp24660
sg21
I0
sba(iArchitecture
Entity
p24661
(dp24662
g11
(lp24663
sg13
S'com.google.common.util.concurrent.AbstractService$1'
p24664
sg15
(lp24665
sg17
(lp24666
sg19
(lp24667
sg21
I0
sba(iArchitecture
Entity
p24668
(dp24669
g11
(lp24670
sg13
S'com.google.common.util.concurrent.AbstractService$2'
p24671
sg15
(lp24672
sg17
(lp24673
sg19
(lp24674
sg21
I0
sba(iArchitecture
Entity
p24675
(dp24676
g11
(lp24677
sg13
S'com.google.common.util.concurrent.AbstractService$3'
p24678
sg15
(lp24679
sg17
(lp24680
sg19
(lp24681
sg21
I0
sba(iArchitecture
Entity
p24682
(dp24683
g11
(lp24684
sg13
S'com.google.common.util.concurrent.AbstractService$4'
p24685
sg15
(lp24686
sg17
(lp24687
sg19
(lp24688
sg21
I0
sba(iArchitecture
Entity
p24689
(dp24690
g11
(lp24691
sg13
S'com.google.common.util.concurrent.AbstractService$5'
p24692
sg15
(lp24693
sg17
(lp24694
sg19
(lp24695
sg21
I0
sba(iArchitecture
Entity
p24696
(dp24697
g11
(lp24698
sg13
S'com.google.common.util.concurrent.AbstractService$6'
p24699
sg15
(lp24700
sg17
(lp24701
sg19
(lp24702
sg21
I0
sba(iArchitecture
Entity
p24703
(dp24704
g11
(lp24705
sg13
S'com.google.common.util.concurrent.AbstractService$HasReachedRunningGuard'
p24706
sg15
(lp24707
sg17
(lp24708
sg19
(lp24709
sg21
I0
sba(iArchitecture
Entity
p24710
(dp24711
g11
(lp24712
sg13
S'com.google.common.util.concurrent.AbstractService$IsStartableGuard'
p24713
sg15
(lp24714
sg17
(lp24715
sg19
(lp24716
sg21
I0
sba(iArchitecture
Entity
p24717
(dp24718
g11
(lp24719
sg13
S'com.google.common.util.concurrent.AbstractService$IsStoppableGuard'
p24720
sg15
(lp24721
sg17
(lp24722
sg19
(lp24723
sg21
I0
sba(iArchitecture
Entity
p24724
(dp24725
g11
(lp24726
sg13
S'com.google.common.util.concurrent.AbstractService$IsStoppedGuard'
p24727
sg15
(lp24728
sg17
(lp24729
sg19
(lp24730
sg21
I0
sba(iArchitecture
Entity
p24731
(dp24732
g11
(lp24733
sg13
S'com.google.common.util.concurrent.AbstractService$StateSnapshot'
p24734
sg15
(lp24735
sg17
(lp24736
sg19
(lp24737
sg21
I0
sba(iArchitecture
Entity
p24738
(dp24739
g11
(lp24740
sg13
S'com.google.common.util.concurrent.AbstractTransformFuture'
p24741
sg15
(lp24742
sg17
(lp24743
sg19
(lp24744
sg21
I0
sba(iArchitecture
Entity
p24745
(dp24746
g11
(lp24747
sg13
S'com.google.common.util.concurrent.AbstractTransformFuture$AsyncTransformFuture'
p24748
sg15
(lp24749
sg17
(lp24750
sg19
(lp24751
sg21
I0
sba(iArchitecture
Entity
p24752
(dp24753
g11
(lp24754
sg13
S'com.google.common.util.concurrent.AbstractTransformFuture$TransformFuture'
p24755
sg15
(lp24756
sg17
(lp24757
sg19
(lp24758
sg21
I0
sba(iArchitecture
Entity
p24759
(dp24760
g11
(lp24761
sg13
S'com.google.common.util.concurrent.AggregateFuture'
p24762
sg15
(lp24763
sg17
(lp24764
sg19
(lp24765
sg21
I0
sba(iArchitecture
Entity
p24766
(dp24767
g11
(lp24768
sg13
S'com.google.common.util.concurrent.AggregateFuture$RunningState'
p24769
sg15
(lp24770
sg17
(lp24771
sg19
(lp24772
sg21
I0
sba(iArchitecture
Entity
p24773
(dp24774
g11
(lp24775
sg13
S'com.google.common.util.concurrent.AggregateFuture$RunningState$1'
p24776
sg15
(lp24777
sg17
(lp24778
sg19
(lp24779
sg21
I0
sba(iArchitecture
Entity
p24780
(dp24781
g11
(lp24782
sg13
S'com.google.common.util.concurrent.AggregateFutureState'
p24783
sg15
(lp24784
sg17
(lp24785
sg19
(lp24786
sg21
I0
sba(iArchitecture
Entity
p24787
(dp24788
g11
(lp24789
sg13
S'com.google.common.util.concurrent.AggregateFutureState$1'
p24790
sg15
(lp24791
sg17
(lp24792
sg19
(lp24793
sg21
I0
sba(iArchitecture
Entity
p24794
(dp24795
g11
(lp24796
sg13
S'com.google.common.util.concurrent.AggregateFutureState$AtomicHelper'
p24797
sg15
(lp24798
sg17
(lp24799
sg19
(lp24800
sg21
I0
sba(iArchitecture
Entity
p24801
(dp24802
g11
(lp24803
sg13
S'com.google.common.util.concurrent.AggregateFutureState$SafeAtomicHelper'
p24804
sg15
(lp24805
sg17
(lp24806
sg19
(lp24807
sg21
I0
sba(iArchitecture
Entity
p24808
(dp24809
g11
(lp24810
sg13
S'com.google.common.util.concurrent.AggregateFutureState$SynchronizedAtomicHelper'
p24811
sg15
(lp24812
sg17
(lp24813
sg19
(lp24814
sg21
I0
sba(iArchitecture
Entity
p24815
(dp24816
g11
(lp24817
sg13
S'com.google.common.util.concurrent.AsyncCallable'
p24818
sg15
(lp24819
sg17
(lp24820
sg19
(lp24821
sg21
I0
sba(iArchitecture
Entity
p24822
(dp24823
g11
(lp24824
sg13
S'com.google.common.util.concurrent.AsyncFunction'
p24825
sg15
(lp24826
sg17
(lp24827
sg19
(lp24828
sg21
I0
sba(iArchitecture
Entity
p24829
(dp24830
g11
(lp24831
sg13
S'com.google.common.util.concurrent.AtomicLongMap'
p24832
sg15
(lp24833
sg17
(lp24834
sg19
(lp24835
sg21
I0
sba(iArchitecture
Entity
p24836
(dp24837
g11
(lp24838
sg13
S'com.google.common.util.concurrent.AtomicLongMap$1'
p24839
sg15
(lp24840
sg17
(lp24841
sg19
(lp24842
sg21
I0
sba(iArchitecture
Entity
p24843
(dp24844
g11
(lp24845
sg13
S'com.google.common.util.concurrent.Callables'
p24846
sg15
(lp24847
sg17
(lp24848
sg19
(lp24849
sg21
I0
sba(iArchitecture
Entity
p24850
(dp24851
g11
(lp24852
sg13
S'com.google.common.util.concurrent.Callables$1'
p24853
sg15
(lp24854
sg17
(lp24855
sg19
(lp24856
sg21
I0
sba(iArchitecture
Entity
p24857
(dp24858
g11
(lp24859
sg13
S'com.google.common.util.concurrent.Callables$2'
p24860
sg15
(lp24861
sg17
(lp24862
sg19
(lp24863
sg21
I0
sba(iArchitecture
Entity
p24864
(dp24865
g11
(lp24866
sg13
S'com.google.common.util.concurrent.Callables$3'
p24867
sg15
(lp24868
sg17
(lp24869
sg19
(lp24870
sg21
I0
sba(iArchitecture
Entity
p24871
(dp24872
g11
(lp24873
sg13
S'com.google.common.util.concurrent.Callables$4'
p24874
sg15
(lp24875
sg17
(lp24876
sg19
(lp24877
sg21
I0
sba(iArchitecture
Entity
p24878
(dp24879
g11
(lp24880
sg13
S'com.google.common.util.concurrent.CheckedFuture'
p24881
sg15
(lp24882
sg17
(lp24883
sg19
(lp24884
sg21
I0
sba(iArchitecture
Entity
p24885
(dp24886
g11
(lp24887
sg13
S'com.google.common.util.concurrent.CollectionFuture'
p24888
sg15
(lp24889
sg17
(lp24890
sg19
(lp24891
sg21
I0
sba(iArchitecture
Entity
p24892
(dp24893
g11
(lp24894
sg13
S'com.google.common.util.concurrent.CollectionFuture$CollectionFutureRunningState'
p24895
sg15
(lp24896
sg17
(lp24897
sg19
(lp24898
sg21
I0
sba(iArchitecture
Entity
p24899
(dp24900
g11
(lp24901
sg13
S'com.google.common.util.concurrent.CollectionFuture$ListFuture'
p24902
sg15
(lp24903
sg17
(lp24904
sg19
(lp24905
sg21
I0
sba(iArchitecture
Entity
p24906
(dp24907
g11
(lp24908
sg13
S'com.google.common.util.concurrent.CollectionFuture$ListFuture$ListFutureRunningState'
p24909
sg15
(lp24910
sg17
(lp24911
sg19
(lp24912
sg21
I0
sba(iArchitecture
Entity
p24913
(dp24914
g11
(lp24915
sg13
S'com.google.common.util.concurrent.CombinedFuture'
p24916
sg15
(lp24917
sg17
(lp24918
sg19
(lp24919
sg21
I0
sba(iArchitecture
Entity
p24920
(dp24921
g11
(lp24922
sg13
S'com.google.common.util.concurrent.CombinedFuture$AsyncCallableInterruptibleTask'
p24923
sg15
(lp24924
sg17
(lp24925
sg19
(lp24926
sg21
I0
sba(iArchitecture
Entity
p24927
(dp24928
g11
(lp24929
sg13
S'com.google.common.util.concurrent.CombinedFuture$CallableInterruptibleTask'
p24930
sg15
(lp24931
sg17
(lp24932
sg19
(lp24933
sg21
I0
sba(iArchitecture
Entity
p24934
(dp24935
g11
(lp24936
sg13
S'com.google.common.util.concurrent.CombinedFuture$CombinedFutureInterruptibleTask'
p24937
sg15
(lp24938
sg17
(lp24939
sg19
(lp24940
sg21
I0
sba(iArchitecture
Entity
p24941
(dp24942
g11
(lp24943
sg13
S'com.google.common.util.concurrent.CombinedFuture$CombinedFutureRunningState'
p24944
sg15
(lp24945
sg17
(lp24946
sg19
(lp24947
sg21
I0
sba(iArchitecture
Entity
p24948
(dp24949
g11
(lp24950
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory'
p24951
sg15
(lp24952
sg17
(lp24953
sg19
(lp24954
sg21
I0
sba(iArchitecture
Entity
p24955
(dp24956
g11
(lp24957
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$1'
p24958
sg15
(lp24959
sg17
(lp24960
sg19
(lp24961
sg21
I0
sba(iArchitecture
Entity
p24962
(dp24963
g11
(lp24964
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingLock'
p24965
sg15
(lp24966
sg17
(lp24967
sg19
(lp24968
sg21
I0
sba(iArchitecture
Entity
p24969
(dp24970
g11
(lp24971
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantLock'
p24972
sg15
(lp24973
sg17
(lp24974
sg19
(lp24975
sg21
I0
sba(iArchitecture
Entity
p24976
(dp24977
g11
(lp24978
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantReadLock'
p24979
sg15
(lp24980
sg17
(lp24981
sg19
(lp24982
sg21
I0
sba(iArchitecture
Entity
p24983
(dp24984
g11
(lp24985
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantReadWriteLock'
p24986
sg15
(lp24987
sg17
(lp24988
sg19
(lp24989
sg21
I0
sba(iArchitecture
Entity
p24990
(dp24991
g11
(lp24992
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantWriteLock'
p24993
sg15
(lp24994
sg17
(lp24995
sg19
(lp24996
sg21
I0
sba(iArchitecture
Entity
p24997
(dp24998
g11
(lp24999
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$ExampleStackTrace'
p25000
sg15
(lp25001
sg17
(lp25002
sg19
(lp25003
sg21
I0
sba(iArchitecture
Entity
p25004
(dp25005
g11
(lp25006
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$LockGraphNode'
p25007
sg15
(lp25008
sg17
(lp25009
sg19
(lp25010
sg21
I0
sba(iArchitecture
Entity
p25011
(dp25012
g11
(lp25013
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies'
p25014
sg15
(lp25015
sg17
(lp25016
sg19
(lp25017
sg21
I0
sba(iArchitecture
Entity
p25018
(dp25019
g11
(lp25020
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies$1'
p25021
sg15
(lp25022
sg17
(lp25023
sg19
(lp25024
sg21
I0
sba(iArchitecture
Entity
p25025
(dp25026
g11
(lp25027
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies$2'
p25028
sg15
(lp25029
sg17
(lp25030
sg19
(lp25031
sg21
I0
sba(iArchitecture
Entity
p25032
(dp25033
g11
(lp25034
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies$3'
p25035
sg15
(lp25036
sg17
(lp25037
sg19
(lp25038
sg21
I0
sba(iArchitecture
Entity
p25039
(dp25040
g11
(lp25041
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policy'
p25042
sg15
(lp25043
sg17
(lp25044
sg19
(lp25045
sg21
I0
sba(iArchitecture
Entity
p25046
(dp25047
g11
(lp25048
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$PotentialDeadlockException'
p25049
sg15
(lp25050
sg17
(lp25051
sg19
(lp25052
sg21
I0
sba(iArchitecture
Entity
p25053
(dp25054
g11
(lp25055
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$WithExplicitOrdering'
p25056
sg15
(lp25057
sg17
(lp25058
sg19
(lp25059
sg21
I0
sba(iArchitecture
Entity
p25060
(dp25061
g11
(lp25062
sg13
S'com.google.common.util.concurrent.ExecutionError'
p25063
sg15
(lp25064
sg17
(lp25065
sg19
(lp25066
sg21
I0
sba(iArchitecture
Entity
p25067
(dp25068
g11
(lp25069
sg13
S'com.google.common.util.concurrent.ExecutionList'
p25070
sg15
(lp25071
sg17
(lp25072
sg19
(lp25073
sg21
I0
sba(iArchitecture
Entity
p25074
(dp25075
g11
(lp25076
sg13
S'com.google.common.util.concurrent.ExecutionList$RunnableExecutorPair'
p25077
sg15
(lp25078
sg17
(lp25079
sg19
(lp25080
sg21
I0
sba(iArchitecture
Entity
p25081
(dp25082
g11
(lp25083
sg13
S'com.google.common.util.concurrent.ForwardingCheckedFuture'
p25084
sg15
(lp25085
sg17
(lp25086
sg19
(lp25087
sg21
I0
sba(iArchitecture
Entity
p25088
(dp25089
g11
(lp25090
sg13
S'com.google.common.util.concurrent.ForwardingCheckedFuture$SimpleForwardingCheckedFuture'
p25091
sg15
(lp25092
sg17
(lp25093
sg19
(lp25094
sg21
I0
sba(iArchitecture
Entity
p25095
(dp25096
g11
(lp25097
sg13
S'com.google.common.util.concurrent.ForwardingExecutorService'
p25098
sg15
(lp25099
sg17
(lp25100
sg19
(lp25101
sg21
I0
sba(iArchitecture
Entity
p25102
(dp25103
g11
(lp25104
sg13
S'com.google.common.util.concurrent.ForwardingFuture'
p25105
sg15
(lp25106
sg17
(lp25107
sg19
(lp25108
sg21
I0
sba(iArchitecture
Entity
p25109
(dp25110
g11
(lp25111
sg13
S'com.google.common.util.concurrent.ForwardingFuture$SimpleForwardingFuture'
p25112
sg15
(lp25113
sg17
(lp25114
sg19
(lp25115
sg21
I0
sba(iArchitecture
Entity
p25116
(dp25117
g11
(lp25118
sg13
S'com.google.common.util.concurrent.ForwardingListenableFuture'
p25119
sg15
(lp25120
sg17
(lp25121
sg19
(lp25122
sg21
I0
sba(iArchitecture
Entity
p25123
(dp25124
g11
(lp25125
sg13
S'com.google.common.util.concurrent.ForwardingListenableFuture$SimpleForwardingListenableFuture'
p25126
sg15
(lp25127
sg17
(lp25128
sg19
(lp25129
sg21
I0
sba(iArchitecture
Entity
p25130
(dp25131
g11
(lp25132
sg13
S'com.google.common.util.concurrent.ForwardingListeningExecutorService'
p25133
sg15
(lp25134
sg17
(lp25135
sg19
(lp25136
sg21
I0
sba(iArchitecture
Entity
p25137
(dp25138
g11
(lp25139
sg13
S'com.google.common.util.concurrent.FutureCallback'
p25140
sg15
(lp25141
sg17
(lp25142
sg19
(lp25143
sg21
I0
sba(iArchitecture
Entity
p25144
(dp25145
g11
(lp25146
sg13
S'com.google.common.util.concurrent.Futures'
p25147
sg15
(lp25148
sg17
(lp25149
sg19
(lp25150
sg21
I0
sba(iArchitecture
Entity
p25151
(dp25152
g11
(lp25153
sg13
S'com.google.common.util.concurrent.Futures$1'
p25154
sg15
(lp25155
sg17
(lp25156
sg19
(lp25157
sg21
I0
sba(iArchitecture
Entity
p25158
(dp25159
g11
(lp25160
sg13
S'com.google.common.util.concurrent.Futures$2'
p25161
sg15
(lp25162
sg17
(lp25163
sg19
(lp25164
sg21
I0
sba(iArchitecture
Entity
p25165
(dp25166
g11
(lp25167
sg13
S'com.google.common.util.concurrent.Futures$3'
p25168
sg15
(lp25169
sg17
(lp25170
sg19
(lp25171
sg21
I0
sba(iArchitecture
Entity
p25172
(dp25173
g11
(lp25174
sg13
S'com.google.common.util.concurrent.Futures$4'
p25175
sg15
(lp25176
sg17
(lp25177
sg19
(lp25178
sg21
I0
sba(iArchitecture
Entity
p25179
(dp25180
g11
(lp25181
sg13
S'com.google.common.util.concurrent.Futures$FutureCombiner'
p25182
sg15
(lp25183
sg17
(lp25184
sg19
(lp25185
sg21
I0
sba(iArchitecture
Entity
p25186
(dp25187
g11
(lp25188
sg13
S'com.google.common.util.concurrent.Futures$MappingCheckedFuture'
p25189
sg15
(lp25190
sg17
(lp25191
sg19
(lp25192
sg21
I0
sba(iArchitecture
Entity
p25193
(dp25194
g11
(lp25195
sg13
S'com.google.common.util.concurrent.Futures$NonCancellationPropagatingFuture'
p25196
sg15
(lp25197
sg17
(lp25198
sg19
(lp25199
sg21
I0
sba(iArchitecture
Entity
p25200
(dp25201
g11
(lp25202
sg13
S'com.google.common.util.concurrent.Futures$NonCancellationPropagatingFuture$1'
p25203
sg15
(lp25204
sg17
(lp25205
sg19
(lp25206
sg21
I0
sba(iArchitecture
Entity
p25207
(dp25208
g11
(lp25209
sg13
S'com.google.common.util.concurrent.FuturesGetChecked'
p25210
sg15
(lp25211
sg17
(lp25212
sg19
(lp25213
sg21
I0
sba(iArchitecture
Entity
p25214
(dp25215
g11
(lp25216
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$1'
p25217
sg15
(lp25218
sg17
(lp25219
sg19
(lp25220
sg21
I0
sba(iArchitecture
Entity
p25221
(dp25222
g11
(lp25223
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidator'
p25224
sg15
(lp25225
sg17
(lp25226
sg19
(lp25227
sg21
I0
sba(iArchitecture
Entity
p25228
(dp25229
g11
(lp25230
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder'
p25231
sg15
(lp25232
sg17
(lp25233
sg19
(lp25234
sg21
I0
sba(iArchitecture
Entity
p25235
(dp25236
g11
(lp25237
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder$ClassValueValidator'
p25238
sg15
(lp25239
sg17
(lp25240
sg19
(lp25241
sg21
I0
sba(iArchitecture
Entity
p25242
(dp25243
g11
(lp25244
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder$ClassValueValidator$1'
p25245
sg15
(lp25246
sg17
(lp25247
sg19
(lp25248
sg21
I0
sba(iArchitecture
Entity
p25249
(dp25250
g11
(lp25251
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder$WeakSetValidator'
p25252
sg15
(lp25253
sg17
(lp25254
sg19
(lp25255
sg21
I0
sba(iArchitecture
Entity
p25256
(dp25257
g11
(lp25258
sg13
S'com.google.common.util.concurrent.GwtFuturesCatchingSpecialization'
p25259
sg15
(lp25260
sg17
(lp25261
sg19
(lp25262
sg21
I0
sba(iArchitecture
Entity
p25263
(dp25264
g11
(lp25265
sg13
S'com.google.common.util.concurrent.ImmediateFuture'
p25266
sg15
(lp25267
sg17
(lp25268
sg19
(lp25269
sg21
I0
sba(iArchitecture
Entity
p25270
(dp25271
g11
(lp25272
sg13
S'com.google.common.util.concurrent.ImmediateFuture$ImmediateCancelledFuture'
p25273
sg15
(lp25274
sg17
(lp25275
sg19
(lp25276
sg21
I0
sba(iArchitecture
Entity
p25277
(dp25278
g11
(lp25279
sg13
S'com.google.common.util.concurrent.ImmediateFuture$ImmediateFailedCheckedFuture'
p25280
sg15
(lp25281
sg17
(lp25282
sg19
(lp25283
sg21
I0
sba(iArchitecture
Entity
p25284
(dp25285
g11
(lp25286
sg13
S'com.google.common.util.concurrent.ImmediateFuture$ImmediateFailedFuture'
p25287
sg15
(lp25288
sg17
(lp25289
sg19
(lp25290
sg21
I0
sba(iArchitecture
Entity
p25291
(dp25292
g11
(lp25293
sg13
S'com.google.common.util.concurrent.ImmediateFuture$ImmediateSuccessfulCheckedFuture'
p25294
sg15
(lp25295
sg17
(lp25296
sg19
(lp25297
sg21
I0
sba(iArchitecture
Entity
p25298
(dp25299
g11
(lp25300
sg13
S'com.google.common.util.concurrent.ImmediateFuture$ImmediateSuccessfulFuture'
p25301
sg15
(lp25302
sg17
(lp25303
sg19
(lp25304
sg21
I0
sba(iArchitecture
Entity
p25305
(dp25306
g11
(lp25307
sg13
S'com.google.common.util.concurrent.InterruptibleTask'
p25308
sg15
(lp25309
sg17
(lp25310
sg19
(lp25311
sg21
I0
sba(iArchitecture
Entity
p25312
(dp25313
g11
(lp25314
sg13
S'com.google.common.util.concurrent.InterruptibleTask$1'
p25315
sg15
(lp25316
sg17
(lp25317
sg19
(lp25318
sg21
I0
sba(iArchitecture
Entity
p25319
(dp25320
g11
(lp25321
sg13
S'com.google.common.util.concurrent.InterruptibleTask$AtomicHelper'
p25322
sg15
(lp25323
sg17
(lp25324
sg19
(lp25325
sg21
I0
sba(iArchitecture
Entity
p25326
(dp25327
g11
(lp25328
sg13
S'com.google.common.util.concurrent.InterruptibleTask$SafeAtomicHelper'
p25329
sg15
(lp25330
sg17
(lp25331
sg19
(lp25332
sg21
I0
sba(iArchitecture
Entity
p25333
(dp25334
g11
(lp25335
sg13
S'com.google.common.util.concurrent.InterruptibleTask$SynchronizedAtomicHelper'
p25336
sg15
(lp25337
sg17
(lp25338
sg19
(lp25339
sg21
I0
sba(iArchitecture
Entity
p25340
(dp25341
g11
(lp25342
sg13
S'com.google.common.util.concurrent.JdkFutureAdapters'
p25343
sg15
(lp25344
sg17
(lp25345
sg19
(lp25346
sg21
I0
sba(iArchitecture
Entity
p25347
(dp25348
g11
(lp25349
sg13
S'com.google.common.util.concurrent.JdkFutureAdapters$ListenableFutureAdapter'
p25350
sg15
(lp25351
sg17
(lp25352
sg19
(lp25353
sg21
I0
sba(iArchitecture
Entity
p25354
(dp25355
g11
(lp25356
sg13
S'com.google.common.util.concurrent.JdkFutureAdapters$ListenableFutureAdapter$1'
p25357
sg15
(lp25358
sg17
(lp25359
sg19
(lp25360
sg21
I0
sba(iArchitecture
Entity
p25361
(dp25362
g11
(lp25363
sg13
S'com.google.common.util.concurrent.ListenableFuture'
p25364
sg15
(lp25365
sg17
(lp25366
sg19
(lp25367
sg21
I0
sba(iArchitecture
Entity
p25368
(dp25369
g11
(lp25370
sg13
S'com.google.common.util.concurrent.ListenableScheduledFuture'
p25371
sg15
(lp25372
sg17
(lp25373
sg19
(lp25374
sg21
I0
sba(iArchitecture
Entity
p25375
(dp25376
g11
(lp25377
sg13
S'com.google.common.util.concurrent.ListenerCallQueue'
p25378
sg15
(lp25379
sg17
(lp25380
sg19
(lp25381
sg21
I0
sba(iArchitecture
Entity
p25382
(dp25383
g11
(lp25384
sg13
S'com.google.common.util.concurrent.ListenerCallQueue$Callback'
p25385
sg15
(lp25386
sg17
(lp25387
sg19
(lp25388
sg21
I0
sba(iArchitecture
Entity
p25389
(dp25390
g11
(lp25391
sg13
S'com.google.common.util.concurrent.ListeningExecutorService'
p25392
sg15
(lp25393
sg17
(lp25394
sg19
(lp25395
sg21
I0
sba(iArchitecture
Entity
p25396
(dp25397
g11
(lp25398
sg13
S'com.google.common.util.concurrent.ListeningScheduledExecutorService'
p25399
sg15
(lp25400
sg17
(lp25401
sg19
(lp25402
sg21
I0
sba(iArchitecture
Entity
p25403
(dp25404
g11
(lp25405
sg13
S'com.google.common.util.concurrent.Monitor'
p25406
sg15
(lp25407
sg17
(lp25408
sg19
(lp25409
sg21
I0
sba(iArchitecture
Entity
p25410
(dp25411
g11
(lp25412
sg13
S'com.google.common.util.concurrent.Monitor$Guard'
p25413
sg15
(lp25414
sg17
(lp25415
sg19
(lp25416
sg21
I0
sba(iArchitecture
Entity
p25417
(dp25418
g11
(lp25419
sg13
S'com.google.common.util.concurrent.MoreExecutors'
p25420
sg15
(lp25421
sg17
(lp25422
sg19
(lp25423
sg21
I0
sba(iArchitecture
Entity
p25424
(dp25425
g11
(lp25426
sg13
S'com.google.common.util.concurrent.MoreExecutors$1'
p25427
sg15
(lp25428
sg17
(lp25429
sg19
(lp25430
sg21
I0
sba(iArchitecture
Entity
p25431
(dp25432
g11
(lp25433
sg13
S'com.google.common.util.concurrent.MoreExecutors$2'
p25434
sg15
(lp25435
sg17
(lp25436
sg19
(lp25437
sg21
I0
sba(iArchitecture
Entity
p25438
(dp25439
g11
(lp25440
sg13
S'com.google.common.util.concurrent.MoreExecutors$3'
p25441
sg15
(lp25442
sg17
(lp25443
sg19
(lp25444
sg21
I0
sba(iArchitecture
Entity
p25445
(dp25446
g11
(lp25447
sg13
S'com.google.common.util.concurrent.MoreExecutors$4'
p25448
sg15
(lp25449
sg17
(lp25450
sg19
(lp25451
sg21
I0
sba(iArchitecture
Entity
p25452
(dp25453
g11
(lp25454
sg13
S'com.google.common.util.concurrent.MoreExecutors$5'
p25455
sg15
(lp25456
sg17
(lp25457
sg19
(lp25458
sg21
I0
sba(iArchitecture
Entity
p25459
(dp25460
g11
(lp25461
sg13
S'com.google.common.util.concurrent.MoreExecutors$5$1'
p25462
sg15
(lp25463
sg17
(lp25464
sg19
(lp25465
sg21
I0
sba(iArchitecture
Entity
p25466
(dp25467
g11
(lp25468
sg13
S'com.google.common.util.concurrent.MoreExecutors$Application'
p25469
sg15
(lp25470
sg17
(lp25471
sg19
(lp25472
sg21
I0
sba(iArchitecture
Entity
p25473
(dp25474
g11
(lp25475
sg13
S'com.google.common.util.concurrent.MoreExecutors$Application$1'
p25476
sg15
(lp25477
sg17
(lp25478
sg19
(lp25479
sg21
I0
sba(iArchitecture
Entity
p25480
(dp25481
g11
(lp25482
sg13
S'com.google.common.util.concurrent.MoreExecutors$DirectExecutor'
p25483
sg15
(lp25484
sg17
(lp25485
sg19
(lp25486
sg21
I0
sba(iArchitecture
Entity
p25487
(dp25488
g11
(lp25489
sg13
S'com.google.common.util.concurrent.MoreExecutors$DirectExecutorService'
p25490
sg15
(lp25491
sg17
(lp25492
sg19
(lp25493
sg21
I0
sba(iArchitecture
Entity
p25494
(dp25495
g11
(lp25496
sg13
S'com.google.common.util.concurrent.MoreExecutors$ListeningDecorator'
p25497
sg15
(lp25498
sg17
(lp25499
sg19
(lp25500
sg21
I0
sba(iArchitecture
Entity
p25501
(dp25502
g11
(lp25503
sg13
S'com.google.common.util.concurrent.MoreExecutors$ScheduledListeningDecorator'
p25504
sg15
(lp25505
sg17
(lp25506
sg19
(lp25507
sg21
I0
sba(iArchitecture
Entity
p25508
(dp25509
g11
(lp25510
sg13
S'com.google.common.util.concurrent.MoreExecutors$ScheduledListeningDecorator$ListenableScheduledTask'
p25511
sg15
(lp25512
sg17
(lp25513
sg19
(lp25514
sg21
I0
sba(iArchitecture
Entity
p25515
(dp25516
g11
(lp25517
sg13
S'com.google.common.util.concurrent.MoreExecutors$ScheduledListeningDecorator$NeverSuccessfulListenableFutureTask'
p25518
sg15
(lp25519
sg17
(lp25520
sg19
(lp25521
sg21
I0
sba(iArchitecture
Entity
p25522
(dp25523
g11
(lp25524
sg13
S'com.google.common.util.concurrent.Partially'
p25525
sg15
(lp25526
sg17
(lp25527
sg19
(lp25528
sg21
I0
sba(iArchitecture
Entity
p25529
(dp25530
g11
(lp25531
sg13
S'com.google.common.util.concurrent.Partially$GwtIncompatible'
p25532
sg15
(lp25533
sg17
(lp25534
sg19
(lp25535
sg21
I0
sba(iArchitecture
Entity
p25536
(dp25537
g11
(lp25538
sg13
S'com.google.common.util.concurrent.Platform'
p25539
sg15
(lp25540
sg17
(lp25541
sg19
(lp25542
sg21
I0
sba(iArchitecture
Entity
p25543
(dp25544
g11
(lp25545
sg13
S'com.google.common.util.concurrent.RateLimiter'
p25546
sg15
(lp25547
sg17
(lp25548
sg19
(lp25549
sg21
I0
sba(iArchitecture
Entity
p25550
(dp25551
g11
(lp25552
sg13
S'com.google.common.util.concurrent.RateLimiter$SleepingStopwatch'
p25553
sg15
(lp25554
sg17
(lp25555
sg19
(lp25556
sg21
I0
sba(iArchitecture
Entity
p25557
(dp25558
g11
(lp25559
sg13
S'com.google.common.util.concurrent.RateLimiter$SleepingStopwatch$1'
p25560
sg15
(lp25561
sg17
(lp25562
sg19
(lp25563
sg21
I0
sba(iArchitecture
Entity
p25564
(dp25565
g11
(lp25566
sg13
S'com.google.common.util.concurrent.Runnables'
p25567
sg15
(lp25568
sg17
(lp25569
sg19
(lp25570
sg21
I0
sba(iArchitecture
Entity
p25571
(dp25572
g11
(lp25573
sg13
S'com.google.common.util.concurrent.Runnables$1'
p25574
sg15
(lp25575
sg17
(lp25576
sg19
(lp25577
sg21
I0
sba(iArchitecture
Entity
p25578
(dp25579
g11
(lp25580
sg13
S'com.google.common.util.concurrent.SerializingExecutor'
p25581
sg15
(lp25582
sg17
(lp25583
sg19
(lp25584
sg21
I0
sba(iArchitecture
Entity
p25585
(dp25586
g11
(lp25587
sg13
S'com.google.common.util.concurrent.SerializingExecutor$1'
p25588
sg15
(lp25589
sg17
(lp25590
sg19
(lp25591
sg21
I0
sba(iArchitecture
Entity
p25592
(dp25593
g11
(lp25594
sg13
S'com.google.common.util.concurrent.SerializingExecutor$QueueWorker'
p25595
sg15
(lp25596
sg17
(lp25597
sg19
(lp25598
sg21
I0
sba(iArchitecture
Entity
p25599
(dp25600
g11
(lp25601
sg13
S'com.google.common.util.concurrent.Service'
p25602
sg15
(lp25603
sg17
(lp25604
sg19
(lp25605
sg21
I0
sba(iArchitecture
Entity
p25606
(dp25607
g11
(lp25608
sg13
S'com.google.common.util.concurrent.Service$1'
p25609
sg15
(lp25610
sg17
(lp25611
sg19
(lp25612
sg21
I0
sba(iArchitecture
Entity
p25613
(dp25614
g11
(lp25615
sg13
S'com.google.common.util.concurrent.Service$Listener'
p25616
sg15
(lp25617
sg17
(lp25618
sg19
(lp25619
sg21
I0
sba(iArchitecture
Entity
p25620
(dp25621
g11
(lp25622
sg13
S'com.google.common.util.concurrent.Service$State'
p25623
sg15
(lp25624
sg17
(lp25625
sg19
(lp25626
sg21
I0
sba(iArchitecture
Entity
p25627
(dp25628
g11
(lp25629
sg13
S'com.google.common.util.concurrent.Service$State$1'
p25630
sg15
(lp25631
sg17
(lp25632
sg19
(lp25633
sg21
I0
sba(iArchitecture
Entity
p25634
(dp25635
g11
(lp25636
sg13
S'com.google.common.util.concurrent.Service$State$2'
p25637
sg15
(lp25638
sg17
(lp25639
sg19
(lp25640
sg21
I0
sba(iArchitecture
Entity
p25641
(dp25642
g11
(lp25643
sg13
S'com.google.common.util.concurrent.Service$State$3'
p25644
sg15
(lp25645
sg17
(lp25646
sg19
(lp25647
sg21
I0
sba(iArchitecture
Entity
p25648
(dp25649
g11
(lp25650
sg13
S'com.google.common.util.concurrent.Service$State$4'
p25651
sg15
(lp25652
sg17
(lp25653
sg19
(lp25654
sg21
I0
sba(iArchitecture
Entity
p25655
(dp25656
g11
(lp25657
sg13
S'com.google.common.util.concurrent.Service$State$5'
p25658
sg15
(lp25659
sg17
(lp25660
sg19
(lp25661
sg21
I0
sba(iArchitecture
Entity
p25662
(dp25663
g11
(lp25664
sg13
S'com.google.common.util.concurrent.Service$State$6'
p25665
sg15
(lp25666
sg17
(lp25667
sg19
(lp25668
sg21
I0
sba(iArchitecture
Entity
p25669
(dp25670
g11
(lp25671
sg13
S'com.google.common.util.concurrent.ServiceManager'
p25672
sg15
(lp25673
sg17
(lp25674
sg19
(lp25675
sg21
I0
sba(iArchitecture
Entity
p25676
(dp25677
g11
(lp25678
sg13
S'com.google.common.util.concurrent.ServiceManager$1'
p25679
sg15
(lp25680
sg17
(lp25681
sg19
(lp25682
sg21
I0
sba(iArchitecture
Entity
p25683
(dp25684
g11
(lp25685
sg13
S'com.google.common.util.concurrent.ServiceManager$2'
p25686
sg15
(lp25687
sg17
(lp25688
sg19
(lp25689
sg21
I0
sba(iArchitecture
Entity
p25690
(dp25691
g11
(lp25692
sg13
S'com.google.common.util.concurrent.ServiceManager$EmptyServiceManagerWarning'
p25693
sg15
(lp25694
sg17
(lp25695
sg19
(lp25696
sg21
I0
sba(iArchitecture
Entity
p25697
(dp25698
g11
(lp25699
sg13
S'com.google.common.util.concurrent.ServiceManager$Listener'
p25700
sg15
(lp25701
sg17
(lp25702
sg19
(lp25703
sg21
I0
sba(iArchitecture
Entity
p25704
(dp25705
g11
(lp25706
sg13
S'com.google.common.util.concurrent.ServiceManager$NoOpService'
p25707
sg15
(lp25708
sg17
(lp25709
sg19
(lp25710
sg21
I0
sba(iArchitecture
Entity
p25711
(dp25712
g11
(lp25713
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceListener'
p25714
sg15
(lp25715
sg17
(lp25716
sg19
(lp25717
sg21
I0
sba(iArchitecture
Entity
p25718
(dp25719
g11
(lp25720
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState'
p25721
sg15
(lp25722
sg17
(lp25723
sg19
(lp25724
sg21
I0
sba(iArchitecture
Entity
p25725
(dp25726
g11
(lp25727
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$1'
p25728
sg15
(lp25729
sg17
(lp25730
sg19
(lp25731
sg21
I0
sba(iArchitecture
Entity
p25732
(dp25733
g11
(lp25734
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$2'
p25735
sg15
(lp25736
sg17
(lp25737
sg19
(lp25738
sg21
I0
sba(iArchitecture
Entity
p25739
(dp25740
g11
(lp25741
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$AwaitHealthGuard'
p25742
sg15
(lp25743
sg17
(lp25744
sg19
(lp25745
sg21
I0
sba(iArchitecture
Entity
p25746
(dp25747
g11
(lp25748
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$StoppedGuard'
p25749
sg15
(lp25750
sg17
(lp25751
sg19
(lp25752
sg21
I0
sba(iArchitecture
Entity
p25753
(dp25754
g11
(lp25755
sg13
S'com.google.common.util.concurrent.SettableFuture'
p25756
sg15
(lp25757
sg17
(lp25758
sg19
(lp25759
sg21
I0
sba(iArchitecture
Entity
p25760
(dp25761
g11
(lp25762
sg13
S'com.google.common.util.concurrent.SimpleTimeLimiter'
p25763
sg15
(lp25764
sg17
(lp25765
sg19
(lp25766
sg21
I0
sba(iArchitecture
Entity
p25767
(dp25768
g11
(lp25769
sg13
S'com.google.common.util.concurrent.SimpleTimeLimiter$1'
p25770
sg15
(lp25771
sg17
(lp25772
sg19
(lp25773
sg21
I0
sba(iArchitecture
Entity
p25774
(dp25775
g11
(lp25776
sg13
S'com.google.common.util.concurrent.SimpleTimeLimiter$1$1'
p25777
sg15
(lp25778
sg17
(lp25779
sg19
(lp25780
sg21
I0
sba(iArchitecture
Entity
p25781
(dp25782
g11
(lp25783
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter'
p25784
sg15
(lp25785
sg17
(lp25786
sg19
(lp25787
sg21
I0
sba(iArchitecture
Entity
p25788
(dp25789
g11
(lp25790
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter$1'
p25791
sg15
(lp25792
sg17
(lp25793
sg19
(lp25794
sg21
I0
sba(iArchitecture
Entity
p25795
(dp25796
g11
(lp25797
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter$SmoothBursty'
p25798
sg15
(lp25799
sg17
(lp25800
sg19
(lp25801
sg21
I0
sba(iArchitecture
Entity
p25802
(dp25803
g11
(lp25804
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter$SmoothWarmingUp'
p25805
sg15
(lp25806
sg17
(lp25807
sg19
(lp25808
sg21
I0
sba(iArchitecture
Entity
p25809
(dp25810
g11
(lp25811
sg13
S'com.google.common.util.concurrent.Striped'
p25812
sg15
(lp25813
sg17
(lp25814
sg19
(lp25815
sg21
I0
sba(iArchitecture
Entity
p25816
(dp25817
g11
(lp25818
sg13
S'com.google.common.util.concurrent.Striped$1'
p25819
sg15
(lp25820
sg17
(lp25821
sg19
(lp25822
sg21
I0
sba(iArchitecture
Entity
p25823
(dp25824
g11
(lp25825
sg13
S'com.google.common.util.concurrent.Striped$2'
p25826
sg15
(lp25827
sg17
(lp25828
sg19
(lp25829
sg21
I0
sba(iArchitecture
Entity
p25830
(dp25831
g11
(lp25832
sg13
S'com.google.common.util.concurrent.Striped$3'
p25833
sg15
(lp25834
sg17
(lp25835
sg19
(lp25836
sg21
I0
sba(iArchitecture
Entity
p25837
(dp25838
g11
(lp25839
sg13
S'com.google.common.util.concurrent.Striped$4'
p25840
sg15
(lp25841
sg17
(lp25842
sg19
(lp25843
sg21
I0
sba(iArchitecture
Entity
p25844
(dp25845
g11
(lp25846
sg13
S'com.google.common.util.concurrent.Striped$5'
p25847
sg15
(lp25848
sg17
(lp25849
sg19
(lp25850
sg21
I0
sba(iArchitecture
Entity
p25851
(dp25852
g11
(lp25853
sg13
S'com.google.common.util.concurrent.Striped$CompactStriped'
p25854
sg15
(lp25855
sg17
(lp25856
sg19
(lp25857
sg21
I0
sba(iArchitecture
Entity
p25858
(dp25859
g11
(lp25860
sg13
S'com.google.common.util.concurrent.Striped$LargeLazyStriped'
p25861
sg15
(lp25862
sg17
(lp25863
sg19
(lp25864
sg21
I0
sba(iArchitecture
Entity
p25865
(dp25866
g11
(lp25867
sg13
S'com.google.common.util.concurrent.Striped$PaddedLock'
p25868
sg15
(lp25869
sg17
(lp25870
sg19
(lp25871
sg21
I0
sba(iArchitecture
Entity
p25872
(dp25873
g11
(lp25874
sg13
S'com.google.common.util.concurrent.Striped$PaddedSemaphore'
p25875
sg15
(lp25876
sg17
(lp25877
sg19
(lp25878
sg21
I0
sba(iArchitecture
Entity
p25879
(dp25880
g11
(lp25881
sg13
S'com.google.common.util.concurrent.Striped$PowerOfTwoStriped'
p25882
sg15
(lp25883
sg17
(lp25884
sg19
(lp25885
sg21
I0
sba(iArchitecture
Entity
p25886
(dp25887
g11
(lp25888
sg13
S'com.google.common.util.concurrent.Striped$SmallLazyStriped'
p25889
sg15
(lp25890
sg17
(lp25891
sg19
(lp25892
sg21
I0
sba(iArchitecture
Entity
p25893
(dp25894
g11
(lp25895
sg13
S'com.google.common.util.concurrent.Striped$SmallLazyStriped$ArrayReference'
p25896
sg15
(lp25897
sg17
(lp25898
sg19
(lp25899
sg21
I0
sba(iArchitecture
Entity
p25900
(dp25901
g11
(lp25902
sg13
S'com.google.common.util.concurrent.ThreadFactoryBuilder'
p25903
sg15
(lp25904
sg17
(lp25905
sg19
(lp25906
sg21
I0
sba(iArchitecture
Entity
p25907
(dp25908
g11
(lp25909
sg13
S'com.google.common.util.concurrent.ThreadFactoryBuilder$1'
p25910
sg15
(lp25911
sg17
(lp25912
sg19
(lp25913
sg21
I0
sba(iArchitecture
Entity
p25914
(dp25915
g11
(lp25916
sg13
S'com.google.common.util.concurrent.TimeLimiter'
p25917
sg15
(lp25918
sg17
(lp25919
sg19
(lp25920
sg21
I0
sba(iArchitecture
Entity
p25921
(dp25922
g11
(lp25923
sg13
S'com.google.common.util.concurrent.TimeoutFuture'
p25924
sg15
(lp25925
sg17
(lp25926
sg19
(lp25927
sg21
I0
sba(iArchitecture
Entity
p25928
(dp25929
g11
(lp25930
sg13
S'com.google.common.util.concurrent.TimeoutFuture$Fire'
p25931
sg15
(lp25932
sg17
(lp25933
sg19
(lp25934
sg21
I0
sba(iArchitecture
Entity
p25935
(dp25936
g11
(lp25937
sg13
S'com.google.common.util.concurrent.TrustedListenableFutureTask'
p25938
sg15
(lp25939
sg17
(lp25940
sg19
(lp25941
sg21
I0
sba(iArchitecture
Entity
p25942
(dp25943
g11
(lp25944
sg13
S'com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask'
p25945
sg15
(lp25946
sg17
(lp25947
sg19
(lp25948
sg21
I0
sba(iArchitecture
Entity
p25949
(dp25950
g11
(lp25951
sg13
S'com.google.common.util.concurrent.UncaughtExceptionHandlers'
p25952
sg15
(lp25953
sg17
(lp25954
sg19
(lp25955
sg21
I0
sba(iArchitecture
Entity
p25956
(dp25957
g11
(lp25958
sg13
S'com.google.common.util.concurrent.UncaughtExceptionHandlers$Exiter'
p25959
sg15
(lp25960
sg17
(lp25961
sg19
(lp25962
sg21
I0
sba(iArchitecture
Entity
p25963
(dp25964
g11
(lp25965
sg13
S'com.google.common.util.concurrent.UncheckedExecutionException'
p25966
sg15
(lp25967
sg17
(lp25968
sg19
(lp25969
sg21
I0
sba(iArchitecture
Entity
p25970
(dp25971
g11
(lp25972
sg13
S'com.google.common.util.concurrent.UncheckedTimeoutException'
p25973
sg15
(lp25974
sg17
(lp25975
sg19
(lp25976
sg21
I0
sba(iArchitecture
Entity
p25977
(dp25978
g11
(lp25979
sg13
S'com.google.common.util.concurrent.Uninterruptibles'
p25980
sg15
(lp25981
sg17
(lp25982
sg19
(lp25983
sg21
I0
sba(iArchitecture
Entity
p25984
(dp25985
g11
(lp25986
sg13
S'com.google.common.util.concurrent.WrappingExecutorService'
p25987
sg15
(lp25988
sg17
(lp25989
sg19
(lp25990
sg21
I0
sba(iArchitecture
Entity
p25991
(dp25992
g11
(lp25993
sg13
S'com.google.common.util.concurrent.WrappingExecutorService$1'
p25994
sg15
(lp25995
sg17
(lp25996
sg19
(lp25997
sg21
I0
sba(iArchitecture
Entity
p25998
(dp25999
g11
(lp26000
sg13
S'com.google.common.util.concurrent.WrappingScheduledExecutorService'
p26001
sg15
(lp26002
sg17
(lp26003
sg19
(lp26004
sg21
I0
sba(iArchitecture
Entity
p26005
(dp26006
g11
(lp26007
sg13
S'com.google.errorprone.annotations.ForOverride'
p26008
sg15
(lp26009
sg17
(lp26010
sg19
(lp26011
sg21
I0
sba(iArchitecture
Entity
p26012
(dp26013
g11
(lp26014
sg13
S'istFutureRunningState'
p26015
sg15
(lp26016
sg17
(lp26017
sg19
(lp26018
sg21
I0
sba(iArchitecture
Entity
p26019
(dp26020
g11
(lp26021
sg13
S'org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement'
p26022
sg15
(lp26023
sg17
(lp26024
sg19
(lp26025
sg21
I0
sbasg1135
(lp26026
g24328
ag24335
ag24342
ag24349
ag24356
ag24363
ag24370
ag24377
ag24384
ag24391
ag24398
ag24405
ag24412
ag24419
ag24426
ag24433
ag24440
ag24447
ag24454
ag24461
ag24468
ag24475
ag24482
ag24489
ag24496
ag24503
ag24510
ag24517
ag24524
ag24531
ag24538
ag24545
ag24552
ag24559
ag24566
ag24573
ag24580
ag24587
ag24594
ag24601
ag24608
ag24615
ag24622
ag24629
ag24636
ag24643
ag24650
ag24657
ag24664
ag24671
ag24678
ag24685
ag24692
ag24699
ag24706
ag24713
ag24720
ag24727
ag24734
ag24741
ag24748
ag24755
ag24762
ag24769
ag24776
ag24783
ag24790
ag24797
ag24804
ag24811
ag24818
ag24825
ag24832
ag24839
ag24846
ag24853
ag24860
ag24867
ag24874
ag24881
ag24888
ag24895
ag24902
ag24909
ag24916
ag24923
ag24930
ag24937
ag24944
ag24951
ag24958
ag24965
ag24972
ag24979
ag24986
ag24993
ag25000
ag25007
ag25014
ag25021
ag25028
ag25035
ag25042
ag25049
ag25056
ag25063
ag25070
ag25077
ag25084
ag25091
ag25098
ag25105
ag25112
ag25119
ag25126
ag25133
ag25140
ag25147
ag25154
ag25161
ag25168
ag25175
ag25182
ag25189
ag25196
ag25203
ag25210
ag25217
ag25224
ag25231
ag25238
ag25245
ag25252
ag25259
ag25266
ag25273
ag25280
ag25287
ag25294
ag25301
ag25308
ag25315
ag25322
ag25329
ag25336
ag25343
ag25350
ag25357
ag25364
ag25371
ag25378
ag25385
ag25392
ag25399
ag25406
ag25413
ag25420
ag25427
ag25434
ag25441
ag25448
ag25455
ag25462
ag25469
ag25476
ag25483
ag25490
ag25497
ag25504
ag25511
ag25518
ag25525
ag25532
ag25539
ag25546
ag25553
ag25560
ag25567
ag25574
ag25581
ag25588
ag25595
ag25602
ag25609
ag25616
ag25623
ag25630
ag25637
ag25644
ag25651
ag25658
ag25665
ag25672
ag25679
ag25686
ag25693
ag25700
ag25707
ag25714
ag25721
ag25728
ag25735
ag25742
ag25749
ag25756
ag25763
ag25770
ag25777
ag25784
ag25791
ag25798
ag25805
ag25812
ag25819
ag25826
ag25833
ag25840
ag25847
ag25854
ag25861
ag25868
ag25875
ag25882
ag25889
ag25896
ag25903
ag25910
ag25917
ag25924
ag25931
ag25938
ag25945
ag25952
ag25959
ag25966
ag25973
ag25980
ag25987
ag25994
ag26001
ag26008
ag26015
ag26022
asg1137
I0
sg21
I0
sg1138
S'com.google.common.util.concurrent.ss'
p26027
sba(iArchitecture
Cluster
p26028
(dp26029
g7
(lp26030
(iArchitecture
Entity
p26031
(dp26032
g11
(lp26033
sg13
S'com.google.thirdparty.publicsuffix.PublicSuffixPatterns'
p26034
sg15
(lp26035
sg17
(lp26036
sg19
(lp26037
sg21
I0
sba(iArchitecture
Entity
p26038
(dp26039
g11
(lp26040
sg13
S'com.google.thirdparty.publicsuffix.PublicSuffixType'
p26041
sg15
(lp26042
sg17
(lp26043
sg19
(lp26044
sg21
I0
sba(iArchitecture
Entity
p26045
(dp26046
g11
(lp26047
sg13
S'com.google.thirdparty.publicsuffix.TrieParser'
p26048
sg15
(lp26049
sg17
(lp26050
sg19
(lp26051
sg21
I0
sbasg1135
(lp26052
g26034
ag26041
ag26048
asg1137
I0
sg21
I0
sg1138
S'com.google.thirdparty.publicsuffix.ss'
p26053
sbasg13265
g13266
sg1135
(lp26054
sg13268
I00
sg1138
S'20.0'
p26055
sba(iArchitecture
Architecture
p26056
(dp26057
g3
(lp26058
(iArchitecture
Cluster
p26059
(dp26060
g7
(lp26061
(iArchitecture
Entity
p26062
(dp26063
g11
(lp26064
sg13
S'com.google.common.annotations.GwtIncompatible'
p26065
sg15
(lp26066
sg17
(lp26067
sg19
(lp26068
sg21
I0
sba(iArchitecture
Entity
p26069
(dp26070
g11
(lp26071
sg13
S'com.google.common.base.Absent'
p26072
sg15
(lp26073
sg17
(lp26074
sg19
(lp26075
sg21
I0
sba(iArchitecture
Entity
p26076
(dp26077
g11
(lp26078
sg13
S'com.google.common.base.AbstractIterator'
p26079
sg15
(lp26080
sg17
(lp26081
sg19
(lp26082
sg21
I0
sba(iArchitecture
Entity
p26083
(dp26084
g11
(lp26085
sg13
S'com.google.common.base.AbstractIterator$1'
p26086
sg15
(lp26087
sg17
(lp26088
sg19
(lp26089
sg21
I0
sba(iArchitecture
Entity
p26090
(dp26091
g11
(lp26092
sg13
S'com.google.common.base.AbstractIterator$State'
p26093
sg15
(lp26094
sg17
(lp26095
sg19
(lp26096
sg21
I0
sba(iArchitecture
Entity
p26097
(dp26098
g11
(lp26099
sg13
S'com.google.common.base.Ascii'
p26100
sg15
(lp26101
sg17
(lp26102
sg19
(lp26103
sg21
I0
sba(iArchitecture
Entity
p26104
(dp26105
g11
(lp26106
sg13
S'com.google.common.base.CaseFormat'
p26107
sg15
(lp26108
sg17
(lp26109
sg19
(lp26110
sg21
I0
sba(iArchitecture
Entity
p26111
(dp26112
g11
(lp26113
sg13
S'com.google.common.base.CaseFormat$1'
p26114
sg15
(lp26115
sg17
(lp26116
sg19
(lp26117
sg21
I0
sba(iArchitecture
Entity
p26118
(dp26119
g11
(lp26120
sg13
S'com.google.common.base.CaseFormat$2'
p26121
sg15
(lp26122
sg17
(lp26123
sg19
(lp26124
sg21
I0
sba(iArchitecture
Entity
p26125
(dp26126
g11
(lp26127
sg13
S'com.google.common.base.CaseFormat$3'
p26128
sg15
(lp26129
sg17
(lp26130
sg19
(lp26131
sg21
I0
sba(iArchitecture
Entity
p26132
(dp26133
g11
(lp26134
sg13
S'com.google.common.base.CaseFormat$4'
p26135
sg15
(lp26136
sg17
(lp26137
sg19
(lp26138
sg21
I0
sba(iArchitecture
Entity
p26139
(dp26140
g11
(lp26141
sg13
S'com.google.common.base.CaseFormat$5'
p26142
sg15
(lp26143
sg17
(lp26144
sg19
(lp26145
sg21
I0
sba(iArchitecture
Entity
p26146
(dp26147
g11
(lp26148
sg13
S'com.google.common.base.CaseFormat$StringConverter'
p26149
sg15
(lp26150
sg17
(lp26151
sg19
(lp26152
sg21
I0
sba(iArchitecture
Entity
p26153
(dp26154
g11
(lp26155
sg13
S'com.google.common.base.CharMatcher'
p26156
sg15
(lp26157
sg17
(lp26158
sg19
(lp26159
sg21
I0
sba(iArchitecture
Entity
p26160
(dp26161
g11
(lp26162
sg13
S'com.google.common.base.CharMatcher$1'
p26163
sg15
(lp26164
sg17
(lp26165
sg19
(lp26166
sg21
I0
sba(iArchitecture
Entity
p26167
(dp26168
g11
(lp26169
sg13
S'com.google.common.base.CharMatcher$And'
p26170
sg15
(lp26171
sg17
(lp26172
sg19
(lp26173
sg21
I0
sba(iArchitecture
Entity
p26174
(dp26175
g11
(lp26176
sg13
S'com.google.common.base.CharMatcher$Any'
p26177
sg15
(lp26178
sg17
(lp26179
sg19
(lp26180
sg21
I0
sba(iArchitecture
Entity
p26181
(dp26182
g11
(lp26183
sg13
S'com.google.common.base.CharMatcher$AnyOf'
p26184
sg15
(lp26185
sg17
(lp26186
sg19
(lp26187
sg21
I0
sba(iArchitecture
Entity
p26188
(dp26189
g11
(lp26190
sg13
S'com.google.common.base.CharMatcher$Ascii'
p26191
sg15
(lp26192
sg17
(lp26193
sg19
(lp26194
sg21
I0
sba(iArchitecture
Entity
p26195
(dp26196
g11
(lp26197
sg13
S'com.google.common.base.CharMatcher$BitSetMatcher'
p26198
sg15
(lp26199
sg17
(lp26200
sg19
(lp26201
sg21
I0
sba(iArchitecture
Entity
p26202
(dp26203
g11
(lp26204
sg13
S'com.google.common.base.CharMatcher$BreakingWhitespace'
p26205
sg15
(lp26206
sg17
(lp26207
sg19
(lp26208
sg21
I0
sba(iArchitecture
Entity
p26209
(dp26210
g11
(lp26211
sg13
S'com.google.common.base.CharMatcher$Digit'
p26212
sg15
(lp26213
sg17
(lp26214
sg19
(lp26215
sg21
I0
sba(iArchitecture
Entity
p26216
(dp26217
g11
(lp26218
sg13
S'com.google.common.base.CharMatcher$FastMatcher'
p26219
sg15
(lp26220
sg17
(lp26221
sg19
(lp26222
sg21
I0
sba(iArchitecture
Entity
p26223
(dp26224
g11
(lp26225
sg13
S'com.google.common.base.CharMatcher$ForPredicate'
p26226
sg15
(lp26227
sg17
(lp26228
sg19
(lp26229
sg21
I0
sba(iArchitecture
Entity
p26230
(dp26231
g11
(lp26232
sg13
S'com.google.common.base.CharMatcher$InRange'
p26233
sg15
(lp26234
sg17
(lp26235
sg19
(lp26236
sg21
I0
sba(iArchitecture
Entity
p26237
(dp26238
g11
(lp26239
sg13
S'com.google.common.base.CharMatcher$Invisible'
p26240
sg15
(lp26241
sg17
(lp26242
sg19
(lp26243
sg21
I0
sba(iArchitecture
Entity
p26244
(dp26245
g11
(lp26246
sg13
S'com.google.common.base.CharMatcher$Is'
p26247
sg15
(lp26248
sg17
(lp26249
sg19
(lp26250
sg21
I0
sba(iArchitecture
Entity
p26251
(dp26252
g11
(lp26253
sg13
S'com.google.common.base.CharMatcher$IsEither'
p26254
sg15
(lp26255
sg17
(lp26256
sg19
(lp26257
sg21
I0
sba(iArchitecture
Entity
p26258
(dp26259
g11
(lp26260
sg13
S'com.google.common.base.CharMatcher$IsNot'
p26261
sg15
(lp26262
sg17
(lp26263
sg19
(lp26264
sg21
I0
sba(iArchitecture
Entity
p26265
(dp26266
g11
(lp26267
sg13
S'com.google.common.base.CharMatcher$JavaDigit'
p26268
sg15
(lp26269
sg17
(lp26270
sg19
(lp26271
sg21
I0
sba(iArchitecture
Entity
p26272
(dp26273
g11
(lp26274
sg13
S'com.google.common.base.CharMatcher$JavaIsoControl'
p26275
sg15
(lp26276
sg17
(lp26277
sg19
(lp26278
sg21
I0
sba(iArchitecture
Entity
p26279
(dp26280
g11
(lp26281
sg13
S'com.google.common.base.CharMatcher$JavaLetter'
p26282
sg15
(lp26283
sg17
(lp26284
sg19
(lp26285
sg21
I0
sba(iArchitecture
Entity
p26286
(dp26287
g11
(lp26288
sg13
S'com.google.common.base.CharMatcher$JavaLetterOrDigit'
p26289
sg15
(lp26290
sg17
(lp26291
sg19
(lp26292
sg21
I0
sba(iArchitecture
Entity
p26293
(dp26294
g11
(lp26295
sg13
S'com.google.common.base.CharMatcher$JavaLowerCase'
p26296
sg15
(lp26297
sg17
(lp26298
sg19
(lp26299
sg21
I0
sba(iArchitecture
Entity
p26300
(dp26301
g11
(lp26302
sg13
S'com.google.common.base.CharMatcher$JavaUpperCase'
p26303
sg15
(lp26304
sg17
(lp26305
sg19
(lp26306
sg21
I0
sba(iArchitecture
Entity
p26307
(dp26308
g11
(lp26309
sg13
S'com.google.common.base.CharMatcher$NamedFastMatcher'
p26310
sg15
(lp26311
sg17
(lp26312
sg19
(lp26313
sg21
I0
sba(iArchitecture
Entity
p26314
(dp26315
g11
(lp26316
sg13
S'com.google.common.base.CharMatcher$Negated'
p26317
sg15
(lp26318
sg17
(lp26319
sg19
(lp26320
sg21
I0
sba(iArchitecture
Entity
p26321
(dp26322
g11
(lp26323
sg13
S'com.google.common.base.CharMatcher$NegatedFastMatcher'
p26324
sg15
(lp26325
sg17
(lp26326
sg19
(lp26327
sg21
I0
sba(iArchitecture
Entity
p26328
(dp26329
g11
(lp26330
sg13
S'com.google.common.base.CharMatcher$None'
p26331
sg15
(lp26332
sg17
(lp26333
sg19
(lp26334
sg21
I0
sba(iArchitecture
Entity
p26335
(dp26336
g11
(lp26337
sg13
S'com.google.common.base.CharMatcher$Or'
p26338
sg15
(lp26339
sg17
(lp26340
sg19
(lp26341
sg21
I0
sba(iArchitecture
Entity
p26342
(dp26343
g11
(lp26344
sg13
S'com.google.common.base.CharMatcher$RangesMatcher'
p26345
sg15
(lp26346
sg17
(lp26347
sg19
(lp26348
sg21
I0
sba(iArchitecture
Entity
p26349
(dp26350
g11
(lp26351
sg13
S'com.google.common.base.CharMatcher$SingleWidth'
p26352
sg15
(lp26353
sg17
(lp26354
sg19
(lp26355
sg21
I0
sba(iArchitecture
Entity
p26356
(dp26357
g11
(lp26358
sg13
S'com.google.common.base.CharMatcher$Whitespace'
p26359
sg15
(lp26360
sg17
(lp26361
sg19
(lp26362
sg21
I0
sba(iArchitecture
Entity
p26363
(dp26364
g11
(lp26365
sg13
S'com.google.common.base.CommonMatcher'
p26366
sg15
(lp26367
sg17
(lp26368
sg19
(lp26369
sg21
I0
sba(iArchitecture
Entity
p26370
(dp26371
g11
(lp26372
sg13
S'com.google.common.base.CommonPattern'
p26373
sg15
(lp26374
sg17
(lp26375
sg19
(lp26376
sg21
I0
sba(iArchitecture
Entity
p26377
(dp26378
g11
(lp26379
sg13
S'com.google.common.base.Converter'
p26380
sg15
(lp26381
sg17
(lp26382
sg19
(lp26383
sg21
I0
sba(iArchitecture
Entity
p26384
(dp26385
g11
(lp26386
sg13
S'com.google.common.base.Converter$1'
p26387
sg15
(lp26388
sg17
(lp26389
sg19
(lp26390
sg21
I0
sba(iArchitecture
Entity
p26391
(dp26392
g11
(lp26393
sg13
S'com.google.common.base.Converter$1$1'
p26394
sg15
(lp26395
sg17
(lp26396
sg19
(lp26397
sg21
I0
sba(iArchitecture
Entity
p26398
(dp26399
g11
(lp26400
sg13
S'com.google.common.base.Converter$ConverterComposition'
p26401
sg15
(lp26402
sg17
(lp26403
sg19
(lp26404
sg21
I0
sba(iArchitecture
Entity
p26405
(dp26406
g11
(lp26407
sg13
S'com.google.common.base.Converter$FunctionBasedConverter'
p26408
sg15
(lp26409
sg17
(lp26410
sg19
(lp26411
sg21
I0
sba(iArchitecture
Entity
p26412
(dp26413
g11
(lp26414
sg13
S'com.google.common.base.Converter$IdentityConverter'
p26415
sg15
(lp26416
sg17
(lp26417
sg19
(lp26418
sg21
I0
sba(iArchitecture
Entity
p26419
(dp26420
g11
(lp26421
sg13
S'com.google.common.base.Converter$ReverseConverter'
p26422
sg15
(lp26423
sg17
(lp26424
sg19
(lp26425
sg21
I0
sba(iArchitecture
Entity
p26426
(dp26427
g11
(lp26428
sg13
S'com.google.common.base.Enums'
p26429
sg15
(lp26430
sg17
(lp26431
sg19
(lp26432
sg21
I0
sba(iArchitecture
Entity
p26433
(dp26434
g11
(lp26435
sg13
S'com.google.common.base.Enums$StringConverter'
p26436
sg15
(lp26437
sg17
(lp26438
sg19
(lp26439
sg21
I0
sba(iArchitecture
Entity
p26440
(dp26441
g11
(lp26442
sg13
S'com.google.common.base.Equivalence'
p26443
sg15
(lp26444
sg17
(lp26445
sg19
(lp26446
sg21
I0
sba(iArchitecture
Entity
p26447
(dp26448
g11
(lp26449
sg13
S'com.google.common.base.Equivalence$1'
p26450
sg15
(lp26451
sg17
(lp26452
sg19
(lp26453
sg21
I0
sba(iArchitecture
Entity
p26454
(dp26455
g11
(lp26456
sg13
S'com.google.common.base.Equivalence$Equals'
p26457
sg15
(lp26458
sg17
(lp26459
sg19
(lp26460
sg21
I0
sba(iArchitecture
Entity
p26461
(dp26462
g11
(lp26463
sg13
S'com.google.common.base.Equivalence$EquivalentToPredicate'
p26464
sg15
(lp26465
sg17
(lp26466
sg19
(lp26467
sg21
I0
sba(iArchitecture
Entity
p26468
(dp26469
g11
(lp26470
sg13
S'com.google.common.base.Equivalence$Identity'
p26471
sg15
(lp26472
sg17
(lp26473
sg19
(lp26474
sg21
I0
sba(iArchitecture
Entity
p26475
(dp26476
g11
(lp26477
sg13
S'com.google.common.base.Equivalence$Wrapper'
p26478
sg15
(lp26479
sg17
(lp26480
sg19
(lp26481
sg21
I0
sba(iArchitecture
Entity
p26482
(dp26483
g11
(lp26484
sg13
S'com.google.common.base.ExtraObjectsMethodsForWeb'
p26485
sg15
(lp26486
sg17
(lp26487
sg19
(lp26488
sg21
I0
sba(iArchitecture
Entity
p26489
(dp26490
g11
(lp26491
sg13
S'com.google.common.base.FinalizablePhantomReference'
p26492
sg15
(lp26493
sg17
(lp26494
sg19
(lp26495
sg21
I0
sba(iArchitecture
Entity
p26496
(dp26497
g11
(lp26498
sg13
S'com.google.common.base.FinalizableReference'
p26499
sg15
(lp26500
sg17
(lp26501
sg19
(lp26502
sg21
I0
sba(iArchitecture
Entity
p26503
(dp26504
g11
(lp26505
sg13
S'com.google.common.base.FinalizableReferenceQueue'
p26506
sg15
(lp26507
sg17
(lp26508
sg19
(lp26509
sg21
I0
sba(iArchitecture
Entity
p26510
(dp26511
g11
(lp26512
sg13
S'com.google.common.base.FinalizableReferenceQueue$DecoupledLoader'
p26513
sg15
(lp26514
sg17
(lp26515
sg19
(lp26516
sg21
I0
sba(iArchitecture
Entity
p26517
(dp26518
g11
(lp26519
sg13
S'com.google.common.base.FinalizableReferenceQueue$DirectLoader'
p26520
sg15
(lp26521
sg17
(lp26522
sg19
(lp26523
sg21
I0
sba(iArchitecture
Entity
p26524
(dp26525
g11
(lp26526
sg13
S'com.google.common.base.FinalizableReferenceQueue$FinalizerLoader'
p26527
sg15
(lp26528
sg17
(lp26529
sg19
(lp26530
sg21
I0
sba(iArchitecture
Entity
p26531
(dp26532
g11
(lp26533
sg13
S'com.google.common.base.FinalizableReferenceQueue$SystemLoader'
p26534
sg15
(lp26535
sg17
(lp26536
sg19
(lp26537
sg21
I0
sba(iArchitecture
Entity
p26538
(dp26539
g11
(lp26540
sg13
S'com.google.common.base.FinalizableSoftReference'
p26541
sg15
(lp26542
sg17
(lp26543
sg19
(lp26544
sg21
I0
sba(iArchitecture
Entity
p26545
(dp26546
g11
(lp26547
sg13
S'com.google.common.base.FinalizableWeakReference'
p26548
sg15
(lp26549
sg17
(lp26550
sg19
(lp26551
sg21
I0
sba(iArchitecture
Entity
p26552
(dp26553
g11
(lp26554
sg13
S'com.google.common.base.Function'
p26555
sg15
(lp26556
sg17
(lp26557
sg19
(lp26558
sg21
I0
sba(iArchitecture
Entity
p26559
(dp26560
g11
(lp26561
sg13
S'com.google.common.base.FunctionalEquivalence'
p26562
sg15
(lp26563
sg17
(lp26564
sg19
(lp26565
sg21
I0
sba(iArchitecture
Entity
p26566
(dp26567
g11
(lp26568
sg13
S'com.google.common.base.Functions'
p26569
sg15
(lp26570
sg17
(lp26571
sg19
(lp26572
sg21
I0
sba(iArchitecture
Entity
p26573
(dp26574
g11
(lp26575
sg13
S'com.google.common.base.Functions$1'
p26576
sg15
(lp26577
sg17
(lp26578
sg19
(lp26579
sg21
I0
sba(iArchitecture
Entity
p26580
(dp26581
g11
(lp26582
sg13
S'com.google.common.base.Functions$ConstantFunction'
p26583
sg15
(lp26584
sg17
(lp26585
sg19
(lp26586
sg21
I0
sba(iArchitecture
Entity
p26587
(dp26588
g11
(lp26589
sg13
S'com.google.common.base.Functions$ForMapWithDefault'
p26590
sg15
(lp26591
sg17
(lp26592
sg19
(lp26593
sg21
I0
sba(iArchitecture
Entity
p26594
(dp26595
g11
(lp26596
sg13
S'com.google.common.base.Functions$FunctionComposition'
p26597
sg15
(lp26598
sg17
(lp26599
sg19
(lp26600
sg21
I0
sba(iArchitecture
Entity
p26601
(dp26602
g11
(lp26603
sg13
S'com.google.common.base.Functions$FunctionForMapNoDefault'
p26604
sg15
(lp26605
sg17
(lp26606
sg19
(lp26607
sg21
I0
sba(iArchitecture
Entity
p26608
(dp26609
g11
(lp26610
sg13
S'com.google.common.base.Functions$IdentityFunction'
p26611
sg15
(lp26612
sg17
(lp26613
sg19
(lp26614
sg21
I0
sba(iArchitecture
Entity
p26615
(dp26616
g11
(lp26617
sg13
S'com.google.common.base.Functions$PredicateFunction'
p26618
sg15
(lp26619
sg17
(lp26620
sg19
(lp26621
sg21
I0
sba(iArchitecture
Entity
p26622
(dp26623
g11
(lp26624
sg13
S'com.google.common.base.Functions$SupplierFunction'
p26625
sg15
(lp26626
sg17
(lp26627
sg19
(lp26628
sg21
I0
sba(iArchitecture
Entity
p26629
(dp26630
g11
(lp26631
sg13
S'com.google.common.base.Functions$ToStringFunction'
p26632
sg15
(lp26633
sg17
(lp26634
sg19
(lp26635
sg21
I0
sba(iArchitecture
Entity
p26636
(dp26637
g11
(lp26638
sg13
S'com.google.common.base.JdkPattern'
p26639
sg15
(lp26640
sg17
(lp26641
sg19
(lp26642
sg21
I0
sba(iArchitecture
Entity
p26643
(dp26644
g11
(lp26645
sg13
S'com.google.common.base.JdkPattern$JdkMatcher'
p26646
sg15
(lp26647
sg17
(lp26648
sg19
(lp26649
sg21
I0
sba(iArchitecture
Entity
p26650
(dp26651
g11
(lp26652
sg13
S'com.google.common.base.Joiner'
p26653
sg15
(lp26654
sg17
(lp26655
sg19
(lp26656
sg21
I0
sba(iArchitecture
Entity
p26657
(dp26658
g11
(lp26659
sg13
S'com.google.common.base.Joiner$1'
p26660
sg15
(lp26661
sg17
(lp26662
sg19
(lp26663
sg21
I0
sba(iArchitecture
Entity
p26664
(dp26665
g11
(lp26666
sg13
S'com.google.common.base.Joiner$2'
p26667
sg15
(lp26668
sg17
(lp26669
sg19
(lp26670
sg21
I0
sba(iArchitecture
Entity
p26671
(dp26672
g11
(lp26673
sg13
S'com.google.common.base.Joiner$3'
p26674
sg15
(lp26675
sg17
(lp26676
sg19
(lp26677
sg21
I0
sba(iArchitecture
Entity
p26678
(dp26679
g11
(lp26680
sg13
S'com.google.common.base.Joiner$MapJoiner'
p26681
sg15
(lp26682
sg17
(lp26683
sg19
(lp26684
sg21
I0
sba(iArchitecture
Entity
p26685
(dp26686
g11
(lp26687
sg13
S'com.google.common.base.MoreObjects'
p26688
sg15
(lp26689
sg17
(lp26690
sg19
(lp26691
sg21
I0
sba(iArchitecture
Entity
p26692
(dp26693
g11
(lp26694
sg13
S'com.google.common.base.MoreObjects$1'
p26695
sg15
(lp26696
sg17
(lp26697
sg19
(lp26698
sg21
I0
sba(iArchitecture
Entity
p26699
(dp26700
g11
(lp26701
sg13
S'com.google.common.base.MoreObjects$ToStringHelper'
p26702
sg15
(lp26703
sg17
(lp26704
sg19
(lp26705
sg21
I0
sba(iArchitecture
Entity
p26706
(dp26707
g11
(lp26708
sg13
S'com.google.common.base.MoreObjects$ToStringHelper$ValueHolder'
p26709
sg15
(lp26710
sg17
(lp26711
sg19
(lp26712
sg21
I0
sba(iArchitecture
Entity
p26713
(dp26714
g11
(lp26715
sg13
S'com.google.common.base.Objects'
p26716
sg15
(lp26717
sg17
(lp26718
sg19
(lp26719
sg21
I0
sba(iArchitecture
Entity
p26720
(dp26721
g11
(lp26722
sg13
S'com.google.common.base.Optional'
p26723
sg15
(lp26724
sg17
(lp26725
sg19
(lp26726
sg21
I0
sba(iArchitecture
Entity
p26727
(dp26728
g11
(lp26729
sg13
S'com.google.common.base.Optional$1'
p26730
sg15
(lp26731
sg17
(lp26732
sg19
(lp26733
sg21
I0
sba(iArchitecture
Entity
p26734
(dp26735
g11
(lp26736
sg13
S'com.google.common.base.Optional$1$1'
p26737
sg15
(lp26738
sg17
(lp26739
sg19
(lp26740
sg21
I0
sba(iArchitecture
Entity
p26741
(dp26742
g11
(lp26743
sg13
S'com.google.common.base.PairwiseEquivalence'
p26744
sg15
(lp26745
sg17
(lp26746
sg19
(lp26747
sg21
I0
sba(iArchitecture
Entity
p26748
(dp26749
g11
(lp26750
sg13
S'com.google.common.base.PatternCompiler'
p26751
sg15
(lp26752
sg17
(lp26753
sg19
(lp26754
sg21
I0
sba(iArchitecture
Entity
p26755
(dp26756
g11
(lp26757
sg13
S'com.google.common.base.Platform'
p26758
sg15
(lp26759
sg17
(lp26760
sg19
(lp26761
sg21
I0
sba(iArchitecture
Entity
p26762
(dp26763
g11
(lp26764
sg13
S'com.google.common.base.Platform$1'
p26765
sg15
(lp26766
sg17
(lp26767
sg19
(lp26768
sg21
I0
sba(iArchitecture
Entity
p26769
(dp26770
g11
(lp26771
sg13
S'com.google.common.base.Platform$JdkPatternCompiler'
p26772
sg15
(lp26773
sg17
(lp26774
sg19
(lp26775
sg21
I0
sba(iArchitecture
Entity
p26776
(dp26777
g11
(lp26778
sg13
S'com.google.common.base.Predicate'
p26779
sg15
(lp26780
sg17
(lp26781
sg19
(lp26782
sg21
I0
sba(iArchitecture
Entity
p26783
(dp26784
g11
(lp26785
sg13
S'com.google.common.base.Predicates'
p26786
sg15
(lp26787
sg17
(lp26788
sg19
(lp26789
sg21
I0
sba(iArchitecture
Entity
p26790
(dp26791
g11
(lp26792
sg13
S'com.google.common.base.Predicates$1'
p26793
sg15
(lp26794
sg17
(lp26795
sg19
(lp26796
sg21
I0
sba(iArchitecture
Entity
p26797
(dp26798
g11
(lp26799
sg13
S'com.google.common.base.Predicates$AndPredicate'
p26800
sg15
(lp26801
sg17
(lp26802
sg19
(lp26803
sg21
I0
sba(iArchitecture
Entity
p26804
(dp26805
g11
(lp26806
sg13
S'com.google.common.base.Predicates$CompositionPredicate'
p26807
sg15
(lp26808
sg17
(lp26809
sg19
(lp26810
sg21
I0
sba(iArchitecture
Entity
p26811
(dp26812
g11
(lp26813
sg13
S'com.google.common.base.Predicates$ContainsPatternFromStringPredicate'
p26814
sg15
(lp26815
sg17
(lp26816
sg19
(lp26817
sg21
I0
sba(iArchitecture
Entity
p26818
(dp26819
g11
(lp26820
sg13
S'com.google.common.base.Predicates$ContainsPatternPredicate'
p26821
sg15
(lp26822
sg17
(lp26823
sg19
(lp26824
sg21
I0
sba(iArchitecture
Entity
p26825
(dp26826
g11
(lp26827
sg13
S'com.google.common.base.Predicates$InPredicate'
p26828
sg15
(lp26829
sg17
(lp26830
sg19
(lp26831
sg21
I0
sba(iArchitecture
Entity
p26832
(dp26833
g11
(lp26834
sg13
S'com.google.common.base.Predicates$InstanceOfPredicate'
p26835
sg15
(lp26836
sg17
(lp26837
sg19
(lp26838
sg21
I0
sba(iArchitecture
Entity
p26839
(dp26840
g11
(lp26841
sg13
S'com.google.common.base.Predicates$IsEqualToPredicate'
p26842
sg15
(lp26843
sg17
(lp26844
sg19
(lp26845
sg21
I0
sba(iArchitecture
Entity
p26846
(dp26847
g11
(lp26848
sg13
S'com.google.common.base.Predicates$NotPredicate'
p26849
sg15
(lp26850
sg17
(lp26851
sg19
(lp26852
sg21
I0
sba(iArchitecture
Entity
p26853
(dp26854
g11
(lp26855
sg13
S'com.google.common.base.Predicates$ObjectPredicate'
p26856
sg15
(lp26857
sg17
(lp26858
sg19
(lp26859
sg21
I0
sba(iArchitecture
Entity
p26860
(dp26861
g11
(lp26862
sg13
S'com.google.common.base.Predicates$ObjectPredicate$1'
p26863
sg15
(lp26864
sg17
(lp26865
sg19
(lp26866
sg21
I0
sba(iArchitecture
Entity
p26867
(dp26868
g11
(lp26869
sg13
S'com.google.common.base.Predicates$ObjectPredicate$2'
p26870
sg15
(lp26871
sg17
(lp26872
sg19
(lp26873
sg21
I0
sba(iArchitecture
Entity
p26874
(dp26875
g11
(lp26876
sg13
S'com.google.common.base.Predicates$ObjectPredicate$3'
p26877
sg15
(lp26878
sg17
(lp26879
sg19
(lp26880
sg21
I0
sba(iArchitecture
Entity
p26881
(dp26882
g11
(lp26883
sg13
S'com.google.common.base.Predicates$ObjectPredicate$4'
p26884
sg15
(lp26885
sg17
(lp26886
sg19
(lp26887
sg21
I0
sba(iArchitecture
Entity
p26888
(dp26889
g11
(lp26890
sg13
S'com.google.common.base.Predicates$OrPredicate'
p26891
sg15
(lp26892
sg17
(lp26893
sg19
(lp26894
sg21
I0
sba(iArchitecture
Entity
p26895
(dp26896
g11
(lp26897
sg13
S'com.google.common.base.Predicates$SubtypeOfPredicate'
p26898
sg15
(lp26899
sg17
(lp26900
sg19
(lp26901
sg21
I0
sba(iArchitecture
Entity
p26902
(dp26903
g11
(lp26904
sg13
S'com.google.common.base.Present'
p26905
sg15
(lp26906
sg17
(lp26907
sg19
(lp26908
sg21
I0
sba(iArchitecture
Entity
p26909
(dp26910
g11
(lp26911
sg13
S'com.google.common.base.SmallCharMatcher'
p26912
sg15
(lp26913
sg17
(lp26914
sg19
(lp26915
sg21
I0
sba(iArchitecture
Entity
p26916
(dp26917
g11
(lp26918
sg13
S'com.google.common.base.Splitter'
p26919
sg15
(lp26920
sg17
(lp26921
sg19
(lp26922
sg21
I0
sba(iArchitecture
Entity
p26923
(dp26924
g11
(lp26925
sg13
S'com.google.common.base.Splitter$1'
p26926
sg15
(lp26927
sg17
(lp26928
sg19
(lp26929
sg21
I0
sba(iArchitecture
Entity
p26930
(dp26931
g11
(lp26932
sg13
S'com.google.common.base.Splitter$1$1'
p26933
sg15
(lp26934
sg17
(lp26935
sg19
(lp26936
sg21
I0
sba(iArchitecture
Entity
p26937
(dp26938
g11
(lp26939
sg13
S'com.google.common.base.Splitter$2'
p26940
sg15
(lp26941
sg17
(lp26942
sg19
(lp26943
sg21
I0
sba(iArchitecture
Entity
p26944
(dp26945
g11
(lp26946
sg13
S'com.google.common.base.Splitter$2$1'
p26947
sg15
(lp26948
sg17
(lp26949
sg19
(lp26950
sg21
I0
sba(iArchitecture
Entity
p26951
(dp26952
g11
(lp26953
sg13
S'com.google.common.base.Splitter$3'
p26954
sg15
(lp26955
sg17
(lp26956
sg19
(lp26957
sg21
I0
sba(iArchitecture
Entity
p26958
(dp26959
g11
(lp26960
sg13
S'com.google.common.base.Splitter$3$1'
p26961
sg15
(lp26962
sg17
(lp26963
sg19
(lp26964
sg21
I0
sba(iArchitecture
Entity
p26965
(dp26966
g11
(lp26967
sg13
S'com.google.common.base.Splitter$4'
p26968
sg15
(lp26969
sg17
(lp26970
sg19
(lp26971
sg21
I0
sba(iArchitecture
Entity
p26972
(dp26973
g11
(lp26974
sg13
S'com.google.common.base.Splitter$4$1'
p26975
sg15
(lp26976
sg17
(lp26977
sg19
(lp26978
sg21
I0
sba(iArchitecture
Entity
p26979
(dp26980
g11
(lp26981
sg13
S'com.google.common.base.Splitter$5'
p26982
sg15
(lp26983
sg17
(lp26984
sg19
(lp26985
sg21
I0
sba(iArchitecture
Entity
p26986
(dp26987
g11
(lp26988
sg13
S'com.google.common.base.Splitter$MapSplitter'
p26989
sg15
(lp26990
sg17
(lp26991
sg19
(lp26992
sg21
I0
sba(iArchitecture
Entity
p26993
(dp26994
g11
(lp26995
sg13
S'com.google.common.base.Splitter$SplittingIterator'
p26996
sg15
(lp26997
sg17
(lp26998
sg19
(lp26999
sg21
I0
sba(iArchitecture
Entity
p27000
(dp27001
g11
(lp27002
sg13
S'com.google.common.base.Splitter$Strategy'
p27003
sg15
(lp27004
sg17
(lp27005
sg19
(lp27006
sg21
I0
sba(iArchitecture
Entity
p27007
(dp27008
g11
(lp27009
sg13
S'com.google.common.base.StandardSystemProperty'
p27010
sg15
(lp27011
sg17
(lp27012
sg19
(lp27013
sg21
I0
sba(iArchitecture
Entity
p27014
(dp27015
g11
(lp27016
sg13
S'com.google.common.base.Stopwatch'
p27017
sg15
(lp27018
sg17
(lp27019
sg19
(lp27020
sg21
I0
sba(iArchitecture
Entity
p27021
(dp27022
g11
(lp27023
sg13
S'com.google.common.base.Stopwatch$1'
p27024
sg15
(lp27025
sg17
(lp27026
sg19
(lp27027
sg21
I0
sba(iArchitecture
Entity
p27028
(dp27029
g11
(lp27030
sg13
S'com.google.common.base.Supplier'
p27031
sg15
(lp27032
sg17
(lp27033
sg19
(lp27034
sg21
I0
sba(iArchitecture
Entity
p27035
(dp27036
g11
(lp27037
sg13
S'com.google.common.base.Suppliers'
p27038
sg15
(lp27039
sg17
(lp27040
sg19
(lp27041
sg21
I0
sba(iArchitecture
Entity
p27042
(dp27043
g11
(lp27044
sg13
S'com.google.common.base.Suppliers$ExpiringMemoizingSupplier'
p27045
sg15
(lp27046
sg17
(lp27047
sg19
(lp27048
sg21
I0
sba(iArchitecture
Entity
p27049
(dp27050
g11
(lp27051
sg13
S'com.google.common.base.Suppliers$MemoizingSupplier'
p27052
sg15
(lp27053
sg17
(lp27054
sg19
(lp27055
sg21
I0
sba(iArchitecture
Entity
p27056
(dp27057
g11
(lp27058
sg13
S'com.google.common.base.Suppliers$NonSerializableMemoizingSupplier'
p27059
sg15
(lp27060
sg17
(lp27061
sg19
(lp27062
sg21
I0
sba(iArchitecture
Entity
p27063
(dp27064
g11
(lp27065
sg13
S'com.google.common.base.Suppliers$SupplierComposition'
p27066
sg15
(lp27067
sg17
(lp27068
sg19
(lp27069
sg21
I0
sba(iArchitecture
Entity
p27070
(dp27071
g11
(lp27072
sg13
S'com.google.common.base.Suppliers$SupplierFunction'
p27073
sg15
(lp27074
sg17
(lp27075
sg19
(lp27076
sg21
I0
sba(iArchitecture
Entity
p27077
(dp27078
g11
(lp27079
sg13
S'com.google.common.base.Suppliers$SupplierFunctionImpl'
p27080
sg15
(lp27081
sg17
(lp27082
sg19
(lp27083
sg21
I0
sba(iArchitecture
Entity
p27084
(dp27085
g11
(lp27086
sg13
S'com.google.common.base.Suppliers$SupplierOfInstance'
p27087
sg15
(lp27088
sg17
(lp27089
sg19
(lp27090
sg21
I0
sba(iArchitecture
Entity
p27091
(dp27092
g11
(lp27093
sg13
S'com.google.common.base.Suppliers$ThreadSafeSupplier'
p27094
sg15
(lp27095
sg17
(lp27096
sg19
(lp27097
sg21
I0
sba(iArchitecture
Entity
p27098
(dp27099
g11
(lp27100
V2866
p27101
ag27101
ag27101
ag27101
ag27101
asg13
S'com.google.common.base.Throwables'
p27102
sg15
(lp27103
VException cause can be set by initCause method which can lead to a circular reference:\u000a```java\u000aException cause = new Exception();\u000aException exception = new Exception(cause);\u000acause.initCause(exception);\u000a```\u000aCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\u000a\u000aIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. 
p27104
aVException cause can be set by initCause method which can lead to a circular reference:\u000a```java\u000aException cause = new Exception();\u000aException exception = new Exception(cause);\u000acause.initCause(exception);\u000a```\u000aCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\u000a\u000aIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. 
p27105
aVException cause can be set by initCause method which can lead to a circular reference:\u000a```java\u000aException cause = new Exception();\u000aException exception = new Exception(cause);\u000acause.initCause(exception);\u000a```\u000aCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\u000a\u000aIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. 
p27106
aVException cause can be set by initCause method which can lead to a circular reference:\u000a```java\u000aException cause = new Exception();\u000aException exception = new Exception(cause);\u000acause.initCause(exception);\u000a```\u000aCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\u000a\u000aIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. 
p27107
aVException cause can be set by initCause method which can lead to a circular reference:\u000a```java\u000aException cause = new Exception();\u000aException exception = new Exception(cause);\u000acause.initCause(exception);\u000a```\u000aCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\u000a\u000aIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. 
p27108
asg17
(lp27109
(lp27110
I0
aag27110
ag27110
ag27110
ag27110
asg19
(lp27111
VMake Throwables.getCausalChain and Throwables.getRootCause cyclic reference safe
p27112
ag27112
ag27112
ag27112
ag27112
asg21
I0
sba(iArchitecture
Entity
p27113
(dp27114
g11
(lp27115
g27101
ag27101
ag27101
ag27101
ag27101
asg13
S'com.google.common.base.Throwables$1'
p27116
sg15
(lp27117
VException cause can be set by initCause method which can lead to a circular reference:\u000a```java\u000aException cause = new Exception();\u000aException exception = new Exception(cause);\u000acause.initCause(exception);\u000a```\u000aCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\u000a\u000aIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. 
p27118
aVException cause can be set by initCause method which can lead to a circular reference:\u000a```java\u000aException cause = new Exception();\u000aException exception = new Exception(cause);\u000acause.initCause(exception);\u000a```\u000aCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\u000a\u000aIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. 
p27119
aVException cause can be set by initCause method which can lead to a circular reference:\u000a```java\u000aException cause = new Exception();\u000aException exception = new Exception(cause);\u000acause.initCause(exception);\u000a```\u000aCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\u000a\u000aIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. 
p27120
aVException cause can be set by initCause method which can lead to a circular reference:\u000a```java\u000aException cause = new Exception();\u000aException exception = new Exception(cause);\u000acause.initCause(exception);\u000a```\u000aCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\u000a\u000aIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. 
p27121
aVException cause can be set by initCause method which can lead to a circular reference:\u000a```java\u000aException cause = new Exception();\u000aException exception = new Exception(cause);\u000acause.initCause(exception);\u000a```\u000aCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\u000a\u000aIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. 
p27122
asg17
(lp27123
g27110
ag27110
ag27110
ag27110
ag27110
asg19
(lp27124
g27112
ag27112
ag27112
ag27112
ag27112
asg21
I0
sba(iArchitecture
Entity
p27125
(dp27126
g11
(lp27127
sg13
S'com.google.common.base.Ticker'
p27128
sg15
(lp27129
sg17
(lp27130
sg19
(lp27131
sg21
I0
sba(iArchitecture
Entity
p27132
(dp27133
g11
(lp27134
sg13
S'com.google.common.base.Ticker$1'
p27135
sg15
(lp27136
sg17
(lp27137
sg19
(lp27138
sg21
I0
sba(iArchitecture
Entity
p27139
(dp27140
g11
(lp27141
sg13
S'com.google.common.base.Verify'
p27142
sg15
(lp27143
sg17
(lp27144
sg19
(lp27145
sg21
I0
sba(iArchitecture
Entity
p27146
(dp27147
g11
(lp27148
sg13
S'com.google.common.base.VerifyException'
p27149
sg15
(lp27150
sg17
(lp27151
sg19
(lp27152
sg21
I0
sba(iArchitecture
Entity
p27153
(dp27154
g11
(lp27155
sg13
S'com.google.common.collect.ForwardingBlockingDeque'
p27156
sg15
(lp27157
sg17
(lp27158
sg19
(lp27159
sg21
I0
sba(iArchitecture
Entity
p27160
(dp27161
g11
(lp27162
sg13
S'com.google.common.collect.ForwardingDeque'
p27163
sg15
(lp27164
sg17
(lp27165
sg19
(lp27166
sg21
I0
sba(iArchitecture
Entity
p27167
(dp27168
g11
(lp27169
sg13
S'com.google.common.io.Flushables'
p27170
sg15
(lp27171
sg17
(lp27172
sg19
(lp27173
sg21
I0
sba(iArchitecture
Entity
p27174
(dp27175
g11
(lp27176
sg13
S'com.google.common.util.concurrent.AtomicDouble'
p27177
sg15
(lp27178
sg17
(lp27179
sg19
(lp27180
sg21
I0
sba(iArchitecture
Entity
p27181
(dp27182
g11
(lp27183
sg13
S'com.google.common.util.concurrent.AtomicDoubleArray'
p27184
sg15
(lp27185
sg17
(lp27186
sg19
(lp27187
sg21
I0
sba(iArchitecture
Entity
p27188
(dp27189
g11
(lp27190
sg13
S'com.google.common.util.concurrent.Atomics'
p27191
sg15
(lp27192
sg17
(lp27193
sg19
(lp27194
sg21
I0
sba(iArchitecture
Entity
p27195
(dp27196
g11
(lp27197
sg13
S'com.google.common.util.concurrent.ForwardingBlockingDeque'
p27198
sg15
(lp27199
sg17
(lp27200
sg19
(lp27201
sg21
I0
sba(iArchitecture
Entity
p27202
(dp27203
g11
(lp27204
sg13
S'com.google.common.util.concurrent.ForwardingBlockingQueue'
p27205
sg15
(lp27206
sg17
(lp27207
sg19
(lp27208
sg21
I0
sbasg1135
(lp27209
g26065
ag26072
ag26079
ag26086
ag26093
ag26100
ag26107
ag26114
ag26121
ag26128
ag26135
ag26142
ag26149
ag26156
ag26163
ag26170
ag26177
ag26184
ag26191
ag26198
ag26205
ag26212
ag26219
ag26226
ag26233
ag26240
ag26247
ag26254
ag26261
ag26268
ag26275
ag26282
ag26289
ag26296
ag26303
ag26310
ag26317
ag26324
ag26331
ag26338
ag26345
ag26352
ag26359
ag26366
ag26373
ag26380
ag26387
ag26394
ag26401
ag26408
ag26415
ag26422
ag26429
ag26436
ag26443
ag26450
ag26457
ag26464
ag26471
ag26478
ag26485
ag26492
ag26499
ag26506
ag26513
ag26520
ag26527
ag26534
ag26541
ag26548
ag26555
ag26562
ag26569
ag26576
ag26583
ag26590
ag26597
ag26604
ag26611
ag26618
ag26625
ag26632
ag26639
ag26646
ag26653
ag26660
ag26667
ag26674
ag26681
ag26688
ag26695
ag26702
ag26709
ag26716
ag26723
ag26730
ag26737
ag26744
ag26751
ag26758
ag26765
ag26772
ag26779
ag26786
ag26793
ag26800
ag26807
ag26814
ag26821
ag26828
ag26835
ag26842
ag26849
ag26856
ag26863
ag26870
ag26877
ag26884
ag26891
ag26898
ag26905
ag26912
ag26919
ag26926
ag26933
ag26940
ag26947
ag26954
ag26961
ag26968
ag26975
ag26982
ag26989
ag26996
ag27003
ag27010
ag27017
ag27024
ag27031
ag27038
ag27045
ag27052
ag27059
ag27066
ag27073
ag27080
ag27087
ag27094
ag27102
ag27116
ag27128
ag27135
ag27142
ag27149
ag27156
ag27163
ag27170
ag27177
ag27184
ag27191
ag27198
ag27205
asg1137
I0
sg21
I0
sg1138
S'com.google.common.base.ss'
p27210
sba(iArchitecture
Cluster
p27211
(dp27212
g7
(lp27213
(iArchitecture
Entity
p27214
(dp27215
g11
(lp27216
sg13
S'com.google.common.base.Defaults'
p27217
sg15
(lp27218
sg17
(lp27219
sg19
(lp27220
sg21
I0
sba(iArchitecture
Entity
p27221
(dp27222
g11
(lp27223
sg13
S'com.google.common.base.Preconditions'
p27224
sg15
(lp27225
sg17
(lp27226
sg19
(lp27227
sg21
I0
sba(iArchitecture
Entity
p27228
(dp27229
g11
(lp27230
sg13
S'com.google.common.base.Utf8'
p27231
sg15
(lp27232
sg17
(lp27233
sg19
(lp27234
sg21
I0
sba(iArchitecture
Entity
p27235
(dp27236
g11
(lp27237
sg13
S'com.google.common.cache.AbstractCache'
p27238
sg15
(lp27239
sg17
(lp27240
sg19
(lp27241
sg21
I0
sba(iArchitecture
Entity
p27242
(dp27243
g11
(lp27244
sg13
S'com.google.common.cache.AbstractCache$SimpleStatsCounter'
p27245
sg15
(lp27246
sg17
(lp27247
sg19
(lp27248
sg21
I0
sba(iArchitecture
Entity
p27249
(dp27250
g11
(lp27251
sg13
S'com.google.common.cache.AbstractCache$StatsCounter'
p27252
sg15
(lp27253
sg17
(lp27254
sg19
(lp27255
sg21
I0
sba(iArchitecture
Entity
p27256
(dp27257
g11
(lp27258
sg13
S'com.google.common.cache.Cache'
p27259
sg15
(lp27260
sg17
(lp27261
sg19
(lp27262
sg21
I0
sba(iArchitecture
Entity
p27263
(dp27264
g11
(lp27265
sg13
S'com.google.common.cache.CacheBuilder'
p27266
sg15
(lp27267
sg17
(lp27268
sg19
(lp27269
sg21
I0
sba(iArchitecture
Entity
p27270
(dp27271
g11
(lp27272
sg13
S'com.google.common.cache.CacheBuilder$1'
p27273
sg15
(lp27274
sg17
(lp27275
sg19
(lp27276
sg21
I0
sba(iArchitecture
Entity
p27277
(dp27278
g11
(lp27279
sg13
S'com.google.common.cache.CacheBuilder$2'
p27280
sg15
(lp27281
sg17
(lp27282
sg19
(lp27283
sg21
I0
sba(iArchitecture
Entity
p27284
(dp27285
g11
(lp27286
sg13
S'com.google.common.cache.CacheBuilder$3'
p27287
sg15
(lp27288
sg17
(lp27289
sg19
(lp27290
sg21
I0
sba(iArchitecture
Entity
p27291
(dp27292
g11
(lp27293
sg13
S'com.google.common.cache.CacheBuilder$NullListener'
p27294
sg15
(lp27295
sg17
(lp27296
sg19
(lp27297
sg21
I0
sba(iArchitecture
Entity
p27298
(dp27299
g11
(lp27300
sg13
S'com.google.common.cache.CacheBuilder$OneWeigher'
p27301
sg15
(lp27302
sg17
(lp27303
sg19
(lp27304
sg21
I0
sba(iArchitecture
Entity
p27305
(dp27306
g11
(lp27307
sg13
S'com.google.common.cache.CacheBuilderSpec'
p27308
sg15
(lp27309
sg17
(lp27310
sg19
(lp27311
sg21
I0
sba(iArchitecture
Entity
p27312
(dp27313
g11
(lp27314
sg13
S'com.google.common.cache.CacheBuilderSpec$1'
p27315
sg15
(lp27316
sg17
(lp27317
sg19
(lp27318
sg21
I0
sba(iArchitecture
Entity
p27319
(dp27320
g11
(lp27321
sg13
S'com.google.common.cache.CacheBuilderSpec$AccessDurationParser'
p27322
sg15
(lp27323
sg17
(lp27324
sg19
(lp27325
sg21
I0
sba(iArchitecture
Entity
p27326
(dp27327
g11
(lp27328
sg13
S'com.google.common.cache.CacheBuilderSpec$ConcurrencyLevelParser'
p27329
sg15
(lp27330
sg17
(lp27331
sg19
(lp27332
sg21
I0
sba(iArchitecture
Entity
p27333
(dp27334
g11
(lp27335
sg13
S'com.google.common.cache.CacheBuilderSpec$DurationParser'
p27336
sg15
(lp27337
sg17
(lp27338
sg19
(lp27339
sg21
I0
sba(iArchitecture
Entity
p27340
(dp27341
g11
(lp27342
sg13
S'com.google.common.cache.CacheBuilderSpec$InitialCapacityParser'
p27343
sg15
(lp27344
sg17
(lp27345
sg19
(lp27346
sg21
I0
sba(iArchitecture
Entity
p27347
(dp27348
g11
(lp27349
sg13
S'com.google.common.cache.CacheBuilderSpec$IntegerParser'
p27350
sg15
(lp27351
sg17
(lp27352
sg19
(lp27353
sg21
I0
sba(iArchitecture
Entity
p27354
(dp27355
g11
(lp27356
sg13
S'com.google.common.cache.CacheBuilderSpec$KeyStrengthParser'
p27357
sg15
(lp27358
sg17
(lp27359
sg19
(lp27360
sg21
I0
sba(iArchitecture
Entity
p27361
(dp27362
g11
(lp27363
sg13
S'com.google.common.cache.CacheBuilderSpec$LongParser'
p27364
sg15
(lp27365
sg17
(lp27366
sg19
(lp27367
sg21
I0
sba(iArchitecture
Entity
p27368
(dp27369
g11
(lp27370
sg13
S'com.google.common.cache.CacheBuilderSpec$MaximumSizeParser'
p27371
sg15
(lp27372
sg17
(lp27373
sg19
(lp27374
sg21
I0
sba(iArchitecture
Entity
p27375
(dp27376
g11
(lp27377
sg13
S'com.google.common.cache.CacheBuilderSpec$MaximumWeightParser'
p27378
sg15
(lp27379
sg17
(lp27380
sg19
(lp27381
sg21
I0
sba(iArchitecture
Entity
p27382
(dp27383
g11
(lp27384
sg13
S'com.google.common.cache.CacheBuilderSpec$RecordStatsParser'
p27385
sg15
(lp27386
sg17
(lp27387
sg19
(lp27388
sg21
I0
sba(iArchitecture
Entity
p27389
(dp27390
g11
(lp27391
sg13
S'com.google.common.cache.CacheBuilderSpec$RefreshDurationParser'
p27392
sg15
(lp27393
sg17
(lp27394
sg19
(lp27395
sg21
I0
sba(iArchitecture
Entity
p27396
(dp27397
g11
(lp27398
sg13
S'com.google.common.cache.CacheBuilderSpec$ValueParser'
p27399
sg15
(lp27400
sg17
(lp27401
sg19
(lp27402
sg21
I0
sba(iArchitecture
Entity
p27403
(dp27404
g11
(lp27405
sg13
S'com.google.common.cache.CacheBuilderSpec$ValueStrengthParser'
p27406
sg15
(lp27407
sg17
(lp27408
sg19
(lp27409
sg21
I0
sba(iArchitecture
Entity
p27410
(dp27411
g11
(lp27412
sg13
S'com.google.common.cache.CacheBuilderSpec$WriteDurationParser'
p27413
sg15
(lp27414
sg17
(lp27415
sg19
(lp27416
sg21
I0
sba(iArchitecture
Entity
p27417
(dp27418
g11
(lp27419
sg13
S'com.google.common.cache.CacheLoader'
p27420
sg15
(lp27421
sg17
(lp27422
sg19
(lp27423
sg21
I0
sba(iArchitecture
Entity
p27424
(dp27425
g11
(lp27426
sg13
S'com.google.common.cache.CacheLoader$1'
p27427
sg15
(lp27428
sg17
(lp27429
sg19
(lp27430
sg21
I0
sba(iArchitecture
Entity
p27431
(dp27432
g11
(lp27433
sg13
S'com.google.common.cache.CacheLoader$1$1'
p27434
sg15
(lp27435
sg17
(lp27436
sg19
(lp27437
sg21
I0
sba(iArchitecture
Entity
p27438
(dp27439
g11
(lp27440
sg13
S'com.google.common.cache.CacheLoader$FunctionToCacheLoader'
p27441
sg15
(lp27442
sg17
(lp27443
sg19
(lp27444
sg21
I0
sba(iArchitecture
Entity
p27445
(dp27446
g11
(lp27447
sg13
S'com.google.common.cache.CacheLoader$InvalidCacheLoadException'
p27448
sg15
(lp27449
sg17
(lp27450
sg19
(lp27451
sg21
I0
sba(iArchitecture
Entity
p27452
(dp27453
g11
(lp27454
sg13
S'com.google.common.cache.CacheLoader$SupplierToCacheLoader'
p27455
sg15
(lp27456
sg17
(lp27457
sg19
(lp27458
sg21
I0
sba(iArchitecture
Entity
p27459
(dp27460
g11
(lp27461
sg13
S'com.google.common.cache.CacheLoader$UnsupportedLoadingOperationException'
p27462
sg15
(lp27463
sg17
(lp27464
sg19
(lp27465
sg21
I0
sba(iArchitecture
Entity
p27466
(dp27467
g11
(lp27468
sg13
S'com.google.common.cache.CacheStats'
p27469
sg15
(lp27470
sg17
(lp27471
sg19
(lp27472
sg21
I0
sba(iArchitecture
Entity
p27473
(dp27474
g11
(lp27475
sg13
S'com.google.common.cache.ForwardingCache'
p27476
sg15
(lp27477
sg17
(lp27478
sg19
(lp27479
sg21
I0
sba(iArchitecture
Entity
p27480
(dp27481
g11
(lp27482
sg13
S'com.google.common.cache.ForwardingCache$SimpleForwardingCache'
p27483
sg15
(lp27484
sg17
(lp27485
sg19
(lp27486
sg21
I0
sba(iArchitecture
Entity
p27487
(dp27488
g11
(lp27489
sg13
S'com.google.common.cache.ForwardingLoadingCache'
p27490
sg15
(lp27491
sg17
(lp27492
sg19
(lp27493
sg21
I0
sba(iArchitecture
Entity
p27494
(dp27495
g11
(lp27496
sg13
S'com.google.common.cache.ForwardingLoadingCache$SimpleForwardingLoadingCache'
p27497
sg15
(lp27498
sg17
(lp27499
sg19
(lp27500
sg21
I0
sba(iArchitecture
Entity
p27501
(dp27502
g11
(lp27503
sg13
S'com.google.common.cache.LoadingCache'
p27504
sg15
(lp27505
sg17
(lp27506
sg19
(lp27507
sg21
I0
sba(iArchitecture
Entity
p27508
(dp27509
g11
(lp27510
sg13
S'com.google.common.cache.LocalCache'
p27511
sg15
(lp27512
sg17
(lp27513
sg19
(lp27514
sg21
I0
sba(iArchitecture
Entity
p27515
(dp27516
g11
(lp27517
sg13
S'com.google.common.cache.LocalCache$1'
p27518
sg15
(lp27519
sg17
(lp27520
sg19
(lp27521
sg21
I0
sba(iArchitecture
Entity
p27522
(dp27523
g11
(lp27524
sg13
S'com.google.common.cache.LocalCache$2'
p27525
sg15
(lp27526
sg17
(lp27527
sg19
(lp27528
sg21
I0
sba(iArchitecture
Entity
p27529
(dp27530
g11
(lp27531
sg13
S'com.google.common.cache.LocalCache$AbstractCacheSet'
p27532
sg15
(lp27533
sg17
(lp27534
sg19
(lp27535
sg21
I0
sba(iArchitecture
Entity
p27536
(dp27537
g11
(lp27538
sg13
S'com.google.common.cache.LocalCache$AbstractReferenceEntry'
p27539
sg15
(lp27540
sg17
(lp27541
sg19
(lp27542
sg21
I0
sba(iArchitecture
Entity
p27543
(dp27544
g11
(lp27545
sg13
S'com.google.common.cache.LocalCache$AccessQueue'
p27546
sg15
(lp27547
sg17
(lp27548
sg19
(lp27549
sg21
I0
sba(iArchitecture
Entity
p27550
(dp27551
g11
(lp27552
sg13
S'com.google.common.cache.LocalCache$AccessQueue$1'
p27553
sg15
(lp27554
sg17
(lp27555
sg19
(lp27556
sg21
I0
sba(iArchitecture
Entity
p27557
(dp27558
g11
(lp27559
sg13
S'com.google.common.cache.LocalCache$AccessQueue$2'
p27560
sg15
(lp27561
sg17
(lp27562
sg19
(lp27563
sg21
I0
sba(iArchitecture
Entity
p27564
(dp27565
g11
(lp27566
sg13
S'com.google.common.cache.LocalCache$EntryFactory'
p27567
sg15
(lp27568
sg17
(lp27569
sg19
(lp27570
sg21
I0
sba(iArchitecture
Entity
p27571
(dp27572
g11
(lp27573
sg13
S'com.google.common.cache.LocalCache$EntryFactory$1'
p27574
sg15
(lp27575
sg17
(lp27576
sg19
(lp27577
sg21
I0
sba(iArchitecture
Entity
p27578
(dp27579
g11
(lp27580
sg13
S'com.google.common.cache.LocalCache$EntryFactory$2'
p27581
sg15
(lp27582
sg17
(lp27583
sg19
(lp27584
sg21
I0
sba(iArchitecture
Entity
p27585
(dp27586
g11
(lp27587
sg13
S'com.google.common.cache.LocalCache$EntryFactory$3'
p27588
sg15
(lp27589
sg17
(lp27590
sg19
(lp27591
sg21
I0
sba(iArchitecture
Entity
p27592
(dp27593
g11
(lp27594
sg13
S'com.google.common.cache.LocalCache$EntryFactory$4'
p27595
sg15
(lp27596
sg17
(lp27597
sg19
(lp27598
sg21
I0
sba(iArchitecture
Entity
p27599
(dp27600
g11
(lp27601
sg13
S'com.google.common.cache.LocalCache$EntryFactory$5'
p27602
sg15
(lp27603
sg17
(lp27604
sg19
(lp27605
sg21
I0
sba(iArchitecture
Entity
p27606
(dp27607
g11
(lp27608
sg13
S'com.google.common.cache.LocalCache$EntryFactory$6'
p27609
sg15
(lp27610
sg17
(lp27611
sg19
(lp27612
sg21
I0
sba(iArchitecture
Entity
p27613
(dp27614
g11
(lp27615
sg13
S'com.google.common.cache.LocalCache$EntryFactory$7'
p27616
sg15
(lp27617
sg17
(lp27618
sg19
(lp27619
sg21
I0
sba(iArchitecture
Entity
p27620
(dp27621
g11
(lp27622
sg13
S'com.google.common.cache.LocalCache$EntryFactory$8'
p27623
sg15
(lp27624
sg17
(lp27625
sg19
(lp27626
sg21
I0
sba(iArchitecture
Entity
p27627
(dp27628
g11
(lp27629
sg13
S'com.google.common.cache.LocalCache$EntryIterator'
p27630
sg15
(lp27631
sg17
(lp27632
sg19
(lp27633
sg21
I0
sba(iArchitecture
Entity
p27634
(dp27635
g11
(lp27636
sg13
S'com.google.common.cache.LocalCache$EntrySet'
p27637
sg15
(lp27638
sg17
(lp27639
sg19
(lp27640
sg21
I0
sba(iArchitecture
Entity
p27641
(dp27642
g11
(lp27643
sg13
S'com.google.common.cache.LocalCache$HashIterator'
p27644
sg15
(lp27645
sg17
(lp27646
sg19
(lp27647
sg21
I0
sba(iArchitecture
Entity
p27648
(dp27649
g11
(lp27650
sg13
S'com.google.common.cache.LocalCache$KeyIterator'
p27651
sg15
(lp27652
sg17
(lp27653
sg19
(lp27654
sg21
I0
sba(iArchitecture
Entity
p27655
(dp27656
g11
(lp27657
sg13
S'com.google.common.cache.LocalCache$KeySet'
p27658
sg15
(lp27659
sg17
(lp27660
sg19
(lp27661
sg21
I0
sba(iArchitecture
Entity
p27662
(dp27663
g11
(lp27664
sg13
S'com.google.common.cache.LocalCache$LoadingSerializationProxy'
p27665
sg15
(lp27666
sg17
(lp27667
sg19
(lp27668
sg21
I0
sba(iArchitecture
Entity
p27669
(dp27670
g11
(lp27671
sg13
S'com.google.common.cache.LocalCache$LoadingValueReference'
p27672
sg15
(lp27673
sg17
(lp27674
sg19
(lp27675
sg21
I0
sba(iArchitecture
Entity
p27676
(dp27677
g11
(lp27678
sg13
S'com.google.common.cache.LocalCache$LoadingValueReference$1'
p27679
sg15
(lp27680
sg17
(lp27681
sg19
(lp27682
sg21
I0
sba(iArchitecture
Entity
p27683
(dp27684
g11
(lp27685
sg13
S'com.google.common.cache.LocalCache$LocalLoadingCache'
p27686
sg15
(lp27687
sg17
(lp27688
sg19
(lp27689
sg21
I0
sba(iArchitecture
Entity
p27690
(dp27691
g11
(lp27692
sg13
S'com.google.common.cache.LocalCache$LocalManualCache'
p27693
sg15
(lp27694
sg17
(lp27695
sg19
(lp27696
sg21
I0
sba(iArchitecture
Entity
p27697
(dp27698
g11
(lp27699
sg13
S'com.google.common.cache.LocalCache$LocalManualCache$1'
p27700
sg15
(lp27701
sg17
(lp27702
sg19
(lp27703
sg21
I0
sba(iArchitecture
Entity
p27704
(dp27705
g11
(lp27706
sg13
S'com.google.common.cache.LocalCache$ManualSerializationProxy'
p27707
sg15
(lp27708
sg17
(lp27709
sg19
(lp27710
sg21
I0
sba(iArchitecture
Entity
p27711
(dp27712
g11
(lp27713
sg13
S'com.google.common.cache.LocalCache$NullEntry'
p27714
sg15
(lp27715
sg17
(lp27716
sg19
(lp27717
sg21
I0
sba(iArchitecture
Entity
p27718
(dp27719
g11
(lp27720
sg13
S'com.google.common.cache.LocalCache$ReferenceEntry'
p27721
sg15
(lp27722
sg17
(lp27723
sg19
(lp27724
sg21
I0
sba(iArchitecture
Entity
p27725
(dp27726
g11
(lp27727
sg13
S'com.google.common.cache.LocalCache$Segment'
p27728
sg15
(lp27729
sg17
(lp27730
sg19
(lp27731
sg21
I0
sba(iArchitecture
Entity
p27732
(dp27733
g11
(lp27734
sg13
S'com.google.common.cache.LocalCache$Segment$1'
p27735
sg15
(lp27736
sg17
(lp27737
sg19
(lp27738
sg21
I0
sba(iArchitecture
Entity
p27739
(dp27740
g11
(lp27741
sg13
S'com.google.common.cache.LocalCache$SoftValueReference'
p27742
sg15
(lp27743
sg17
(lp27744
sg19
(lp27745
sg21
I0
sba(iArchitecture
Entity
p27746
(dp27747
g11
(lp27748
sg13
S'com.google.common.cache.LocalCache$Strength'
p27749
sg15
(lp27750
sg17
(lp27751
sg19
(lp27752
sg21
I0
sba(iArchitecture
Entity
p27753
(dp27754
g11
(lp27755
sg13
S'com.google.common.cache.LocalCache$Strength$1'
p27756
sg15
(lp27757
sg17
(lp27758
sg19
(lp27759
sg21
I0
sba(iArchitecture
Entity
p27760
(dp27761
g11
(lp27762
sg13
S'com.google.common.cache.LocalCache$Strength$2'
p27763
sg15
(lp27764
sg17
(lp27765
sg19
(lp27766
sg21
I0
sba(iArchitecture
Entity
p27767
(dp27768
g11
(lp27769
sg13
S'com.google.common.cache.LocalCache$Strength$3'
p27770
sg15
(lp27771
sg17
(lp27772
sg19
(lp27773
sg21
I0
sba(iArchitecture
Entity
p27774
(dp27775
g11
(lp27776
sg13
S'com.google.common.cache.LocalCache$StrongAccessEntry'
p27777
sg15
(lp27778
sg17
(lp27779
sg19
(lp27780
sg21
I0
sba(iArchitecture
Entity
p27781
(dp27782
g11
(lp27783
sg13
S'com.google.common.cache.LocalCache$StrongAccessWriteEntry'
p27784
sg15
(lp27785
sg17
(lp27786
sg19
(lp27787
sg21
I0
sba(iArchitecture
Entity
p27788
(dp27789
g11
(lp27790
sg13
S'com.google.common.cache.LocalCache$StrongEntry'
p27791
sg15
(lp27792
sg17
(lp27793
sg19
(lp27794
sg21
I0
sba(iArchitecture
Entity
p27795
(dp27796
g11
(lp27797
sg13
S'com.google.common.cache.LocalCache$StrongValueReference'
p27798
sg15
(lp27799
sg17
(lp27800
sg19
(lp27801
sg21
I0
sba(iArchitecture
Entity
p27802
(dp27803
g11
(lp27804
sg13
S'com.google.common.cache.LocalCache$StrongWriteEntry'
p27805
sg15
(lp27806
sg17
(lp27807
sg19
(lp27808
sg21
I0
sba(iArchitecture
Entity
p27809
(dp27810
g11
(lp27811
sg13
S'com.google.common.cache.LocalCache$ValueIterator'
p27812
sg15
(lp27813
sg17
(lp27814
sg19
(lp27815
sg21
I0
sba(iArchitecture
Entity
p27816
(dp27817
g11
(lp27818
sg13
S'com.google.common.cache.LocalCache$ValueReference'
p27819
sg15
(lp27820
sg17
(lp27821
sg19
(lp27822
sg21
I0
sba(iArchitecture
Entity
p27823
(dp27824
g11
(lp27825
sg13
S'com.google.common.cache.LocalCache$Values'
p27826
sg15
(lp27827
sg17
(lp27828
sg19
(lp27829
sg21
I0
sba(iArchitecture
Entity
p27830
(dp27831
g11
(lp27832
sg13
S'com.google.common.cache.LocalCache$WeakAccessEntry'
p27833
sg15
(lp27834
sg17
(lp27835
sg19
(lp27836
sg21
I0
sba(iArchitecture
Entity
p27837
(dp27838
g11
(lp27839
sg13
S'com.google.common.cache.LocalCache$WeakAccessWriteEntry'
p27840
sg15
(lp27841
sg17
(lp27842
sg19
(lp27843
sg21
I0
sba(iArchitecture
Entity
p27844
(dp27845
g11
(lp27846
sg13
S'com.google.common.cache.LocalCache$WeakEntry'
p27847
sg15
(lp27848
sg17
(lp27849
sg19
(lp27850
sg21
I0
sba(iArchitecture
Entity
p27851
(dp27852
g11
(lp27853
sg13
S'com.google.common.cache.LocalCache$WeakValueReference'
p27854
sg15
(lp27855
sg17
(lp27856
sg19
(lp27857
sg21
I0
sba(iArchitecture
Entity
p27858
(dp27859
g11
(lp27860
sg13
S'com.google.common.cache.LocalCache$WeakWriteEntry'
p27861
sg15
(lp27862
sg17
(lp27863
sg19
(lp27864
sg21
I0
sba(iArchitecture
Entity
p27865
(dp27866
g11
(lp27867
sg13
S'com.google.common.cache.LocalCache$WeightedSoftValueReference'
p27868
sg15
(lp27869
sg17
(lp27870
sg19
(lp27871
sg21
I0
sba(iArchitecture
Entity
p27872
(dp27873
g11
(lp27874
sg13
S'com.google.common.cache.LocalCache$WeightedStrongValueReference'
p27875
sg15
(lp27876
sg17
(lp27877
sg19
(lp27878
sg21
I0
sba(iArchitecture
Entity
p27879
(dp27880
g11
(lp27881
sg13
S'com.google.common.cache.LocalCache$WeightedWeakValueReference'
p27882
sg15
(lp27883
sg17
(lp27884
sg19
(lp27885
sg21
I0
sba(iArchitecture
Entity
p27886
(dp27887
g11
(lp27888
sg13
S'com.google.common.cache.LocalCache$WriteQueue'
p27889
sg15
(lp27890
sg17
(lp27891
sg19
(lp27892
sg21
I0
sba(iArchitecture
Entity
p27893
(dp27894
g11
(lp27895
sg13
S'com.google.common.cache.LocalCache$WriteQueue$1'
p27896
sg15
(lp27897
sg17
(lp27898
sg19
(lp27899
sg21
I0
sba(iArchitecture
Entity
p27900
(dp27901
g11
(lp27902
sg13
S'com.google.common.cache.LocalCache$WriteQueue$2'
p27903
sg15
(lp27904
sg17
(lp27905
sg19
(lp27906
sg21
I0
sba(iArchitecture
Entity
p27907
(dp27908
g11
(lp27909
sg13
S'com.google.common.cache.LocalCache$WriteThroughEntry'
p27910
sg15
(lp27911
sg17
(lp27912
sg19
(lp27913
sg21
I0
sba(iArchitecture
Entity
p27914
(dp27915
g11
(lp27916
sg13
S'com.google.common.cache.LongAddable'
p27917
sg15
(lp27918
sg17
(lp27919
sg19
(lp27920
sg21
I0
sba(iArchitecture
Entity
p27921
(dp27922
g11
(lp27923
sg13
S'com.google.common.cache.LongAddables'
p27924
sg15
(lp27925
sg17
(lp27926
sg19
(lp27927
sg21
I0
sba(iArchitecture
Entity
p27928
(dp27929
g11
(lp27930
sg13
S'com.google.common.cache.LongAddables$1'
p27931
sg15
(lp27932
sg17
(lp27933
sg19
(lp27934
sg21
I0
sba(iArchitecture
Entity
p27935
(dp27936
g11
(lp27937
sg13
S'com.google.common.cache.LongAddables$2'
p27938
sg15
(lp27939
sg17
(lp27940
sg19
(lp27941
sg21
I0
sba(iArchitecture
Entity
p27942
(dp27943
g11
(lp27944
sg13
S'com.google.common.cache.LongAddables$PureJavaLongAddable'
p27945
sg15
(lp27946
sg17
(lp27947
sg19
(lp27948
sg21
I0
sba(iArchitecture
Entity
p27949
(dp27950
g11
(lp27951
sg13
S'com.google.common.cache.LongAdder'
p27952
sg15
(lp27953
sg17
(lp27954
sg19
(lp27955
sg21
I0
sba(iArchitecture
Entity
p27956
(dp27957
g11
(lp27958
sg13
S'com.google.common.cache.RemovalCause'
p27959
sg15
(lp27960
sg17
(lp27961
sg19
(lp27962
sg21
I0
sba(iArchitecture
Entity
p27963
(dp27964
g11
(lp27965
sg13
S'com.google.common.cache.RemovalCause$1'
p27966
sg15
(lp27967
sg17
(lp27968
sg19
(lp27969
sg21
I0
sba(iArchitecture
Entity
p27970
(dp27971
g11
(lp27972
sg13
S'com.google.common.cache.RemovalCause$2'
p27973
sg15
(lp27974
sg17
(lp27975
sg19
(lp27976
sg21
I0
sba(iArchitecture
Entity
p27977
(dp27978
g11
(lp27979
sg13
S'com.google.common.cache.RemovalCause$3'
p27980
sg15
(lp27981
sg17
(lp27982
sg19
(lp27983
sg21
I0
sba(iArchitecture
Entity
p27984
(dp27985
g11
(lp27986
sg13
S'com.google.common.cache.RemovalCause$4'
p27987
sg15
(lp27988
sg17
(lp27989
sg19
(lp27990
sg21
I0
sba(iArchitecture
Entity
p27991
(dp27992
g11
(lp27993
sg13
S'com.google.common.cache.RemovalCause$5'
p27994
sg15
(lp27995
sg17
(lp27996
sg19
(lp27997
sg21
I0
sba(iArchitecture
Entity
p27998
(dp27999
g11
(lp28000
sg13
S'com.google.common.cache.RemovalListener'
p28001
sg15
(lp28002
sg17
(lp28003
sg19
(lp28004
sg21
I0
sba(iArchitecture
Entity
p28005
(dp28006
g11
(lp28007
sg13
S'com.google.common.cache.RemovalListeners'
p28008
sg15
(lp28009
sg17
(lp28010
sg19
(lp28011
sg21
I0
sba(iArchitecture
Entity
p28012
(dp28013
g11
(lp28014
sg13
S'com.google.common.cache.RemovalListeners$1'
p28015
sg15
(lp28016
sg17
(lp28017
sg19
(lp28018
sg21
I0
sba(iArchitecture
Entity
p28019
(dp28020
g11
(lp28021
sg13
S'com.google.common.cache.RemovalListeners$1$1'
p28022
sg15
(lp28023
sg17
(lp28024
sg19
(lp28025
sg21
I0
sba(iArchitecture
Entity
p28026
(dp28027
g11
(lp28028
sg13
S'com.google.common.cache.RemovalNotification'
p28029
sg15
(lp28030
sg17
(lp28031
sg19
(lp28032
sg21
I0
sba(iArchitecture
Entity
p28033
(dp28034
g11
(lp28035
sg13
S'com.google.common.cache.Striped64'
p28036
sg15
(lp28037
sg17
(lp28038
sg19
(lp28039
sg21
I0
sba(iArchitecture
Entity
p28040
(dp28041
g11
(lp28042
sg13
S'com.google.common.cache.Striped64$1'
p28043
sg15
(lp28044
sg17
(lp28045
sg19
(lp28046
sg21
I0
sba(iArchitecture
Entity
p28047
(dp28048
g11
(lp28049
sg13
S'com.google.common.cache.Striped64$Cell'
p28050
sg15
(lp28051
sg17
(lp28052
sg19
(lp28053
sg21
I0
sba(iArchitecture
Entity
p28054
(dp28055
g11
(lp28056
sg13
S'com.google.common.cache.Weigher'
p28057
sg15
(lp28058
sg17
(lp28059
sg19
(lp28060
sg21
I0
sba(iArchitecture
Entity
p28061
(dp28062
g11
(lp28063
sg13
S'com.google.common.escape.ArrayBasedUnicodeEscaper'
p28064
sg15
(lp28065
sg17
(lp28066
sg19
(lp28067
sg21
I0
sba(iArchitecture
Entity
p28068
(dp28069
g11
(lp28070
sg13
S'com.google.common.hash.HashingInputStream'
p28071
sg15
(lp28072
sg17
(lp28073
sg19
(lp28074
sg21
I0
sba(iArchitecture
Entity
p28075
(dp28076
g11
(lp28077
sg13
S'com.google.common.hash.HashingOutputStream'
p28078
sg15
(lp28079
sg17
(lp28080
sg19
(lp28081
sg21
I0
sba(iArchitecture
Entity
p28082
(dp28083
g11
(lp28084
sg13
S'com.google.common.io.CountingInputStream'
p28085
sg15
(lp28086
sg17
(lp28087
sg19
(lp28088
sg21
I0
sba(iArchitecture
Entity
p28089
(dp28090
g11
(lp28091
sg13
S'com.google.common.io.CountingOutputStream'
p28092
sg15
(lp28093
sg17
(lp28094
sg19
(lp28095
sg21
I0
sba(iArchitecture
Entity
p28096
(dp28097
g11
(lp28098
sg13
S'com.google.common.io.PatternFilenameFilter'
p28099
sg15
(lp28100
sg17
(lp28101
sg19
(lp28102
sg21
I0
sba(iArchitecture
Entity
p28103
(dp28104
g11
(lp28105
sg13
S'com.google.common.primitives.UnsignedInteger'
p28106
sg15
(lp28107
sg17
(lp28108
sg19
(lp28109
sg21
I0
sba(iArchitecture
Entity
p28110
(dp28111
g11
(lp28112
sg13
S'com.google.common.util.concurrent.AtomicLongMap'
p28113
sg15
(lp28114
sg17
(lp28115
sg19
(lp28116
sg21
I0
sba(iArchitecture
Entity
p28117
(dp28118
g11
(lp28119
sg13
S'com.google.common.util.concurrent.ListenableFutureTask'
p28120
sg15
(lp28121
sg17
(lp28122
sg19
(lp28123
sg21
I0
sbasg1135
(lp28124
g27217
ag27224
ag27231
ag27238
ag27245
ag27252
ag27259
ag27266
ag27273
ag27280
ag27287
ag27294
ag27301
ag27308
ag27315
ag27322
ag27329
ag27336
ag27343
ag27350
ag27357
ag27364
ag27371
ag27378
ag27385
ag27392
ag27399
ag27406
ag27413
ag27420
ag27427
ag27434
ag27441
ag27448
ag27455
ag27462
ag27469
ag27476
ag27483
ag27490
ag27497
ag27504
ag27511
ag27518
ag27525
ag27532
ag27539
ag27546
ag27553
ag27560
ag27567
ag27574
ag27581
ag27588
ag27595
ag27602
ag27609
ag27616
ag27623
ag27630
ag27637
ag27644
ag27651
ag27658
ag27665
ag27672
ag27679
ag27686
ag27693
ag27700
ag27707
ag27714
ag27721
ag27728
ag27735
ag27742
ag27749
ag27756
ag27763
ag27770
ag27777
ag27784
ag27791
ag27798
ag27805
ag27812
ag27819
ag27826
ag27833
ag27840
ag27847
ag27854
ag27861
ag27868
ag27875
ag27882
ag27889
ag27896
ag27903
ag27910
ag27917
ag27924
ag27931
ag27938
ag27945
ag27952
ag27959
ag27966
ag27973
ag27980
ag27987
ag27994
ag28001
ag28008
ag28015
ag28022
ag28029
ag28036
ag28043
ag28050
ag28057
ag28064
ag28071
ag28078
ag28085
ag28092
ag28099
ag28106
ag28113
ag28120
asg1137
I0
sg21
I0
sg1138
S'com.google.common.cache.ss'
p28125
sba(iArchitecture
Cluster
p28126
(dp28127
g7
(lp28128
(iArchitecture
Entity
p28129
(dp28130
g11
(lp28131
sg13
S'com.google.common.annotations.Beta'
p28132
sg15
(lp28133
sg17
(lp28134
sg19
(lp28135
sg21
I0
sba(iArchitecture
Entity
p28136
(dp28137
g11
(lp28138
sg13
S'com.google.common.annotations.GwtCompatible'
p28139
sg15
(lp28140
sg17
(lp28141
sg19
(lp28142
sg21
I0
sba(iArchitecture
Entity
p28143
(dp28144
g11
(lp28145
sg13
S'com.google.common.annotations.VisibleForTesting'
p28146
sg15
(lp28147
sg17
(lp28148
sg19
(lp28149
sg21
I0
sba(iArchitecture
Entity
p28150
(dp28151
g11
(lp28152
sg13
S'com.google.common.cache.AbstractLoadingCache'
p28153
sg15
(lp28154
sg17
(lp28155
sg19
(lp28156
sg21
I0
sba(iArchitecture
Entity
p28157
(dp28158
g11
(lp28159
sg13
S'com.google.common.collect.AbstractBiMap'
p28160
sg15
(lp28161
sg17
(lp28162
sg19
(lp28163
sg21
I0
sba(iArchitecture
Entity
p28164
(dp28165
g11
(lp28166
sg13
S'com.google.common.collect.AbstractBiMap$1'
p28167
sg15
(lp28168
sg17
(lp28169
sg19
(lp28170
sg21
I0
sba(iArchitecture
Entity
p28171
(dp28172
g11
(lp28173
sg13
S'com.google.common.collect.AbstractBiMap$BiMapEntry'
p28174
sg15
(lp28175
sg17
(lp28176
sg19
(lp28177
sg21
I0
sba(iArchitecture
Entity
p28178
(dp28179
g11
(lp28180
sg13
S'com.google.common.collect.AbstractBiMap$EntrySet'
p28181
sg15
(lp28182
sg17
(lp28183
sg19
(lp28184
sg21
I0
sba(iArchitecture
Entity
p28185
(dp28186
g11
(lp28187
sg13
S'com.google.common.collect.AbstractBiMap$Inverse'
p28188
sg15
(lp28189
sg17
(lp28190
sg19
(lp28191
sg21
I0
sba(iArchitecture
Entity
p28192
(dp28193
g11
(lp28194
sg13
S'com.google.common.collect.AbstractBiMap$KeySet'
p28195
sg15
(lp28196
sg17
(lp28197
sg19
(lp28198
sg21
I0
sba(iArchitecture
Entity
p28199
(dp28200
g11
(lp28201
sg13
S'com.google.common.collect.AbstractBiMap$ValueSet'
p28202
sg15
(lp28203
sg17
(lp28204
sg19
(lp28205
sg21
I0
sba(iArchitecture
Entity
p28206
(dp28207
g11
(lp28208
sg13
S'com.google.common.collect.AbstractIndexedListIterator'
p28209
sg15
(lp28210
sg17
(lp28211
sg19
(lp28212
sg21
I0
sba(iArchitecture
Entity
p28213
(dp28214
g11
(lp28215
sg13
S'com.google.common.collect.AbstractIterator'
p28216
sg15
(lp28217
sg17
(lp28218
sg19
(lp28219
sg21
I0
sba(iArchitecture
Entity
p28220
(dp28221
g11
(lp28222
sg13
S'com.google.common.collect.AbstractIterator$1'
p28223
sg15
(lp28224
sg17
(lp28225
sg19
(lp28226
sg21
I0
sba(iArchitecture
Entity
p28227
(dp28228
g11
(lp28229
sg13
S'com.google.common.collect.AbstractIterator$State'
p28230
sg15
(lp28231
sg17
(lp28232
sg19
(lp28233
sg21
I0
sba(iArchitecture
Entity
p28234
(dp28235
g11
(lp28236
sg13
S'com.google.common.collect.AbstractListMultimap'
p28237
sg15
(lp28238
sg17
(lp28239
sg19
(lp28240
sg21
I0
sba(iArchitecture
Entity
p28241
(dp28242
g11
(lp28243
sg13
S'com.google.common.collect.AbstractMapBasedMultimap'
p28244
sg15
(lp28245
sg17
(lp28246
sg19
(lp28247
sg21
I0
sba(iArchitecture
Entity
p28248
(dp28249
g11
(lp28250
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$1'
p28251
sg15
(lp28252
sg17
(lp28253
sg19
(lp28254
sg21
I0
sba(iArchitecture
Entity
p28255
(dp28256
g11
(lp28257
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$2'
p28258
sg15
(lp28259
sg17
(lp28260
sg19
(lp28261
sg21
I0
sba(iArchitecture
Entity
p28262
(dp28263
g11
(lp28264
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$AsMap'
p28265
sg15
(lp28266
sg17
(lp28267
sg19
(lp28268
sg21
I0
sba(iArchitecture
Entity
p28269
(dp28270
g11
(lp28271
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapEntries'
p28272
sg15
(lp28273
sg17
(lp28274
sg19
(lp28275
sg21
I0
sba(iArchitecture
Entity
p28276
(dp28277
g11
(lp28278
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$AsMap$AsMapIterator'
p28279
sg15
(lp28280
sg17
(lp28281
sg19
(lp28282
sg21
I0
sba(iArchitecture
Entity
p28283
(dp28284
g11
(lp28285
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$Itr'
p28286
sg15
(lp28287
sg17
(lp28288
sg19
(lp28289
sg21
I0
sba(iArchitecture
Entity
p28290
(dp28291
g11
(lp28292
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$KeySet'
p28293
sg15
(lp28294
sg17
(lp28295
sg19
(lp28296
sg21
I0
sba(iArchitecture
Entity
p28297
(dp28298
g11
(lp28299
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$KeySet$1'
p28300
sg15
(lp28301
sg17
(lp28302
sg19
(lp28303
sg21
I0
sba(iArchitecture
Entity
p28304
(dp28305
g11
(lp28306
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$NavigableAsMap'
p28307
sg15
(lp28308
sg17
(lp28309
sg19
(lp28310
sg21
I0
sba(iArchitecture
Entity
p28311
(dp28312
g11
(lp28313
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$NavigableKeySet'
p28314
sg15
(lp28315
sg17
(lp28316
sg19
(lp28317
sg21
I0
sba(iArchitecture
Entity
p28318
(dp28319
g11
(lp28320
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$RandomAccessWrappedList'
p28321
sg15
(lp28322
sg17
(lp28323
sg19
(lp28324
sg21
I0
sba(iArchitecture
Entity
p28325
(dp28326
g11
(lp28327
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$SortedAsMap'
p28328
sg15
(lp28329
sg17
(lp28330
sg19
(lp28331
sg21
I0
sba(iArchitecture
Entity
p28332
(dp28333
g11
(lp28334
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$SortedKeySet'
p28335
sg15
(lp28336
sg17
(lp28337
sg19
(lp28338
sg21
I0
sba(iArchitecture
Entity
p28339
(dp28340
g11
(lp28341
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection'
p28342
sg15
(lp28343
sg17
(lp28344
sg19
(lp28345
sg21
I0
sba(iArchitecture
Entity
p28346
(dp28347
g11
(lp28348
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedCollection$WrappedIterator'
p28349
sg15
(lp28350
sg17
(lp28351
sg19
(lp28352
sg21
I0
sba(iArchitecture
Entity
p28353
(dp28354
g11
(lp28355
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedList'
p28356
sg15
(lp28357
sg17
(lp28358
sg19
(lp28359
sg21
I0
sba(iArchitecture
Entity
p28360
(dp28361
g11
(lp28362
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedList$WrappedListIterator'
p28363
sg15
(lp28364
sg17
(lp28365
sg19
(lp28366
sg21
I0
sba(iArchitecture
Entity
p28367
(dp28368
g11
(lp28369
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedNavigableSet'
p28370
sg15
(lp28371
sg17
(lp28372
sg19
(lp28373
sg21
I0
sba(iArchitecture
Entity
p28374
(dp28375
g11
(lp28376
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedSet'
p28377
sg15
(lp28378
sg17
(lp28379
sg19
(lp28380
sg21
I0
sba(iArchitecture
Entity
p28381
(dp28382
g11
(lp28383
sg13
S'com.google.common.collect.AbstractMapBasedMultimap$WrappedSortedSet'
p28384
sg15
(lp28385
sg17
(lp28386
sg19
(lp28387
sg21
I0
sba(iArchitecture
Entity
p28388
(dp28389
g11
(lp28390
sg13
S'com.google.common.collect.AbstractMapBasedMultiset'
p28391
sg15
(lp28392
sg17
(lp28393
sg19
(lp28394
sg21
I0
sba(iArchitecture
Entity
p28395
(dp28396
g11
(lp28397
sg13
S'com.google.common.collect.AbstractMapBasedMultiset$1'
p28398
sg15
(lp28399
sg17
(lp28400
sg19
(lp28401
sg21
I0
sba(iArchitecture
Entity
p28402
(dp28403
g11
(lp28404
sg13
S'com.google.common.collect.AbstractMapBasedMultiset$1$1'
p28405
sg15
(lp28406
sg17
(lp28407
sg19
(lp28408
sg21
I0
sba(iArchitecture
Entity
p28409
(dp28410
g11
(lp28411
sg13
S'com.google.common.collect.AbstractMapBasedMultiset$MapBasedMultisetIterator'
p28412
sg15
(lp28413
sg17
(lp28414
sg19
(lp28415
sg21
I0
sba(iArchitecture
Entity
p28416
(dp28417
g11
(lp28418
sg13
S'com.google.common.collect.AbstractMapEntry'
p28419
sg15
(lp28420
sg17
(lp28421
sg19
(lp28422
sg21
I0
sba(iArchitecture
Entity
p28423
(dp28424
g11
(lp28425
sg13
S'com.google.common.collect.AbstractMultimap'
p28426
sg15
(lp28427
sg17
(lp28428
sg19
(lp28429
sg21
I0
sba(iArchitecture
Entity
p28430
(dp28431
g11
(lp28432
sg13
S'com.google.common.collect.AbstractMultimap$1'
p28433
sg15
(lp28434
sg17
(lp28435
sg19
(lp28436
sg21
I0
sba(iArchitecture
Entity
p28437
(dp28438
g11
(lp28439
sg13
S'com.google.common.collect.AbstractMultimap$Entries'
p28440
sg15
(lp28441
sg17
(lp28442
sg19
(lp28443
sg21
I0
sba(iArchitecture
Entity
p28444
(dp28445
g11
(lp28446
sg13
S'com.google.common.collect.AbstractMultimap$EntrySet'
p28447
sg15
(lp28448
sg17
(lp28449
sg19
(lp28450
sg21
I0
sba(iArchitecture
Entity
p28451
(dp28452
g11
(lp28453
sg13
S'com.google.common.collect.AbstractMultimap$Values'
p28454
sg15
(lp28455
sg17
(lp28456
sg19
(lp28457
sg21
I0
sba(iArchitecture
Entity
p28458
(dp28459
g11
(lp28460
sg13
S'com.google.common.collect.AbstractMultiset'
p28461
sg15
(lp28462
sg17
(lp28463
sg19
(lp28464
sg21
I0
sba(iArchitecture
Entity
p28465
(dp28466
g11
(lp28467
sg13
S'com.google.common.collect.AbstractMultiset$ElementSet'
p28468
sg15
(lp28469
sg17
(lp28470
sg19
(lp28471
sg21
I0
sba(iArchitecture
Entity
p28472
(dp28473
g11
(lp28474
sg13
S'com.google.common.collect.AbstractMultiset$EntrySet'
p28475
sg15
(lp28476
sg17
(lp28477
sg19
(lp28478
sg21
I0
sba(iArchitecture
Entity
p28479
(dp28480
g11
(lp28481
sg13
S'com.google.common.collect.AbstractNavigableMap'
p28482
sg15
(lp28483
sg17
(lp28484
sg19
(lp28485
sg21
I0
sba(iArchitecture
Entity
p28486
(dp28487
g11
(lp28488
sg13
S'com.google.common.collect.AbstractNavigableMap$1'
p28489
sg15
(lp28490
sg17
(lp28491
sg19
(lp28492
sg21
I0
sba(iArchitecture
Entity
p28493
(dp28494
g11
(lp28495
sg13
S'com.google.common.collect.AbstractNavigableMap$DescendingMap'
p28496
sg15
(lp28497
sg17
(lp28498
sg19
(lp28499
sg21
I0
sba(iArchitecture
Entity
p28500
(dp28501
g11
(lp28502
sg13
S'com.google.common.collect.AbstractRangeSet'
p28503
sg15
(lp28504
sg17
(lp28505
sg19
(lp28506
sg21
I0
sba(iArchitecture
Entity
p28507
(dp28508
g11
(lp28509
sg13
S'com.google.common.collect.AbstractSequentialIterator'
p28510
sg15
(lp28511
sg17
(lp28512
sg19
(lp28513
sg21
I0
sba(iArchitecture
Entity
p28514
(dp28515
g11
(lp28516
sg13
S'com.google.common.collect.AbstractSetMultimap'
p28517
sg15
(lp28518
sg17
(lp28519
sg19
(lp28520
sg21
I0
sba(iArchitecture
Entity
p28521
(dp28522
g11
(lp28523
sg13
S'com.google.common.collect.AbstractSortedKeySortedSetMultimap'
p28524
sg15
(lp28525
sg17
(lp28526
sg19
(lp28527
sg21
I0
sba(iArchitecture
Entity
p28528
(dp28529
g11
(lp28530
sg13
S'com.google.common.collect.AbstractSortedMultiset'
p28531
sg15
(lp28532
sg17
(lp28533
sg19
(lp28534
sg21
I0
sba(iArchitecture
Entity
p28535
(dp28536
g11
(lp28537
sg13
S'com.google.common.collect.AbstractSortedMultiset$1DescendingMultisetImpl'
p28538
sg15
(lp28539
sg17
(lp28540
sg19
(lp28541
sg21
I0
sba(iArchitecture
Entity
p28542
(dp28543
g11
(lp28544
sg13
S'com.google.common.collect.AbstractSortedSetMultimap'
p28545
sg15
(lp28546
sg17
(lp28547
sg19
(lp28548
sg21
I0
sba(iArchitecture
Entity
p28549
(dp28550
g11
(lp28551
sg13
S'com.google.common.collect.AbstractTable'
p28552
sg15
(lp28553
sg17
(lp28554
sg19
(lp28555
sg21
I0
sba(iArchitecture
Entity
p28556
(dp28557
g11
(lp28558
sg13
S'com.google.common.collect.AbstractTable$1'
p28559
sg15
(lp28560
sg17
(lp28561
sg19
(lp28562
sg21
I0
sba(iArchitecture
Entity
p28563
(dp28564
g11
(lp28565
sg13
S'com.google.common.collect.AbstractTable$CellSet'
p28566
sg15
(lp28567
sg17
(lp28568
sg19
(lp28569
sg21
I0
sba(iArchitecture
Entity
p28570
(dp28571
g11
(lp28572
sg13
S'com.google.common.collect.AbstractTable$Values'
p28573
sg15
(lp28574
sg17
(lp28575
sg19
(lp28576
sg21
I0
sba(iArchitecture
Entity
p28577
(dp28578
g11
(lp28579
sg13
S'com.google.common.collect.AllEqualOrdering'
p28580
sg15
(lp28581
sg17
(lp28582
sg19
(lp28583
sg21
I0
sba(iArchitecture
Entity
p28584
(dp28585
g11
(lp28586
sg13
S'com.google.common.collect.ArrayListMultimap'
p28587
sg15
(lp28588
sg17
(lp28589
sg19
(lp28590
sg21
I0
sba(iArchitecture
Entity
p28591
(dp28592
g11
(lp28593
sg13
S'com.google.common.collect.ArrayListMultimapGwtSerializationDependencies'
p28594
sg15
(lp28595
sg17
(lp28596
sg19
(lp28597
sg21
I0
sba(iArchitecture
Entity
p28598
(dp28599
g11
(lp28600
sg13
S'com.google.common.collect.ArrayTable'
p28601
sg15
(lp28602
sg17
(lp28603
sg19
(lp28604
sg21
I0
sba(iArchitecture
Entity
p28605
(dp28606
g11
(lp28607
sg13
S'com.google.common.collect.ArrayTable$1'
p28608
sg15
(lp28609
sg17
(lp28610
sg19
(lp28611
sg21
I0
sba(iArchitecture
Entity
p28612
(dp28613
g11
(lp28614
sg13
S'com.google.common.collect.ArrayTable$2'
p28615
sg15
(lp28616
sg17
(lp28617
sg19
(lp28618
sg21
I0
sba(iArchitecture
Entity
p28619
(dp28620
g11
(lp28621
sg13
S'com.google.common.collect.ArrayTable$3'
p28622
sg15
(lp28623
sg17
(lp28624
sg19
(lp28625
sg21
I0
sba(iArchitecture
Entity
p28626
(dp28627
g11
(lp28628
sg13
S'com.google.common.collect.ArrayTable$ArrayMap'
p28629
sg15
(lp28630
sg17
(lp28631
sg19
(lp28632
sg21
I0
sba(iArchitecture
Entity
p28633
(dp28634
g11
(lp28635
sg13
S'com.google.common.collect.ArrayTable$ArrayMap$1'
p28636
sg15
(lp28637
sg17
(lp28638
sg19
(lp28639
sg21
I0
sba(iArchitecture
Entity
p28640
(dp28641
g11
(lp28642
sg13
S'com.google.common.collect.ArrayTable$ArrayMap$2'
p28643
sg15
(lp28644
sg17
(lp28645
sg19
(lp28646
sg21
I0
sba(iArchitecture
Entity
p28647
(dp28648
g11
(lp28649
sg13
S'com.google.common.collect.ArrayTable$Column'
p28650
sg15
(lp28651
sg17
(lp28652
sg19
(lp28653
sg21
I0
sba(iArchitecture
Entity
p28654
(dp28655
g11
(lp28656
sg13
S'com.google.common.collect.ArrayTable$ColumnMap'
p28657
sg15
(lp28658
sg17
(lp28659
sg19
(lp28660
sg21
I0
sba(iArchitecture
Entity
p28661
(dp28662
g11
(lp28663
sg13
S'com.google.common.collect.ArrayTable$Row'
p28664
sg15
(lp28665
sg17
(lp28666
sg19
(lp28667
sg21
I0
sba(iArchitecture
Entity
p28668
(dp28669
g11
(lp28670
sg13
S'com.google.common.collect.ArrayTable$RowMap'
p28671
sg15
(lp28672
sg17
(lp28673
sg19
(lp28674
sg21
I0
sba(iArchitecture
Entity
p28675
(dp28676
g11
(lp28677
sg13
S'com.google.common.collect.BiMap'
p28678
sg15
(lp28679
sg17
(lp28680
sg19
(lp28681
sg21
I0
sba(iArchitecture
Entity
p28682
(dp28683
g11
(lp28684
sg13
S'com.google.common.collect.BinaryTreeTraverser'
p28685
sg15
(lp28686
sg17
(lp28687
sg19
(lp28688
sg21
I0
sba(iArchitecture
Entity
p28689
(dp28690
g11
(lp28691
sg13
S'com.google.common.collect.BinaryTreeTraverser$1'
p28692
sg15
(lp28693
sg17
(lp28694
sg19
(lp28695
sg21
I0
sba(iArchitecture
Entity
p28696
(dp28697
g11
(lp28698
sg13
S'com.google.common.collect.BinaryTreeTraverser$1$1'
p28699
sg15
(lp28700
sg17
(lp28701
sg19
(lp28702
sg21
I0
sba(iArchitecture
Entity
p28703
(dp28704
g11
(lp28705
sg13
S'com.google.common.collect.BinaryTreeTraverser$2'
p28706
sg15
(lp28707
sg17
(lp28708
sg19
(lp28709
sg21
I0
sba(iArchitecture
Entity
p28710
(dp28711
g11
(lp28712
sg13
S'com.google.common.collect.BinaryTreeTraverser$2$1'
p28713
sg15
(lp28714
sg17
(lp28715
sg19
(lp28716
sg21
I0
sba(iArchitecture
Entity
p28717
(dp28718
g11
(lp28719
sg13
S'com.google.common.collect.BinaryTreeTraverser$InOrderIterator'
p28720
sg15
(lp28721
sg17
(lp28722
sg19
(lp28723
sg21
I0
sba(iArchitecture
Entity
p28724
(dp28725
g11
(lp28726
sg13
S'com.google.common.collect.BinaryTreeTraverser$PostOrderIterator'
p28727
sg15
(lp28728
sg17
(lp28729
sg19
(lp28730
sg21
I0
sba(iArchitecture
Entity
p28731
(dp28732
g11
(lp28733
sg13
S'com.google.common.collect.BinaryTreeTraverser$PreOrderIterator'
p28734
sg15
(lp28735
sg17
(lp28736
sg19
(lp28737
sg21
I0
sba(iArchitecture
Entity
p28738
(dp28739
g11
(lp28740
sg13
S'com.google.common.collect.BoundType'
p28741
sg15
(lp28742
sg17
(lp28743
sg19
(lp28744
sg21
I0
sba(iArchitecture
Entity
p28745
(dp28746
g11
(lp28747
sg13
S'com.google.common.collect.BoundType$1'
p28748
sg15
(lp28749
sg17
(lp28750
sg19
(lp28751
sg21
I0
sba(iArchitecture
Entity
p28752
(dp28753
g11
(lp28754
sg13
S'com.google.common.collect.BoundType$2'
p28755
sg15
(lp28756
sg17
(lp28757
sg19
(lp28758
sg21
I0
sba(iArchitecture
Entity
p28759
(dp28760
g11
(lp28761
sg13
S'com.google.common.collect.ByFunctionOrdering'
p28762
sg15
(lp28763
sg17
(lp28764
sg19
(lp28765
sg21
I0
sba(iArchitecture
Entity
p28766
(dp28767
g11
(lp28768
sg13
S'com.google.common.collect.CartesianList'
p28769
sg15
(lp28770
sg17
(lp28771
sg19
(lp28772
sg21
I0
sba(iArchitecture
Entity
p28773
(dp28774
g11
(lp28775
sg13
S'com.google.common.collect.CartesianList$1'
p28776
sg15
(lp28777
sg17
(lp28778
sg19
(lp28779
sg21
I0
sba(iArchitecture
Entity
p28780
(dp28781
g11
(lp28782
sg13
S'com.google.common.collect.ClassToInstanceMap'
p28783
sg15
(lp28784
sg17
(lp28785
sg19
(lp28786
sg21
I0
sba(iArchitecture
Entity
p28787
(dp28788
g11
(lp28789
sg13
S'com.google.common.collect.CollectCollectors'
p28790
sg15
(lp28791
sg17
(lp28792
sg19
(lp28793
sg21
I0
sba(iArchitecture
Entity
p28794
(dp28795
g11
(lp28796
sg13
S'com.google.common.collect.CollectPreconditions'
p28797
sg15
(lp28798
sg17
(lp28799
sg19
(lp28800
sg21
I0
sba(iArchitecture
Entity
p28801
(dp28802
g11
(lp28803
sg13
S'com.google.common.collect.CollectSpliterators'
p28804
sg15
(lp28805
sg17
(lp28806
sg19
(lp28807
sg21
I0
sba(iArchitecture
Entity
p28808
(dp28809
g11
(lp28810
sg13
S'com.google.common.collect.CollectSpliterators$1'
p28811
sg15
(lp28812
sg17
(lp28813
sg19
(lp28814
sg21
I0
sba(iArchitecture
Entity
p28815
(dp28816
g11
(lp28817
sg13
S'com.google.common.collect.CollectSpliterators$1FlatMapSpliterator'
p28818
sg15
(lp28819
sg17
(lp28820
sg19
(lp28821
sg21
I0
sba(iArchitecture
Entity
p28822
(dp28823
g11
(lp28824
sg13
S'com.google.common.collect.CollectSpliterators$1Splitr'
p28825
sg15
(lp28826
sg17
(lp28827
sg19
(lp28828
sg21
I0
sba(iArchitecture
Entity
p28829
(dp28830
g11
(lp28831
sg13
S'com.google.common.collect.CollectSpliterators$1WithCharacteristics'
p28832
sg15
(lp28833
sg17
(lp28834
sg19
(lp28835
sg21
I0
sba(iArchitecture
Entity
p28836
(dp28837
g11
(lp28838
sg13
S'com.google.common.collect.Collections2'
p28839
sg15
(lp28840
sg17
(lp28841
sg19
(lp28842
sg21
I0
sba(iArchitecture
Entity
p28843
(dp28844
g11
(lp28845
sg13
S'com.google.common.collect.Collections2$FilteredCollection'
p28846
sg15
(lp28847
sg17
(lp28848
sg19
(lp28849
sg21
I0
sba(iArchitecture
Entity
p28850
(dp28851
g11
(lp28852
sg13
S'com.google.common.collect.Collections2$OrderedPermutationCollection'
p28853
sg15
(lp28854
sg17
(lp28855
sg19
(lp28856
sg21
I0
sba(iArchitecture
Entity
p28857
(dp28858
g11
(lp28859
sg13
S'com.google.common.collect.Collections2$OrderedPermutationIterator'
p28860
sg15
(lp28861
sg17
(lp28862
sg19
(lp28863
sg21
I0
sba(iArchitecture
Entity
p28864
(dp28865
g11
(lp28866
sg13
S'com.google.common.collect.Collections2$PermutationCollection'
p28867
sg15
(lp28868
sg17
(lp28869
sg19
(lp28870
sg21
I0
sba(iArchitecture
Entity
p28871
(dp28872
g11
(lp28873
sg13
S'com.google.common.collect.Collections2$PermutationIterator'
p28874
sg15
(lp28875
sg17
(lp28876
sg19
(lp28877
sg21
I0
sba(iArchitecture
Entity
p28878
(dp28879
g11
(lp28880
sg13
S'com.google.common.collect.Collections2$TransformedCollection'
p28881
sg15
(lp28882
sg17
(lp28883
sg19
(lp28884
sg21
I0
sba(iArchitecture
Entity
p28885
(dp28886
g11
(lp28887
sg13
S'com.google.common.collect.ComparatorOrdering'
p28888
sg15
(lp28889
sg17
(lp28890
sg19
(lp28891
sg21
I0
sba(iArchitecture
Entity
p28892
(dp28893
g11
(lp28894
sg13
S'com.google.common.collect.Comparators'
p28895
sg15
(lp28896
sg17
(lp28897
sg19
(lp28898
sg21
I0
sba(iArchitecture
Entity
p28899
(dp28900
g11
(lp28901
sg13
S'com.google.common.collect.ComparisonChain'
p28902
sg15
(lp28903
sg17
(lp28904
sg19
(lp28905
sg21
I0
sba(iArchitecture
Entity
p28906
(dp28907
g11
(lp28908
sg13
S'com.google.common.collect.ComparisonChain$1'
p28909
sg15
(lp28910
sg17
(lp28911
sg19
(lp28912
sg21
I0
sba(iArchitecture
Entity
p28913
(dp28914
g11
(lp28915
sg13
S'com.google.common.collect.ComparisonChain$InactiveComparisonChain'
p28916
sg15
(lp28917
sg17
(lp28918
sg19
(lp28919
sg21
I0
sba(iArchitecture
Entity
p28920
(dp28921
g11
(lp28922
sg13
S'com.google.common.collect.CompoundOrdering'
p28923
sg15
(lp28924
sg17
(lp28925
sg19
(lp28926
sg21
I0
sba(iArchitecture
Entity
p28927
(dp28928
g11
(lp28929
sg13
S'com.google.common.collect.ComputationException'
p28930
sg15
(lp28931
sg17
(lp28932
sg19
(lp28933
sg21
I0
sba(iArchitecture
Entity
p28934
(dp28935
g11
(lp28936
sg13
S'com.google.common.collect.ConcurrentHashMultiset'
p28937
sg15
(lp28938
sg17
(lp28939
sg19
(lp28940
sg21
I0
sba(iArchitecture
Entity
p28941
(dp28942
g11
(lp28943
sg13
S'com.google.common.collect.ConcurrentHashMultiset$1'
p28944
sg15
(lp28945
sg17
(lp28946
sg19
(lp28947
sg21
I0
sba(iArchitecture
Entity
p28948
(dp28949
g11
(lp28950
sg13
S'com.google.common.collect.ConcurrentHashMultiset$2'
p28951
sg15
(lp28952
sg17
(lp28953
sg19
(lp28954
sg21
I0
sba(iArchitecture
Entity
p28955
(dp28956
g11
(lp28957
sg13
S'com.google.common.collect.ConcurrentHashMultiset$3'
p28958
sg15
(lp28959
sg17
(lp28960
sg19
(lp28961
sg21
I0
sba(iArchitecture
Entity
p28962
(dp28963
g11
(lp28964
sg13
S'com.google.common.collect.ConcurrentHashMultiset$EntrySet'
p28965
sg15
(lp28966
sg17
(lp28967
sg19
(lp28968
sg21
I0
sba(iArchitecture
Entity
p28969
(dp28970
g11
(lp28971
sg13
S'com.google.common.collect.ConcurrentHashMultiset$FieldSettersHolder'
p28972
sg15
(lp28973
sg17
(lp28974
sg19
(lp28975
sg21
I0
sba(iArchitecture
Entity
p28976
(dp28977
g11
(lp28978
sg13
S'com.google.common.collect.ConsumingQueueIterator'
p28979
sg15
(lp28980
sg17
(lp28981
sg19
(lp28982
sg21
I0
sba(iArchitecture
Entity
p28983
(dp28984
g11
(lp28985
sg13
S'com.google.common.collect.ContiguousSet'
p28986
sg15
(lp28987
sg17
(lp28988
sg19
(lp28989
sg21
I0
sba(iArchitecture
Entity
p28990
(dp28991
g11
(lp28992
sg13
S'com.google.common.collect.Count'
p28993
sg15
(lp28994
sg17
(lp28995
sg19
(lp28996
sg21
I0
sba(iArchitecture
Entity
p28997
(dp28998
g11
(lp28999
sg13
S'com.google.common.collect.Cut'
p29000
sg15
(lp29001
sg17
(lp29002
sg19
(lp29003
sg21
I0
sba(iArchitecture
Entity
p29004
(dp29005
g11
(lp29006
sg13
S'com.google.common.collect.Cut$1'
p29007
sg15
(lp29008
sg17
(lp29009
sg19
(lp29010
sg21
I0
sba(iArchitecture
Entity
p29011
(dp29012
g11
(lp29013
sg13
S'com.google.common.collect.Cut$AboveAll'
p29014
sg15
(lp29015
sg17
(lp29016
sg19
(lp29017
sg21
I0
sba(iArchitecture
Entity
p29018
(dp29019
g11
(lp29020
sg13
S'com.google.common.collect.Cut$AboveValue'
p29021
sg15
(lp29022
sg17
(lp29023
sg19
(lp29024
sg21
I0
sba(iArchitecture
Entity
p29025
(dp29026
g11
(lp29027
sg13
S'com.google.common.collect.Cut$BelowAll'
p29028
sg15
(lp29029
sg17
(lp29030
sg19
(lp29031
sg21
I0
sba(iArchitecture
Entity
p29032
(dp29033
g11
(lp29034
sg13
S'com.google.common.collect.Cut$BelowValue'
p29035
sg15
(lp29036
sg17
(lp29037
sg19
(lp29038
sg21
I0
sba(iArchitecture
Entity
p29039
(dp29040
g11
(lp29041
sg13
S'com.google.common.collect.DenseImmutableTable'
p29042
sg15
(lp29043
sg17
(lp29044
sg19
(lp29045
sg21
I0
sba(iArchitecture
Entity
p29046
(dp29047
g11
(lp29048
sg13
S'com.google.common.collect.DenseImmutableTable$1'
p29049
sg15
(lp29050
sg17
(lp29051
sg19
(lp29052
sg21
I0
sba(iArchitecture
Entity
p29053
(dp29054
g11
(lp29055
sg13
S'com.google.common.collect.DenseImmutableTable$Column'
p29056
sg15
(lp29057
sg17
(lp29058
sg19
(lp29059
sg21
I0
sba(iArchitecture
Entity
p29060
(dp29061
g11
(lp29062
sg13
S'com.google.common.collect.DenseImmutableTable$ColumnMap'
p29063
sg15
(lp29064
sg17
(lp29065
sg19
(lp29066
sg21
I0
sba(iArchitecture
Entity
p29067
(dp29068
g11
(lp29069
sg13
S'com.google.common.collect.DenseImmutableTable$ImmutableArrayMap'
p29070
sg15
(lp29071
sg17
(lp29072
sg19
(lp29073
sg21
I0
sba(iArchitecture
Entity
p29074
(dp29075
g11
(lp29076
sg13
S'com.google.common.collect.DenseImmutableTable$ImmutableArrayMap$1'
p29077
sg15
(lp29078
sg17
(lp29079
sg19
(lp29080
sg21
I0
sba(iArchitecture
Entity
p29081
(dp29082
g11
(lp29083
sg13
S'com.google.common.collect.DenseImmutableTable$Row'
p29084
sg15
(lp29085
sg17
(lp29086
sg19
(lp29087
sg21
I0
sba(iArchitecture
Entity
p29088
(dp29089
g11
(lp29090
sg13
S'com.google.common.collect.DenseImmutableTable$RowMap'
p29091
sg15
(lp29092
sg17
(lp29093
sg19
(lp29094
sg21
I0
sba(iArchitecture
Entity
p29095
(dp29096
g11
(lp29097
sg13
S'com.google.common.collect.DescendingImmutableSortedMultiset'
p29098
sg15
(lp29099
sg17
(lp29100
sg19
(lp29101
sg21
I0
sba(iArchitecture
Entity
p29102
(dp29103
g11
(lp29104
sg13
S'com.google.common.collect.DescendingImmutableSortedSet'
p29105
sg15
(lp29106
sg17
(lp29107
sg19
(lp29108
sg21
I0
sba(iArchitecture
Entity
p29109
(dp29110
g11
(lp29111
sg13
S'com.google.common.collect.DescendingMultiset'
p29112
sg15
(lp29113
sg17
(lp29114
sg19
(lp29115
sg21
I0
sba(iArchitecture
Entity
p29116
(dp29117
g11
(lp29118
sg13
S'com.google.common.collect.DescendingMultiset$1EntrySetImpl'
p29119
sg15
(lp29120
sg17
(lp29121
sg19
(lp29122
sg21
I0
sba(iArchitecture
Entity
p29123
(dp29124
g11
(lp29125
sg13
S'com.google.common.collect.DiscreteDomain'
p29126
sg15
(lp29127
sg17
(lp29128
sg19
(lp29129
sg21
I0
sba(iArchitecture
Entity
p29130
(dp29131
g11
(lp29132
sg13
S'com.google.common.collect.DiscreteDomain$1'
p29133
sg15
(lp29134
sg17
(lp29135
sg19
(lp29136
sg21
I0
sba(iArchitecture
Entity
p29137
(dp29138
g11
(lp29139
sg13
S'com.google.common.collect.DiscreteDomain$BigIntegerDomain'
p29140
sg15
(lp29141
sg17
(lp29142
sg19
(lp29143
sg21
I0
sba(iArchitecture
Entity
p29144
(dp29145
g11
(lp29146
sg13
S'com.google.common.collect.DiscreteDomain$IntegerDomain'
p29147
sg15
(lp29148
sg17
(lp29149
sg19
(lp29150
sg21
I0
sba(iArchitecture
Entity
p29151
(dp29152
g11
(lp29153
sg13
S'com.google.common.collect.DiscreteDomain$LongDomain'
p29154
sg15
(lp29155
sg17
(lp29156
sg19
(lp29157
sg21
I0
sba(iArchitecture
Entity
p29158
(dp29159
g11
(lp29160
sg13
S'com.google.common.collect.EmptyContiguousSet'
p29161
sg15
(lp29162
sg17
(lp29163
sg19
(lp29164
sg21
I0
sba(iArchitecture
Entity
p29165
(dp29166
g11
(lp29167
sg13
S'com.google.common.collect.EmptyContiguousSet$1'
p29168
sg15
(lp29169
sg17
(lp29170
sg19
(lp29171
sg21
I0
sba(iArchitecture
Entity
p29172
(dp29173
g11
(lp29174
sg13
S'com.google.common.collect.EmptyContiguousSet$SerializedForm'
p29175
sg15
(lp29176
sg17
(lp29177
sg19
(lp29178
sg21
I0
sba(iArchitecture
Entity
p29179
(dp29180
g11
(lp29181
sg13
S'com.google.common.collect.EmptyImmutableListMultimap'
p29182
sg15
(lp29183
sg17
(lp29184
sg19
(lp29185
sg21
I0
sba(iArchitecture
Entity
p29186
(dp29187
g11
(lp29188
sg13
S'com.google.common.collect.EmptyImmutableSetMultimap'
p29189
sg15
(lp29190
sg17
(lp29191
sg19
(lp29192
sg21
I0
sba(iArchitecture
Entity
p29193
(dp29194
g11
(lp29195
sg13
S'com.google.common.collect.EnumBiMap'
p29196
sg15
(lp29197
sg17
(lp29198
sg19
(lp29199
sg21
I0
sba(iArchitecture
Entity
p29200
(dp29201
g11
(lp29202
sg13
S'com.google.common.collect.EnumHashBiMap'
p29203
sg15
(lp29204
sg17
(lp29205
sg19
(lp29206
sg21
I0
sba(iArchitecture
Entity
p29207
(dp29208
g11
(lp29209
sg13
S'com.google.common.collect.EnumMultiset'
p29210
sg15
(lp29211
sg17
(lp29212
sg19
(lp29213
sg21
I0
sba(iArchitecture
Entity
p29214
(dp29215
g11
(lp29216
sg13
S'com.google.common.collect.EvictingQueue'
p29217
sg15
(lp29218
sg17
(lp29219
sg19
(lp29220
sg21
I0
sba(iArchitecture
Entity
p29221
(dp29222
g11
(lp29223
sg13
S'com.google.common.collect.ExplicitOrdering'
p29224
sg15
(lp29225
sg17
(lp29226
sg19
(lp29227
sg21
I0
sba(iArchitecture
Entity
p29228
(dp29229
g11
(lp29230
sg13
S'com.google.common.collect.FilteredEntryMultimap'
p29231
sg15
(lp29232
sg17
(lp29233
sg19
(lp29234
sg21
I0
sba(iArchitecture
Entity
p29235
(dp29236
g11
(lp29237
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap'
p29238
sg15
(lp29239
sg17
(lp29240
sg19
(lp29241
sg21
I0
sba(iArchitecture
Entity
p29242
(dp29243
g11
(lp29244
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$1EntrySetImpl'
p29245
sg15
(lp29246
sg17
(lp29247
sg19
(lp29248
sg21
I0
sba(iArchitecture
Entity
p29249
(dp29250
g11
(lp29251
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$1EntrySetImpl$1'
p29252
sg15
(lp29253
sg17
(lp29254
sg19
(lp29255
sg21
I0
sba(iArchitecture
Entity
p29256
(dp29257
g11
(lp29258
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$1KeySetImpl'
p29259
sg15
(lp29260
sg17
(lp29261
sg19
(lp29262
sg21
I0
sba(iArchitecture
Entity
p29263
(dp29264
g11
(lp29265
sg13
S'com.google.common.collect.FilteredEntryMultimap$AsMap$1ValuesImpl'
p29266
sg15
(lp29267
sg17
(lp29268
sg19
(lp29269
sg21
I0
sba(iArchitecture
Entity
p29270
(dp29271
g11
(lp29272
sg13
S'com.google.common.collect.FilteredEntryMultimap$Keys'
p29273
sg15
(lp29274
sg17
(lp29275
sg19
(lp29276
sg21
I0
sba(iArchitecture
Entity
p29277
(dp29278
g11
(lp29279
sg13
S'com.google.common.collect.FilteredEntryMultimap$Keys$1'
p29280
sg15
(lp29281
sg17
(lp29282
sg19
(lp29283
sg21
I0
sba(iArchitecture
Entity
p29284
(dp29285
g11
(lp29286
sg13
S'com.google.common.collect.FilteredEntryMultimap$Keys$1$1'
p29287
sg15
(lp29288
sg17
(lp29289
sg19
(lp29290
sg21
I0
sba(iArchitecture
Entity
p29291
(dp29292
g11
(lp29293
sg13
S'com.google.common.collect.FilteredEntryMultimap$ValuePredicate'
p29294
sg15
(lp29295
sg17
(lp29296
sg19
(lp29297
sg21
I0
sba(iArchitecture
Entity
p29298
(dp29299
g11
(lp29300
sg13
S'com.google.common.collect.FilteredEntrySetMultimap'
p29301
sg15
(lp29302
sg17
(lp29303
sg19
(lp29304
sg21
I0
sba(iArchitecture
Entity
p29305
(dp29306
g11
(lp29307
sg13
S'com.google.common.collect.FilteredKeyListMultimap'
p29308
sg15
(lp29309
sg17
(lp29310
sg19
(lp29311
sg21
I0
sba(iArchitecture
Entity
p29312
(dp29313
g11
(lp29314
sg13
S'com.google.common.collect.FilteredKeyMultimap'
p29315
sg15
(lp29316
sg17
(lp29317
sg19
(lp29318
sg21
I0
sba(iArchitecture
Entity
p29319
(dp29320
g11
(lp29321
sg13
S'com.google.common.collect.FilteredKeyMultimap$AddRejectingList'
p29322
sg15
(lp29323
sg17
(lp29324
sg19
(lp29325
sg21
I0
sba(iArchitecture
Entity
p29326
(dp29327
g11
(lp29328
sg13
S'com.google.common.collect.FilteredKeyMultimap$AddRejectingSet'
p29329
sg15
(lp29330
sg17
(lp29331
sg19
(lp29332
sg21
I0
sba(iArchitecture
Entity
p29333
(dp29334
g11
(lp29335
sg13
S'com.google.common.collect.FilteredKeyMultimap$Entries'
p29336
sg15
(lp29337
sg17
(lp29338
sg19
(lp29339
sg21
I0
sba(iArchitecture
Entity
p29340
(dp29341
g11
(lp29342
sg13
S'com.google.common.collect.FilteredKeySetMultimap'
p29343
sg15
(lp29344
sg17
(lp29345
sg19
(lp29346
sg21
I0
sba(iArchitecture
Entity
p29347
(dp29348
g11
(lp29349
sg13
S'com.google.common.collect.FilteredKeySetMultimap$EntrySet'
p29350
sg15
(lp29351
sg17
(lp29352
sg19
(lp29353
sg21
I0
sba(iArchitecture
Entity
p29354
(dp29355
g11
(lp29356
sg13
S'com.google.common.collect.FilteredMultimap'
p29357
sg15
(lp29358
sg17
(lp29359
sg19
(lp29360
sg21
I0
sba(iArchitecture
Entity
p29361
(dp29362
g11
(lp29363
sg13
S'com.google.common.collect.FilteredMultimapValues'
p29364
sg15
(lp29365
sg17
(lp29366
sg19
(lp29367
sg21
I0
sba(iArchitecture
Entity
p29368
(dp29369
g11
(lp29370
sg13
S'com.google.common.collect.FilteredSetMultimap'
p29371
sg15
(lp29372
sg17
(lp29373
sg19
(lp29374
sg21
I0
sba(iArchitecture
Entity
p29375
(dp29376
g11
(lp29377
sg13
S'com.google.common.collect.FluentIterable'
p29378
sg15
(lp29379
sg17
(lp29380
sg19
(lp29381
sg21
I0
sba(iArchitecture
Entity
p29382
(dp29383
g11
(lp29384
sg13
S'com.google.common.collect.FluentIterable$1'
p29385
sg15
(lp29386
sg17
(lp29387
sg19
(lp29388
sg21
I0
sba(iArchitecture
Entity
p29389
(dp29390
g11
(lp29391
sg13
S'com.google.common.collect.FluentIterable$2'
p29392
sg15
(lp29393
sg17
(lp29394
sg19
(lp29395
sg21
I0
sba(iArchitecture
Entity
p29396
(dp29397
g11
(lp29398
sg13
S'com.google.common.collect.FluentIterable$FromIterableFunction'
p29399
sg15
(lp29400
sg17
(lp29401
sg19
(lp29402
sg21
I0
sba(iArchitecture
Entity
p29403
(dp29404
g11
(lp29405
sg13
S'com.google.common.collect.ForwardingCollection'
p29406
sg15
(lp29407
sg17
(lp29408
sg19
(lp29409
sg21
I0
sba(iArchitecture
Entity
p29410
(dp29411
g11
(lp29412
sg13
S'com.google.common.collect.ForwardingConcurrentMap'
p29413
sg15
(lp29414
sg17
(lp29415
sg19
(lp29416
sg21
I0
sba(iArchitecture
Entity
p29417
(dp29418
g11
(lp29419
sg13
S'com.google.common.collect.ForwardingImmutableCollection'
p29420
sg15
(lp29421
sg17
(lp29422
sg19
(lp29423
sg21
I0
sba(iArchitecture
Entity
p29424
(dp29425
g11
(lp29426
sg13
S'com.google.common.collect.ForwardingImmutableList'
p29427
sg15
(lp29428
sg17
(lp29429
sg19
(lp29430
sg21
I0
sba(iArchitecture
Entity
p29431
(dp29432
g11
(lp29433
sg13
S'com.google.common.collect.ForwardingImmutableMap'
p29434
sg15
(lp29435
sg17
(lp29436
sg19
(lp29437
sg21
I0
sba(iArchitecture
Entity
p29438
(dp29439
g11
(lp29440
sg13
S'com.google.common.collect.ForwardingImmutableSet'
p29441
sg15
(lp29442
sg17
(lp29443
sg19
(lp29444
sg21
I0
sba(iArchitecture
Entity
p29445
(dp29446
g11
(lp29447
sg13
S'com.google.common.collect.ForwardingIterator'
p29448
sg15
(lp29449
sg17
(lp29450
sg19
(lp29451
sg21
I0
sba(iArchitecture
Entity
p29452
(dp29453
g11
(lp29454
sg13
S'com.google.common.collect.ForwardingList'
p29455
sg15
(lp29456
sg17
(lp29457
sg19
(lp29458
sg21
I0
sba(iArchitecture
Entity
p29459
(dp29460
g11
(lp29461
sg13
S'com.google.common.collect.ForwardingListIterator'
p29462
sg15
(lp29463
sg17
(lp29464
sg19
(lp29465
sg21
I0
sba(iArchitecture
Entity
p29466
(dp29467
g11
(lp29468
sg13
S'com.google.common.collect.ForwardingListMultimap'
p29469
sg15
(lp29470
sg17
(lp29471
sg19
(lp29472
sg21
I0
sba(iArchitecture
Entity
p29473
(dp29474
g11
(lp29475
sg13
S'com.google.common.collect.ForwardingMap'
p29476
sg15
(lp29477
sg17
(lp29478
sg19
(lp29479
sg21
I0
sba(iArchitecture
Entity
p29480
(dp29481
g11
(lp29482
sg13
S'com.google.common.collect.ForwardingMap$StandardEntrySet'
p29483
sg15
(lp29484
sg17
(lp29485
sg19
(lp29486
sg21
I0
sba(iArchitecture
Entity
p29487
(dp29488
g11
(lp29489
sg13
S'com.google.common.collect.ForwardingMap$StandardKeySet'
p29490
sg15
(lp29491
sg17
(lp29492
sg19
(lp29493
sg21
I0
sba(iArchitecture
Entity
p29494
(dp29495
g11
(lp29496
sg13
S'com.google.common.collect.ForwardingMap$StandardValues'
p29497
sg15
(lp29498
sg17
(lp29499
sg19
(lp29500
sg21
I0
sba(iArchitecture
Entity
p29501
(dp29502
g11
(lp29503
sg13
S'com.google.common.collect.ForwardingMultimap'
p29504
sg15
(lp29505
sg17
(lp29506
sg19
(lp29507
sg21
I0
sba(iArchitecture
Entity
p29508
(dp29509
g11
(lp29510
sg13
S'com.google.common.collect.ForwardingMultiset'
p29511
sg15
(lp29512
sg17
(lp29513
sg19
(lp29514
sg21
I0
sba(iArchitecture
Entity
p29515
(dp29516
g11
(lp29517
sg13
S'com.google.common.collect.ForwardingMultiset$StandardElementSet'
p29518
sg15
(lp29519
sg17
(lp29520
sg19
(lp29521
sg21
I0
sba(iArchitecture
Entity
p29522
(dp29523
g11
(lp29524
sg13
S'com.google.common.collect.ForwardingNavigableMap'
p29525
sg15
(lp29526
sg17
(lp29527
sg19
(lp29528
sg21
I0
sba(iArchitecture
Entity
p29529
(dp29530
g11
(lp29531
sg13
S'com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap'
p29532
sg15
(lp29533
sg17
(lp29534
sg19
(lp29535
sg21
I0
sba(iArchitecture
Entity
p29536
(dp29537
g11
(lp29538
sg13
S'com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap$1'
p29539
sg15
(lp29540
sg17
(lp29541
sg19
(lp29542
sg21
I0
sba(iArchitecture
Entity
p29543
(dp29544
g11
(lp29545
sg13
S'com.google.common.collect.ForwardingNavigableMap$StandardNavigableKeySet'
p29546
sg15
(lp29547
sg17
(lp29548
sg19
(lp29549
sg21
I0
sba(iArchitecture
Entity
p29550
(dp29551
g11
(lp29552
sg13
S'com.google.common.collect.ForwardingNavigableSet'
p29553
sg15
(lp29554
sg17
(lp29555
sg19
(lp29556
sg21
I0
sba(iArchitecture
Entity
p29557
(dp29558
g11
(lp29559
sg13
S'com.google.common.collect.ForwardingNavigableSet$StandardDescendingSet'
p29560
sg15
(lp29561
sg17
(lp29562
sg19
(lp29563
sg21
I0
sba(iArchitecture
Entity
p29564
(dp29565
g11
(lp29566
sg13
S'com.google.common.collect.ForwardingQueue'
p29567
sg15
(lp29568
sg17
(lp29569
sg19
(lp29570
sg21
I0
sba(iArchitecture
Entity
p29571
(dp29572
g11
(lp29573
sg13
S'com.google.common.collect.ForwardingSet'
p29574
sg15
(lp29575
sg17
(lp29576
sg19
(lp29577
sg21
I0
sba(iArchitecture
Entity
p29578
(dp29579
g11
(lp29580
sg13
S'com.google.common.collect.ForwardingSetMultimap'
p29581
sg15
(lp29582
sg17
(lp29583
sg19
(lp29584
sg21
I0
sba(iArchitecture
Entity
p29585
(dp29586
g11
(lp29587
sg13
S'com.google.common.collect.ForwardingSortedMap'
p29588
sg15
(lp29589
sg17
(lp29590
sg19
(lp29591
sg21
I0
sba(iArchitecture
Entity
p29592
(dp29593
g11
(lp29594
sg13
S'com.google.common.collect.ForwardingSortedMap$StandardKeySet'
p29595
sg15
(lp29596
sg17
(lp29597
sg19
(lp29598
sg21
I0
sba(iArchitecture
Entity
p29599
(dp29600
g11
(lp29601
sg13
S'com.google.common.collect.ForwardingSortedMultiset'
p29602
sg15
(lp29603
sg17
(lp29604
sg19
(lp29605
sg21
I0
sba(iArchitecture
Entity
p29606
(dp29607
g11
(lp29608
sg13
S'com.google.common.collect.ForwardingSortedMultiset$StandardDescendingMultiset'
p29609
sg15
(lp29610
sg17
(lp29611
sg19
(lp29612
sg21
I0
sba(iArchitecture
Entity
p29613
(dp29614
g11
(lp29615
sg13
S'com.google.common.collect.ForwardingSortedMultiset$StandardElementSet'
p29616
sg15
(lp29617
sg17
(lp29618
sg19
(lp29619
sg21
I0
sba(iArchitecture
Entity
p29620
(dp29621
g11
(lp29622
sg13
S'com.google.common.collect.ForwardingSortedSet'
p29623
sg15
(lp29624
sg17
(lp29625
sg19
(lp29626
sg21
I0
sba(iArchitecture
Entity
p29627
(dp29628
g11
(lp29629
sg13
S'com.google.common.collect.ForwardingSortedSetMultimap'
p29630
sg15
(lp29631
sg17
(lp29632
sg19
(lp29633
sg21
I0
sba(iArchitecture
Entity
p29634
(dp29635
g11
(lp29636
sg13
S'com.google.common.collect.ForwardingTable'
p29637
sg15
(lp29638
sg17
(lp29639
sg19
(lp29640
sg21
I0
sba(iArchitecture
Entity
p29641
(dp29642
g11
(lp29643
sg13
S'com.google.common.collect.GeneralRange'
p29644
sg15
(lp29645
sg17
(lp29646
sg19
(lp29647
sg21
I0
sba(iArchitecture
Entity
p29648
(dp29649
g11
(lp29650
sg13
S'com.google.common.collect.GwtTransient'
p29651
sg15
(lp29652
sg17
(lp29653
sg19
(lp29654
sg21
I0
sba(iArchitecture
Entity
p29655
(dp29656
g11
(lp29657
sg13
S'com.google.common.collect.HashBasedTable'
p29658
sg15
(lp29659
sg17
(lp29660
sg19
(lp29661
sg21
I0
sba(iArchitecture
Entity
p29662
(dp29663
g11
(lp29664
sg13
S'com.google.common.collect.HashBasedTable$Factory'
p29665
sg15
(lp29666
sg17
(lp29667
sg19
(lp29668
sg21
I0
sba(iArchitecture
Entity
p29669
(dp29670
g11
(lp29671
sg13
S'com.google.common.collect.HashBiMap'
p29672
sg15
(lp29673
sg17
(lp29674
sg19
(lp29675
sg21
I0
sba(iArchitecture
Entity
p29676
(dp29677
g11
(lp29678
sg13
S'com.google.common.collect.HashBiMap$1'
p29679
sg15
(lp29680
sg17
(lp29681
sg19
(lp29682
sg21
I0
sba(iArchitecture
Entity
p29683
(dp29684
g11
(lp29685
sg13
S'com.google.common.collect.HashBiMap$1$MapEntry'
p29686
sg15
(lp29687
sg17
(lp29688
sg19
(lp29689
sg21
I0
sba(iArchitecture
Entity
p29690
(dp29691
g11
(lp29692
sg13
S'com.google.common.collect.HashBiMap$1.MapEntry'
p29693
sg15
(lp29694
sg17
(lp29695
sg19
(lp29696
sg21
I0
sba(iArchitecture
Entity
p29697
(dp29698
g11
(lp29699
sg13
S'com.google.common.collect.HashBiMap$BiEntry'
p29700
sg15
(lp29701
sg17
(lp29702
sg19
(lp29703
sg21
I0
sba(iArchitecture
Entity
p29704
(dp29705
g11
(lp29706
sg13
S'com.google.common.collect.HashBiMap$Inverse'
p29707
sg15
(lp29708
sg17
(lp29709
sg19
(lp29710
sg21
I0
sba(iArchitecture
Entity
p29711
(dp29712
g11
(lp29713
sg13
S'com.google.common.collect.HashBiMap$Inverse$1'
p29714
sg15
(lp29715
sg17
(lp29716
sg19
(lp29717
sg21
I0
sba(iArchitecture
Entity
p29718
(dp29719
g11
(lp29720
sg13
S'com.google.common.collect.HashBiMap$Inverse$1$InverseEntry'
p29721
sg15
(lp29722
sg17
(lp29723
sg19
(lp29724
sg21
I0
sba(iArchitecture
Entity
p29725
(dp29726
g11
(lp29727
sg13
S'com.google.common.collect.HashBiMap$Inverse$1.InverseEntry'
p29728
sg15
(lp29729
sg17
(lp29730
sg19
(lp29731
sg21
I0
sba(iArchitecture
Entity
p29732
(dp29733
g11
(lp29734
sg13
S'com.google.common.collect.HashBiMap$Inverse$InverseKeySet'
p29735
sg15
(lp29736
sg17
(lp29737
sg19
(lp29738
sg21
I0
sba(iArchitecture
Entity
p29739
(dp29740
g11
(lp29741
sg13
S'com.google.common.collect.HashBiMap$Inverse$InverseKeySet$1'
p29742
sg15
(lp29743
sg17
(lp29744
sg19
(lp29745
sg21
I0
sba(iArchitecture
Entity
p29746
(dp29747
g11
(lp29748
sg13
S'com.google.common.collect.HashBiMap$InverseSerializedForm'
p29749
sg15
(lp29750
sg17
(lp29751
sg19
(lp29752
sg21
I0
sba(iArchitecture
Entity
p29753
(dp29754
g11
(lp29755
sg13
S'com.google.common.collect.HashBiMap$Itr'
p29756
sg15
(lp29757
sg17
(lp29758
sg19
(lp29759
sg21
I0
sba(iArchitecture
Entity
p29760
(dp29761
g11
(lp29762
sg13
S'com.google.common.collect.HashBiMap$KeySet'
p29763
sg15
(lp29764
sg17
(lp29765
sg19
(lp29766
sg21
I0
sba(iArchitecture
Entity
p29767
(dp29768
g11
(lp29769
sg13
S'com.google.common.collect.HashBiMap$KeySet$1'
p29770
sg15
(lp29771
sg17
(lp29772
sg19
(lp29773
sg21
I0
sba(iArchitecture
Entity
p29774
(dp29775
g11
(lp29776
sg13
S'com.google.common.collect.HashMultimap'
p29777
sg15
(lp29778
sg17
(lp29779
sg19
(lp29780
sg21
I0
sba(iArchitecture
Entity
p29781
(dp29782
g11
(lp29783
sg13
S'com.google.common.collect.HashMultimapGwtSerializationDependencies'
p29784
sg15
(lp29785
sg17
(lp29786
sg19
(lp29787
sg21
I0
sba(iArchitecture
Entity
p29788
(dp29789
g11
(lp29790
sg13
S'com.google.common.collect.Hashing'
p29791
sg15
(lp29792
sg17
(lp29793
sg19
(lp29794
sg21
I0
sba(iArchitecture
Entity
p29795
(dp29796
g11
(lp29797
sg13
S'com.google.common.collect.ImmutableAsList'
p29798
sg15
(lp29799
sg17
(lp29800
sg19
(lp29801
sg21
I0
sba(iArchitecture
Entity
p29802
(dp29803
g11
(lp29804
sg13
S'com.google.common.collect.ImmutableAsList$SerializedForm'
p29805
sg15
(lp29806
sg17
(lp29807
sg19
(lp29808
sg21
I0
sba(iArchitecture
Entity
p29809
(dp29810
g11
(lp29811
sg13
S'com.google.common.collect.ImmutableBiMap'
p29812
sg15
(lp29813
sg17
(lp29814
sg19
(lp29815
sg21
I0
sba(iArchitecture
Entity
p29816
(dp29817
g11
(lp29818
sg13
S'com.google.common.collect.ImmutableBiMap$Builder'
p29819
sg15
(lp29820
sg17
(lp29821
sg19
(lp29822
sg21
I0
sba(iArchitecture
Entity
p29823
(dp29824
g11
(lp29825
sg13
S'com.google.common.collect.ImmutableBiMap$SerializedForm'
p29826
sg15
(lp29827
sg17
(lp29828
sg19
(lp29829
sg21
I0
sba(iArchitecture
Entity
p29830
(dp29831
g11
(lp29832
sg13
S'com.google.common.collect.ImmutableBiMapFauxverideShim'
p29833
sg15
(lp29834
sg17
(lp29835
sg19
(lp29836
sg21
I0
sba(iArchitecture
Entity
p29837
(dp29838
g11
(lp29839
sg13
S'com.google.common.collect.ImmutableClassToInstanceMap'
p29840
sg15
(lp29841
sg17
(lp29842
sg19
(lp29843
sg21
I0
sba(iArchitecture
Entity
p29844
(dp29845
g11
(lp29846
sg13
S'com.google.common.collect.ImmutableClassToInstanceMap$1'
p29847
sg15
(lp29848
sg17
(lp29849
sg19
(lp29850
sg21
I0
sba(iArchitecture
Entity
p29851
(dp29852
g11
(lp29853
sg13
S'com.google.common.collect.ImmutableClassToInstanceMap$Builder'
p29854
sg15
(lp29855
sg17
(lp29856
sg19
(lp29857
sg21
I0
sba(iArchitecture
Entity
p29858
(dp29859
g11
(lp29860
sg13
S'com.google.common.collect.ImmutableCollection'
p29861
sg15
(lp29862
sg17
(lp29863
sg19
(lp29864
sg21
I0
sba(iArchitecture
Entity
p29865
(dp29866
g11
(lp29867
sg13
S'com.google.common.collect.ImmutableCollection$ArrayBasedBuilder'
p29868
sg15
(lp29869
sg17
(lp29870
sg19
(lp29871
sg21
I0
sba(iArchitecture
Entity
p29872
(dp29873
g11
(lp29874
sg13
S'com.google.common.collect.ImmutableCollection$Builder'
p29875
sg15
(lp29876
sg17
(lp29877
sg19
(lp29878
sg21
I0
sba(iArchitecture
Entity
p29879
(dp29880
g11
(lp29881
sg13
S'com.google.common.collect.ImmutableEntry'
p29882
sg15
(lp29883
sg17
(lp29884
sg19
(lp29885
sg21
I0
sba(iArchitecture
Entity
p29886
(dp29887
g11
(lp29888
sg13
S'com.google.common.collect.ImmutableEnumMap'
p29889
sg15
(lp29890
sg17
(lp29891
sg19
(lp29892
sg21
I0
sba(iArchitecture
Entity
p29893
(dp29894
g11
(lp29895
sg13
S'com.google.common.collect.ImmutableEnumMap$1'
p29896
sg15
(lp29897
sg17
(lp29898
sg19
(lp29899
sg21
I0
sba(iArchitecture
Entity
p29900
(dp29901
g11
(lp29902
sg13
S'com.google.common.collect.ImmutableEnumMap$EnumSerializedForm'
p29903
sg15
(lp29904
sg17
(lp29905
sg19
(lp29906
sg21
I0
sba(iArchitecture
Entity
p29907
(dp29908
g11
(lp29909
sg13
S'com.google.common.collect.ImmutableEnumSet'
p29910
sg15
(lp29911
sg17
(lp29912
sg19
(lp29913
sg21
I0
sba(iArchitecture
Entity
p29914
(dp29915
g11
(lp29916
sg13
S'com.google.common.collect.ImmutableEnumSet$1'
p29917
sg15
(lp29918
sg17
(lp29919
sg19
(lp29920
sg21
I0
sba(iArchitecture
Entity
p29921
(dp29922
g11
(lp29923
sg13
S'com.google.common.collect.ImmutableEnumSet$EnumSerializedForm'
p29924
sg15
(lp29925
sg17
(lp29926
sg19
(lp29927
sg21
I0
sba(iArchitecture
Entity
p29928
(dp29929
g11
(lp29930
sg13
S'com.google.common.collect.ImmutableList'
p29931
sg15
(lp29932
sg17
(lp29933
sg19
(lp29934
sg21
I0
sba(iArchitecture
Entity
p29935
(dp29936
g11
(lp29937
sg13
S'com.google.common.collect.ImmutableList$1'
p29938
sg15
(lp29939
sg17
(lp29940
sg19
(lp29941
sg21
I0
sba(iArchitecture
Entity
p29942
(dp29943
g11
(lp29944
sg13
S'com.google.common.collect.ImmutableList$Builder'
p29945
sg15
(lp29946
sg17
(lp29947
sg19
(lp29948
sg21
I0
sba(iArchitecture
Entity
p29949
(dp29950
g11
(lp29951
sg13
S'com.google.common.collect.ImmutableList$ReverseImmutableList'
p29952
sg15
(lp29953
sg17
(lp29954
sg19
(lp29955
sg21
I0
sba(iArchitecture
Entity
p29956
(dp29957
g11
(lp29958
sg13
S'com.google.common.collect.ImmutableList$SerializedForm'
p29959
sg15
(lp29960
sg17
(lp29961
sg19
(lp29962
sg21
I0
sba(iArchitecture
Entity
p29963
(dp29964
g11
(lp29965
sg13
S'com.google.common.collect.ImmutableList$SubList'
p29966
sg15
(lp29967
sg17
(lp29968
sg19
(lp29969
sg21
I0
sba(iArchitecture
Entity
p29970
(dp29971
g11
(lp29972
sg13
S'com.google.common.collect.ImmutableListMultimap'
p29973
sg15
(lp29974
sg17
(lp29975
sg19
(lp29976
sg21
I0
sba(iArchitecture
Entity
p29977
(dp29978
g11
(lp29979
sg13
S'com.google.common.collect.ImmutableListMultimap$Builder'
p29980
sg15
(lp29981
sg17
(lp29982
sg19
(lp29983
sg21
I0
sba(iArchitecture
Entity
p29984
(dp29985
g11
(lp29986
sg13
S'com.google.common.collect.ImmutableMap'
p29987
sg15
(lp29988
sg17
(lp29989
sg19
(lp29990
sg21
I0
sba(iArchitecture
Entity
p29991
(dp29992
g11
(lp29993
sg13
S'com.google.common.collect.ImmutableMap$1'
p29994
sg15
(lp29995
sg17
(lp29996
sg19
(lp29997
sg21
I0
sba(iArchitecture
Entity
p29998
(dp29999
g11
(lp30000
sg13
S'com.google.common.collect.ImmutableMap$Builder'
p30001
sg15
(lp30002
sg17
(lp30003
sg19
(lp30004
sg21
I0
sba(iArchitecture
Entity
p30005
(dp30006
g11
(lp30007
sg13
S'com.google.common.collect.ImmutableMap$IteratorBasedImmutableMap'
p30008
sg15
(lp30009
sg17
(lp30010
sg19
(lp30011
sg21
I0
sba(iArchitecture
Entity
p30012
(dp30013
g11
(lp30014
sg13
S'com.google.common.collect.ImmutableMap$IteratorBasedImmutableMap$1EntrySetImpl'
p30015
sg15
(lp30016
sg17
(lp30017
sg19
(lp30018
sg21
I0
sba(iArchitecture
Entity
p30019
(dp30020
g11
(lp30021
sg13
S'com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets'
p30022
sg15
(lp30023
sg17
(lp30024
sg19
(lp30025
sg21
I0
sba(iArchitecture
Entity
p30026
(dp30027
g11
(lp30028
sg13
S'com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1'
p30029
sg15
(lp30030
sg17
(lp30031
sg19
(lp30032
sg21
I0
sba(iArchitecture
Entity
p30033
(dp30034
g11
(lp30035
sg13
S'com.google.common.collect.ImmutableMap$MapViewOfValuesAsSingletonSets$1$1'
p30036
sg15
(lp30037
sg17
(lp30038
sg19
(lp30039
sg21
I0
sba(iArchitecture
Entity
p30040
(dp30041
g11
(lp30042
sg13
S'com.google.common.collect.ImmutableMap$SerializedForm'
p30043
sg15
(lp30044
sg17
(lp30045
sg19
(lp30046
sg21
I0
sba(iArchitecture
Entity
p30047
(dp30048
g11
(lp30049
sg13
S'com.google.common.collect.ImmutableMapEntry'
p30050
sg15
(lp30051
sg17
(lp30052
sg19
(lp30053
sg21
I0
sba(iArchitecture
Entity
p30054
(dp30055
g11
(lp30056
sg13
S'com.google.common.collect.ImmutableMapEntry$NonTerminalImmutableBiMapEntry'
p30057
sg15
(lp30058
sg17
(lp30059
sg19
(lp30060
sg21
I0
sba(iArchitecture
Entity
p30061
(dp30062
g11
(lp30063
sg13
S'com.google.common.collect.ImmutableMapEntry$NonTerminalImmutableMapEntry'
p30064
sg15
(lp30065
sg17
(lp30066
sg19
(lp30067
sg21
I0
sba(iArchitecture
Entity
p30068
(dp30069
g11
(lp30070
sg13
S'com.google.common.collect.ImmutableMapEntrySet'
p30071
sg15
(lp30072
sg17
(lp30073
sg19
(lp30074
sg21
I0
sba(iArchitecture
Entity
p30075
(dp30076
g11
(lp30077
sg13
S'com.google.common.collect.ImmutableMapEntrySet$EntrySetSerializedForm'
p30078
sg15
(lp30079
sg17
(lp30080
sg19
(lp30081
sg21
I0
sba(iArchitecture
Entity
p30082
(dp30083
g11
(lp30084
sg13
S'com.google.common.collect.ImmutableMapEntrySet$RegularEntrySet'
p30085
sg15
(lp30086
sg17
(lp30087
sg19
(lp30088
sg21
I0
sba(iArchitecture
Entity
p30089
(dp30090
g11
(lp30091
sg13
S'com.google.common.collect.ImmutableMapKeySet'
p30092
sg15
(lp30093
sg17
(lp30094
sg19
(lp30095
sg21
I0
sba(iArchitecture
Entity
p30096
(dp30097
g11
(lp30098
sg13
S'com.google.common.collect.ImmutableMapKeySet$KeySetSerializedForm'
p30099
sg15
(lp30100
sg17
(lp30101
sg19
(lp30102
sg21
I0
sba(iArchitecture
Entity
p30103
(dp30104
g11
(lp30105
sg13
S'com.google.common.collect.ImmutableMapValues'
p30106
sg15
(lp30107
sg17
(lp30108
sg19
(lp30109
sg21
I0
sba(iArchitecture
Entity
p30110
(dp30111
g11
(lp30112
sg13
S'com.google.common.collect.ImmutableMapValues$1'
p30113
sg15
(lp30114
sg17
(lp30115
sg19
(lp30116
sg21
I0
sba(iArchitecture
Entity
p30117
(dp30118
g11
(lp30119
sg13
S'com.google.common.collect.ImmutableMapValues$2'
p30120
sg15
(lp30121
sg17
(lp30122
sg19
(lp30123
sg21
I0
sba(iArchitecture
Entity
p30124
(dp30125
g11
(lp30126
sg13
S'com.google.common.collect.ImmutableMapValues$SerializedForm'
p30127
sg15
(lp30128
sg17
(lp30129
sg19
(lp30130
sg21
I0
sba(iArchitecture
Entity
p30131
(dp30132
g11
(lp30133
sg13
S'com.google.common.collect.ImmutableMultimap'
p30134
sg15
(lp30135
sg17
(lp30136
sg19
(lp30137
sg21
I0
sba(iArchitecture
Entity
p30138
(dp30139
g11
(lp30140
sg13
S'com.google.common.collect.ImmutableMultimap$1'
p30141
sg15
(lp30142
sg17
(lp30143
sg19
(lp30144
sg21
I0
sba(iArchitecture
Entity
p30145
(dp30146
g11
(lp30147
sg13
S'com.google.common.collect.ImmutableMultimap$2'
p30148
sg15
(lp30149
sg17
(lp30150
sg19
(lp30151
sg21
I0
sba(iArchitecture
Entity
p30152
(dp30153
g11
(lp30154
sg13
S'com.google.common.collect.ImmutableMultimap$Builder'
p30155
sg15
(lp30156
sg17
(lp30157
sg19
(lp30158
sg21
I0
sba(iArchitecture
Entity
p30159
(dp30160
g11
(lp30161
sg13
S'com.google.common.collect.ImmutableMultimap$EntryCollection'
p30162
sg15
(lp30163
sg17
(lp30164
sg19
(lp30165
sg21
I0
sba(iArchitecture
Entity
p30166
(dp30167
g11
(lp30168
sg13
S'com.google.common.collect.ImmutableMultimap$FieldSettersHolder'
p30169
sg15
(lp30170
sg17
(lp30171
sg19
(lp30172
sg21
I0
sba(iArchitecture
Entity
p30173
(dp30174
g11
(lp30175
sg13
S'com.google.common.collect.ImmutableMultimap$Itr'
p30176
sg15
(lp30177
sg17
(lp30178
sg19
(lp30179
sg21
I0
sba(iArchitecture
Entity
p30180
(dp30181
g11
(lp30182
sg13
S'com.google.common.collect.ImmutableMultimap$Keys'
p30183
sg15
(lp30184
sg17
(lp30185
sg19
(lp30186
sg21
I0
sba(iArchitecture
Entity
p30187
(dp30188
g11
(lp30189
sg13
S'com.google.common.collect.ImmutableMultimap$Values'
p30190
sg15
(lp30191
sg17
(lp30192
sg19
(lp30193
sg21
I0
sba(iArchitecture
Entity
p30194
(dp30195
g11
(lp30196
sg13
S'com.google.common.collect.ImmutableMultiset'
p30197
sg15
(lp30198
sg17
(lp30199
sg19
(lp30200
sg21
I0
sba(iArchitecture
Entity
p30201
(dp30202
g11
(lp30203
sg13
S'com.google.common.collect.ImmutableMultiset$1'
p30204
sg15
(lp30205
sg17
(lp30206
sg19
(lp30207
sg21
I0
sba(iArchitecture
Entity
p30208
(dp30209
g11
(lp30210
sg13
S'com.google.common.collect.ImmutableMultiset$Builder'
p30211
sg15
(lp30212
sg17
(lp30213
sg19
(lp30214
sg21
I0
sba(iArchitecture
Entity
p30215
(dp30216
g11
(lp30217
sg13
S'com.google.common.collect.ImmutableMultiset$EntrySet'
p30218
sg15
(lp30219
sg17
(lp30220
sg19
(lp30221
sg21
I0
sba(iArchitecture
Entity
p30222
(dp30223
g11
(lp30224
sg13
S'com.google.common.collect.ImmutableMultiset$EntrySetSerializedForm'
p30225
sg15
(lp30226
sg17
(lp30227
sg19
(lp30228
sg21
I0
sba(iArchitecture
Entity
p30229
(dp30230
g11
(lp30231
sg13
S'com.google.common.collect.ImmutableMultiset$SerializedForm'
p30232
sg15
(lp30233
sg17
(lp30234
sg19
(lp30235
sg21
I0
sba(iArchitecture
Entity
p30236
(dp30237
g11
(lp30238
sg13
S'com.google.common.collect.ImmutableMultisetGwtSerializationDependencies'
p30239
sg15
(lp30240
sg17
(lp30241
sg19
(lp30242
sg21
I0
sba(iArchitecture
Entity
p30243
(dp30244
g11
(lp30245
sg13
S'com.google.common.collect.ImmutableRangeMap'
p30246
sg15
(lp30247
sg17
(lp30248
sg19
(lp30249
sg21
I0
sba(iArchitecture
Entity
p30250
(dp30251
g11
(lp30252
sg13
S'com.google.common.collect.ImmutableRangeMap$1'
p30253
sg15
(lp30254
sg17
(lp30255
sg19
(lp30256
sg21
I0
sba(iArchitecture
Entity
p30257
(dp30258
g11
(lp30259
sg13
S'com.google.common.collect.ImmutableRangeMap$2'
p30260
sg15
(lp30261
sg17
(lp30262
sg19
(lp30263
sg21
I0
sba(iArchitecture
Entity
p30264
(dp30265
g11
(lp30266
sg13
S'com.google.common.collect.ImmutableRangeMap$Builder'
p30267
sg15
(lp30268
sg17
(lp30269
sg19
(lp30270
sg21
I0
sba(iArchitecture
Entity
p30271
(dp30272
g11
(lp30273
sg13
S'com.google.common.collect.ImmutableRangeMap$SerializedForm'
p30274
sg15
(lp30275
sg17
(lp30276
sg19
(lp30277
sg21
I0
sba(iArchitecture
Entity
p30278
(dp30279
g11
(lp30280
sg13
S'com.google.common.collect.ImmutableRangeSet'
p30281
sg15
(lp30282
sg17
(lp30283
sg19
(lp30284
sg21
I0
sba(iArchitecture
Entity
p30285
(dp30286
g11
(lp30287
sg13
S'com.google.common.collect.ImmutableRangeSet$1'
p30288
sg15
(lp30289
sg17
(lp30290
sg19
(lp30291
sg21
I0
sba(iArchitecture
Entity
p30292
(dp30293
g11
(lp30294
sg13
S'com.google.common.collect.ImmutableRangeSet$AsSet'
p30295
sg15
(lp30296
sg17
(lp30297
sg19
(lp30298
sg21
I0
sba(iArchitecture
Entity
p30299
(dp30300
g11
(lp30301
sg13
S'com.google.common.collect.ImmutableRangeSet$AsSet$1'
p30302
sg15
(lp30303
sg17
(lp30304
sg19
(lp30305
sg21
I0
sba(iArchitecture
Entity
p30306
(dp30307
g11
(lp30308
sg13
S'com.google.common.collect.ImmutableRangeSet$AsSet$2'
p30309
sg15
(lp30310
sg17
(lp30311
sg19
(lp30312
sg21
I0
sba(iArchitecture
Entity
p30313
(dp30314
g11
(lp30315
sg13
S'com.google.common.collect.ImmutableRangeSet$AsSetSerializedForm'
p30316
sg15
(lp30317
sg17
(lp30318
sg19
(lp30319
sg21
I0
sba(iArchitecture
Entity
p30320
(dp30321
g11
(lp30322
sg13
S'com.google.common.collect.ImmutableRangeSet$Builder'
p30323
sg15
(lp30324
sg17
(lp30325
sg19
(lp30326
sg21
I0
sba(iArchitecture
Entity
p30327
(dp30328
g11
(lp30329
sg13
S'com.google.common.collect.ImmutableRangeSet$ComplementRanges'
p30330
sg15
(lp30331
sg17
(lp30332
sg19
(lp30333
sg21
I0
sba(iArchitecture
Entity
p30334
(dp30335
g11
(lp30336
sg13
S'com.google.common.collect.ImmutableRangeSet$SerializedForm'
p30337
sg15
(lp30338
sg17
(lp30339
sg19
(lp30340
sg21
I0
sba(iArchitecture
Entity
p30341
(dp30342
g11
(lp30343
sg13
S'com.google.common.collect.ImmutableSet'
p30344
sg15
(lp30345
sg17
(lp30346
sg19
(lp30347
sg21
I0
sba(iArchitecture
Entity
p30348
(dp30349
g11
(lp30350
sg13
S'com.google.common.collect.ImmutableSet$Indexed'
p30351
sg15
(lp30352
sg17
(lp30353
sg19
(lp30354
sg21
I0
sba(iArchitecture
Entity
p30355
(dp30356
g11
(lp30357
sg13
S'com.google.common.collect.ImmutableSet$Indexed$1'
p30358
sg15
(lp30359
sg17
(lp30360
sg19
(lp30361
sg21
I0
sba(iArchitecture
Entity
p30362
(dp30363
g11
(lp30364
sg13
S'com.google.common.collect.ImmutableSet$SerializedForm'
p30365
sg15
(lp30366
sg17
(lp30367
sg19
(lp30368
sg21
I0
sba(iArchitecture
Entity
p30369
(dp30370
g11
(lp30371
sg13
S'com.google.common.collect.ImmutableSetMultimap'
p30372
sg15
(lp30373
sg17
(lp30374
sg19
(lp30375
sg21
I0
sba(iArchitecture
Entity
p30376
(dp30377
g11
(lp30378
sg13
S'com.google.common.collect.ImmutableSetMultimap$Builder'
p30379
sg15
(lp30380
sg17
(lp30381
sg19
(lp30382
sg21
I0
sba(iArchitecture
Entity
p30383
(dp30384
g11
(lp30385
sg13
S'com.google.common.collect.ImmutableSetMultimap$EntrySet'
p30386
sg15
(lp30387
sg17
(lp30388
sg19
(lp30389
sg21
I0
sba(iArchitecture
Entity
p30390
(dp30391
g11
(lp30392
sg13
S'com.google.common.collect.ImmutableSortedAsList'
p30393
sg15
(lp30394
sg17
(lp30395
sg19
(lp30396
sg21
I0
sba(iArchitecture
Entity
p30397
(dp30398
g11
(lp30399
sg13
S'com.google.common.collect.ImmutableSortedMap'
p30400
sg15
(lp30401
sg17
(lp30402
sg19
(lp30403
sg21
I0
sba(iArchitecture
Entity
p30404
(dp30405
g11
(lp30406
sg13
S'com.google.common.collect.ImmutableSortedMap$1'
p30407
sg15
(lp30408
sg17
(lp30409
sg19
(lp30410
sg21
I0
sba(iArchitecture
Entity
p30411
(dp30412
g11
(lp30413
sg13
S'com.google.common.collect.ImmutableSortedMap$1EntrySet'
p30414
sg15
(lp30415
sg17
(lp30416
sg19
(lp30417
sg21
I0
sba(iArchitecture
Entity
p30418
(dp30419
g11
(lp30420
sg13
S'com.google.common.collect.ImmutableSortedMap$1EntrySet$1'
p30421
sg15
(lp30422
sg17
(lp30423
sg19
(lp30424
sg21
I0
sba(iArchitecture
Entity
p30425
(dp30426
g11
(lp30427
sg13
S'com.google.common.collect.ImmutableSortedMap$Builder'
p30428
sg15
(lp30429
sg17
(lp30430
sg19
(lp30431
sg21
I0
sba(iArchitecture
Entity
p30432
(dp30433
g11
(lp30434
sg13
S'com.google.common.collect.ImmutableSortedMap$SerializedForm'
p30435
sg15
(lp30436
sg17
(lp30437
sg19
(lp30438
sg21
I0
sba(iArchitecture
Entity
p30439
(dp30440
g11
(lp30441
sg13
S'com.google.common.collect.ImmutableSortedMapFauxverideShim'
p30442
sg15
(lp30443
sg17
(lp30444
sg19
(lp30445
sg21
I0
sba(iArchitecture
Entity
p30446
(dp30447
g11
(lp30448
sg13
S'com.google.common.collect.ImmutableSortedMultiset'
p30449
sg15
(lp30450
sg17
(lp30451
sg19
(lp30452
sg21
I0
sba(iArchitecture
Entity
p30453
(dp30454
g11
(lp30455
sg13
S'com.google.common.collect.ImmutableSortedMultiset$Builder'
p30456
sg15
(lp30457
sg17
(lp30458
sg19
(lp30459
sg21
I0
sba(iArchitecture
Entity
p30460
(dp30461
g11
(lp30462
sg13
S'com.google.common.collect.ImmutableSortedMultiset$SerializedForm'
p30463
sg15
(lp30464
sg17
(lp30465
sg19
(lp30466
sg21
I0
sba(iArchitecture
Entity
p30467
(dp30468
g11
(lp30469
sg13
S'com.google.common.collect.ImmutableSortedMultisetFauxverideShim'
p30470
sg15
(lp30471
sg17
(lp30472
sg19
(lp30473
sg21
I0
sba(iArchitecture
Entity
p30474
(dp30475
g11
(lp30476
sg13
S'com.google.common.collect.ImmutableSortedSet'
p30477
sg15
(lp30478
sg17
(lp30479
sg19
(lp30480
sg21
I0
sba(iArchitecture
Entity
p30481
(dp30482
g11
(lp30483
sg13
S'com.google.common.collect.ImmutableSortedSet$1'
p30484
sg15
(lp30485
sg17
(lp30486
sg19
(lp30487
sg21
I0
sba(iArchitecture
Entity
p30488
(dp30489
g11
(lp30490
sg13
S'com.google.common.collect.ImmutableSortedSet$Builder'
p30491
sg15
(lp30492
sg17
(lp30493
sg19
(lp30494
sg21
I0
sba(iArchitecture
Entity
p30495
(dp30496
g11
(lp30497
sg13
S'com.google.common.collect.ImmutableSortedSet$SerializedForm'
p30498
sg15
(lp30499
sg17
(lp30500
sg19
(lp30501
sg21
I0
sba(iArchitecture
Entity
p30502
(dp30503
g11
(lp30504
sg13
S'com.google.common.collect.ImmutableSortedSetFauxverideShim'
p30505
sg15
(lp30506
sg17
(lp30507
sg19
(lp30508
sg21
I0
sba(iArchitecture
Entity
p30509
(dp30510
g11
(lp30511
sg13
S'com.google.common.collect.ImmutableTable'
p30512
sg15
(lp30513
sg17
(lp30514
sg19
(lp30515
sg21
I0
sba(iArchitecture
Entity
p30516
(dp30517
g11
(lp30518
sg13
S'com.google.common.collect.ImmutableTable$1'
p30519
sg15
(lp30520
sg17
(lp30521
sg19
(lp30522
sg21
I0
sba(iArchitecture
Entity
p30523
(dp30524
g11
(lp30525
sg13
S'com.google.common.collect.ImmutableTable$Builder'
p30526
sg15
(lp30527
sg17
(lp30528
sg19
(lp30529
sg21
I0
sba(iArchitecture
Entity
p30530
(dp30531
g11
(lp30532
sg13
S'com.google.common.collect.ImmutableTable$CollectorState'
p30533
sg15
(lp30534
sg17
(lp30535
sg19
(lp30536
sg21
I0
sba(iArchitecture
Entity
p30537
(dp30538
g11
(lp30539
sg13
S'com.google.common.collect.ImmutableTable$MutableCell'
p30540
sg15
(lp30541
sg17
(lp30542
sg19
(lp30543
sg21
I0
sba(iArchitecture
Entity
p30544
(dp30545
g11
(lp30546
sg13
S'com.google.common.collect.ImmutableTable$SerializedForm'
p30547
sg15
(lp30548
sg17
(lp30549
sg19
(lp30550
sg21
I0
sba(iArchitecture
Entity
p30551
(dp30552
g11
(lp30553
sg13
S'com.google.common.collect.Interner'
p30554
sg15
(lp30555
sg17
(lp30556
sg19
(lp30557
sg21
I0
sba(iArchitecture
Entity
p30558
(dp30559
g11
(lp30560
sg13
S'com.google.common.collect.Interners'
p30561
sg15
(lp30562
sg17
(lp30563
sg19
(lp30564
sg21
I0
sba(iArchitecture
Entity
p30565
(dp30566
g11
(lp30567
sg13
S'com.google.common.collect.Interners$1'
p30568
sg15
(lp30569
sg17
(lp30570
sg19
(lp30571
sg21
I0
sba(iArchitecture
Entity
p30572
(dp30573
g11
(lp30574
sg13
S'com.google.common.collect.Interners$InternerBuilder'
p30575
sg15
(lp30576
sg17
(lp30577
sg19
(lp30578
sg21
I0
sba(iArchitecture
Entity
p30579
(dp30580
g11
(lp30581
sg13
S'com.google.common.collect.Interners$InternerFunction'
p30582
sg15
(lp30583
sg17
(lp30584
sg19
(lp30585
sg21
I0
sba(iArchitecture
Entity
p30586
(dp30587
g11
(lp30588
sg13
S'com.google.common.collect.Interners$InternerImpl'
p30589
sg15
(lp30590
sg17
(lp30591
sg19
(lp30592
sg21
I0
sba(iArchitecture
Entity
p30593
(dp30594
g11
(lp30595
sg13
S'com.google.common.collect.Iterables'
p30596
sg15
(lp30597
sg17
(lp30598
sg19
(lp30599
sg21
I0
sba(iArchitecture
Entity
p30600
(dp30601
g11
(lp30602
sg13
S'com.google.common.collect.Iterables$1'
p30603
sg15
(lp30604
sg17
(lp30605
sg19
(lp30606
sg21
I0
sba(iArchitecture
Entity
p30607
(dp30608
g11
(lp30609
sg13
S'com.google.common.collect.Iterables$10'
p30610
sg15
(lp30611
sg17
(lp30612
sg19
(lp30613
sg21
I0
sba(iArchitecture
Entity
p30614
(dp30615
g11
(lp30616
sg13
S'com.google.common.collect.Iterables$11'
p30617
sg15
(lp30618
sg17
(lp30619
sg19
(lp30620
sg21
I0
sba(iArchitecture
Entity
p30621
(dp30622
g11
(lp30623
sg13
S'com.google.common.collect.Iterables$12'
p30624
sg15
(lp30625
sg17
(lp30626
sg19
(lp30627
sg21
I0
sba(iArchitecture
Entity
p30628
(dp30629
g11
(lp30630
sg13
S'com.google.common.collect.Iterables$13'
p30631
sg15
(lp30632
sg17
(lp30633
sg19
(lp30634
sg21
I0
sba(iArchitecture
Entity
p30635
(dp30636
g11
(lp30637
sg13
S'com.google.common.collect.Iterables$2'
p30638
sg15
(lp30639
sg17
(lp30640
sg19
(lp30641
sg21
I0
sba(iArchitecture
Entity
p30642
(dp30643
g11
(lp30644
sg13
S'com.google.common.collect.Iterables$3'
p30645
sg15
(lp30646
sg17
(lp30647
sg19
(lp30648
sg21
I0
sba(iArchitecture
Entity
p30649
(dp30650
g11
(lp30651
sg13
S'com.google.common.collect.Iterables$4'
p30652
sg15
(lp30653
sg17
(lp30654
sg19
(lp30655
sg21
I0
sba(iArchitecture
Entity
p30656
(dp30657
g11
(lp30658
sg13
S'com.google.common.collect.Iterables$5'
p30659
sg15
(lp30660
sg17
(lp30661
sg19
(lp30662
sg21
I0
sba(iArchitecture
Entity
p30663
(dp30664
g11
(lp30665
sg13
S'com.google.common.collect.Iterables$6'
p30666
sg15
(lp30667
sg17
(lp30668
sg19
(lp30669
sg21
I0
sba(iArchitecture
Entity
p30670
(dp30671
g11
(lp30672
sg13
S'com.google.common.collect.Iterables$7'
p30673
sg15
(lp30674
sg17
(lp30675
sg19
(lp30676
sg21
I0
sba(iArchitecture
Entity
p30677
(dp30678
g11
(lp30679
sg13
S'com.google.common.collect.Iterables$8'
p30680
sg15
(lp30681
sg17
(lp30682
sg19
(lp30683
sg21
I0
sba(iArchitecture
Entity
p30684
(dp30685
g11
(lp30686
sg13
S'com.google.common.collect.Iterables$8$1'
p30687
sg15
(lp30688
sg17
(lp30689
sg19
(lp30690
sg21
I0
sba(iArchitecture
Entity
p30691
(dp30692
g11
(lp30693
sg13
S'com.google.common.collect.Iterables$9'
p30694
sg15
(lp30695
sg17
(lp30696
sg19
(lp30697
sg21
I0
sba(iArchitecture
Entity
p30698
(dp30699
g11
(lp30700
sg13
S'com.google.common.collect.Iterables$UnmodifiableIterable'
p30701
sg15
(lp30702
sg17
(lp30703
sg19
(lp30704
sg21
I0
sba(iArchitecture
Entity
p30705
(dp30706
g11
(lp30707
sg13
S'com.google.common.collect.Iterators'
p30708
sg15
(lp30709
sg17
(lp30710
sg19
(lp30711
sg21
I0
sba(iArchitecture
Entity
p30712
(dp30713
g11
(lp30714
sg13
S'com.google.common.collect.Iterators$1'
p30715
sg15
(lp30716
sg17
(lp30717
sg19
(lp30718
sg21
I0
sba(iArchitecture
Entity
p30719
(dp30720
g11
(lp30721
sg13
S'com.google.common.collect.Iterators$10'
p30722
sg15
(lp30723
sg17
(lp30724
sg19
(lp30725
sg21
I0
sba(iArchitecture
Entity
p30726
(dp30727
g11
(lp30728
sg13
S'com.google.common.collect.Iterators$2'
p30729
sg15
(lp30730
sg17
(lp30731
sg19
(lp30732
sg21
I0
sba(iArchitecture
Entity
p30733
(dp30734
g11
(lp30735
sg13
S'com.google.common.collect.Iterators$3'
p30736
sg15
(lp30737
sg17
(lp30738
sg19
(lp30739
sg21
I0
sba(iArchitecture
Entity
p30740
(dp30741
g11
(lp30742
sg13
S'com.google.common.collect.Iterators$4'
p30743
sg15
(lp30744
sg17
(lp30745
sg19
(lp30746
sg21
I0
sba(iArchitecture
Entity
p30747
(dp30748
g11
(lp30749
sg13
S'com.google.common.collect.Iterators$5'
p30750
sg15
(lp30751
sg17
(lp30752
sg19
(lp30753
sg21
I0
sba(iArchitecture
Entity
p30754
(dp30755
g11
(lp30756
sg13
S'com.google.common.collect.Iterators$6'
p30757
sg15
(lp30758
sg17
(lp30759
sg19
(lp30760
sg21
I0
sba(iArchitecture
Entity
p30761
(dp30762
g11
(lp30763
sg13
S'com.google.common.collect.Iterators$7'
p30764
sg15
(lp30765
sg17
(lp30766
sg19
(lp30767
sg21
I0
sba(iArchitecture
Entity
p30768
(dp30769
g11
(lp30770
sg13
S'com.google.common.collect.Iterators$8'
p30771
sg15
(lp30772
sg17
(lp30773
sg19
(lp30774
sg21
I0
sba(iArchitecture
Entity
p30775
(dp30776
g11
(lp30777
sg13
S'com.google.common.collect.Iterators$9'
p30778
sg15
(lp30779
sg17
(lp30780
sg19
(lp30781
sg21
I0
sba(iArchitecture
Entity
p30782
(dp30783
g11
(lp30784
sg13
S'com.google.common.collect.Iterators$ArrayItr'
p30785
sg15
(lp30786
sg17
(lp30787
sg19
(lp30788
sg21
I0
sba(iArchitecture
Entity
p30789
(dp30790
g11
(lp30791
sg13
S'com.google.common.collect.Iterators$ConcatenatedIterator'
p30792
sg15
(lp30793
sg17
(lp30794
sg19
(lp30795
sg21
I0
sba(iArchitecture
Entity
p30796
(dp30797
g11
(lp30798
sg13
S'com.google.common.collect.Iterators$ConcatenatedIterator$1'
p30799
sg15
(lp30800
sg17
(lp30801
sg19
(lp30802
sg21
I0
sba(iArchitecture
Entity
p30803
(dp30804
g11
(lp30805
sg13
S'com.google.common.collect.Iterators$EmptyModifiableIterator'
p30806
sg15
(lp30807
sg17
(lp30808
sg19
(lp30809
sg21
I0
sba(iArchitecture
Entity
p30810
(dp30811
g11
(lp30812
sg13
S'com.google.common.collect.Iterators$MergingIterator'
p30813
sg15
(lp30814
sg17
(lp30815
sg19
(lp30816
sg21
I0
sba(iArchitecture
Entity
p30817
(dp30818
g11
(lp30819
sg13
S'com.google.common.collect.Iterators$MergingIterator$1'
p30820
sg15
(lp30821
sg17
(lp30822
sg19
(lp30823
sg21
I0
sba(iArchitecture
Entity
p30824
(dp30825
g11
(lp30826
sg13
S'com.google.common.collect.Iterators$PeekingImpl'
p30827
sg15
(lp30828
sg17
(lp30829
sg19
(lp30830
sg21
I0
sba(iArchitecture
Entity
p30831
(dp30832
g11
(lp30833
sg13
S'com.google.common.collect.LexicographicalOrdering'
p30834
sg15
(lp30835
sg17
(lp30836
sg19
(lp30837
sg21
I0
sba(iArchitecture
Entity
p30838
(dp30839
g11
(lp30840
sg13
S'com.google.common.collect.LinkedHashMultimap'
p30841
sg15
(lp30842
sg17
(lp30843
sg19
(lp30844
sg21
I0
sba(iArchitecture
Entity
p30845
(dp30846
g11
(lp30847
sg13
S'com.google.common.collect.LinkedHashMultimap$1'
p30848
sg15
(lp30849
sg17
(lp30850
sg19
(lp30851
sg21
I0
sba(iArchitecture
Entity
p30852
(dp30853
g11
(lp30854
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueEntry'
p30855
sg15
(lp30856
sg17
(lp30857
sg19
(lp30858
sg21
I0
sba(iArchitecture
Entity
p30859
(dp30860
g11
(lp30861
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueSet'
p30862
sg15
(lp30863
sg17
(lp30864
sg19
(lp30865
sg21
I0
sba(iArchitecture
Entity
p30866
(dp30867
g11
(lp30868
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueSet$1'
p30869
sg15
(lp30870
sg17
(lp30871
sg19
(lp30872
sg21
I0
sba(iArchitecture
Entity
p30873
(dp30874
g11
(lp30875
sg13
S'com.google.common.collect.LinkedHashMultimap$ValueSetLink'
p30876
sg15
(lp30877
sg17
(lp30878
sg19
(lp30879
sg21
I0
sba(iArchitecture
Entity
p30880
(dp30881
g11
(lp30882
sg13
S'com.google.common.collect.LinkedHashMultimapGwtSerializationDependencies'
p30883
sg15
(lp30884
sg17
(lp30885
sg19
(lp30886
sg21
I0
sba(iArchitecture
Entity
p30887
(dp30888
g11
(lp30889
sg13
S'com.google.common.collect.LinkedHashMultiset'
p30890
sg15
(lp30891
sg17
(lp30892
sg19
(lp30893
sg21
I0
sba(iArchitecture
Entity
p30894
(dp30895
g11
(lp30896
sg13
S'com.google.common.collect.LinkedListMultimap'
p30897
sg15
(lp30898
sg17
(lp30899
sg19
(lp30900
sg21
I0
sba(iArchitecture
Entity
p30901
(dp30902
g11
(lp30903
sg13
S'com.google.common.collect.LinkedListMultimap$1'
p30904
sg15
(lp30905
sg17
(lp30906
sg19
(lp30907
sg21
I0
sba(iArchitecture
Entity
p30908
(dp30909
g11
(lp30910
sg13
S'com.google.common.collect.LinkedListMultimap$1EntriesImpl'
p30911
sg15
(lp30912
sg17
(lp30913
sg19
(lp30914
sg21
I0
sba(iArchitecture
Entity
p30915
(dp30916
g11
(lp30917
sg13
S'com.google.common.collect.LinkedListMultimap$1KeySetImpl'
p30918
sg15
(lp30919
sg17
(lp30920
sg19
(lp30921
sg21
I0
sba(iArchitecture
Entity
p30922
(dp30923
g11
(lp30924
sg13
S'com.google.common.collect.LinkedListMultimap$1ValuesImpl'
p30925
sg15
(lp30926
sg17
(lp30927
sg19
(lp30928
sg21
I0
sba(iArchitecture
Entity
p30929
(dp30930
g11
(lp30931
sg13
S'com.google.common.collect.LinkedListMultimap$1ValuesImpl$1'
p30932
sg15
(lp30933
sg17
(lp30934
sg19
(lp30935
sg21
I0
sba(iArchitecture
Entity
p30936
(dp30937
g11
(lp30938
sg13
S'com.google.common.collect.LinkedListMultimap$DistinctKeyIterator'
p30939
sg15
(lp30940
sg17
(lp30941
sg19
(lp30942
sg21
I0
sba(iArchitecture
Entity
p30943
(dp30944
g11
(lp30945
sg13
S'com.google.common.collect.LinkedListMultimap$KeyList'
p30946
sg15
(lp30947
sg17
(lp30948
sg19
(lp30949
sg21
I0
sba(iArchitecture
Entity
p30950
(dp30951
g11
(lp30952
sg13
S'com.google.common.collect.LinkedListMultimap$Node'
p30953
sg15
(lp30954
sg17
(lp30955
sg19
(lp30956
sg21
I0
sba(iArchitecture
Entity
p30957
(dp30958
g11
(lp30959
sg13
S'com.google.common.collect.LinkedListMultimap$NodeIterator'
p30960
sg15
(lp30961
sg17
(lp30962
sg19
(lp30963
sg21
I0
sba(iArchitecture
Entity
p30964
(dp30965
g11
(lp30966
sg13
S'com.google.common.collect.LinkedListMultimap$ValueForKeyIterator'
p30967
sg15
(lp30968
sg17
(lp30969
sg19
(lp30970
sg21
I0
sba(iArchitecture
Entity
p30971
(dp30972
g11
(lp30973
sg13
S'com.google.common.collect.ListMultimap'
p30974
sg15
(lp30975
sg17
(lp30976
sg19
(lp30977
sg21
I0
sba(iArchitecture
Entity
p30978
(dp30979
g11
(lp30980
sg13
S'com.google.common.collect.Lists'
p30981
sg15
(lp30982
sg17
(lp30983
sg19
(lp30984
sg21
I0
sba(iArchitecture
Entity
p30985
(dp30986
g11
(lp30987
sg13
S'com.google.common.collect.Lists$1'
p30988
sg15
(lp30989
sg17
(lp30990
sg19
(lp30991
sg21
I0
sba(iArchitecture
Entity
p30992
(dp30993
g11
(lp30994
sg13
S'com.google.common.collect.Lists$2'
p30995
sg15
(lp30996
sg17
(lp30997
sg19
(lp30998
sg21
I0
sba(iArchitecture
Entity
p30999
(dp31000
g11
(lp31001
sg13
S'com.google.common.collect.Lists$AbstractListWrapper'
p31002
sg15
(lp31003
sg17
(lp31004
sg19
(lp31005
sg21
I0
sba(iArchitecture
Entity
p31006
(dp31007
g11
(lp31008
sg13
S'com.google.common.collect.Lists$CharSequenceAsList'
p31009
sg15
(lp31010
sg17
(lp31011
sg19
(lp31012
sg21
I0
sba(iArchitecture
Entity
p31013
(dp31014
g11
(lp31015
sg13
S'com.google.common.collect.Lists$OnePlusArrayList'
p31016
sg15
(lp31017
sg17
(lp31018
sg19
(lp31019
sg21
I0
sba(iArchitecture
Entity
p31020
(dp31021
g11
(lp31022
sg13
S'com.google.common.collect.Lists$Partition'
p31023
sg15
(lp31024
sg17
(lp31025
sg19
(lp31026
sg21
I0
sba(iArchitecture
Entity
p31027
(dp31028
g11
(lp31029
sg13
S'com.google.common.collect.Lists$RandomAccessListWrapper'
p31030
sg15
(lp31031
sg17
(lp31032
sg19
(lp31033
sg21
I0
sba(iArchitecture
Entity
p31034
(dp31035
g11
(lp31036
sg13
S'com.google.common.collect.Lists$RandomAccessPartition'
p31037
sg15
(lp31038
sg17
(lp31039
sg19
(lp31040
sg21
I0
sba(iArchitecture
Entity
p31041
(dp31042
g11
(lp31043
sg13
S'com.google.common.collect.Lists$RandomAccessReverseList'
p31044
sg15
(lp31045
sg17
(lp31046
sg19
(lp31047
sg21
I0
sba(iArchitecture
Entity
p31048
(dp31049
g11
(lp31050
sg13
S'com.google.common.collect.Lists$ReverseList'
p31051
sg15
(lp31052
sg17
(lp31053
sg19
(lp31054
sg21
I0
sba(iArchitecture
Entity
p31055
(dp31056
g11
(lp31057
sg13
S'com.google.common.collect.Lists$ReverseList$1'
p31058
sg15
(lp31059
sg17
(lp31060
sg19
(lp31061
sg21
I0
sba(iArchitecture
Entity
p31062
(dp31063
g11
(lp31064
sg13
S'com.google.common.collect.Lists$StringAsImmutableList'
p31065
sg15
(lp31066
sg17
(lp31067
sg19
(lp31068
sg21
I0
sba(iArchitecture
Entity
p31069
(dp31070
g11
(lp31071
sg13
S'com.google.common.collect.Lists$TransformingRandomAccessList'
p31072
sg15
(lp31073
sg17
(lp31074
sg19
(lp31075
sg21
I0
sba(iArchitecture
Entity
p31076
(dp31077
g11
(lp31078
sg13
S'com.google.common.collect.Lists$TransformingRandomAccessList$1'
p31079
sg15
(lp31080
sg17
(lp31081
sg19
(lp31082
sg21
I0
sba(iArchitecture
Entity
p31083
(dp31084
g11
(lp31085
sg13
S'com.google.common.collect.Lists$TransformingSequentialList'
p31086
sg15
(lp31087
sg17
(lp31088
sg19
(lp31089
sg21
I0
sba(iArchitecture
Entity
p31090
(dp31091
g11
(lp31092
sg13
S'com.google.common.collect.Lists$TransformingSequentialList$1'
p31093
sg15
(lp31094
sg17
(lp31095
sg19
(lp31096
sg21
I0
sba(iArchitecture
Entity
p31097
(dp31098
g11
(lp31099
sg13
S'com.google.common.collect.Lists$TwoPlusArrayList'
p31100
sg15
(lp31101
sg17
(lp31102
sg19
(lp31103
sg21
I0
sba(iArchitecture
Entity
p31104
(dp31105
g11
(lp31106
sg13
S'com.google.common.collect.MapDifference'
p31107
sg15
(lp31108
sg17
(lp31109
sg19
(lp31110
sg21
I0
sba(iArchitecture
Entity
p31111
(dp31112
g11
(lp31113
sg13
S'com.google.common.collect.MapDifference$ValueDifference'
p31114
sg15
(lp31115
sg17
(lp31116
sg19
(lp31117
sg21
I0
sba(iArchitecture
Entity
p31118
(dp31119
g11
(lp31120
sg13
S'com.google.common.collect.MapMaker'
p31121
sg15
(lp31122
sg17
(lp31123
sg19
(lp31124
sg21
I0
sba(iArchitecture
Entity
p31125
(dp31126
g11
(lp31127
sg13
S'com.google.common.collect.MapMaker$Dummy'
p31128
sg15
(lp31129
sg17
(lp31130
sg19
(lp31131
sg21
I0
sba(iArchitecture
Entity
p31132
(dp31133
g11
(lp31134
sg13
S'com.google.common.collect.MapMakerInternalMap'
p31135
sg15
(lp31136
sg17
(lp31137
sg19
(lp31138
sg21
I0
sba(iArchitecture
Entity
p31139
(dp31140
g11
(lp31141
sg13
S'com.google.common.collect.MapMakerInternalMap$1'
p31142
sg15
(lp31143
sg17
(lp31144
sg19
(lp31145
sg21
I0
sba(iArchitecture
Entity
p31146
(dp31147
g11
(lp31148
sg13
S'com.google.common.collect.MapMakerInternalMap$AbstractSerializationProxy'
p31149
sg15
(lp31150
sg17
(lp31151
sg19
(lp31152
sg21
I0
sba(iArchitecture
Entity
p31153
(dp31154
g11
(lp31155
sg13
S'com.google.common.collect.MapMakerInternalMap$AbstractStrongKeyEntry'
p31156
sg15
(lp31157
sg17
(lp31158
sg19
(lp31159
sg21
I0
sba(iArchitecture
Entity
p31160
(dp31161
g11
(lp31162
sg13
S'com.google.common.collect.MapMakerInternalMap$AbstractWeakKeyEntry'
p31163
sg15
(lp31164
sg17
(lp31165
sg19
(lp31166
sg21
I0
sba(iArchitecture
Entity
p31167
(dp31168
g11
(lp31169
sg13
S'com.google.common.collect.MapMakerInternalMap$CleanupMapTask'
p31170
sg15
(lp31171
sg17
(lp31172
sg19
(lp31173
sg21
I0
sba(iArchitecture
Entity
p31174
(dp31175
g11
(lp31176
sg13
S'com.google.common.collect.MapMakerInternalMap$DummyInternalEntry'
p31177
sg15
(lp31178
sg17
(lp31179
sg19
(lp31180
sg21
I0
sba(iArchitecture
Entity
p31181
(dp31182
g11
(lp31183
sg13
S'com.google.common.collect.MapMakerInternalMap$EntryIterator'
p31184
sg15
(lp31185
sg17
(lp31186
sg19
(lp31187
sg21
I0
sba(iArchitecture
Entity
p31188
(dp31189
g11
(lp31190
sg13
S'com.google.common.collect.MapMakerInternalMap$EntrySet'
p31191
sg15
(lp31192
sg17
(lp31193
sg19
(lp31194
sg21
I0
sba(iArchitecture
Entity
p31195
(dp31196
g11
(lp31197
sg13
S'com.google.common.collect.MapMakerInternalMap$HashIterator'
p31198
sg15
(lp31199
sg17
(lp31200
sg19
(lp31201
sg21
I0
sba(iArchitecture
Entity
p31202
(dp31203
g11
(lp31204
sg13
S'com.google.common.collect.MapMakerInternalMap$InternalEntry'
p31205
sg15
(lp31206
sg17
(lp31207
sg19
(lp31208
sg21
I0
sba(iArchitecture
Entity
p31209
(dp31210
g11
(lp31211
sg13
S'com.google.common.collect.MapMakerInternalMap$InternalEntryHelper'
p31212
sg15
(lp31213
sg17
(lp31214
sg19
(lp31215
sg21
I0
sba(iArchitecture
Entity
p31216
(dp31217
g11
(lp31218
sg13
S'com.google.common.collect.MapMakerInternalMap$KeyIterator'
p31219
sg15
(lp31220
sg17
(lp31221
sg19
(lp31222
sg21
I0
sba(iArchitecture
Entity
p31223
(dp31224
g11
(lp31225
sg13
S'com.google.common.collect.MapMakerInternalMap$KeySet'
p31226
sg15
(lp31227
sg17
(lp31228
sg19
(lp31229
sg21
I0
sba(iArchitecture
Entity
p31230
(dp31231
g11
(lp31232
sg13
S'com.google.common.collect.MapMakerInternalMap$SafeToArraySet'
p31233
sg15
(lp31234
sg17
(lp31235
sg19
(lp31236
sg21
I0
sba(iArchitecture
Entity
p31237
(dp31238
g11
(lp31239
sg13
S'com.google.common.collect.MapMakerInternalMap$Segment'
p31240
sg15
(lp31241
sg17
(lp31242
sg19
(lp31243
sg21
I0
sba(iArchitecture
Entity
p31244
(dp31245
g11
(lp31246
sg13
S'com.google.common.collect.MapMakerInternalMap$SerializationProxy'
p31247
sg15
(lp31248
sg17
(lp31249
sg19
(lp31250
sg21
I0
sba(iArchitecture
Entity
p31251
(dp31252
g11
(lp31253
sg13
S'com.google.common.collect.MapMakerInternalMap$Strength'
p31254
sg15
(lp31255
sg17
(lp31256
sg19
(lp31257
sg21
I0
sba(iArchitecture
Entity
p31258
(dp31259
g11
(lp31260
sg13
S'com.google.common.collect.MapMakerInternalMap$Strength$1'
p31261
sg15
(lp31262
sg17
(lp31263
sg19
(lp31264
sg21
I0
sba(iArchitecture
Entity
p31265
(dp31266
g11
(lp31267
sg13
S'com.google.common.collect.MapMakerInternalMap$Strength$2'
p31268
sg15
(lp31269
sg17
(lp31270
sg19
(lp31271
sg21
I0
sba(iArchitecture
Entity
p31272
(dp31273
g11
(lp31274
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyDummyValueEntry'
p31275
sg15
(lp31276
sg17
(lp31277
sg19
(lp31278
sg21
I0
sba(iArchitecture
Entity
p31279
(dp31280
g11
(lp31281
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyDummyValueEntry$Helper'
p31282
sg15
(lp31283
sg17
(lp31284
sg19
(lp31285
sg21
I0
sba(iArchitecture
Entity
p31286
(dp31287
g11
(lp31288
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyDummyValueSegment'
p31289
sg15
(lp31290
sg17
(lp31291
sg19
(lp31292
sg21
I0
sba(iArchitecture
Entity
p31293
(dp31294
g11
(lp31295
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyStrongValueEntry'
p31296
sg15
(lp31297
sg17
(lp31298
sg19
(lp31299
sg21
I0
sba(iArchitecture
Entity
p31300
(dp31301
g11
(lp31302
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyStrongValueEntry$Helper'
p31303
sg15
(lp31304
sg17
(lp31305
sg19
(lp31306
sg21
I0
sba(iArchitecture
Entity
p31307
(dp31308
g11
(lp31309
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyStrongValueSegment'
p31310
sg15
(lp31311
sg17
(lp31312
sg19
(lp31313
sg21
I0
sba(iArchitecture
Entity
p31314
(dp31315
g11
(lp31316
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyWeakValueEntry'
p31317
sg15
(lp31318
sg17
(lp31319
sg19
(lp31320
sg21
I0
sba(iArchitecture
Entity
p31321
(dp31322
g11
(lp31323
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyWeakValueEntry$Helper'
p31324
sg15
(lp31325
sg17
(lp31326
sg19
(lp31327
sg21
I0
sba(iArchitecture
Entity
p31328
(dp31329
g11
(lp31330
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongKeyWeakValueSegment'
p31331
sg15
(lp31332
sg17
(lp31333
sg19
(lp31334
sg21
I0
sba(iArchitecture
Entity
p31335
(dp31336
g11
(lp31337
sg13
S'com.google.common.collect.MapMakerInternalMap$StrongValueEntry'
p31338
sg15
(lp31339
sg17
(lp31340
sg19
(lp31341
sg21
I0
sba(iArchitecture
Entity
p31342
(dp31343
g11
(lp31344
sg13
S'com.google.common.collect.MapMakerInternalMap$ValueIterator'
p31345
sg15
(lp31346
sg17
(lp31347
sg19
(lp31348
sg21
I0
sba(iArchitecture
Entity
p31349
(dp31350
g11
(lp31351
sg13
S'com.google.common.collect.MapMakerInternalMap$Values'
p31352
sg15
(lp31353
sg17
(lp31354
sg19
(lp31355
sg21
I0
sba(iArchitecture
Entity
p31356
(dp31357
g11
(lp31358
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyDummyValueEntry'
p31359
sg15
(lp31360
sg17
(lp31361
sg19
(lp31362
sg21
I0
sba(iArchitecture
Entity
p31363
(dp31364
g11
(lp31365
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyDummyValueEntry$Helper'
p31366
sg15
(lp31367
sg17
(lp31368
sg19
(lp31369
sg21
I0
sba(iArchitecture
Entity
p31370
(dp31371
g11
(lp31372
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyDummyValueSegment'
p31373
sg15
(lp31374
sg17
(lp31375
sg19
(lp31376
sg21
I0
sba(iArchitecture
Entity
p31377
(dp31378
g11
(lp31379
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyStrongValueEntry'
p31380
sg15
(lp31381
sg17
(lp31382
sg19
(lp31383
sg21
I0
sba(iArchitecture
Entity
p31384
(dp31385
g11
(lp31386
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyStrongValueEntry$Helper'
p31387
sg15
(lp31388
sg17
(lp31389
sg19
(lp31390
sg21
I0
sba(iArchitecture
Entity
p31391
(dp31392
g11
(lp31393
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyStrongValueSegment'
p31394
sg15
(lp31395
sg17
(lp31396
sg19
(lp31397
sg21
I0
sba(iArchitecture
Entity
p31398
(dp31399
g11
(lp31400
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyWeakValueEntry'
p31401
sg15
(lp31402
sg17
(lp31403
sg19
(lp31404
sg21
I0
sba(iArchitecture
Entity
p31405
(dp31406
g11
(lp31407
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyWeakValueEntry$Helper'
p31408
sg15
(lp31409
sg17
(lp31410
sg19
(lp31411
sg21
I0
sba(iArchitecture
Entity
p31412
(dp31413
g11
(lp31414
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakKeyWeakValueSegment'
p31415
sg15
(lp31416
sg17
(lp31417
sg19
(lp31418
sg21
I0
sba(iArchitecture
Entity
p31419
(dp31420
g11
(lp31421
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakValueEntry'
p31422
sg15
(lp31423
sg17
(lp31424
sg19
(lp31425
sg21
I0
sba(iArchitecture
Entity
p31426
(dp31427
g11
(lp31428
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakValueReference'
p31429
sg15
(lp31430
sg17
(lp31431
sg19
(lp31432
sg21
I0
sba(iArchitecture
Entity
p31433
(dp31434
g11
(lp31435
sg13
S'com.google.common.collect.MapMakerInternalMap$WeakValueReferenceImpl'
p31436
sg15
(lp31437
sg17
(lp31438
sg19
(lp31439
sg21
I0
sba(iArchitecture
Entity
p31440
(dp31441
g11
(lp31442
sg13
S'com.google.common.collect.MapMakerInternalMap$WriteThroughEntry'
p31443
sg15
(lp31444
sg17
(lp31445
sg19
(lp31446
sg21
I0
sba(iArchitecture
Entity
p31447
(dp31448
g11
(lp31449
sg13
S'com.google.common.collect.Maps'
p31450
sg15
(lp31451
sg17
(lp31452
sg19
(lp31453
sg21
I0
sba(iArchitecture
Entity
p31454
(dp31455
g11
(lp31456
sg13
S'com.google.common.collect.Maps$1'
p31457
sg15
(lp31458
sg17
(lp31459
sg19
(lp31460
sg21
I0
sba(iArchitecture
Entity
p31461
(dp31462
g11
(lp31463
sg13
S'com.google.common.collect.Maps$10'
p31464
sg15
(lp31465
sg17
(lp31466
sg19
(lp31467
sg21
I0
sba(iArchitecture
Entity
p31468
(dp31469
g11
(lp31470
sg13
S'com.google.common.collect.Maps$11'
p31471
sg15
(lp31472
sg17
(lp31473
sg19
(lp31474
sg21
I0
sba(iArchitecture
Entity
p31475
(dp31476
g11
(lp31477
sg13
S'com.google.common.collect.Maps$2'
p31478
sg15
(lp31479
sg17
(lp31480
sg19
(lp31481
sg21
I0
sba(iArchitecture
Entity
p31482
(dp31483
g11
(lp31484
sg13
S'com.google.common.collect.Maps$3'
p31485
sg15
(lp31486
sg17
(lp31487
sg19
(lp31488
sg21
I0
sba(iArchitecture
Entity
p31489
(dp31490
g11
(lp31491
sg13
S'com.google.common.collect.Maps$4'
p31492
sg15
(lp31493
sg17
(lp31494
sg19
(lp31495
sg21
I0
sba(iArchitecture
Entity
p31496
(dp31497
g11
(lp31498
sg13
S'com.google.common.collect.Maps$5'
p31499
sg15
(lp31500
sg17
(lp31501
sg19
(lp31502
sg21
I0
sba(iArchitecture
Entity
p31503
(dp31504
g11
(lp31505
sg13
S'com.google.common.collect.Maps$6'
p31506
sg15
(lp31507
sg17
(lp31508
sg19
(lp31509
sg21
I0
sba(iArchitecture
Entity
p31510
(dp31511
g11
(lp31512
sg13
S'com.google.common.collect.Maps$7'
p31513
sg15
(lp31514
sg17
(lp31515
sg19
(lp31516
sg21
I0
sba(iArchitecture
Entity
p31517
(dp31518
g11
(lp31519
sg13
S'com.google.common.collect.Maps$8'
p31520
sg15
(lp31521
sg17
(lp31522
sg19
(lp31523
sg21
I0
sba(iArchitecture
Entity
p31524
(dp31525
g11
(lp31526
sg13
S'com.google.common.collect.Maps$9'
p31527
sg15
(lp31528
sg17
(lp31529
sg19
(lp31530
sg21
I0
sba(iArchitecture
Entity
p31531
(dp31532
g11
(lp31533
sg13
S'com.google.common.collect.Maps$AbstractFilteredMap'
p31534
sg15
(lp31535
sg17
(lp31536
sg19
(lp31537
sg21
I0
sba(iArchitecture
Entity
p31538
(dp31539
g11
(lp31540
sg13
S'com.google.common.collect.Maps$Accumulator'
p31541
sg15
(lp31542
sg17
(lp31543
sg19
(lp31544
sg21
I0
sba(iArchitecture
Entity
p31545
(dp31546
g11
(lp31547
sg13
S'com.google.common.collect.Maps$AsMapView'
p31548
sg15
(lp31549
sg17
(lp31550
sg19
(lp31551
sg21
I0
sba(iArchitecture
Entity
p31552
(dp31553
g11
(lp31554
sg13
S'com.google.common.collect.Maps$AsMapView$1EntrySetImpl'
p31555
sg15
(lp31556
sg17
(lp31557
sg19
(lp31558
sg21
I0
sba(iArchitecture
Entity
p31559
(dp31560
g11
(lp31561
sg13
S'com.google.common.collect.Maps$BiMapConverter'
p31562
sg15
(lp31563
sg17
(lp31564
sg19
(lp31565
sg21
I0
sba(iArchitecture
Entity
p31566
(dp31567
g11
(lp31568
sg13
S'com.google.common.collect.Maps$DescendingMap'
p31569
sg15
(lp31570
sg17
(lp31571
sg19
(lp31572
sg21
I0
sba(iArchitecture
Entity
p31573
(dp31574
g11
(lp31575
sg13
S'com.google.common.collect.Maps$DescendingMap$1EntrySetImpl'
p31576
sg15
(lp31577
sg17
(lp31578
sg19
(lp31579
sg21
I0
sba(iArchitecture
Entity
p31580
(dp31581
g11
(lp31582
sg13
S'com.google.common.collect.Maps$EntryFunction'
p31583
sg15
(lp31584
sg17
(lp31585
sg19
(lp31586
sg21
I0
sba(iArchitecture
Entity
p31587
(dp31588
g11
(lp31589
sg13
S'com.google.common.collect.Maps$EntryFunction$1'
p31590
sg15
(lp31591
sg17
(lp31592
sg19
(lp31593
sg21
I0
sba(iArchitecture
Entity
p31594
(dp31595
g11
(lp31596
sg13
S'com.google.common.collect.Maps$EntryFunction$2'
p31597
sg15
(lp31598
sg17
(lp31599
sg19
(lp31600
sg21
I0
sba(iArchitecture
Entity
p31601
(dp31602
g11
(lp31603
sg13
S'com.google.common.collect.Maps$EntrySet'
p31604
sg15
(lp31605
sg17
(lp31606
sg19
(lp31607
sg21
I0
sba(iArchitecture
Entity
p31608
(dp31609
g11
(lp31610
sg13
S'com.google.common.collect.Maps$EntryTransformer'
p31611
sg15
(lp31612
sg17
(lp31613
sg19
(lp31614
sg21
I0
sba(iArchitecture
Entity
p31615
(dp31616
g11
(lp31617
sg13
S'com.google.common.collect.Maps$FilteredEntryBiMap'
p31618
sg15
(lp31619
sg17
(lp31620
sg19
(lp31621
sg21
I0
sba(iArchitecture
Entity
p31622
(dp31623
g11
(lp31624
sg13
S'com.google.common.collect.Maps$FilteredEntryBiMap$1'
p31625
sg15
(lp31626
sg17
(lp31627
sg19
(lp31628
sg21
I0
sba(iArchitecture
Entity
p31629
(dp31630
g11
(lp31631
sg13
S'com.google.common.collect.Maps$FilteredEntryMap'
p31632
sg15
(lp31633
sg17
(lp31634
sg19
(lp31635
sg21
I0
sba(iArchitecture
Entity
p31636
(dp31637
g11
(lp31638
sg13
S'com.google.common.collect.Maps$FilteredEntryMap$EntrySet'
p31639
sg15
(lp31640
sg17
(lp31641
sg19
(lp31642
sg21
I0
sba(iArchitecture
Entity
p31643
(dp31644
g11
(lp31645
sg13
S'com.google.common.collect.Maps$FilteredEntryMap$EntrySet$1'
p31646
sg15
(lp31647
sg17
(lp31648
sg19
(lp31649
sg21
I0
sba(iArchitecture
Entity
p31650
(dp31651
g11
(lp31652
sg13
S'com.google.common.collect.Maps$FilteredEntryMap$EntrySet$1$1'
p31653
sg15
(lp31654
sg17
(lp31655
sg19
(lp31656
sg21
I0
sba(iArchitecture
Entity
p31657
(dp31658
g11
(lp31659
sg13
S'com.google.common.collect.Maps$FilteredEntryMap$KeySet'
p31660
sg15
(lp31661
sg17
(lp31662
sg19
(lp31663
sg21
I0
sba(iArchitecture
Entity
p31664
(dp31665
g11
(lp31666
sg13
S'com.google.common.collect.Maps$FilteredEntryNavigableMap'
p31667
sg15
(lp31668
sg17
(lp31669
sg19
(lp31670
sg21
I0
sba(iArchitecture
Entity
p31671
(dp31672
g11
(lp31673
sg13
S'com.google.common.collect.Maps$FilteredEntryNavigableMap$1'
p31674
sg15
(lp31675
sg17
(lp31676
sg19
(lp31677
sg21
I0
sba(iArchitecture
Entity
p31678
(dp31679
g11
(lp31680
sg13
S'com.google.common.collect.Maps$FilteredEntrySortedMap'
p31681
sg15
(lp31682
sg17
(lp31683
sg19
(lp31684
sg21
I0
sba(iArchitecture
Entity
p31685
(dp31686
g11
(lp31687
sg13
S'com.google.common.collect.Maps$FilteredEntrySortedMap$SortedKeySet'
p31688
sg15
(lp31689
sg17
(lp31690
sg19
(lp31691
sg21
I0
sba(iArchitecture
Entity
p31692
(dp31693
g11
(lp31694
sg13
S'com.google.common.collect.Maps$FilteredKeyMap'
p31695
sg15
(lp31696
sg17
(lp31697
sg19
(lp31698
sg21
I0
sba(iArchitecture
Entity
p31699
(dp31700
g11
(lp31701
sg13
S'com.google.common.collect.Maps$FilteredMapValues'
p31702
sg15
(lp31703
sg17
(lp31704
sg19
(lp31705
sg21
I0
sba(iArchitecture
Entity
p31706
(dp31707
g11
(lp31708
sg13
S'com.google.common.collect.Maps$IteratorBasedAbstractMap'
p31709
sg15
(lp31710
sg17
(lp31711
sg19
(lp31712
sg21
I0
sba(iArchitecture
Entity
p31713
(dp31714
g11
(lp31715
sg13
S'com.google.common.collect.Maps$IteratorBasedAbstractMap$1'
p31716
sg15
(lp31717
sg17
(lp31718
sg19
(lp31719
sg21
I0
sba(iArchitecture
Entity
p31720
(dp31721
g11
(lp31722
sg13
S'com.google.common.collect.Maps$KeySet'
p31723
sg15
(lp31724
sg17
(lp31725
sg19
(lp31726
sg21
I0
sba(iArchitecture
Entity
p31727
(dp31728
g11
(lp31729
sg13
S'com.google.common.collect.Maps$MapDifferenceImpl'
p31730
sg15
(lp31731
sg17
(lp31732
sg19
(lp31733
sg21
I0
sba(iArchitecture
Entity
p31734
(dp31735
g11
(lp31736
sg13
S'com.google.common.collect.Maps$NavigableAsMapView'
p31737
sg15
(lp31738
sg17
(lp31739
sg19
(lp31740
sg21
I0
sba(iArchitecture
Entity
p31741
(dp31742
g11
(lp31743
sg13
S'com.google.common.collect.Maps$NavigableKeySet'
p31744
sg15
(lp31745
sg17
(lp31746
sg19
(lp31747
sg21
I0
sba(iArchitecture
Entity
p31748
(dp31749
g11
(lp31750
sg13
S'com.google.common.collect.Maps$SortedAsMapView'
p31751
sg15
(lp31752
sg17
(lp31753
sg19
(lp31754
sg21
I0
sba(iArchitecture
Entity
p31755
(dp31756
g11
(lp31757
sg13
S'com.google.common.collect.Maps$SortedKeySet'
p31758
sg15
(lp31759
sg17
(lp31760
sg19
(lp31761
sg21
I0
sba(iArchitecture
Entity
p31762
(dp31763
g11
(lp31764
sg13
S'com.google.common.collect.Maps$SortedMapDifferenceImpl'
p31765
sg15
(lp31766
sg17
(lp31767
sg19
(lp31768
sg21
I0
sba(iArchitecture
Entity
p31769
(dp31770
g11
(lp31771
sg13
S'com.google.common.collect.Maps$TransformedEntriesMap'
p31772
sg15
(lp31773
sg17
(lp31774
sg19
(lp31775
sg21
I0
sba(iArchitecture
Entity
p31776
(dp31777
g11
(lp31778
sg13
S'com.google.common.collect.Maps$TransformedEntriesNavigableMap'
p31779
sg15
(lp31780
sg17
(lp31781
sg19
(lp31782
sg21
I0
sba(iArchitecture
Entity
p31783
(dp31784
g11
(lp31785
sg13
S'com.google.common.collect.Maps$TransformedEntriesSortedMap'
p31786
sg15
(lp31787
sg17
(lp31788
sg19
(lp31789
sg21
I0
sba(iArchitecture
Entity
p31790
(dp31791
g11
(lp31792
sg13
S'com.google.common.collect.Maps$UnmodifiableBiMap'
p31793
sg15
(lp31794
sg17
(lp31795
sg19
(lp31796
sg21
I0
sba(iArchitecture
Entity
p31797
(dp31798
g11
(lp31799
sg13
S'com.google.common.collect.Maps$UnmodifiableEntries'
p31800
sg15
(lp31801
sg17
(lp31802
sg19
(lp31803
sg21
I0
sba(iArchitecture
Entity
p31804
(dp31805
g11
(lp31806
sg13
S'com.google.common.collect.Maps$UnmodifiableEntrySet'
p31807
sg15
(lp31808
sg17
(lp31809
sg19
(lp31810
sg21
I0
sba(iArchitecture
Entity
p31811
(dp31812
g11
(lp31813
sg13
S'com.google.common.collect.Maps$UnmodifiableNavigableMap'
p31814
sg15
(lp31815
sg17
(lp31816
sg19
(lp31817
sg21
I0
sba(iArchitecture
Entity
p31818
(dp31819
g11
(lp31820
sg13
S'com.google.common.collect.Maps$ValueDifferenceImpl'
p31821
sg15
(lp31822
sg17
(lp31823
sg19
(lp31824
sg21
I0
sba(iArchitecture
Entity
p31825
(dp31826
g11
(lp31827
sg13
S'com.google.common.collect.Maps$Values'
p31828
sg15
(lp31829
sg17
(lp31830
sg19
(lp31831
sg21
I0
sba(iArchitecture
Entity
p31832
(dp31833
g11
(lp31834
sg13
S'com.google.common.collect.Maps$ViewCachingAbstractMap'
p31835
sg15
(lp31836
sg17
(lp31837
sg19
(lp31838
sg21
I0
sba(iArchitecture
Entity
p31839
(dp31840
g11
(lp31841
sg13
S'com.google.common.collect.MinMaxPriorityQueue'
p31842
sg15
(lp31843
sg17
(lp31844
sg19
(lp31845
sg21
I0
sba(iArchitecture
Entity
p31846
(dp31847
g11
(lp31848
sg13
S'com.google.common.collect.MinMaxPriorityQueue$1'
p31849
sg15
(lp31850
sg17
(lp31851
sg19
(lp31852
sg21
I0
sba(iArchitecture
Entity
p31853
(dp31854
g11
(lp31855
sg13
S'com.google.common.collect.MinMaxPriorityQueue$Builder'
p31856
sg15
(lp31857
sg17
(lp31858
sg19
(lp31859
sg21
I0
sba(iArchitecture
Entity
p31860
(dp31861
g11
(lp31862
sg13
S'com.google.common.collect.MinMaxPriorityQueue$Heap'
p31863
sg15
(lp31864
sg17
(lp31865
sg19
(lp31866
sg21
I0
sba(iArchitecture
Entity
p31867
(dp31868
g11
(lp31869
sg13
S'com.google.common.collect.MinMaxPriorityQueue$MoveDesc'
p31870
sg15
(lp31871
sg17
(lp31872
sg19
(lp31873
sg21
I0
sba(iArchitecture
Entity
p31874
(dp31875
g11
(lp31876
sg13
S'com.google.common.collect.MinMaxPriorityQueue$QueueIterator'
p31877
sg15
(lp31878
sg17
(lp31879
sg19
(lp31880
sg21
I0
sba(iArchitecture
Entity
p31881
(dp31882
g11
(lp31883
sg13
S'com.google.common.collect.MoreCollectors'
p31884
sg15
(lp31885
sg17
(lp31886
sg19
(lp31887
sg21
I0
sba(iArchitecture
Entity
p31888
(dp31889
g11
(lp31890
sg13
S'com.google.common.collect.MoreCollectors$ToOptionalState'
p31891
sg15
(lp31892
sg17
(lp31893
sg19
(lp31894
sg21
I0
sba(iArchitecture
Entity
p31895
(dp31896
g11
(lp31897
sg13
S'com.google.common.collect.Multimap'
p31898
sg15
(lp31899
sg17
(lp31900
sg19
(lp31901
sg21
I0
sba(iArchitecture
Entity
p31902
(dp31903
g11
(lp31904
sg13
S'com.google.common.collect.MultimapBuilder'
p31905
sg15
(lp31906
sg17
(lp31907
sg19
(lp31908
sg21
I0
sba(iArchitecture
Entity
p31909
(dp31910
g11
(lp31911
sg13
S'com.google.common.collect.MultimapBuilder$1'
p31912
sg15
(lp31913
sg17
(lp31914
sg19
(lp31915
sg21
I0
sba(iArchitecture
Entity
p31916
(dp31917
g11
(lp31918
sg13
S'com.google.common.collect.MultimapBuilder$2'
p31919
sg15
(lp31920
sg17
(lp31921
sg19
(lp31922
sg21
I0
sba(iArchitecture
Entity
p31923
(dp31924
g11
(lp31925
sg13
S'com.google.common.collect.MultimapBuilder$3'
p31926
sg15
(lp31927
sg17
(lp31928
sg19
(lp31929
sg21
I0
sba(iArchitecture
Entity
p31930
(dp31931
g11
(lp31932
sg13
S'com.google.common.collect.MultimapBuilder$4'
p31933
sg15
(lp31934
sg17
(lp31935
sg19
(lp31936
sg21
I0
sba(iArchitecture
Entity
p31937
(dp31938
g11
(lp31939
sg13
S'com.google.common.collect.MultimapBuilder$ArrayListSupplier'
p31940
sg15
(lp31941
sg17
(lp31942
sg19
(lp31943
sg21
I0
sba(iArchitecture
Entity
p31944
(dp31945
g11
(lp31946
sg13
S'com.google.common.collect.MultimapBuilder$EnumSetSupplier'
p31947
sg15
(lp31948
sg17
(lp31949
sg19
(lp31950
sg21
I0
sba(iArchitecture
Entity
p31951
(dp31952
g11
(lp31953
sg13
S'com.google.common.collect.MultimapBuilder$HashSetSupplier'
p31954
sg15
(lp31955
sg17
(lp31956
sg19
(lp31957
sg21
I0
sba(iArchitecture
Entity
p31958
(dp31959
g11
(lp31960
sg13
S'com.google.common.collect.MultimapBuilder$LinkedHashSetSupplier'
p31961
sg15
(lp31962
sg17
(lp31963
sg19
(lp31964
sg21
I0
sba(iArchitecture
Entity
p31965
(dp31966
g11
(lp31967
sg13
S'com.google.common.collect.MultimapBuilder$LinkedListSupplier'
p31968
sg15
(lp31969
sg17
(lp31970
sg19
(lp31971
sg21
I0
sba(iArchitecture
Entity
p31972
(dp31973
g11
(lp31974
sg13
S'com.google.common.collect.MultimapBuilder$ListMultimapBuilder'
p31975
sg15
(lp31976
sg17
(lp31977
sg19
(lp31978
sg21
I0
sba(iArchitecture
Entity
p31979
(dp31980
g11
(lp31981
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys'
p31982
sg15
(lp31983
sg17
(lp31984
sg19
(lp31985
sg21
I0
sba(iArchitecture
Entity
p31986
(dp31987
g11
(lp31988
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$1'
p31989
sg15
(lp31990
sg17
(lp31991
sg19
(lp31992
sg21
I0
sba(iArchitecture
Entity
p31993
(dp31994
g11
(lp31995
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$2'
p31996
sg15
(lp31997
sg17
(lp31998
sg19
(lp31999
sg21
I0
sba(iArchitecture
Entity
p32000
(dp32001
g11
(lp32002
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$3'
p32003
sg15
(lp32004
sg17
(lp32005
sg19
(lp32006
sg21
I0
sba(iArchitecture
Entity
p32007
(dp32008
g11
(lp32009
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$4'
p32010
sg15
(lp32011
sg17
(lp32012
sg19
(lp32013
sg21
I0
sba(iArchitecture
Entity
p32014
(dp32015
g11
(lp32016
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$5'
p32017
sg15
(lp32018
sg17
(lp32019
sg19
(lp32020
sg21
I0
sba(iArchitecture
Entity
p32021
(dp32022
g11
(lp32023
sg13
S'com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys$6'
p32024
sg15
(lp32025
sg17
(lp32026
sg19
(lp32027
sg21
I0
sba(iArchitecture
Entity
p32028
(dp32029
g11
(lp32030
sg13
S'com.google.common.collect.MultimapBuilder$SetMultimapBuilder'
p32031
sg15
(lp32032
sg17
(lp32033
sg19
(lp32034
sg21
I0
sba(iArchitecture
Entity
p32035
(dp32036
g11
(lp32037
sg13
S'com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder'
p32038
sg15
(lp32039
sg17
(lp32040
sg19
(lp32041
sg21
I0
sba(iArchitecture
Entity
p32042
(dp32043
g11
(lp32044
sg13
S'com.google.common.collect.MultimapBuilder$TreeSetSupplier'
p32045
sg15
(lp32046
sg17
(lp32047
sg19
(lp32048
sg21
I0
sba(iArchitecture
Entity
p32049
(dp32050
g11
(lp32051
sg13
S'com.google.common.collect.Multimaps'
p32052
sg15
(lp32053
sg17
(lp32054
sg19
(lp32055
sg21
I0
sba(iArchitecture
Entity
p32056
(dp32057
g11
(lp32058
sg13
S'com.google.common.collect.Multimaps$AsMap'
p32059
sg15
(lp32060
sg17
(lp32061
sg19
(lp32062
sg21
I0
sba(iArchitecture
Entity
p32063
(dp32064
g11
(lp32065
sg13
S'com.google.common.collect.Multimaps$AsMap$EntrySet'
p32066
sg15
(lp32067
sg17
(lp32068
sg19
(lp32069
sg21
I0
sba(iArchitecture
Entity
p32070
(dp32071
g11
(lp32072
sg13
S'com.google.common.collect.Multimaps$AsMap$EntrySet$1'
p32073
sg15
(lp32074
sg17
(lp32075
sg19
(lp32076
sg21
I0
sba(iArchitecture
Entity
p32077
(dp32078
g11
(lp32079
sg13
S'com.google.common.collect.Multimaps$CustomListMultimap'
p32080
sg15
(lp32081
sg17
(lp32082
sg19
(lp32083
sg21
I0
sba(iArchitecture
Entity
p32084
(dp32085
g11
(lp32086
sg13
S'com.google.common.collect.Multimaps$CustomMultimap'
p32087
sg15
(lp32088
sg17
(lp32089
sg19
(lp32090
sg21
I0
sba(iArchitecture
Entity
p32091
(dp32092
g11
(lp32093
sg13
S'com.google.common.collect.Multimaps$CustomSetMultimap'
p32094
sg15
(lp32095
sg17
(lp32096
sg19
(lp32097
sg21
I0
sba(iArchitecture
Entity
p32098
(dp32099
g11
(lp32100
sg13
S'com.google.common.collect.Multimaps$CustomSortedSetMultimap'
p32101
sg15
(lp32102
sg17
(lp32103
sg19
(lp32104
sg21
I0
sba(iArchitecture
Entity
p32105
(dp32106
g11
(lp32107
sg13
S'com.google.common.collect.Multimaps$Entries'
p32108
sg15
(lp32109
sg17
(lp32110
sg19
(lp32111
sg21
I0
sba(iArchitecture
Entity
p32112
(dp32113
g11
(lp32114
sg13
S'com.google.common.collect.Multimaps$Keys'
p32115
sg15
(lp32116
sg17
(lp32117
sg19
(lp32118
sg21
I0
sba(iArchitecture
Entity
p32119
(dp32120
g11
(lp32121
sg13
S'com.google.common.collect.Multimaps$Keys$1'
p32122
sg15
(lp32123
sg17
(lp32124
sg19
(lp32125
sg21
I0
sba(iArchitecture
Entity
p32126
(dp32127
g11
(lp32128
sg13
S'com.google.common.collect.Multimaps$Keys$1$1'
p32129
sg15
(lp32130
sg17
(lp32131
sg19
(lp32132
sg21
I0
sba(iArchitecture
Entity
p32133
(dp32134
g11
(lp32135
sg13
S'com.google.common.collect.Multimaps$Keys$KeysEntrySet'
p32136
sg15
(lp32137
sg17
(lp32138
sg19
(lp32139
sg21
I0
sba(iArchitecture
Entity
p32140
(dp32141
g11
(lp32142
sg13
S'com.google.common.collect.Multimaps$MapMultimap'
p32143
sg15
(lp32144
sg17
(lp32145
sg19
(lp32146
sg21
I0
sba(iArchitecture
Entity
p32147
(dp32148
g11
(lp32149
sg13
S'com.google.common.collect.Multimaps$MapMultimap$1'
p32150
sg15
(lp32151
sg17
(lp32152
sg19
(lp32153
sg21
I0
sba(iArchitecture
Entity
p32154
(dp32155
g11
(lp32156
sg13
S'com.google.common.collect.Multimaps$MapMultimap$1$1'
p32157
sg15
(lp32158
sg17
(lp32159
sg19
(lp32160
sg21
I0
sba(iArchitecture
Entity
p32161
(dp32162
g11
(lp32163
sg13
S'com.google.common.collect.Multimaps$TransformedEntriesListMultimap'
p32164
sg15
(lp32165
sg17
(lp32166
sg19
(lp32167
sg21
I0
sba(iArchitecture
Entity
p32168
(dp32169
g11
(lp32170
sg13
S'com.google.common.collect.Multimaps$TransformedEntriesMultimap'
p32171
sg15
(lp32172
sg17
(lp32173
sg19
(lp32174
sg21
I0
sba(iArchitecture
Entity
p32175
(dp32176
g11
(lp32177
sg13
S'com.google.common.collect.Multimaps$TransformedEntriesMultimap$1'
p32178
sg15
(lp32179
sg17
(lp32180
sg19
(lp32181
sg21
I0
sba(iArchitecture
Entity
p32182
(dp32183
g11
(lp32184
sg13
S'com.google.common.collect.Multimaps$UnmodifiableListMultimap'
p32185
sg15
(lp32186
sg17
(lp32187
sg19
(lp32188
sg21
I0
sba(iArchitecture
Entity
p32189
(dp32190
g11
(lp32191
sg13
S'com.google.common.collect.Multimaps$UnmodifiableMultimap'
p32192
sg15
(lp32193
sg17
(lp32194
sg19
(lp32195
sg21
I0
sba(iArchitecture
Entity
p32196
(dp32197
g11
(lp32198
sg13
S'com.google.common.collect.Multimaps$UnmodifiableMultimap$1'
p32199
sg15
(lp32200
sg17
(lp32201
sg19
(lp32202
sg21
I0
sba(iArchitecture
Entity
p32203
(dp32204
g11
(lp32205
sg13
S'com.google.common.collect.Multimaps$UnmodifiableSetMultimap'
p32206
sg15
(lp32207
sg17
(lp32208
sg19
(lp32209
sg21
I0
sba(iArchitecture
Entity
p32210
(dp32211
g11
(lp32212
sg13
S'com.google.common.collect.Multimaps$UnmodifiableSortedSetMultimap'
p32213
sg15
(lp32214
sg17
(lp32215
sg19
(lp32216
sg21
I0
sba(iArchitecture
Entity
p32217
(dp32218
g11
(lp32219
sg13
S'com.google.common.collect.Multiset'
p32220
sg15
(lp32221
sg17
(lp32222
sg19
(lp32223
sg21
I0
sba(iArchitecture
Entity
p32224
(dp32225
g11
(lp32226
sg13
S'com.google.common.collect.Multiset$Entry'
p32227
sg15
(lp32228
sg17
(lp32229
sg19
(lp32230
sg21
I0
sba(iArchitecture
Entity
p32231
(dp32232
g11
(lp32233
sg13
S'com.google.common.collect.Multisets'
p32234
sg15
(lp32235
sg17
(lp32236
sg19
(lp32237
sg21
I0
sba(iArchitecture
Entity
p32238
(dp32239
g11
(lp32240
sg13
S'com.google.common.collect.Multisets$1'
p32241
sg15
(lp32242
sg17
(lp32243
sg19
(lp32244
sg21
I0
sba(iArchitecture
Entity
p32245
(dp32246
g11
(lp32247
sg13
S'com.google.common.collect.Multisets$1$1'
p32248
sg15
(lp32249
sg17
(lp32250
sg19
(lp32251
sg21
I0
sba(iArchitecture
Entity
p32252
(dp32253
g11
(lp32254
sg13
S'com.google.common.collect.Multisets$2'
p32255
sg15
(lp32256
sg17
(lp32257
sg19
(lp32258
sg21
I0
sba(iArchitecture
Entity
p32259
(dp32260
g11
(lp32261
sg13
S'com.google.common.collect.Multisets$2$1'
p32262
sg15
(lp32263
sg17
(lp32264
sg19
(lp32265
sg21
I0
sba(iArchitecture
Entity
p32266
(dp32267
g11
(lp32268
sg13
S'com.google.common.collect.Multisets$3'
p32269
sg15
(lp32270
sg17
(lp32271
sg19
(lp32272
sg21
I0
sba(iArchitecture
Entity
p32273
(dp32274
g11
(lp32275
sg13
S'com.google.common.collect.Multisets$3$1'
p32276
sg15
(lp32277
sg17
(lp32278
sg19
(lp32279
sg21
I0
sba(iArchitecture
Entity
p32280
(dp32281
g11
(lp32282
sg13
S'com.google.common.collect.Multisets$4'
p32283
sg15
(lp32284
sg17
(lp32285
sg19
(lp32286
sg21
I0
sba(iArchitecture
Entity
p32287
(dp32288
g11
(lp32289
sg13
S'com.google.common.collect.Multisets$4$1'
p32290
sg15
(lp32291
sg17
(lp32292
sg19
(lp32293
sg21
I0
sba(iArchitecture
Entity
p32294
(dp32295
g11
(lp32296
sg13
S'com.google.common.collect.Multisets$AbstractEntry'
p32297
sg15
(lp32298
sg17
(lp32299
sg19
(lp32300
sg21
I0
sba(iArchitecture
Entity
p32301
(dp32302
g11
(lp32303
sg13
S'com.google.common.collect.Multisets$DecreasingCount'
p32304
sg15
(lp32305
sg17
(lp32306
sg19
(lp32307
sg21
I0
sba(iArchitecture
Entity
p32308
(dp32309
g11
(lp32310
sg13
S'com.google.common.collect.Multisets$ElementSet'
p32311
sg15
(lp32312
sg17
(lp32313
sg19
(lp32314
sg21
I0
sba(iArchitecture
Entity
p32315
(dp32316
g11
(lp32317
sg13
S'com.google.common.collect.Multisets$ElementSet$1'
p32318
sg15
(lp32319
sg17
(lp32320
sg19
(lp32321
sg21
I0
sba(iArchitecture
Entity
p32322
(dp32323
g11
(lp32324
sg13
S'com.google.common.collect.Multisets$EntrySet'
p32325
sg15
(lp32326
sg17
(lp32327
sg19
(lp32328
sg21
I0
sba(iArchitecture
Entity
p32329
(dp32330
g11
(lp32331
sg13
S'com.google.common.collect.Multisets$FilteredMultiset'
p32332
sg15
(lp32333
sg17
(lp32334
sg19
(lp32335
sg21
I0
sba(iArchitecture
Entity
p32336
(dp32337
g11
(lp32338
sg13
S'com.google.common.collect.Multisets$FilteredMultiset$1'
p32339
sg15
(lp32340
sg17
(lp32341
sg19
(lp32342
sg21
I0
sba(iArchitecture
Entity
p32343
(dp32344
g11
(lp32345
sg13
S'com.google.common.collect.Multisets$ImmutableEntry'
p32346
sg15
(lp32347
sg17
(lp32348
sg19
(lp32349
sg21
I0
sba(iArchitecture
Entity
p32350
(dp32351
g11
(lp32352
sg13
S'com.google.common.collect.Multisets$MultisetIteratorImpl'
p32353
sg15
(lp32354
sg17
(lp32355
sg19
(lp32356
sg21
I0
sba(iArchitecture
Entity
p32357
(dp32358
g11
(lp32359
sg13
S'com.google.common.collect.Multisets$UnmodifiableMultiset'
p32360
sg15
(lp32361
sg17
(lp32362
sg19
(lp32363
sg21
I0
sba(iArchitecture
Entity
p32364
(dp32365
g11
(lp32366
sg13
S'com.google.common.collect.MultitransformedIterator'
p32367
sg15
(lp32368
sg17
(lp32369
sg19
(lp32370
sg21
I0
sba(iArchitecture
Entity
p32371
(dp32372
g11
(lp32373
sg13
S'com.google.common.collect.MutableClassToInstanceMap'
p32374
sg15
(lp32375
sg17
(lp32376
sg19
(lp32377
sg21
I0
sba(iArchitecture
Entity
p32378
(dp32379
g11
(lp32380
sg13
S'com.google.common.collect.MutableClassToInstanceMap$1'
p32381
sg15
(lp32382
sg17
(lp32383
sg19
(lp32384
sg21
I0
sba(iArchitecture
Entity
p32385
(dp32386
g11
(lp32387
sg13
S'com.google.common.collect.MutableClassToInstanceMap$2'
p32388
sg15
(lp32389
sg17
(lp32390
sg19
(lp32391
sg21
I0
sba(iArchitecture
Entity
p32392
(dp32393
g11
(lp32394
sg13
S'com.google.common.collect.MutableClassToInstanceMap$2$1'
p32395
sg15
(lp32396
sg17
(lp32397
sg19
(lp32398
sg21
I0
sba(iArchitecture
Entity
p32399
(dp32400
g11
(lp32401
sg13
S'com.google.common.collect.MutableClassToInstanceMap$SerializedForm'
p32402
sg15
(lp32403
sg17
(lp32404
sg19
(lp32405
sg21
I0
sba(iArchitecture
Entity
p32406
(dp32407
g11
(lp32408
sg13
S'com.google.common.collect.NaturalOrdering'
p32409
sg15
(lp32410
sg17
(lp32411
sg19
(lp32412
sg21
I0
sba(iArchitecture
Entity
p32413
(dp32414
g11
(lp32415
sg13
S'com.google.common.collect.NullsFirstOrdering'
p32416
sg15
(lp32417
sg17
(lp32418
sg19
(lp32419
sg21
I0
sba(iArchitecture
Entity
p32420
(dp32421
g11
(lp32422
sg13
S'com.google.common.collect.NullsLastOrdering'
p32423
sg15
(lp32424
sg17
(lp32425
sg19
(lp32426
sg21
I0
sba(iArchitecture
Entity
p32427
(dp32428
g11
(lp32429
sg13
S'com.google.common.collect.ObjectArrays'
p32430
sg15
(lp32431
sg17
(lp32432
sg19
(lp32433
sg21
I0
sba(iArchitecture
Entity
p32434
(dp32435
g11
(lp32436
sg13
S'com.google.common.collect.Ordering'
p32437
sg15
(lp32438
sg17
(lp32439
sg19
(lp32440
sg21
I0
sba(iArchitecture
Entity
p32441
(dp32442
g11
(lp32443
sg13
S'com.google.common.collect.Ordering$ArbitraryOrdering'
p32444
sg15
(lp32445
sg17
(lp32446
sg19
(lp32447
sg21
I0
sba(iArchitecture
Entity
p32448
(dp32449
g11
(lp32450
sg13
S'com.google.common.collect.Ordering$ArbitraryOrderingHolder'
p32451
sg15
(lp32452
sg17
(lp32453
sg19
(lp32454
sg21
I0
sba(iArchitecture
Entity
p32455
(dp32456
g11
(lp32457
sg13
S'com.google.common.collect.Ordering$IncomparableValueException'
p32458
sg15
(lp32459
sg17
(lp32460
sg19
(lp32461
sg21
I0
sba(iArchitecture
Entity
p32462
(dp32463
g11
(lp32464
sg13
S'com.google.common.collect.PeekingIterator'
p32465
sg15
(lp32466
sg17
(lp32467
sg19
(lp32468
sg21
I0
sba(iArchitecture
Entity
p32469
(dp32470
g11
(lp32471
sg13
S'com.google.common.collect.Platform'
p32472
sg15
(lp32473
sg17
(lp32474
sg19
(lp32475
sg21
I0
sba(iArchitecture
Entity
p32476
(dp32477
g11
(lp32478
sg13
S'com.google.common.collect.Range'
p32479
sg15
(lp32480
sg17
(lp32481
sg19
(lp32482
sg21
I0
sba(iArchitecture
Entity
p32483
(dp32484
g11
(lp32485
sg13
S'com.google.common.collect.Range$1'
p32486
sg15
(lp32487
sg17
(lp32488
sg19
(lp32489
sg21
I0
sba(iArchitecture
Entity
p32490
(dp32491
g11
(lp32492
sg13
S'com.google.common.collect.Range$2'
p32493
sg15
(lp32494
sg17
(lp32495
sg19
(lp32496
sg21
I0
sba(iArchitecture
Entity
p32497
(dp32498
g11
(lp32499
sg13
S'com.google.common.collect.Range$3'
p32500
sg15
(lp32501
sg17
(lp32502
sg19
(lp32503
sg21
I0
sba(iArchitecture
Entity
p32504
(dp32505
g11
(lp32506
sg13
S'com.google.common.collect.Range$RangeLexOrdering'
p32507
sg15
(lp32508
sg17
(lp32509
sg19
(lp32510
sg21
I0
sba(iArchitecture
Entity
p32511
(dp32512
g11
(lp32513
sg13
S'com.google.common.collect.RangeGwtSerializationDependencies'
p32514
sg15
(lp32515
sg17
(lp32516
sg19
(lp32517
sg21
I0
sba(iArchitecture
Entity
p32518
(dp32519
g11
(lp32520
sg13
S'com.google.common.collect.RangeMap'
p32521
sg15
(lp32522
sg17
(lp32523
sg19
(lp32524
sg21
I0
sba(iArchitecture
Entity
p32525
(dp32526
g11
(lp32527
sg13
S'com.google.common.collect.RangeSet'
p32528
sg15
(lp32529
sg17
(lp32530
sg19
(lp32531
sg21
I0
sba(iArchitecture
Entity
p32532
(dp32533
g11
(lp32534
sg13
S'com.google.common.collect.RegularContiguousSet'
p32535
sg15
(lp32536
sg17
(lp32537
sg19
(lp32538
sg21
I0
sba(iArchitecture
Entity
p32539
(dp32540
g11
(lp32541
sg13
S'com.google.common.collect.RegularContiguousSet$1'
p32542
sg15
(lp32543
sg17
(lp32544
sg19
(lp32545
sg21
I0
sba(iArchitecture
Entity
p32546
(dp32547
g11
(lp32548
sg13
S'com.google.common.collect.RegularContiguousSet$2'
p32549
sg15
(lp32550
sg17
(lp32551
sg19
(lp32552
sg21
I0
sba(iArchitecture
Entity
p32553
(dp32554
g11
(lp32555
sg13
S'com.google.common.collect.RegularContiguousSet$3'
p32556
sg15
(lp32557
sg17
(lp32558
sg19
(lp32559
sg21
I0
sba(iArchitecture
Entity
p32560
(dp32561
g11
(lp32562
sg13
S'com.google.common.collect.RegularContiguousSet$SerializedForm'
p32563
sg15
(lp32564
sg17
(lp32565
sg19
(lp32566
sg21
I0
sba(iArchitecture
Entity
p32567
(dp32568
g11
(lp32569
sg13
S'com.google.common.collect.RegularImmutableAsList'
p32570
sg15
(lp32571
sg17
(lp32572
sg19
(lp32573
sg21
I0
sba(iArchitecture
Entity
p32574
(dp32575
g11
(lp32576
sg13
S'com.google.common.collect.RegularImmutableBiMap'
p32577
sg15
(lp32578
sg17
(lp32579
sg19
(lp32580
sg21
I0
sba(iArchitecture
Entity
p32581
(dp32582
g11
(lp32583
sg13
S'com.google.common.collect.RegularImmutableBiMap$1'
p32584
sg15
(lp32585
sg17
(lp32586
sg19
(lp32587
sg21
I0
sba(iArchitecture
Entity
p32588
(dp32589
g11
(lp32590
sg13
S'com.google.common.collect.RegularImmutableBiMap$Inverse'
p32591
sg15
(lp32592
sg17
(lp32593
sg19
(lp32594
sg21
I0
sba(iArchitecture
Entity
p32595
(dp32596
g11
(lp32597
sg13
S'com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet'
p32598
sg15
(lp32599
sg17
(lp32600
sg19
(lp32601
sg21
I0
sba(iArchitecture
Entity
p32602
(dp32603
g11
(lp32604
sg13
S'com.google.common.collect.RegularImmutableBiMap$Inverse$InverseEntrySet$1'
p32605
sg15
(lp32606
sg17
(lp32607
sg19
(lp32608
sg21
I0
sba(iArchitecture
Entity
p32609
(dp32610
g11
(lp32611
sg13
S'com.google.common.collect.RegularImmutableBiMap$InverseSerializedForm'
p32612
sg15
(lp32613
sg17
(lp32614
sg19
(lp32615
sg21
I0
sba(iArchitecture
Entity
p32616
(dp32617
g11
(lp32618
sg13
S'com.google.common.collect.RegularImmutableList'
p32619
sg15
(lp32620
sg17
(lp32621
sg19
(lp32622
sg21
I0
sba(iArchitecture
Entity
p32623
(dp32624
g11
(lp32625
sg13
S'com.google.common.collect.RegularImmutableMap'
p32626
sg15
(lp32627
sg17
(lp32628
sg19
(lp32629
sg21
I0
sba(iArchitecture
Entity
p32630
(dp32631
g11
(lp32632
sg13
S'com.google.common.collect.RegularImmutableMap$KeySet'
p32633
sg15
(lp32634
sg17
(lp32635
sg19
(lp32636
sg21
I0
sba(iArchitecture
Entity
p32637
(dp32638
g11
(lp32639
sg13
S'com.google.common.collect.RegularImmutableMap$KeySet$SerializedForm'
p32640
sg15
(lp32641
sg17
(lp32642
sg19
(lp32643
sg21
I0
sba(iArchitecture
Entity
p32644
(dp32645
g11
(lp32646
sg13
S'com.google.common.collect.RegularImmutableMap$Values'
p32647
sg15
(lp32648
sg17
(lp32649
sg19
(lp32650
sg21
I0
sba(iArchitecture
Entity
p32651
(dp32652
g11
(lp32653
sg13
S'com.google.common.collect.RegularImmutableMap$Values$SerializedForm'
p32654
sg15
(lp32655
sg17
(lp32656
sg19
(lp32657
sg21
I0
sba(iArchitecture
Entity
p32658
(dp32659
g11
(lp32660
sg13
S'com.google.common.collect.RegularImmutableMultiset'
p32661
sg15
(lp32662
sg17
(lp32663
sg19
(lp32664
sg21
I0
sba(iArchitecture
Entity
p32665
(dp32666
g11
(lp32667
sg13
S'com.google.common.collect.RegularImmutableMultiset$1'
p32668
sg15
(lp32669
sg17
(lp32670
sg19
(lp32671
sg21
I0
sba(iArchitecture
Entity
p32672
(dp32673
g11
(lp32674
sg13
S'com.google.common.collect.RegularImmutableMultiset$ElementSet'
p32675
sg15
(lp32676
sg17
(lp32677
sg19
(lp32678
sg21
I0
sba(iArchitecture
Entity
p32679
(dp32680
g11
(lp32681
sg13
S'com.google.common.collect.RegularImmutableMultiset$NonTerminalEntry'
p32682
sg15
(lp32683
sg17
(lp32684
sg19
(lp32685
sg21
I0
sba(iArchitecture
Entity
p32686
(dp32687
g11
(lp32688
sg13
S'com.google.common.collect.RegularImmutableSet'
p32689
sg15
(lp32690
sg17
(lp32691
sg19
(lp32692
sg21
I0
sba(iArchitecture
Entity
p32693
(dp32694
g11
(lp32695
sg13
S'com.google.common.collect.RegularImmutableSortedMultiset'
p32696
sg15
(lp32697
sg17
(lp32698
sg19
(lp32699
sg21
I0
sba(iArchitecture
Entity
p32700
(dp32701
g11
(lp32702
sg13
S'com.google.common.collect.RegularImmutableSortedSet'
p32703
sg15
(lp32704
sg17
(lp32705
sg19
(lp32706
sg21
I0
sba(iArchitecture
Entity
p32707
(dp32708
g11
(lp32709
sg13
S'com.google.common.collect.RegularImmutableTable'
p32710
sg15
(lp32711
sg17
(lp32712
sg19
(lp32713
sg21
I0
sba(iArchitecture
Entity
p32714
(dp32715
g11
(lp32716
sg13
S'com.google.common.collect.RegularImmutableTable$1'
p32717
sg15
(lp32718
sg17
(lp32719
sg19
(lp32720
sg21
I0
sba(iArchitecture
Entity
p32721
(dp32722
g11
(lp32723
sg13
S'com.google.common.collect.RegularImmutableTable$CellSet'
p32724
sg15
(lp32725
sg17
(lp32726
sg19
(lp32727
sg21
I0
sba(iArchitecture
Entity
p32728
(dp32729
g11
(lp32730
sg13
S'com.google.common.collect.RegularImmutableTable$Values'
p32731
sg15
(lp32732
sg17
(lp32733
sg19
(lp32734
sg21
I0
sba(iArchitecture
Entity
p32735
(dp32736
g11
(lp32737
sg13
S'com.google.common.collect.ReverseNaturalOrdering'
p32738
sg15
(lp32739
sg17
(lp32740
sg19
(lp32741
sg21
I0
sba(iArchitecture
Entity
p32742
(dp32743
g11
(lp32744
sg13
S'com.google.common.collect.ReverseOrdering'
p32745
sg15
(lp32746
sg17
(lp32747
sg19
(lp32748
sg21
I0
sba(iArchitecture
Entity
p32749
(dp32750
g11
(lp32751
sg13
S'com.google.common.collect.RowSortedTable'
p32752
sg15
(lp32753
sg17
(lp32754
sg19
(lp32755
sg21
I0
sba(iArchitecture
Entity
p32756
(dp32757
g11
(lp32758
sg13
S'com.google.common.collect.Serialization'
p32759
sg15
(lp32760
sg17
(lp32761
sg19
(lp32762
sg21
I0
sba(iArchitecture
Entity
p32763
(dp32764
g11
(lp32765
sg13
S'com.google.common.collect.Serialization$1'
p32766
sg15
(lp32767
sg17
(lp32768
sg19
(lp32769
sg21
I0
sba(iArchitecture
Entity
p32770
(dp32771
g11
(lp32772
sg13
S'com.google.common.collect.Serialization$FieldSetter'
p32773
sg15
(lp32774
sg17
(lp32775
sg19
(lp32776
sg21
I0
sba(iArchitecture
Entity
p32777
(dp32778
g11
(lp32779
sg13
S'com.google.common.collect.SetMultimap'
p32780
sg15
(lp32781
sg17
(lp32782
sg19
(lp32783
sg21
I0
sba(iArchitecture
Entity
p32784
(dp32785
g11
(lp32786
sg13
S'com.google.common.collect.Sets'
p32787
sg15
(lp32788
sg17
(lp32789
sg19
(lp32790
sg21
I0
sba(iArchitecture
Entity
p32791
(dp32792
g11
(lp32793
sg13
S'com.google.common.collect.Sets$1'
p32794
sg15
(lp32795
sg17
(lp32796
sg19
(lp32797
sg21
I0
sba(iArchitecture
Entity
p32798
(dp32799
g11
(lp32800
sg13
S'com.google.common.collect.Sets$2'
p32801
sg15
(lp32802
sg17
(lp32803
sg19
(lp32804
sg21
I0
sba(iArchitecture
Entity
p32805
(dp32806
g11
(lp32807
sg13
S'com.google.common.collect.Sets$3'
p32808
sg15
(lp32809
sg17
(lp32810
sg19
(lp32811
sg21
I0
sba(iArchitecture
Entity
p32812
(dp32813
g11
(lp32814
sg13
S'com.google.common.collect.Sets$4'
p32815
sg15
(lp32816
sg17
(lp32817
sg19
(lp32818
sg21
I0
sba(iArchitecture
Entity
p32819
(dp32820
g11
(lp32821
sg13
S'com.google.common.collect.Sets$4$1'
p32822
sg15
(lp32823
sg17
(lp32824
sg19
(lp32825
sg21
I0
sba(iArchitecture
Entity
p32826
(dp32827
g11
(lp32828
sg13
S'com.google.common.collect.Sets$Accumulator'
p32829
sg15
(lp32830
sg17
(lp32831
sg19
(lp32832
sg21
I0
sba(iArchitecture
Entity
p32833
(dp32834
g11
(lp32835
sg13
S'com.google.common.collect.Sets$CartesianSet'
p32836
sg15
(lp32837
sg17
(lp32838
sg19
(lp32839
sg21
I0
sba(iArchitecture
Entity
p32840
(dp32841
g11
(lp32842
sg13
S'com.google.common.collect.Sets$CartesianSet$1'
p32843
sg15
(lp32844
sg17
(lp32845
sg19
(lp32846
sg21
I0
sba(iArchitecture
Entity
p32847
(dp32848
g11
(lp32849
sg13
S'com.google.common.collect.Sets$DescendingSet'
p32850
sg15
(lp32851
sg17
(lp32852
sg19
(lp32853
sg21
I0
sba(iArchitecture
Entity
p32854
(dp32855
g11
(lp32856
sg13
S'com.google.common.collect.Sets$FilteredNavigableSet'
p32857
sg15
(lp32858
sg17
(lp32859
sg19
(lp32860
sg21
I0
sba(iArchitecture
Entity
p32861
(dp32862
g11
(lp32863
sg13
S'com.google.common.collect.Sets$FilteredSet'
p32864
sg15
(lp32865
sg17
(lp32866
sg19
(lp32867
sg21
I0
sba(iArchitecture
Entity
p32868
(dp32869
g11
(lp32870
sg13
S'com.google.common.collect.Sets$FilteredSortedSet'
p32871
sg15
(lp32872
sg17
(lp32873
sg19
(lp32874
sg21
I0
sba(iArchitecture
Entity
p32875
(dp32876
g11
(lp32877
sg13
S'com.google.common.collect.Sets$ImprovedAbstractSet'
p32878
sg15
(lp32879
sg17
(lp32880
sg19
(lp32881
sg21
I0
sba(iArchitecture
Entity
p32882
(dp32883
g11
(lp32884
sg13
S'com.google.common.collect.Sets$PowerSet'
p32885
sg15
(lp32886
sg17
(lp32887
sg19
(lp32888
sg21
I0
sba(iArchitecture
Entity
p32889
(dp32890
g11
(lp32891
sg13
S'com.google.common.collect.Sets$PowerSet$1'
p32892
sg15
(lp32893
sg17
(lp32894
sg19
(lp32895
sg21
I0
sba(iArchitecture
Entity
p32896
(dp32897
g11
(lp32898
sg13
S'com.google.common.collect.Sets$SetView'
p32899
sg15
(lp32900
sg17
(lp32901
sg19
(lp32902
sg21
I0
sba(iArchitecture
Entity
p32903
(dp32904
g11
(lp32905
sg13
S'com.google.common.collect.Sets$SubSet'
p32906
sg15
(lp32907
sg17
(lp32908
sg19
(lp32909
sg21
I0
sba(iArchitecture
Entity
p32910
(dp32911
g11
(lp32912
sg13
S'com.google.common.collect.Sets$SubSet$1'
p32913
sg15
(lp32914
sg17
(lp32915
sg19
(lp32916
sg21
I0
sba(iArchitecture
Entity
p32917
(dp32918
g11
(lp32919
sg13
S'com.google.common.collect.Sets$UnmodifiableNavigableSet'
p32920
sg15
(lp32921
sg17
(lp32922
sg19
(lp32923
sg21
I0
sba(iArchitecture
Entity
p32924
(dp32925
g11
(lp32926
sg13
S'com.google.common.collect.SingletonImmutableBiMap'
p32927
sg15
(lp32928
sg17
(lp32929
sg19
(lp32930
sg21
I0
sba(iArchitecture
Entity
p32931
(dp32932
g11
(lp32933
sg13
S'com.google.common.collect.SingletonImmutableSet'
p32934
sg15
(lp32935
sg17
(lp32936
sg19
(lp32937
sg21
I0
sba(iArchitecture
Entity
p32938
(dp32939
g11
(lp32940
sg13
S'com.google.common.collect.SingletonImmutableTable'
p32941
sg15
(lp32942
sg17
(lp32943
sg19
(lp32944
sg21
I0
sba(iArchitecture
Entity
p32945
(dp32946
g11
(lp32947
sg13
S'com.google.common.collect.SortedIterable'
p32948
sg15
(lp32949
sg17
(lp32950
sg19
(lp32951
sg21
I0
sba(iArchitecture
Entity
p32952
(dp32953
g11
(lp32954
sg13
S'com.google.common.collect.SortedIterables'
p32955
sg15
(lp32956
sg17
(lp32957
sg19
(lp32958
sg21
I0
sba(iArchitecture
Entity
p32959
(dp32960
g11
(lp32961
sg13
S'com.google.common.collect.SortedLists'
p32962
sg15
(lp32963
sg17
(lp32964
sg19
(lp32965
sg21
I0
sba(iArchitecture
Entity
p32966
(dp32967
g11
(lp32968
sg13
S'com.google.common.collect.SortedLists$1'
p32969
sg15
(lp32970
sg17
(lp32971
sg19
(lp32972
sg21
I0
sba(iArchitecture
Entity
p32973
(dp32974
g11
(lp32975
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior'
p32976
sg15
(lp32977
sg17
(lp32978
sg19
(lp32979
sg21
I0
sba(iArchitecture
Entity
p32980
(dp32981
g11
(lp32982
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior$1'
p32983
sg15
(lp32984
sg17
(lp32985
sg19
(lp32986
sg21
I0
sba(iArchitecture
Entity
p32987
(dp32988
g11
(lp32989
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior$2'
p32990
sg15
(lp32991
sg17
(lp32992
sg19
(lp32993
sg21
I0
sba(iArchitecture
Entity
p32994
(dp32995
g11
(lp32996
sg13
S'com.google.common.collect.SortedLists$KeyAbsentBehavior$3'
p32997
sg15
(lp32998
sg17
(lp32999
sg19
(lp33000
sg21
I0
sba(iArchitecture
Entity
p33001
(dp33002
g11
(lp33003
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior'
p33004
sg15
(lp33005
sg17
(lp33006
sg19
(lp33007
sg21
I0
sba(iArchitecture
Entity
p33008
(dp33009
g11
(lp33010
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$1'
p33011
sg15
(lp33012
sg17
(lp33013
sg19
(lp33014
sg21
I0
sba(iArchitecture
Entity
p33015
(dp33016
g11
(lp33017
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$2'
p33018
sg15
(lp33019
sg17
(lp33020
sg19
(lp33021
sg21
I0
sba(iArchitecture
Entity
p33022
(dp33023
g11
(lp33024
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$3'
p33025
sg15
(lp33026
sg17
(lp33027
sg19
(lp33028
sg21
I0
sba(iArchitecture
Entity
p33029
(dp33030
g11
(lp33031
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$4'
p33032
sg15
(lp33033
sg17
(lp33034
sg19
(lp33035
sg21
I0
sba(iArchitecture
Entity
p33036
(dp33037
g11
(lp33038
sg13
S'com.google.common.collect.SortedLists$KeyPresentBehavior$5'
p33039
sg15
(lp33040
sg17
(lp33041
sg19
(lp33042
sg21
I0
sba(iArchitecture
Entity
p33043
(dp33044
g11
(lp33045
sg13
S'com.google.common.collect.SortedMapDifference'
p33046
sg15
(lp33047
sg17
(lp33048
sg19
(lp33049
sg21
I0
sba(iArchitecture
Entity
p33050
(dp33051
g11
(lp33052
sg13
S'com.google.common.collect.SortedMultiset'
p33053
sg15
(lp33054
sg17
(lp33055
sg19
(lp33056
sg21
I0
sba(iArchitecture
Entity
p33057
(dp33058
g11
(lp33059
sg13
S'com.google.common.collect.SortedMultisetBridge'
p33060
sg15
(lp33061
sg17
(lp33062
sg19
(lp33063
sg21
I0
sba(iArchitecture
Entity
p33064
(dp33065
g11
(lp33066
sg13
S'com.google.common.collect.SortedMultisets'
p33067
sg15
(lp33068
sg17
(lp33069
sg19
(lp33070
sg21
I0
sba(iArchitecture
Entity
p33071
(dp33072
g11
(lp33073
sg13
S'com.google.common.collect.SortedMultisets$ElementSet'
p33074
sg15
(lp33075
sg17
(lp33076
sg19
(lp33077
sg21
I0
sba(iArchitecture
Entity
p33078
(dp33079
g11
(lp33080
sg13
S'com.google.common.collect.SortedMultisets$NavigableElementSet'
p33081
sg15
(lp33082
sg17
(lp33083
sg19
(lp33084
sg21
I0
sba(iArchitecture
Entity
p33085
(dp33086
g11
(lp33087
sg13
S'com.google.common.collect.SortedSetMultimap'
p33088
sg15
(lp33089
sg17
(lp33090
sg19
(lp33091
sg21
I0
sba(iArchitecture
Entity
p33092
(dp33093
g11
(lp33094
sg13
S'com.google.common.collect.SparseImmutableTable'
p33095
sg15
(lp33096
sg17
(lp33097
sg19
(lp33098
sg21
I0
sba(iArchitecture
Entity
p33099
(dp33100
g11
(lp33101
sg13
S'com.google.common.collect.StandardRowSortedTable'
p33102
sg15
(lp33103
sg17
(lp33104
sg19
(lp33105
sg21
I0
sba(iArchitecture
Entity
p33106
(dp33107
g11
(lp33108
sg13
S'com.google.common.collect.StandardRowSortedTable$1'
p33109
sg15
(lp33110
sg17
(lp33111
sg19
(lp33112
sg21
I0
sba(iArchitecture
Entity
p33113
(dp33114
g11
(lp33115
sg13
S'com.google.common.collect.StandardRowSortedTable$RowSortedMap'
p33116
sg15
(lp33117
sg17
(lp33118
sg19
(lp33119
sg21
I0
sba(iArchitecture
Entity
p33120
(dp33121
g11
(lp33122
sg13
S'com.google.common.collect.StandardTable'
p33123
sg15
(lp33124
sg17
(lp33125
sg19
(lp33126
sg21
I0
sba(iArchitecture
Entity
p33127
(dp33128
g11
(lp33129
sg13
S'com.google.common.collect.StandardTable$1'
p33130
sg15
(lp33131
sg17
(lp33132
sg19
(lp33133
sg21
I0
sba(iArchitecture
Entity
p33134
(dp33135
g11
(lp33136
sg13
S'com.google.common.collect.StandardTable$CellIterator'
p33137
sg15
(lp33138
sg17
(lp33139
sg19
(lp33140
sg21
I0
sba(iArchitecture
Entity
p33141
(dp33142
g11
(lp33143
sg13
S'com.google.common.collect.StandardTable$Column'
p33144
sg15
(lp33145
sg17
(lp33146
sg19
(lp33147
sg21
I0
sba(iArchitecture
Entity
p33148
(dp33149
g11
(lp33150
sg13
S'com.google.common.collect.StandardTable$Column$EntrySet'
p33151
sg15
(lp33152
sg17
(lp33153
sg19
(lp33154
sg21
I0
sba(iArchitecture
Entity
p33155
(dp33156
g11
(lp33157
sg13
S'com.google.common.collect.StandardTable$Column$EntrySetIterator'
p33158
sg15
(lp33159
sg17
(lp33160
sg19
(lp33161
sg21
I0
sba(iArchitecture
Entity
p33162
(dp33163
g11
(lp33164
sg13
S'com.google.common.collect.StandardTable$Column$EntrySetIterator$1EntryImpl'
p33165
sg15
(lp33166
sg17
(lp33167
sg19
(lp33168
sg21
I0
sba(iArchitecture
Entity
p33169
(dp33170
g11
(lp33171
sg13
S'com.google.common.collect.StandardTable$Column$KeySet'
p33172
sg15
(lp33173
sg17
(lp33174
sg19
(lp33175
sg21
I0
sba(iArchitecture
Entity
p33176
(dp33177
g11
(lp33178
sg13
S'com.google.common.collect.StandardTable$Column$Values'
p33179
sg15
(lp33180
sg17
(lp33181
sg19
(lp33182
sg21
I0
sba(iArchitecture
Entity
p33183
(dp33184
g11
(lp33185
sg13
S'com.google.common.collect.StandardTable$ColumnKeyIterator'
p33186
sg15
(lp33187
sg17
(lp33188
sg19
(lp33189
sg21
I0
sba(iArchitecture
Entity
p33190
(dp33191
g11
(lp33192
sg13
S'com.google.common.collect.StandardTable$ColumnKeySet'
p33193
sg15
(lp33194
sg17
(lp33195
sg19
(lp33196
sg21
I0
sba(iArchitecture
Entity
p33197
(dp33198
g11
(lp33199
sg13
S'com.google.common.collect.StandardTable$ColumnMap'
p33200
sg15
(lp33201
sg17
(lp33202
sg19
(lp33203
sg21
I0
sba(iArchitecture
Entity
p33204
(dp33205
g11
(lp33206
sg13
S'com.google.common.collect.StandardTable$ColumnMap$ColumnMapEntrySet'
p33207
sg15
(lp33208
sg17
(lp33209
sg19
(lp33210
sg21
I0
sba(iArchitecture
Entity
p33211
(dp33212
g11
(lp33213
sg13
S'com.google.common.collect.StandardTable$ColumnMap$ColumnMapEntrySet$1'
p33214
sg15
(lp33215
sg17
(lp33216
sg19
(lp33217
sg21
I0
sba(iArchitecture
Entity
p33218
(dp33219
g11
(lp33220
sg13
S'com.google.common.collect.StandardTable$ColumnMap$ColumnMapValues'
p33221
sg15
(lp33222
sg17
(lp33223
sg19
(lp33224
sg21
I0
sba(iArchitecture
Entity
p33225
(dp33226
g11
(lp33227
sg13
S'com.google.common.collect.StandardTable$Row'
p33228
sg15
(lp33229
sg17
(lp33230
sg19
(lp33231
sg21
I0
sba(iArchitecture
Entity
p33232
(dp33233
g11
(lp33234
sg13
S'com.google.common.collect.StandardTable$Row$1'
p33235
sg15
(lp33236
sg17
(lp33237
sg19
(lp33238
sg21
I0
sba(iArchitecture
Entity
p33239
(dp33240
g11
(lp33241
sg13
S'com.google.common.collect.StandardTable$Row$2'
p33242
sg15
(lp33243
sg17
(lp33244
sg19
(lp33245
sg21
I0
sba(iArchitecture
Entity
p33246
(dp33247
g11
(lp33248
sg13
S'com.google.common.collect.StandardTable$RowMap'
p33249
sg15
(lp33250
sg17
(lp33251
sg19
(lp33252
sg21
I0
sba(iArchitecture
Entity
p33253
(dp33254
g11
(lp33255
sg13
S'com.google.common.collect.StandardTable$RowMap$EntrySet'
p33256
sg15
(lp33257
sg17
(lp33258
sg19
(lp33259
sg21
I0
sba(iArchitecture
Entity
p33260
(dp33261
g11
(lp33262
sg13
S'com.google.common.collect.StandardTable$RowMap$EntrySet$1'
p33263
sg15
(lp33264
sg17
(lp33265
sg19
(lp33266
sg21
I0
sba(iArchitecture
Entity
p33267
(dp33268
g11
(lp33269
sg13
S'com.google.common.collect.StandardTable$TableSet'
p33270
sg15
(lp33271
sg17
(lp33272
sg19
(lp33273
sg21
I0
sba(iArchitecture
Entity
p33274
(dp33275
g11
(lp33276
sg13
S'com.google.common.collect.Streams'
p33277
sg15
(lp33278
sg17
(lp33279
sg19
(lp33280
sg21
I0
sba(iArchitecture
Entity
p33281
(dp33282
g11
(lp33283
sg13
S'com.google.common.collect.Streams$1'
p33284
sg15
(lp33285
sg17
(lp33286
sg19
(lp33287
sg21
I0
sba(iArchitecture
Entity
p33288
(dp33289
g11
(lp33290
sg13
S'com.google.common.collect.Streams$1OptionalState'
p33291
sg15
(lp33292
sg17
(lp33293
sg19
(lp33294
sg21
I0
sba(iArchitecture
Entity
p33295
(dp33296
g11
(lp33297
sg13
S'com.google.common.collect.Streams$1Splitr'
p33298
sg15
(lp33299
sg17
(lp33300
sg19
(lp33301
sg21
I0
sba(iArchitecture
Entity
p33302
(dp33303
g11
(lp33304
sg13
S'com.google.common.collect.Streams$2'
p33305
sg15
(lp33306
sg17
(lp33307
sg19
(lp33308
sg21
I0
sba(iArchitecture
Entity
p33309
(dp33310
g11
(lp33311
sg13
S'com.google.common.collect.Streams$2Splitr'
p33312
sg15
(lp33313
sg17
(lp33314
sg19
(lp33315
sg21
I0
sba(iArchitecture
Entity
p33316
(dp33317
g11
(lp33318
sg13
S'com.google.common.collect.Streams$3'
p33319
sg15
(lp33320
sg17
(lp33321
sg19
(lp33322
sg21
I0
sba(iArchitecture
Entity
p33323
(dp33324
g11
(lp33325
sg13
S'com.google.common.collect.Streams$3Splitr'
p33326
sg15
(lp33327
sg17
(lp33328
sg19
(lp33329
sg21
I0
sba(iArchitecture
Entity
p33330
(dp33331
g11
(lp33332
sg13
S'com.google.common.collect.Streams$4'
p33333
sg15
(lp33334
sg17
(lp33335
sg19
(lp33336
sg21
I0
sba(iArchitecture
Entity
p33337
(dp33338
g11
(lp33339
sg13
S'com.google.common.collect.Streams$4Splitr'
p33340
sg15
(lp33341
sg17
(lp33342
sg19
(lp33343
sg21
I0
sba(iArchitecture
Entity
p33344
(dp33345
g11
(lp33346
sg13
S'com.google.common.collect.Streams$5'
p33347
sg15
(lp33348
sg17
(lp33349
sg19
(lp33350
sg21
I0
sba(iArchitecture
Entity
p33351
(dp33352
g11
(lp33353
sg13
S'com.google.common.collect.Streams$DoubleFunctionWithIndex'
p33354
sg15
(lp33355
sg17
(lp33356
sg19
(lp33357
sg21
I0
sba(iArchitecture
Entity
p33358
(dp33359
g11
(lp33360
sg13
S'com.google.common.collect.Streams$FunctionWithIndex'
p33361
sg15
(lp33362
sg17
(lp33363
sg19
(lp33364
sg21
I0
sba(iArchitecture
Entity
p33365
(dp33366
g11
(lp33367
sg13
S'com.google.common.collect.Streams$IntFunctionWithIndex'
p33368
sg15
(lp33369
sg17
(lp33370
sg19
(lp33371
sg21
I0
sba(iArchitecture
Entity
p33372
(dp33373
g11
(lp33374
sg13
S'com.google.common.collect.Streams$LongFunctionWithIndex'
p33375
sg15
(lp33376
sg17
(lp33377
sg19
(lp33378
sg21
I0
sba(iArchitecture
Entity
p33379
(dp33380
g11
(lp33381
sg13
S'com.google.common.collect.Streams$MapWithIndexSpliterator'
p33382
sg15
(lp33383
sg17
(lp33384
sg19
(lp33385
sg21
I0
sba(iArchitecture
Entity
p33386
(dp33387
g11
(lp33388
sg13
S'com.google.common.collect.Streams$TemporaryPair'
p33389
sg15
(lp33390
sg17
(lp33391
sg19
(lp33392
sg21
I0
sba(iArchitecture
Entity
p33393
(dp33394
g11
(lp33395
sg13
S'com.google.common.collect.Synchronized'
p33396
sg15
(lp33397
sg17
(lp33398
sg19
(lp33399
sg21
I0
sba(iArchitecture
Entity
p33400
(dp33401
g11
(lp33402
sg13
S'com.google.common.collect.Synchronized$1'
p33403
sg15
(lp33404
sg17
(lp33405
sg19
(lp33406
sg21
I0
sba(iArchitecture
Entity
p33407
(dp33408
g11
(lp33409
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMap'
p33410
sg15
(lp33411
sg17
(lp33412
sg19
(lp33413
sg21
I0
sba(iArchitecture
Entity
p33414
(dp33415
g11
(lp33416
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapEntries'
p33417
sg15
(lp33418
sg17
(lp33419
sg19
(lp33420
sg21
I0
sba(iArchitecture
Entity
p33421
(dp33422
g11
(lp33423
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapEntries$1'
p33424
sg15
(lp33425
sg17
(lp33426
sg19
(lp33427
sg21
I0
sba(iArchitecture
Entity
p33428
(dp33429
g11
(lp33430
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapEntries$1$1'
p33431
sg15
(lp33432
sg17
(lp33433
sg19
(lp33434
sg21
I0
sba(iArchitecture
Entity
p33435
(dp33436
g11
(lp33437
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapValues'
p33438
sg15
(lp33439
sg17
(lp33440
sg19
(lp33441
sg21
I0
sba(iArchitecture
Entity
p33442
(dp33443
g11
(lp33444
sg13
S'com.google.common.collect.Synchronized$SynchronizedAsMapValues$1'
p33445
sg15
(lp33446
sg17
(lp33447
sg19
(lp33448
sg21
I0
sba(iArchitecture
Entity
p33449
(dp33450
g11
(lp33451
sg13
S'com.google.common.collect.Synchronized$SynchronizedBiMap'
p33452
sg15
(lp33453
sg17
(lp33454
sg19
(lp33455
sg21
I0
sba(iArchitecture
Entity
p33456
(dp33457
g11
(lp33458
sg13
S'com.google.common.collect.Synchronized$SynchronizedCollection'
p33459
sg15
(lp33460
sg17
(lp33461
sg19
(lp33462
sg21
I0
sba(iArchitecture
Entity
p33463
(dp33464
g11
(lp33465
sg13
S'com.google.common.collect.Synchronized$SynchronizedDeque'
p33466
sg15
(lp33467
sg17
(lp33468
sg19
(lp33469
sg21
I0
sba(iArchitecture
Entity
p33470
(dp33471
g11
(lp33472
sg13
S'com.google.common.collect.Synchronized$SynchronizedEntry'
p33473
sg15
(lp33474
sg17
(lp33475
sg19
(lp33476
sg21
I0
sba(iArchitecture
Entity
p33477
(dp33478
g11
(lp33479
sg13
S'com.google.common.collect.Synchronized$SynchronizedList'
p33480
sg15
(lp33481
sg17
(lp33482
sg19
(lp33483
sg21
I0
sba(iArchitecture
Entity
p33484
(dp33485
g11
(lp33486
sg13
S'com.google.common.collect.Synchronized$SynchronizedListMultimap'
p33487
sg15
(lp33488
sg17
(lp33489
sg19
(lp33490
sg21
I0
sba(iArchitecture
Entity
p33491
(dp33492
g11
(lp33493
sg13
S'com.google.common.collect.Synchronized$SynchronizedMap'
p33494
sg15
(lp33495
sg17
(lp33496
sg19
(lp33497
sg21
I0
sba(iArchitecture
Entity
p33498
(dp33499
g11
(lp33500
sg13
S'com.google.common.collect.Synchronized$SynchronizedMultimap'
p33501
sg15
(lp33502
sg17
(lp33503
sg19
(lp33504
sg21
I0
sba(iArchitecture
Entity
p33505
(dp33506
g11
(lp33507
sg13
S'com.google.common.collect.Synchronized$SynchronizedMultiset'
p33508
sg15
(lp33509
sg17
(lp33510
sg19
(lp33511
sg21
I0
sba(iArchitecture
Entity
p33512
(dp33513
g11
(lp33514
sg13
S'com.google.common.collect.Synchronized$SynchronizedNavigableMap'
p33515
sg15
(lp33516
sg17
(lp33517
sg19
(lp33518
sg21
I0
sba(iArchitecture
Entity
p33519
(dp33520
g11
(lp33521
sg13
S'com.google.common.collect.Synchronized$SynchronizedNavigableSet'
p33522
sg15
(lp33523
sg17
(lp33524
sg19
(lp33525
sg21
I0
sba(iArchitecture
Entity
p33526
(dp33527
g11
(lp33528
sg13
S'com.google.common.collect.Synchronized$SynchronizedObject'
p33529
sg15
(lp33530
sg17
(lp33531
sg19
(lp33532
sg21
I0
sba(iArchitecture
Entity
p33533
(dp33534
g11
(lp33535
sg13
S'com.google.common.collect.Synchronized$SynchronizedQueue'
p33536
sg15
(lp33537
sg17
(lp33538
sg19
(lp33539
sg21
I0
sba(iArchitecture
Entity
p33540
(dp33541
g11
(lp33542
sg13
S'com.google.common.collect.Synchronized$SynchronizedRandomAccessList'
p33543
sg15
(lp33544
sg17
(lp33545
sg19
(lp33546
sg21
I0
sba(iArchitecture
Entity
p33547
(dp33548
g11
(lp33549
sg13
S'com.google.common.collect.Synchronized$SynchronizedSet'
p33550
sg15
(lp33551
sg17
(lp33552
sg19
(lp33553
sg21
I0
sba(iArchitecture
Entity
p33554
(dp33555
g11
(lp33556
sg13
S'com.google.common.collect.Synchronized$SynchronizedSetMultimap'
p33557
sg15
(lp33558
sg17
(lp33559
sg19
(lp33560
sg21
I0
sba(iArchitecture
Entity
p33561
(dp33562
g11
(lp33563
sg13
S'com.google.common.collect.Synchronized$SynchronizedSortedMap'
p33564
sg15
(lp33565
sg17
(lp33566
sg19
(lp33567
sg21
I0
sba(iArchitecture
Entity
p33568
(dp33569
g11
(lp33570
sg13
S'com.google.common.collect.Synchronized$SynchronizedSortedSet'
p33571
sg15
(lp33572
sg17
(lp33573
sg19
(lp33574
sg21
I0
sba(iArchitecture
Entity
p33575
(dp33576
g11
(lp33577
sg13
S'com.google.common.collect.Synchronized$SynchronizedSortedSetMultimap'
p33578
sg15
(lp33579
sg17
(lp33580
sg19
(lp33581
sg21
I0
sba(iArchitecture
Entity
p33582
(dp33583
g11
(lp33584
sg13
S'com.google.common.collect.Synchronized$SynchronizedTable'
p33585
sg15
(lp33586
sg17
(lp33587
sg19
(lp33588
sg21
I0
sba(iArchitecture
Entity
p33589
(dp33590
g11
(lp33591
sg13
S'com.google.common.collect.Synchronized$SynchronizedTable$1'
p33592
sg15
(lp33593
sg17
(lp33594
sg19
(lp33595
sg21
I0
sba(iArchitecture
Entity
p33596
(dp33597
g11
(lp33598
sg13
S'com.google.common.collect.Synchronized$SynchronizedTable$2'
p33599
sg15
(lp33600
sg17
(lp33601
sg19
(lp33602
sg21
I0
sba(iArchitecture
Entity
p33603
(dp33604
g11
(lp33605
sg13
S'com.google.common.collect.Table'
p33606
sg15
(lp33607
sg17
(lp33608
sg19
(lp33609
sg21
I0
sba(iArchitecture
Entity
p33610
(dp33611
g11
(lp33612
sg13
S'com.google.common.collect.Table$Cell'
p33613
sg15
(lp33614
sg17
(lp33615
sg19
(lp33616
sg21
I0
sba(iArchitecture
Entity
p33617
(dp33618
g11
(lp33619
sg13
S'com.google.common.collect.Tables'
p33620
sg15
(lp33621
sg17
(lp33622
sg19
(lp33623
sg21
I0
sba(iArchitecture
Entity
p33624
(dp33625
g11
(lp33626
sg13
S'com.google.common.collect.Tables$1'
p33627
sg15
(lp33628
sg17
(lp33629
sg19
(lp33630
sg21
I0
sba(iArchitecture
Entity
p33631
(dp33632
g11
(lp33633
sg13
S'com.google.common.collect.Tables$AbstractCell'
p33634
sg15
(lp33635
sg17
(lp33636
sg19
(lp33637
sg21
I0
sba(iArchitecture
Entity
p33638
(dp33639
g11
(lp33640
sg13
S'com.google.common.collect.Tables$ImmutableCell'
p33641
sg15
(lp33642
sg17
(lp33643
sg19
(lp33644
sg21
I0
sba(iArchitecture
Entity
p33645
(dp33646
g11
(lp33647
sg13
S'com.google.common.collect.Tables$TransformedTable'
p33648
sg15
(lp33649
sg17
(lp33650
sg19
(lp33651
sg21
I0
sba(iArchitecture
Entity
p33652
(dp33653
g11
(lp33654
sg13
S'com.google.common.collect.Tables$TransformedTable$1'
p33655
sg15
(lp33656
sg17
(lp33657
sg19
(lp33658
sg21
I0
sba(iArchitecture
Entity
p33659
(dp33660
g11
(lp33661
sg13
S'com.google.common.collect.Tables$TransformedTable$2'
p33662
sg15
(lp33663
sg17
(lp33664
sg19
(lp33665
sg21
I0
sba(iArchitecture
Entity
p33666
(dp33667
g11
(lp33668
sg13
S'com.google.common.collect.Tables$TransformedTable$3'
p33669
sg15
(lp33670
sg17
(lp33671
sg19
(lp33672
sg21
I0
sba(iArchitecture
Entity
p33673
(dp33674
g11
(lp33675
sg13
S'com.google.common.collect.Tables$TransposeTable'
p33676
sg15
(lp33677
sg17
(lp33678
sg19
(lp33679
sg21
I0
sba(iArchitecture
Entity
p33680
(dp33681
g11
(lp33682
sg13
S'com.google.common.collect.Tables$TransposeTable$1'
p33683
sg15
(lp33684
sg17
(lp33685
sg19
(lp33686
sg21
I0
sba(iArchitecture
Entity
p33687
(dp33688
g11
(lp33689
sg13
S'com.google.common.collect.Tables$UnmodifiableRowSortedMap'
p33690
sg15
(lp33691
sg17
(lp33692
sg19
(lp33693
sg21
I0
sba(iArchitecture
Entity
p33694
(dp33695
g11
(lp33696
sg13
S'com.google.common.collect.Tables$UnmodifiableTable'
p33697
sg15
(lp33698
sg17
(lp33699
sg19
(lp33700
sg21
I0
sba(iArchitecture
Entity
p33701
(dp33702
g11
(lp33703
sg13
S'com.google.common.collect.TopKSelector'
p33704
sg15
(lp33705
sg17
(lp33706
sg19
(lp33707
sg21
I0
sba(iArchitecture
Entity
p33708
(dp33709
g11
(lp33710
sg13
S'com.google.common.collect.TransformedIterator'
p33711
sg15
(lp33712
sg17
(lp33713
sg19
(lp33714
sg21
I0
sba(iArchitecture
Entity
p33715
(dp33716
g11
(lp33717
sg13
S'com.google.common.collect.TransformedListIterator'
p33718
sg15
(lp33719
sg17
(lp33720
sg19
(lp33721
sg21
I0
sba(iArchitecture
Entity
p33722
(dp33723
g11
(lp33724
sg13
S'com.google.common.collect.TreeBasedTable'
p33725
sg15
(lp33726
sg17
(lp33727
sg19
(lp33728
sg21
I0
sba(iArchitecture
Entity
p33729
(dp33730
g11
(lp33731
sg13
S'com.google.common.collect.TreeBasedTable$1'
p33732
sg15
(lp33733
sg17
(lp33734
sg19
(lp33735
sg21
I0
sba(iArchitecture
Entity
p33736
(dp33737
g11
(lp33738
sg13
S'com.google.common.collect.TreeBasedTable$2'
p33739
sg15
(lp33740
sg17
(lp33741
sg19
(lp33742
sg21
I0
sba(iArchitecture
Entity
p33743
(dp33744
g11
(lp33745
sg13
S'com.google.common.collect.TreeBasedTable$Factory'
p33746
sg15
(lp33747
sg17
(lp33748
sg19
(lp33749
sg21
I0
sba(iArchitecture
Entity
p33750
(dp33751
g11
(lp33752
sg13
S'com.google.common.collect.TreeBasedTable$TreeRow'
p33753
sg15
(lp33754
sg17
(lp33755
sg19
(lp33756
sg21
I0
sba(iArchitecture
Entity
p33757
(dp33758
g11
(lp33759
sg13
S'com.google.common.collect.TreeMultimap'
p33760
sg15
(lp33761
sg17
(lp33762
sg19
(lp33763
sg21
I0
sba(iArchitecture
Entity
p33764
(dp33765
g11
(lp33766
sg13
S'com.google.common.collect.TreeMultiset'
p33767
sg15
(lp33768
sg17
(lp33769
sg19
(lp33770
sg21
I0
sba(iArchitecture
Entity
p33771
(dp33772
g11
(lp33773
sg13
S'com.google.common.collect.TreeMultiset$1'
p33774
sg15
(lp33775
sg17
(lp33776
sg19
(lp33777
sg21
I0
sba(iArchitecture
Entity
p33778
(dp33779
g11
(lp33780
sg13
S'com.google.common.collect.TreeMultiset$2'
p33781
sg15
(lp33782
sg17
(lp33783
sg19
(lp33784
sg21
I0
sba(iArchitecture
Entity
p33785
(dp33786
g11
(lp33787
sg13
S'com.google.common.collect.TreeMultiset$3'
p33788
sg15
(lp33789
sg17
(lp33790
sg19
(lp33791
sg21
I0
sba(iArchitecture
Entity
p33792
(dp33793
g11
(lp33794
sg13
S'com.google.common.collect.TreeMultiset$4'
p33795
sg15
(lp33796
sg17
(lp33797
sg19
(lp33798
sg21
I0
sba(iArchitecture
Entity
p33799
(dp33800
g11
(lp33801
sg13
S'com.google.common.collect.TreeMultiset$Aggregate'
p33802
sg15
(lp33803
sg17
(lp33804
sg19
(lp33805
sg21
I0
sba(iArchitecture
Entity
p33806
(dp33807
g11
(lp33808
sg13
S'com.google.common.collect.TreeMultiset$Aggregate$1'
p33809
sg15
(lp33810
sg17
(lp33811
sg19
(lp33812
sg21
I0
sba(iArchitecture
Entity
p33813
(dp33814
g11
(lp33815
sg13
S'com.google.common.collect.TreeMultiset$Aggregate$2'
p33816
sg15
(lp33817
sg17
(lp33818
sg19
(lp33819
sg21
I0
sba(iArchitecture
Entity
p33820
(dp33821
g11
(lp33822
sg13
S'com.google.common.collect.TreeMultiset$AvlNode'
p33823
sg15
(lp33824
sg17
(lp33825
sg19
(lp33826
sg21
I0
sba(iArchitecture
Entity
p33827
(dp33828
g11
(lp33829
sg13
S'com.google.common.collect.TreeMultiset$Reference'
p33830
sg15
(lp33831
sg17
(lp33832
sg19
(lp33833
sg21
I0
sba(iArchitecture
Entity
p33834
(dp33835
g11
(lp33836
sg13
S'com.google.common.collect.TreeRangeMap'
p33837
sg15
(lp33838
sg17
(lp33839
sg19
(lp33840
sg21
I0
sba(iArchitecture
Entity
p33841
(dp33842
g11
(lp33843
sg13
S'com.google.common.collect.TreeRangeMap$1'
p33844
sg15
(lp33845
sg17
(lp33846
sg19
(lp33847
sg21
I0
sba(iArchitecture
Entity
p33848
(dp33849
g11
(lp33850
sg13
S'com.google.common.collect.TreeRangeMap$AsMapOfRanges'
p33851
sg15
(lp33852
sg17
(lp33853
sg19
(lp33854
sg21
I0
sba(iArchitecture
Entity
p33855
(dp33856
g11
(lp33857
sg13
S'com.google.common.collect.TreeRangeMap$RangeMapEntry'
p33858
sg15
(lp33859
sg17
(lp33860
sg19
(lp33861
sg21
I0
sba(iArchitecture
Entity
p33862
(dp33863
g11
(lp33864
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap'
p33865
sg15
(lp33866
sg17
(lp33867
sg19
(lp33868
sg21
I0
sba(iArchitecture
Entity
p33869
(dp33870
g11
(lp33871
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$1'
p33872
sg15
(lp33873
sg17
(lp33874
sg19
(lp33875
sg21
I0
sba(iArchitecture
Entity
p33876
(dp33877
g11
(lp33878
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$1$1'
p33879
sg15
(lp33880
sg17
(lp33881
sg19
(lp33882
sg21
I0
sba(iArchitecture
Entity
p33883
(dp33884
g11
(lp33885
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap'
p33886
sg15
(lp33887
sg17
(lp33888
sg19
(lp33889
sg21
I0
sba(iArchitecture
Entity
p33890
(dp33891
g11
(lp33892
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$1'
p33893
sg15
(lp33894
sg17
(lp33895
sg19
(lp33896
sg21
I0
sba(iArchitecture
Entity
p33897
(dp33898
g11
(lp33899
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$2'
p33900
sg15
(lp33901
sg17
(lp33902
sg19
(lp33903
sg21
I0
sba(iArchitecture
Entity
p33904
(dp33905
g11
(lp33906
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$3'
p33907
sg15
(lp33908
sg17
(lp33909
sg19
(lp33910
sg21
I0
sba(iArchitecture
Entity
p33911
(dp33912
g11
(lp33913
sg13
S'com.google.common.collect.TreeRangeMap$SubRangeMap$SubRangeMapAsMap$4'
p33914
sg15
(lp33915
sg17
(lp33916
sg19
(lp33917
sg21
I0
sba(iArchitecture
Entity
p33918
(dp33919
g11
(lp33920
sg13
S'com.google.common.collect.TreeRangeSet'
p33921
sg15
(lp33922
sg17
(lp33923
sg19
(lp33924
sg21
I0
sba(iArchitecture
Entity
p33925
(dp33926
g11
(lp33927
sg13
S'com.google.common.collect.TreeRangeSet$1'
p33928
sg15
(lp33929
sg17
(lp33930
sg19
(lp33931
sg21
I0
sba(iArchitecture
Entity
p33932
(dp33933
g11
(lp33934
sg13
S'com.google.common.collect.TreeRangeSet$AsRanges'
p33935
sg15
(lp33936
sg17
(lp33937
sg19
(lp33938
sg21
I0
sba(iArchitecture
Entity
p33939
(dp33940
g11
(lp33941
sg13
S'com.google.common.collect.TreeRangeSet$Complement'
p33942
sg15
(lp33943
sg17
(lp33944
sg19
(lp33945
sg21
I0
sba(iArchitecture
Entity
p33946
(dp33947
g11
(lp33948
sg13
S'com.google.common.collect.TreeRangeSet$ComplementRangesByLowerBound'
p33949
sg15
(lp33950
sg17
(lp33951
sg19
(lp33952
sg21
I0
sba(iArchitecture
Entity
p33953
(dp33954
g11
(lp33955
sg13
S'com.google.common.collect.TreeRangeSet$ComplementRangesByLowerBound$1'
p33956
sg15
(lp33957
sg17
(lp33958
sg19
(lp33959
sg21
I0
sba(iArchitecture
Entity
p33960
(dp33961
g11
(lp33962
sg13
S'com.google.common.collect.TreeRangeSet$ComplementRangesByLowerBound$2'
p33963
sg15
(lp33964
sg17
(lp33965
sg19
(lp33966
sg21
I0
sba(iArchitecture
Entity
p33967
(dp33968
g11
(lp33969
sg13
S'com.google.common.collect.TreeRangeSet$RangesByUpperBound'
p33970
sg15
(lp33971
sg17
(lp33972
sg19
(lp33973
sg21
I0
sba(iArchitecture
Entity
p33974
(dp33975
g11
(lp33976
sg13
S'com.google.common.collect.TreeRangeSet$RangesByUpperBound$1'
p33977
sg15
(lp33978
sg17
(lp33979
sg19
(lp33980
sg21
I0
sba(iArchitecture
Entity
p33981
(dp33982
g11
(lp33983
sg13
S'com.google.common.collect.TreeRangeSet$RangesByUpperBound$2'
p33984
sg15
(lp33985
sg17
(lp33986
sg19
(lp33987
sg21
I0
sba(iArchitecture
Entity
p33988
(dp33989
g11
(lp33990
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSet'
p33991
sg15
(lp33992
sg17
(lp33993
sg19
(lp33994
sg21
I0
sba(iArchitecture
Entity
p33995
(dp33996
g11
(lp33997
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSetRangesByLowerBound'
p33998
sg15
(lp33999
sg17
(lp34000
sg19
(lp34001
sg21
I0
sba(iArchitecture
Entity
p34002
(dp34003
g11
(lp34004
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSetRangesByLowerBound$1'
p34005
sg15
(lp34006
sg17
(lp34007
sg19
(lp34008
sg21
I0
sba(iArchitecture
Entity
p34009
(dp34010
g11
(lp34011
sg13
S'com.google.common.collect.TreeRangeSet$SubRangeSetRangesByLowerBound$2'
p34012
sg15
(lp34013
sg17
(lp34014
sg19
(lp34015
sg21
I0
sba(iArchitecture
Entity
p34016
(dp34017
g11
(lp34018
sg13
S'com.google.common.collect.TreeTraverser'
p34019
sg15
(lp34020
sg17
(lp34021
sg19
(lp34022
sg21
I0
sba(iArchitecture
Entity
p34023
(dp34024
g11
(lp34025
sg13
S'com.google.common.collect.TreeTraverser$1'
p34026
sg15
(lp34027
sg17
(lp34028
sg19
(lp34029
sg21
I0
sba(iArchitecture
Entity
p34030
(dp34031
g11
(lp34032
sg13
S'com.google.common.collect.TreeTraverser$2'
p34033
sg15
(lp34034
sg17
(lp34035
sg19
(lp34036
sg21
I0
sba(iArchitecture
Entity
p34037
(dp34038
g11
(lp34039
sg13
S'com.google.common.collect.TreeTraverser$2$1'
p34040
sg15
(lp34041
sg17
(lp34042
sg19
(lp34043
sg21
I0
sba(iArchitecture
Entity
p34044
(dp34045
g11
(lp34046
sg13
S'com.google.common.collect.TreeTraverser$3'
p34047
sg15
(lp34048
sg17
(lp34049
sg19
(lp34050
sg21
I0
sba(iArchitecture
Entity
p34051
(dp34052
g11
(lp34053
sg13
S'com.google.common.collect.TreeTraverser$3$1'
p34054
sg15
(lp34055
sg17
(lp34056
sg19
(lp34057
sg21
I0
sba(iArchitecture
Entity
p34058
(dp34059
g11
(lp34060
sg13
S'com.google.common.collect.TreeTraverser$4'
p34061
sg15
(lp34062
sg17
(lp34063
sg19
(lp34064
sg21
I0
sba(iArchitecture
Entity
p34065
(dp34066
g11
(lp34067
sg13
S'com.google.common.collect.TreeTraverser$BreadthFirstIterator'
p34068
sg15
(lp34069
sg17
(lp34070
sg19
(lp34071
sg21
I0
sba(iArchitecture
Entity
p34072
(dp34073
g11
(lp34074
sg13
S'com.google.common.collect.TreeTraverser$PostOrderIterator'
p34075
sg15
(lp34076
sg17
(lp34077
sg19
(lp34078
sg21
I0
sba(iArchitecture
Entity
p34079
(dp34080
g11
(lp34081
sg13
S'com.google.common.collect.TreeTraverser$PostOrderNode'
p34082
sg15
(lp34083
sg17
(lp34084
sg19
(lp34085
sg21
I0
sba(iArchitecture
Entity
p34086
(dp34087
g11
(lp34088
sg13
S'com.google.common.collect.TreeTraverser$PreOrderIterator'
p34089
sg15
(lp34090
sg17
(lp34091
sg19
(lp34092
sg21
I0
sba(iArchitecture
Entity
p34093
(dp34094
g11
(lp34095
sg13
S'com.google.common.collect.UnmodifiableIterator'
p34096
sg15
(lp34097
sg17
(lp34098
sg19
(lp34099
sg21
I0
sba(iArchitecture
Entity
p34100
(dp34101
g11
(lp34102
sg13
S'com.google.common.collect.UnmodifiableListIterator'
p34103
sg15
(lp34104
sg17
(lp34105
sg19
(lp34106
sg21
I0
sba(iArchitecture
Entity
p34107
(dp34108
g11
(lp34109
sg13
S'com.google.common.collect.UnmodifiableSortedMultiset'
p34110
sg15
(lp34111
sg17
(lp34112
sg19
(lp34113
sg21
I0
sba(iArchitecture
Entity
p34114
(dp34115
g11
(lp34116
sg13
S'com.google.common.collect.UsingToStringOrdering'
p34117
sg15
(lp34118
sg17
(lp34119
sg19
(lp34120
sg21
I0
sba(iArchitecture
Entity
p34121
(dp34122
g11
(lp34123
sg13
S'com.google.common.collect.WellBehavedMap'
p34124
sg15
(lp34125
sg17
(lp34126
sg19
(lp34127
sg21
I0
sba(iArchitecture
Entity
p34128
(dp34129
g11
(lp34130
sg13
S'com.google.common.collect.WellBehavedMap$1'
p34131
sg15
(lp34132
sg17
(lp34133
sg19
(lp34134
sg21
I0
sba(iArchitecture
Entity
p34135
(dp34136
g11
(lp34137
sg13
S'com.google.common.collect.WellBehavedMap$EntrySet'
p34138
sg15
(lp34139
sg17
(lp34140
sg19
(lp34141
sg21
I0
sba(iArchitecture
Entity
p34142
(dp34143
g11
(lp34144
sg13
S'com.google.common.collect.WellBehavedMap$EntrySet$1'
p34145
sg15
(lp34146
sg17
(lp34147
sg19
(lp34148
sg21
I0
sba(iArchitecture
Entity
p34149
(dp34150
g11
(lp34151
sg13
S'com.google.common.collect.WellBehavedMap$EntrySet$1$1'
p34152
sg15
(lp34153
sg17
(lp34154
sg19
(lp34155
sg21
I0
sba(iArchitecture
Entity
p34156
(dp34157
g11
(lp34158
sg13
S'com.google.common.net.HttpHeaders'
p34159
sg15
(lp34160
sg17
(lp34161
sg19
(lp34162
sg21
I0
sba(iArchitecture
Entity
p34163
(dp34164
g11
(lp34165
sg13
S'com.google.common.reflect.AbstractInvocationHandler'
p34166
sg15
(lp34167
sg17
(lp34168
sg19
(lp34169
sg21
I0
sba(iArchitecture
Entity
p34170
(dp34171
g11
(lp34172
sg13
S'com.google.errorprone.annotations.CanIgnoreReturnValue'
p34173
sg15
(lp34174
sg17
(lp34175
sg19
(lp34176
sg21
I0
sba(iArchitecture
Entity
p34177
(dp34178
g11
(lp34179
sg13
S'com.google.errorprone.annotations.CompatibleWith'
p34180
sg15
(lp34181
sg17
(lp34182
sg19
(lp34183
sg21
I0
sba(iArchitecture
Entity
p34184
(dp34185
g11
(lp34186
sg13
S'com.google.errorprone.annotations.concurrent.LazyInit'
p34187
sg15
(lp34188
sg17
(lp34189
sg19
(lp34190
sg21
I0
sba(iArchitecture
Entity
p34191
(dp34192
g11
(lp34193
sg13
S'com.google.j2objc.annotations.RetainedWith'
p34194
sg15
(lp34195
sg17
(lp34196
sg19
(lp34197
sg21
I0
sba(iArchitecture
Entity
p34198
(dp34199
g11
(lp34200
sg13
S'com.google.j2objc.annotations.Weak'
p34201
sg15
(lp34202
sg17
(lp34203
sg19
(lp34204
sg21
I0
sbasg1135
(lp34205
g28132
ag28139
ag28146
ag28153
ag28160
ag28167
ag28174
ag28181
ag28188
ag28195
ag28202
ag28209
ag28216
ag28223
ag28230
ag28237
ag28244
ag28251
ag28258
ag28265
ag28272
ag28279
ag28286
ag28293
ag28300
ag28307
ag28314
ag28321
ag28328
ag28335
ag28342
ag28349
ag28356
ag28363
ag28370
ag28377
ag28384
ag28391
ag28398
ag28405
ag28412
ag28419
ag28426
ag28433
ag28440
ag28447
ag28454
ag28461
ag28468
ag28475
ag28482
ag28489
ag28496
ag28503
ag28510
ag28517
ag28524
ag28531
ag28538
ag28545
ag28552
ag28559
ag28566
ag28573
ag28580
ag28587
ag28594
ag28601
ag28608
ag28615
ag28622
ag28629
ag28636
ag28643
ag28650
ag28657
ag28664
ag28671
ag28678
ag28685
ag28692
ag28699
ag28706
ag28713
ag28720
ag28727
ag28734
ag28741
ag28748
ag28755
ag28762
ag28769
ag28776
ag28783
ag28790
ag28797
ag28804
ag28811
ag28818
ag28825
ag28832
ag28839
ag28846
ag28853
ag28860
ag28867
ag28874
ag28881
ag28888
ag28895
ag28902
ag28909
ag28916
ag28923
ag28930
ag28937
ag28944
ag28951
ag28958
ag28965
ag28972
ag28979
ag28986
ag28993
ag29000
ag29007
ag29014
ag29021
ag29028
ag29035
ag29042
ag29049
ag29056
ag29063
ag29070
ag29077
ag29084
ag29091
ag29098
ag29105
ag29112
ag29119
ag29126
ag29133
ag29140
ag29147
ag29154
ag29161
ag29168
ag29175
ag29182
ag29189
ag29196
ag29203
ag29210
ag29217
ag29224
ag29231
ag29238
ag29245
ag29252
ag29259
ag29266
ag29273
ag29280
ag29287
ag29294
ag29301
ag29308
ag29315
ag29322
ag29329
ag29336
ag29343
ag29350
ag29357
ag29364
ag29371
ag29378
ag29385
ag29392
ag29399
ag29406
ag29413
ag29420
ag29427
ag29434
ag29441
ag29448
ag29455
ag29462
ag29469
ag29476
ag29483
ag29490
ag29497
ag29504
ag29511
ag29518
ag29525
ag29532
ag29539
ag29546
ag29553
ag29560
ag29567
ag29574
ag29581
ag29588
ag29595
ag29602
ag29609
ag29616
ag29623
ag29630
ag29637
ag29644
ag29651
ag29658
ag29665
ag29672
ag29679
ag29686
ag29693
ag29700
ag29707
ag29714
ag29721
ag29728
ag29735
ag29742
ag29749
ag29756
ag29763
ag29770
ag29777
ag29784
ag29791
ag29798
ag29805
ag29812
ag29819
ag29826
ag29833
ag29840
ag29847
ag29854
ag29861
ag29868
ag29875
ag29882
ag29889
ag29896
ag29903
ag29910
ag29917
ag29924
ag29931
ag29938
ag29945
ag29952
ag29959
ag29966
ag29973
ag29980
ag29987
ag29994
ag30001
ag30008
ag30015
ag30022
ag30029
ag30036
ag30043
ag30050
ag30057
ag30064
ag30071
ag30078
ag30085
ag30092
ag30099
ag30106
ag30113
ag30120
ag30127
ag30134
ag30141
ag30148
ag30155
ag30162
ag30169
ag30176
ag30183
ag30190
ag30197
ag30204
ag30211
ag30218
ag30225
ag30232
ag30239
ag30246
ag30253
ag30260
ag30267
ag30274
ag30281
ag30288
ag30295
ag30302
ag30309
ag30316
ag30323
ag30330
ag30337
ag30344
ag30351
ag30358
ag30365
ag30372
ag30379
ag30386
ag30393
ag30400
ag30407
ag30414
ag30421
ag30428
ag30435
ag30442
ag30449
ag30456
ag30463
ag30470
ag30477
ag30484
ag30491
ag30498
ag30505
ag30512
ag30519
ag30526
ag30533
ag30540
ag30547
ag30554
ag30561
ag30568
ag30575
ag30582
ag30589
ag30596
ag30603
ag30610
ag30617
ag30624
ag30631
ag30638
ag30645
ag30652
ag30659
ag30666
ag30673
ag30680
ag30687
ag30694
ag30701
ag30708
ag30715
ag30722
ag30729
ag30736
ag30743
ag30750
ag30757
ag30764
ag30771
ag30778
ag30785
ag30792
ag30799
ag30806
ag30813
ag30820
ag30827
ag30834
ag30841
ag30848
ag30855
ag30862
ag30869
ag30876
ag30883
ag30890
ag30897
ag30904
ag30911
ag30918
ag30925
ag30932
ag30939
ag30946
ag30953
ag30960
ag30967
ag30974
ag30981
ag30988
ag30995
ag31002
ag31009
ag31016
ag31023
ag31030
ag31037
ag31044
ag31051
ag31058
ag31065
ag31072
ag31079
ag31086
ag31093
ag31100
ag31107
ag31114
ag31121
ag31128
ag31135
ag31142
ag31149
ag31156
ag31163
ag31170
ag31177
ag31184
ag31191
ag31198
ag31205
ag31212
ag31219
ag31226
ag31233
ag31240
ag31247
ag31254
ag31261
ag31268
ag31275
ag31282
ag31289
ag31296
ag31303
ag31310
ag31317
ag31324
ag31331
ag31338
ag31345
ag31352
ag31359
ag31366
ag31373
ag31380
ag31387
ag31394
ag31401
ag31408
ag31415
ag31422
ag31429
ag31436
ag31443
ag31450
ag31457
ag31464
ag31471
ag31478
ag31485
ag31492
ag31499
ag31506
ag31513
ag31520
ag31527
ag31534
ag31541
ag31548
ag31555
ag31562
ag31569
ag31576
ag31583
ag31590
ag31597
ag31604
ag31611
ag31618
ag31625
ag31632
ag31639
ag31646
ag31653
ag31660
ag31667
ag31674
ag31681
ag31688
ag31695
ag31702
ag31709
ag31716
ag31723
ag31730
ag31737
ag31744
ag31751
ag31758
ag31765
ag31772
ag31779
ag31786
ag31793
ag31800
ag31807
ag31814
ag31821
ag31828
ag31835
ag31842
ag31849
ag31856
ag31863
ag31870
ag31877
ag31884
ag31891
ag31898
ag31905
ag31912
ag31919
ag31926
ag31933
ag31940
ag31947
ag31954
ag31961
ag31968
ag31975
ag31982
ag31989
ag31996
ag32003
ag32010
ag32017
ag32024
ag32031
ag32038
ag32045
ag32052
ag32059
ag32066
ag32073
ag32080
ag32087
ag32094
ag32101
ag32108
ag32115
ag32122
ag32129
ag32136
ag32143
ag32150
ag32157
ag32164
ag32171
ag32178
ag32185
ag32192
ag32199
ag32206
ag32213
ag32220
ag32227
ag32234
ag32241
ag32248
ag32255
ag32262
ag32269
ag32276
ag32283
ag32290
ag32297
ag32304
ag32311
ag32318
ag32325
ag32332
ag32339
ag32346
ag32353
ag32360
ag32367
ag32374
ag32381
ag32388
ag32395
ag32402
ag32409
ag32416
ag32423
ag32430
ag32437
ag32444
ag32451
ag32458
ag32465
ag32472
ag32479
ag32486
ag32493
ag32500
ag32507
ag32514
ag32521
ag32528
ag32535
ag32542
ag32549
ag32556
ag32563
ag32570
ag32577
ag32584
ag32591
ag32598
ag32605
ag32612
ag32619
ag32626
ag32633
ag32640
ag32647
ag32654
ag32661
ag32668
ag32675
ag32682
ag32689
ag32696
ag32703
ag32710
ag32717
ag32724
ag32731
ag32738
ag32745
ag32752
ag32759
ag32766
ag32773
ag32780
ag32787
ag32794
ag32801
ag32808
ag32815
ag32822
ag32829
ag32836
ag32843
ag32850
ag32857
ag32864
ag32871
ag32878
ag32885
ag32892
ag32899
ag32906
ag32913
ag32920
ag32927
ag32934
ag32941
ag32948
ag32955
ag32962
ag32969
ag32976
ag32983
ag32990
ag32997
ag33004
ag33011
ag33018
ag33025
ag33032
ag33039
ag33046
ag33053
ag33060
ag33067
ag33074
ag33081
ag33088
ag33095
ag33102
ag33109
ag33116
ag33123
ag33130
ag33137
ag33144
ag33151
ag33158
ag33165
ag33172
ag33179
ag33186
ag33193
ag33200
ag33207
ag33214
ag33221
ag33228
ag33235
ag33242
ag33249
ag33256
ag33263
ag33270
ag33277
ag33284
ag33291
ag33298
ag33305
ag33312
ag33319
ag33326
ag33333
ag33340
ag33347
ag33354
ag33361
ag33368
ag33375
ag33382
ag33389
ag33396
ag33403
ag33410
ag33417
ag33424
ag33431
ag33438
ag33445
ag33452
ag33459
ag33466
ag33473
ag33480
ag33487
ag33494
ag33501
ag33508
ag33515
ag33522
ag33529
ag33536
ag33543
ag33550
ag33557
ag33564
ag33571
ag33578
ag33585
ag33592
ag33599
ag33606
ag33613
ag33620
ag33627
ag33634
ag33641
ag33648
ag33655
ag33662
ag33669
ag33676
ag33683
ag33690
ag33697
ag33704
ag33711
ag33718
ag33725
ag33732
ag33739
ag33746
ag33753
ag33760
ag33767
ag33774
ag33781
ag33788
ag33795
ag33802
ag33809
ag33816
ag33823
ag33830
ag33837
ag33844
ag33851
ag33858
ag33865
ag33872
ag33879
ag33886
ag33893
ag33900
ag33907
ag33914
ag33921
ag33928
ag33935
ag33942
ag33949
ag33956
ag33963
ag33970
ag33977
ag33984
ag33991
ag33998
ag34005
ag34012
ag34019
ag34026
ag34033
ag34040
ag34047
ag34054
ag34061
ag34068
ag34075
ag34082
ag34089
ag34096
ag34103
ag34110
ag34117
ag34124
ag34131
ag34138
ag34145
ag34152
ag34159
ag34166
ag34173
ag34180
ag34187
ag34194
ag34201
asg1137
I0
sg21
I0
sg1138
S'com.google.common.collect.ss'
p34206
sba(iArchitecture
Cluster
p34207
(dp34208
g7
(lp34209
(iArchitecture
Entity
p34210
(dp34211
g11
(lp34212
sg13
S'com.google.common.escape.ArrayBasedCharEscaper'
p34213
sg15
(lp34214
sg17
(lp34215
sg19
(lp34216
sg21
I0
sba(iArchitecture
Entity
p34217
(dp34218
g11
(lp34219
sg13
S'com.google.common.escape.ArrayBasedEscaperMap'
p34220
sg15
(lp34221
sg17
(lp34222
sg19
(lp34223
sg21
I0
sba(iArchitecture
Entity
p34224
(dp34225
g11
(lp34226
sg13
S'com.google.common.escape.CharEscaper'
p34227
sg15
(lp34228
sg17
(lp34229
sg19
(lp34230
sg21
I0
sba(iArchitecture
Entity
p34231
(dp34232
g11
(lp34233
sg13
S'com.google.common.escape.CharEscaperBuilder'
p34234
sg15
(lp34235
sg17
(lp34236
sg19
(lp34237
sg21
I0
sba(iArchitecture
Entity
p34238
(dp34239
g11
(lp34240
sg13
S'com.google.common.escape.CharEscaperBuilder$CharArrayDecorator'
p34241
sg15
(lp34242
sg17
(lp34243
sg19
(lp34244
sg21
I0
sba(iArchitecture
Entity
p34245
(dp34246
g11
(lp34247
sg13
S'com.google.common.escape.Escaper'
p34248
sg15
(lp34249
sg17
(lp34250
sg19
(lp34251
sg21
I0
sba(iArchitecture
Entity
p34252
(dp34253
g11
(lp34254
sg13
S'com.google.common.escape.Escaper$1'
p34255
sg15
(lp34256
sg17
(lp34257
sg19
(lp34258
sg21
I0
sba(iArchitecture
Entity
p34259
(dp34260
g11
(lp34261
sg13
S'com.google.common.escape.Escapers'
p34262
sg15
(lp34263
sg17
(lp34264
sg19
(lp34265
sg21
I0
sba(iArchitecture
Entity
p34266
(dp34267
g11
(lp34268
sg13
S'com.google.common.escape.Escapers$1'
p34269
sg15
(lp34270
sg17
(lp34271
sg19
(lp34272
sg21
I0
sba(iArchitecture
Entity
p34273
(dp34274
g11
(lp34275
sg13
S'com.google.common.escape.Escapers$2'
p34276
sg15
(lp34277
sg17
(lp34278
sg19
(lp34279
sg21
I0
sba(iArchitecture
Entity
p34280
(dp34281
g11
(lp34282
sg13
S'com.google.common.escape.Escapers$Builder'
p34283
sg15
(lp34284
sg17
(lp34285
sg19
(lp34286
sg21
I0
sba(iArchitecture
Entity
p34287
(dp34288
g11
(lp34289
sg13
S'com.google.common.escape.Escapers$Builder$1'
p34290
sg15
(lp34291
sg17
(lp34292
sg19
(lp34293
sg21
I0
sba(iArchitecture
Entity
p34294
(dp34295
g11
(lp34296
sg13
S'com.google.common.escape.Platform'
p34297
sg15
(lp34298
sg17
(lp34299
sg19
(lp34300
sg21
I0
sba(iArchitecture
Entity
p34301
(dp34302
g11
(lp34303
sg13
S'com.google.common.escape.Platform$1'
p34304
sg15
(lp34305
sg17
(lp34306
sg19
(lp34307
sg21
I0
sba(iArchitecture
Entity
p34308
(dp34309
g11
(lp34310
sg13
S'com.google.common.escape.UnicodeEscaper'
p34311
sg15
(lp34312
sg17
(lp34313
sg19
(lp34314
sg21
I0
sba(iArchitecture
Entity
p34315
(dp34316
g11
(lp34317
sg13
S'com.google.common.html.HtmlEscapers'
p34318
sg15
(lp34319
sg17
(lp34320
sg19
(lp34321
sg21
I0
sba(iArchitecture
Entity
p34322
(dp34323
g11
(lp34324
sg13
S'com.google.common.xml.XmlEscapers'
p34325
sg15
(lp34326
sg17
(lp34327
sg19
(lp34328
sg21
I0
sbasg1135
(lp34329
g34213
ag34220
ag34227
ag34234
ag34241
ag34248
ag34255
ag34262
ag34269
ag34276
ag34283
ag34290
ag34297
ag34304
ag34311
ag34318
ag34325
asg1137
I0
sg21
I0
sg1138
S'com.google.common.escape.ss'
p34330
sba(iArchitecture
Cluster
p34331
(dp34332
g7
(lp34333
(iArchitecture
Entity
p34334
(dp34335
g11
(lp34336
sg13
S'com.google.common.eventbus.AllowConcurrentEvents'
p34337
sg15
(lp34338
sg17
(lp34339
sg19
(lp34340
sg21
I0
sba(iArchitecture
Entity
p34341
(dp34342
g11
(lp34343
sg13
S'com.google.common.eventbus.AsyncEventBus'
p34344
sg15
(lp34345
sg17
(lp34346
sg19
(lp34347
sg21
I0
sba(iArchitecture
Entity
p34348
(dp34349
g11
(lp34350
sg13
S'com.google.common.eventbus.DeadEvent'
p34351
sg15
(lp34352
sg17
(lp34353
sg19
(lp34354
sg21
I0
sba(iArchitecture
Entity
p34355
(dp34356
g11
(lp34357
sg13
S'com.google.common.eventbus.Dispatcher'
p34358
sg15
(lp34359
sg17
(lp34360
sg19
(lp34361
sg21
I0
sba(iArchitecture
Entity
p34362
(dp34363
g11
(lp34364
sg13
S'com.google.common.eventbus.Dispatcher$1'
p34365
sg15
(lp34366
sg17
(lp34367
sg19
(lp34368
sg21
I0
sba(iArchitecture
Entity
p34369
(dp34370
g11
(lp34371
sg13
S'com.google.common.eventbus.Dispatcher$ImmediateDispatcher'
p34372
sg15
(lp34373
sg17
(lp34374
sg19
(lp34375
sg21
I0
sba(iArchitecture
Entity
p34376
(dp34377
g11
(lp34378
sg13
S'com.google.common.eventbus.Dispatcher$LegacyAsyncDispatcher'
p34379
sg15
(lp34380
sg17
(lp34381
sg19
(lp34382
sg21
I0
sba(iArchitecture
Entity
p34383
(dp34384
g11
(lp34385
sg13
S'com.google.common.eventbus.Dispatcher$LegacyAsyncDispatcher$EventWithSubscriber'
p34386
sg15
(lp34387
sg17
(lp34388
sg19
(lp34389
sg21
I0
sba(iArchitecture
Entity
p34390
(dp34391
g11
(lp34392
sg13
S'com.google.common.eventbus.Dispatcher$PerThreadQueuedDispatcher'
p34393
sg15
(lp34394
sg17
(lp34395
sg19
(lp34396
sg21
I0
sba(iArchitecture
Entity
p34397
(dp34398
g11
(lp34399
sg13
S'com.google.common.eventbus.Dispatcher$PerThreadQueuedDispatcher$1'
p34400
sg15
(lp34401
sg17
(lp34402
sg19
(lp34403
sg21
I0
sba(iArchitecture
Entity
p34404
(dp34405
g11
(lp34406
sg13
S'com.google.common.eventbus.Dispatcher$PerThreadQueuedDispatcher$2'
p34407
sg15
(lp34408
sg17
(lp34409
sg19
(lp34410
sg21
I0
sba(iArchitecture
Entity
p34411
(dp34412
g11
(lp34413
sg13
S'com.google.common.eventbus.Dispatcher$PerThreadQueuedDispatcher$Event'
p34414
sg15
(lp34415
sg17
(lp34416
sg19
(lp34417
sg21
I0
sba(iArchitecture
Entity
p34418
(dp34419
g11
(lp34420
sg13
S'com.google.common.eventbus.EventBus'
p34421
sg15
(lp34422
sg17
(lp34423
sg19
(lp34424
sg21
I0
sba(iArchitecture
Entity
p34425
(dp34426
g11
(lp34427
sg13
S'com.google.common.eventbus.EventBus$LoggingHandler'
p34428
sg15
(lp34429
sg17
(lp34430
sg19
(lp34431
sg21
I0
sba(iArchitecture
Entity
p34432
(dp34433
g11
(lp34434
sg13
S'com.google.common.eventbus.Subscribe'
p34435
sg15
(lp34436
sg17
(lp34437
sg19
(lp34438
sg21
I0
sba(iArchitecture
Entity
p34439
(dp34440
g11
(lp34441
sg13
S'com.google.common.eventbus.Subscriber'
p34442
sg15
(lp34443
sg17
(lp34444
sg19
(lp34445
sg21
I0
sba(iArchitecture
Entity
p34446
(dp34447
g11
(lp34448
sg13
S'com.google.common.eventbus.Subscriber$1'
p34449
sg15
(lp34450
sg17
(lp34451
sg19
(lp34452
sg21
I0
sba(iArchitecture
Entity
p34453
(dp34454
g11
(lp34455
sg13
S'com.google.common.eventbus.Subscriber$SynchronizedSubscriber'
p34456
sg15
(lp34457
sg17
(lp34458
sg19
(lp34459
sg21
I0
sba(iArchitecture
Entity
p34460
(dp34461
g11
(lp34462
sg13
S'com.google.common.eventbus.SubscriberExceptionContext'
p34463
sg15
(lp34464
sg17
(lp34465
sg19
(lp34466
sg21
I0
sba(iArchitecture
Entity
p34467
(dp34468
g11
(lp34469
sg13
S'com.google.common.eventbus.SubscriberExceptionHandler'
p34470
sg15
(lp34471
sg17
(lp34472
sg19
(lp34473
sg21
I0
sba(iArchitecture
Entity
p34474
(dp34475
g11
(lp34476
sg13
S'com.google.common.eventbus.SubscriberRegistry'
p34477
sg15
(lp34478
sg17
(lp34479
sg19
(lp34480
sg21
I0
sba(iArchitecture
Entity
p34481
(dp34482
g11
(lp34483
sg13
S'com.google.common.eventbus.SubscriberRegistry$1'
p34484
sg15
(lp34485
sg17
(lp34486
sg19
(lp34487
sg21
I0
sba(iArchitecture
Entity
p34488
(dp34489
g11
(lp34490
sg13
S'com.google.common.eventbus.SubscriberRegistry$2'
p34491
sg15
(lp34492
sg17
(lp34493
sg19
(lp34494
sg21
I0
sba(iArchitecture
Entity
p34495
(dp34496
g11
(lp34497
sg13
S'com.google.common.eventbus.SubscriberRegistry$MethodIdentifier'
p34498
sg15
(lp34499
sg17
(lp34500
sg19
(lp34501
sg21
I0
sba(iArchitecture
Entity
p34502
(dp34503
g11
(lp34504
sg13
S'com.google.common.reflect.TypeToken$ClassSet'
p34505
sg15
(lp34506
sg17
(lp34507
sg19
(lp34508
sg21
I0
sba(iArchitecture
Entity
p34509
(dp34510
g11
(lp34511
sg13
S'com.google.common.reflect.TypeToken$TypeSet'
p34512
sg15
(lp34513
sg17
(lp34514
sg19
(lp34515
sg21
I0
sbasg1135
(lp34516
g34337
ag34344
ag34351
ag34358
ag34365
ag34372
ag34379
ag34386
ag34393
ag34400
ag34407
ag34414
ag34421
ag34428
ag34435
ag34442
ag34449
ag34456
ag34463
ag34470
ag34477
ag34484
ag34491
ag34498
ag34505
ag34512
asg1137
I0
sg21
I0
sg1138
S'com.google.common.eventbus.ss'
p34517
sba(iArchitecture
Cluster
p34518
(dp34519
g7
(lp34520
(iArchitecture
Entity
p34521
(dp34522
g11
(lp34523
sg13
S'com.google.common.collect.HashMultiset'
p34524
sg15
(lp34525
sg17
(lp34526
sg19
(lp34527
sg21
I0
sba(iArchitecture
Entity
p34528
(dp34529
g11
(lp34530
sg13
S'com.google.common.graph.AbstractBaseGraph'
p34531
sg15
(lp34532
sg17
(lp34533
sg19
(lp34534
sg21
I0
sba(iArchitecture
Entity
p34535
(dp34536
g11
(lp34537
sg13
S'com.google.common.graph.AbstractBaseGraph$1'
p34538
sg15
(lp34539
sg17
(lp34540
sg19
(lp34541
sg21
I0
sba(iArchitecture
Entity
p34542
(dp34543
g11
(lp34544
sg13
S'com.google.common.graph.AbstractDirectedNetworkConnections'
p34545
sg15
(lp34546
sg17
(lp34547
sg19
(lp34548
sg21
I0
sba(iArchitecture
Entity
p34549
(dp34550
g11
(lp34551
sg13
S'com.google.common.graph.AbstractDirectedNetworkConnections$1'
p34552
sg15
(lp34553
sg17
(lp34554
sg19
(lp34555
sg21
I0
sba(iArchitecture
Entity
p34556
(dp34557
g11
(lp34558
sg13
S'com.google.common.graph.AbstractGraph'
p34559
sg15
(lp34560
sg17
(lp34561
sg19
(lp34562
sg21
I0
sba(iArchitecture
Entity
p34563
(dp34564
g11
(lp34565
sg13
S'com.google.common.graph.AbstractGraphBuilder'
p34566
sg15
(lp34567
sg17
(lp34568
sg19
(lp34569
sg21
I0
sba(iArchitecture
Entity
p34570
(dp34571
g11
(lp34572
sg13
S'com.google.common.graph.AbstractNetwork'
p34573
sg15
(lp34574
sg17
(lp34575
sg19
(lp34576
sg21
I0
sba(iArchitecture
Entity
p34577
(dp34578
g11
(lp34579
sg13
S'com.google.common.graph.AbstractNetwork$1'
p34580
sg15
(lp34581
sg17
(lp34582
sg19
(lp34583
sg21
I0
sba(iArchitecture
Entity
p34584
(dp34585
g11
(lp34586
sg13
S'com.google.common.graph.AbstractNetwork$1$1'
p34587
sg15
(lp34588
sg17
(lp34589
sg19
(lp34590
sg21
I0
sba(iArchitecture
Entity
p34591
(dp34592
g11
(lp34593
sg13
S'com.google.common.graph.AbstractNetwork$1$1$1'
p34594
sg15
(lp34595
sg17
(lp34596
sg19
(lp34597
sg21
I0
sba(iArchitecture
Entity
p34598
(dp34599
g11
(lp34600
sg13
S'com.google.common.graph.AbstractNetwork$2'
p34601
sg15
(lp34602
sg17
(lp34603
sg19
(lp34604
sg21
I0
sba(iArchitecture
Entity
p34605
(dp34606
g11
(lp34607
sg13
S'com.google.common.graph.AbstractUndirectedNetworkConnections'
p34608
sg15
(lp34609
sg17
(lp34610
sg19
(lp34611
sg21
I0
sba(iArchitecture
Entity
p34612
(dp34613
g11
(lp34614
sg13
S'com.google.common.graph.AbstractValueGraph'
p34615
sg15
(lp34616
sg17
(lp34617
sg19
(lp34618
sg21
I0
sba(iArchitecture
Entity
p34619
(dp34620
g11
(lp34621
sg13
S'com.google.common.graph.AbstractValueGraph$1'
p34622
sg15
(lp34623
sg17
(lp34624
sg19
(lp34625
sg21
I0
sba(iArchitecture
Entity
p34626
(dp34627
g11
(lp34628
sg13
S'com.google.common.graph.AbstractValueGraph$2'
p34629
sg15
(lp34630
sg17
(lp34631
sg19
(lp34632
sg21
I0
sba(iArchitecture
Entity
p34633
(dp34634
g11
(lp34635
sg13
S'com.google.common.graph.BaseGraph'
p34636
sg15
(lp34637
sg17
(lp34638
sg19
(lp34639
sg21
I0
sba(iArchitecture
Entity
p34640
(dp34641
g11
(lp34642
sg13
S'com.google.common.graph.ConfigurableMutableGraph'
p34643
sg15
(lp34644
sg17
(lp34645
sg19
(lp34646
sg21
I0
sba(iArchitecture
Entity
p34647
(dp34648
g11
(lp34649
sg13
S'com.google.common.graph.ConfigurableMutableNetwork'
p34650
sg15
(lp34651
sg17
(lp34652
sg19
(lp34653
sg21
I0
sba(iArchitecture
Entity
p34654
(dp34655
g11
(lp34656
sg13
S'com.google.common.graph.ConfigurableMutableValueGraph'
p34657
sg15
(lp34658
sg17
(lp34659
sg19
(lp34660
sg21
I0
sba(iArchitecture
Entity
p34661
(dp34662
g11
(lp34663
sg13
S'com.google.common.graph.ConfigurableNetwork'
p34664
sg15
(lp34665
sg17
(lp34666
sg19
(lp34667
sg21
I0
sba(iArchitecture
Entity
p34668
(dp34669
g11
(lp34670
sg13
S'com.google.common.graph.ConfigurableValueGraph'
p34671
sg15
(lp34672
sg17
(lp34673
sg19
(lp34674
sg21
I0
sba(iArchitecture
Entity
p34675
(dp34676
g11
(lp34677
sg13
S'com.google.common.graph.DirectedGraphConnections'
p34678
sg15
(lp34679
sg17
(lp34680
sg19
(lp34681
sg21
I0
sba(iArchitecture
Entity
p34682
(dp34683
g11
(lp34684
sg13
S'com.google.common.graph.DirectedGraphConnections$1'
p34685
sg15
(lp34686
sg17
(lp34687
sg19
(lp34688
sg21
I0
sba(iArchitecture
Entity
p34689
(dp34690
g11
(lp34691
sg13
S'com.google.common.graph.DirectedGraphConnections$1$1'
p34692
sg15
(lp34693
sg17
(lp34694
sg19
(lp34695
sg21
I0
sba(iArchitecture
Entity
p34696
(dp34697
g11
(lp34698
sg13
S'com.google.common.graph.DirectedGraphConnections$2'
p34699
sg15
(lp34700
sg17
(lp34701
sg19
(lp34702
sg21
I0
sba(iArchitecture
Entity
p34703
(dp34704
g11
(lp34705
sg13
S'com.google.common.graph.DirectedGraphConnections$2$1'
p34706
sg15
(lp34707
sg17
(lp34708
sg19
(lp34709
sg21
I0
sba(iArchitecture
Entity
p34710
(dp34711
g11
(lp34712
sg13
S'com.google.common.graph.DirectedGraphConnections$PredAndSucc'
p34713
sg15
(lp34714
sg17
(lp34715
sg19
(lp34716
sg21
I0
sba(iArchitecture
Entity
p34717
(dp34718
g11
(lp34719
sg13
S'com.google.common.graph.DirectedMultiNetworkConnections'
p34720
sg15
(lp34721
sg17
(lp34722
sg19
(lp34723
sg21
I0
sba(iArchitecture
Entity
p34724
(dp34725
g11
(lp34726
sg13
S'com.google.common.graph.DirectedMultiNetworkConnections$1'
p34727
sg15
(lp34728
sg17
(lp34729
sg19
(lp34730
sg21
I0
sba(iArchitecture
Entity
p34731
(dp34732
g11
(lp34733
sg13
S'com.google.common.graph.DirectedNetworkConnections'
p34734
sg15
(lp34735
sg17
(lp34736
sg19
(lp34737
sg21
I0
sba(iArchitecture
Entity
p34738
(dp34739
g11
(lp34740
sg13
S'com.google.common.graph.EdgesConnecting'
p34741
sg15
(lp34742
sg17
(lp34743
sg19
(lp34744
sg21
I0
sba(iArchitecture
Entity
p34745
(dp34746
g11
(lp34747
sg13
S'com.google.common.graph.ElementOrder'
p34748
sg15
(lp34749
sg17
(lp34750
sg19
(lp34751
sg21
I0
sba(iArchitecture
Entity
p34752
(dp34753
g11
(lp34754
sg13
S'com.google.common.graph.ElementOrder$1'
p34755
sg15
(lp34756
sg17
(lp34757
sg19
(lp34758
sg21
I0
sba(iArchitecture
Entity
p34759
(dp34760
g11
(lp34761
sg13
S'com.google.common.graph.ElementOrder$Type'
p34762
sg15
(lp34763
sg17
(lp34764
sg19
(lp34765
sg21
I0
sba(iArchitecture
Entity
p34766
(dp34767
g11
(lp34768
sg13
S'com.google.common.graph.EndpointPair'
p34769
sg15
(lp34770
sg17
(lp34771
sg19
(lp34772
sg21
I0
sba(iArchitecture
Entity
p34773
(dp34774
g11
(lp34775
sg13
S'com.google.common.graph.EndpointPair$1'
p34776
sg15
(lp34777
sg17
(lp34778
sg19
(lp34779
sg21
I0
sba(iArchitecture
Entity
p34780
(dp34781
g11
(lp34782
sg13
S'com.google.common.graph.EndpointPair$Ordered'
p34783
sg15
(lp34784
sg17
(lp34785
sg19
(lp34786
sg21
I0
sba(iArchitecture
Entity
p34787
(dp34788
g11
(lp34789
sg13
S'com.google.common.graph.EndpointPair$Unordered'
p34790
sg15
(lp34791
sg17
(lp34792
sg19
(lp34793
sg21
I0
sba(iArchitecture
Entity
p34794
(dp34795
g11
(lp34796
sg13
S'com.google.common.graph.EndpointPairIterator'
p34797
sg15
(lp34798
sg17
(lp34799
sg19
(lp34800
sg21
I0
sba(iArchitecture
Entity
p34801
(dp34802
g11
(lp34803
sg13
S'com.google.common.graph.EndpointPairIterator$1'
p34804
sg15
(lp34805
sg17
(lp34806
sg19
(lp34807
sg21
I0
sba(iArchitecture
Entity
p34808
(dp34809
g11
(lp34810
sg13
S'com.google.common.graph.EndpointPairIterator$Directed'
p34811
sg15
(lp34812
sg17
(lp34813
sg19
(lp34814
sg21
I0
sba(iArchitecture
Entity
p34815
(dp34816
g11
(lp34817
sg13
S'com.google.common.graph.EndpointPairIterator$Undirected'
p34818
sg15
(lp34819
sg17
(lp34820
sg19
(lp34821
sg21
I0
sba(iArchitecture
Entity
p34822
(dp34823
g11
(lp34824
sg13
S'com.google.common.graph.ForwardingGraph'
p34825
sg15
(lp34826
sg17
(lp34827
sg19
(lp34828
sg21
I0
sba(iArchitecture
Entity
p34829
(dp34830
g11
(lp34831
sg13
S'com.google.common.graph.Graph'
p34832
sg15
(lp34833
sg17
(lp34834
sg19
(lp34835
sg21
I0
sba(iArchitecture
Entity
p34836
(dp34837
g11
(lp34838
sg13
S'com.google.common.graph.GraphBuilder'
p34839
sg15
(lp34840
sg17
(lp34841
sg19
(lp34842
sg21
I0
sba(iArchitecture
Entity
p34843
(dp34844
g11
(lp34845
sg13
S'com.google.common.graph.GraphConnections'
p34846
sg15
(lp34847
sg17
(lp34848
sg19
(lp34849
sg21
I0
sba(iArchitecture
Entity
p34850
(dp34851
g11
(lp34852
sg13
S'com.google.common.graph.GraphConstants'
p34853
sg15
(lp34854
sg17
(lp34855
sg19
(lp34856
sg21
I0
sba(iArchitecture
Entity
p34857
(dp34858
g11
(lp34859
sg13
S'com.google.common.graph.GraphConstants$Presence'
p34860
sg15
(lp34861
sg17
(lp34862
sg19
(lp34863
sg21
I0
sba(iArchitecture
Entity
p34864
(dp34865
g11
(lp34866
sg13
S'com.google.common.graph.Graphs'
p34867
sg15
(lp34868
sg17
(lp34869
sg19
(lp34870
sg21
I0
sba(iArchitecture
Entity
p34871
(dp34872
g11
(lp34873
sg13
S'com.google.common.graph.Graphs$NodeVisitState'
p34874
sg15
(lp34875
sg17
(lp34876
sg19
(lp34877
sg21
I0
sba(iArchitecture
Entity
p34878
(dp34879
g11
(lp34880
sg13
S'com.google.common.graph.Graphs$TransposedGraph'
p34881
sg15
(lp34882
sg17
(lp34883
sg19
(lp34884
sg21
I0
sba(iArchitecture
Entity
p34885
(dp34886
g11
(lp34887
sg13
S'com.google.common.graph.Graphs$TransposedNetwork'
p34888
sg15
(lp34889
sg17
(lp34890
sg19
(lp34891
sg21
I0
sba(iArchitecture
Entity
p34892
(dp34893
g11
(lp34894
sg13
S'com.google.common.graph.Graphs$TransposedValueGraph'
p34895
sg15
(lp34896
sg17
(lp34897
sg19
(lp34898
sg21
I0
sba(iArchitecture
Entity
p34899
(dp34900
g11
(lp34901
sg13
S'com.google.common.graph.ImmutableGraph'
p34902
sg15
(lp34903
sg17
(lp34904
sg19
(lp34905
sg21
I0
sba(iArchitecture
Entity
p34906
(dp34907
g11
(lp34908
sg13
S'com.google.common.graph.ImmutableNetwork'
p34909
sg15
(lp34910
sg17
(lp34911
sg19
(lp34912
sg21
I0
sba(iArchitecture
Entity
p34913
(dp34914
g11
(lp34915
sg13
S'com.google.common.graph.ImmutableNetwork$1'
p34916
sg15
(lp34917
sg17
(lp34918
sg19
(lp34919
sg21
I0
sba(iArchitecture
Entity
p34920
(dp34921
g11
(lp34922
sg13
S'com.google.common.graph.ImmutableNetwork$2'
p34923
sg15
(lp34924
sg17
(lp34925
sg19
(lp34926
sg21
I0
sba(iArchitecture
Entity
p34927
(dp34928
g11
(lp34929
sg13
S'com.google.common.graph.ImmutableNetwork$3'
p34930
sg15
(lp34931
sg17
(lp34932
sg19
(lp34933
sg21
I0
sba(iArchitecture
Entity
p34934
(dp34935
g11
(lp34936
sg13
S'com.google.common.graph.ImmutableValueGraph'
p34937
sg15
(lp34938
sg17
(lp34939
sg19
(lp34940
sg21
I0
sba(iArchitecture
Entity
p34941
(dp34942
g11
(lp34943
sg13
S'com.google.common.graph.ImmutableValueGraph$1'
p34944
sg15
(lp34945
sg17
(lp34946
sg19
(lp34947
sg21
I0
sba(iArchitecture
Entity
p34948
(dp34949
g11
(lp34950
sg13
S'com.google.common.graph.MapIteratorCache'
p34951
sg15
(lp34952
sg17
(lp34953
sg19
(lp34954
sg21
I0
sba(iArchitecture
Entity
p34955
(dp34956
g11
(lp34957
sg13
S'com.google.common.graph.MapIteratorCache$1'
p34958
sg15
(lp34959
sg17
(lp34960
sg19
(lp34961
sg21
I0
sba(iArchitecture
Entity
p34962
(dp34963
g11
(lp34964
sg13
S'com.google.common.graph.MapIteratorCache$1$1'
p34965
sg15
(lp34966
sg17
(lp34967
sg19
(lp34968
sg21
I0
sba(iArchitecture
Entity
p34969
(dp34970
g11
(lp34971
sg13
S'com.google.common.graph.MapRetrievalCache'
p34972
sg15
(lp34973
sg17
(lp34974
sg19
(lp34975
sg21
I0
sba(iArchitecture
Entity
p34976
(dp34977
g11
(lp34978
sg13
S'com.google.common.graph.MapRetrievalCache$CacheEntry'
p34979
sg15
(lp34980
sg17
(lp34981
sg19
(lp34982
sg21
I0
sba(iArchitecture
Entity
p34983
(dp34984
g11
(lp34985
sg13
S'com.google.common.graph.MultiEdgesConnecting'
p34986
sg15
(lp34987
sg17
(lp34988
sg19
(lp34989
sg21
I0
sba(iArchitecture
Entity
p34990
(dp34991
g11
(lp34992
sg13
S'com.google.common.graph.MultiEdgesConnecting$1'
p34993
sg15
(lp34994
sg17
(lp34995
sg19
(lp34996
sg21
I0
sba(iArchitecture
Entity
p34997
(dp34998
g11
(lp34999
sg13
S'com.google.common.graph.MutableGraph'
p35000
sg15
(lp35001
sg17
(lp35002
sg19
(lp35003
sg21
I0
sba(iArchitecture
Entity
p35004
(dp35005
g11
(lp35006
sg13
S'com.google.common.graph.MutableNetwork'
p35007
sg15
(lp35008
sg17
(lp35009
sg19
(lp35010
sg21
I0
sba(iArchitecture
Entity
p35011
(dp35012
g11
(lp35013
sg13
S'com.google.common.graph.MutableValueGraph'
p35014
sg15
(lp35015
sg17
(lp35016
sg19
(lp35017
sg21
I0
sba(iArchitecture
Entity
p35018
(dp35019
g11
(lp35020
sg13
S'com.google.common.graph.Network'
p35021
sg15
(lp35022
sg17
(lp35023
sg19
(lp35024
sg21
I0
sba(iArchitecture
Entity
p35025
(dp35026
g11
(lp35027
sg13
S'com.google.common.graph.NetworkBuilder'
p35028
sg15
(lp35029
sg17
(lp35030
sg19
(lp35031
sg21
I0
sba(iArchitecture
Entity
p35032
(dp35033
g11
(lp35034
sg13
S'com.google.common.graph.NetworkConnections'
p35035
sg15
(lp35036
sg17
(lp35037
sg19
(lp35038
sg21
I0
sba(iArchitecture
Entity
p35039
(dp35040
g11
(lp35041
sg13
S'com.google.common.graph.UndirectedGraphConnections'
p35042
sg15
(lp35043
sg17
(lp35044
sg19
(lp35045
sg21
I0
sba(iArchitecture
Entity
p35046
(dp35047
g11
(lp35048
sg13
S'com.google.common.graph.UndirectedMultiNetworkConnections'
p35049
sg15
(lp35050
sg17
(lp35051
sg19
(lp35052
sg21
I0
sba(iArchitecture
Entity
p35053
(dp35054
g11
(lp35055
sg13
S'com.google.common.graph.UndirectedMultiNetworkConnections$1'
p35056
sg15
(lp35057
sg17
(lp35058
sg19
(lp35059
sg21
I0
sba(iArchitecture
Entity
p35060
(dp35061
g11
(lp35062
sg13
S'com.google.common.graph.UndirectedNetworkConnections'
p35063
sg15
(lp35064
sg17
(lp35065
sg19
(lp35066
sg21
I0
sba(iArchitecture
Entity
p35067
(dp35068
g11
(lp35069
sg13
S'com.google.common.graph.ValueGraph'
p35070
sg15
(lp35071
sg17
(lp35072
sg19
(lp35073
sg21
I0
sba(iArchitecture
Entity
p35074
(dp35075
g11
(lp35076
sg13
S'com.google.common.graph.ValueGraphBuilder'
p35077
sg15
(lp35078
sg17
(lp35079
sg19
(lp35080
sg21
I0
sba(iArchitecture
Entity
p35081
(dp35082
g11
(lp35083
sg13
S'com.google.errorprone.annotations.Immutable'
p35084
sg15
(lp35085
sg17
(lp35086
sg19
(lp35087
sg21
I0
sbasg1135
(lp35088
g34524
ag34531
ag34538
ag34545
ag34552
ag34559
ag34566
ag34573
ag34580
ag34587
ag34594
ag34601
ag34608
ag34615
ag34622
ag34629
ag34636
ag34643
ag34650
ag34657
ag34664
ag34671
ag34678
ag34685
ag34692
ag34699
ag34706
ag34713
ag34720
ag34727
ag34734
ag34741
ag34748
ag34755
ag34762
ag34769
ag34776
ag34783
ag34790
ag34797
ag34804
ag34811
ag34818
ag34825
ag34832
ag34839
ag34846
ag34853
ag34860
ag34867
ag34874
ag34881
ag34888
ag34895
ag34902
ag34909
ag34916
ag34923
ag34930
ag34937
ag34944
ag34951
ag34958
ag34965
ag34972
ag34979
ag34986
ag34993
ag35000
ag35007
ag35014
ag35021
ag35028
ag35035
ag35042
ag35049
ag35056
ag35063
ag35070
ag35077
ag35084
asg1137
I0
sg21
I0
sg1138
S'com.google.common.graph.ss'
p35089
sba(iArchitecture
Cluster
p35090
(dp35091
g7
(lp35092
(iArchitecture
Entity
p35093
(dp35094
g11
(lp35095
sg13
S'com.google.common.hash.AbstractByteHasher'
p35096
sg15
(lp35097
sg17
(lp35098
sg19
(lp35099
sg21
I0
sba(iArchitecture
Entity
p35100
(dp35101
g11
(lp35102
sg13
S'com.google.common.hash.AbstractCompositeHashFunction'
p35103
sg15
(lp35104
sg17
(lp35105
sg19
(lp35106
sg21
I0
sba(iArchitecture
Entity
p35107
(dp35108
g11
(lp35109
sg13
S'com.google.common.hash.AbstractCompositeHashFunction$1'
p35110
sg15
(lp35111
sg17
(lp35112
sg19
(lp35113
sg21
I0
sba(iArchitecture
Entity
p35114
(dp35115
g11
(lp35116
sg13
S'com.google.common.hash.AbstractHasher'
p35117
sg15
(lp35118
sg17
(lp35119
sg19
(lp35120
sg21
I0
sba(iArchitecture
Entity
p35121
(dp35122
g11
(lp35123
sg13
S'com.google.common.hash.AbstractNonStreamingHashFunction'
p35124
sg15
(lp35125
sg17
(lp35126
sg19
(lp35127
sg21
I0
sba(iArchitecture
Entity
p35128
(dp35129
g11
(lp35130
sg13
S'com.google.common.hash.AbstractNonStreamingHashFunction$BufferingHasher'
p35131
sg15
(lp35132
sg17
(lp35133
sg19
(lp35134
sg21
I0
sba(iArchitecture
Entity
p35135
(dp35136
g11
(lp35137
sg13
S'com.google.common.hash.AbstractNonStreamingHashFunction$ExposedByteArrayOutputStream'
p35138
sg15
(lp35139
sg17
(lp35140
sg19
(lp35141
sg21
I0
sba(iArchitecture
Entity
p35142
(dp35143
g11
(lp35144
sg13
S'com.google.common.hash.AbstractStreamingHashFunction'
p35145
sg15
(lp35146
sg17
(lp35147
sg19
(lp35148
sg21
I0
sba(iArchitecture
Entity
p35149
(dp35150
g11
(lp35151
sg13
S'com.google.common.hash.AbstractStreamingHashFunction$AbstractStreamingHasher'
p35152
sg15
(lp35153
sg17
(lp35154
sg19
(lp35155
sg21
I0
sba(iArchitecture
Entity
p35156
(dp35157
g11
(lp35158
sg13
S'com.google.common.hash.BloomFilter'
p35159
sg15
(lp35160
sg17
(lp35161
sg19
(lp35162
sg21
I0
sba(iArchitecture
Entity
p35163
(dp35164
g11
(lp35165
sg13
S'com.google.common.hash.BloomFilter$1'
p35166
sg15
(lp35167
sg17
(lp35168
sg19
(lp35169
sg21
I0
sba(iArchitecture
Entity
p35170
(dp35171
g11
(lp35172
sg13
S'com.google.common.hash.BloomFilter$SerialForm'
p35173
sg15
(lp35174
sg17
(lp35175
sg19
(lp35176
sg21
I0
sba(iArchitecture
Entity
p35177
(dp35178
g11
(lp35179
sg13
S'com.google.common.hash.BloomFilter$Strategy'
p35180
sg15
(lp35181
sg17
(lp35182
sg19
(lp35183
sg21
I0
sba(iArchitecture
Entity
p35184
(dp35185
g11
(lp35186
sg13
S'com.google.common.hash.BloomFilterStrategies'
p35187
sg15
(lp35188
sg17
(lp35189
sg19
(lp35190
sg21
I0
sba(iArchitecture
Entity
p35191
(dp35192
g11
(lp35193
sg13
S'com.google.common.hash.BloomFilterStrategies$1'
p35194
sg15
(lp35195
sg17
(lp35196
sg19
(lp35197
sg21
I0
sba(iArchitecture
Entity
p35198
(dp35199
g11
(lp35200
sg13
S'com.google.common.hash.BloomFilterStrategies$2'
p35201
sg15
(lp35202
sg17
(lp35203
sg19
(lp35204
sg21
I0
sba(iArchitecture
Entity
p35205
(dp35206
g11
(lp35207
sg13
S'com.google.common.hash.BloomFilterStrategies$BitArray'
p35208
sg15
(lp35209
sg17
(lp35210
sg19
(lp35211
sg21
I0
sba(iArchitecture
Entity
p35212
(dp35213
g11
(lp35214
sg13
S'com.google.common.hash.ChecksumHashFunction'
p35215
sg15
(lp35216
sg17
(lp35217
sg19
(lp35218
sg21
I0
sba(iArchitecture
Entity
p35219
(dp35220
g11
(lp35221
sg13
S'com.google.common.hash.ChecksumHashFunction$1'
p35222
sg15
(lp35223
sg17
(lp35224
sg19
(lp35225
sg21
I0
sba(iArchitecture
Entity
p35226
(dp35227
g11
(lp35228
sg13
S'com.google.common.hash.ChecksumHashFunction$ChecksumHasher'
p35229
sg15
(lp35230
sg17
(lp35231
sg19
(lp35232
sg21
I0
sba(iArchitecture
Entity
p35233
(dp35234
g11
(lp35235
sg13
S'com.google.common.hash.Crc32cHashFunction'
p35236
sg15
(lp35237
sg17
(lp35238
sg19
(lp35239
sg21
I0
sba(iArchitecture
Entity
p35240
(dp35241
g11
(lp35242
sg13
S'com.google.common.hash.Crc32cHashFunction$Crc32cHasher'
p35243
sg15
(lp35244
sg17
(lp35245
sg19
(lp35246
sg21
I0
sba(iArchitecture
Entity
p35247
(dp35248
g11
(lp35249
sg13
S'com.google.common.hash.FarmHashFingerprint64'
p35250
sg15
(lp35251
sg17
(lp35252
sg19
(lp35253
sg21
I0
sba(iArchitecture
Entity
p35254
(dp35255
g11
(lp35256
sg13
S'com.google.common.hash.Funnel'
p35257
sg15
(lp35258
sg17
(lp35259
sg19
(lp35260
sg21
I0
sba(iArchitecture
Entity
p35261
(dp35262
g11
(lp35263
sg13
S'com.google.common.hash.Funnels'
p35264
sg15
(lp35265
sg17
(lp35266
sg19
(lp35267
sg21
I0
sba(iArchitecture
Entity
p35268
(dp35269
g11
(lp35270
sg13
S'com.google.common.hash.Funnels$ByteArrayFunnel'
p35271
sg15
(lp35272
sg17
(lp35273
sg19
(lp35274
sg21
I0
sba(iArchitecture
Entity
p35275
(dp35276
g11
(lp35277
sg13
S'com.google.common.hash.Funnels$IntegerFunnel'
p35278
sg15
(lp35279
sg17
(lp35280
sg19
(lp35281
sg21
I0
sba(iArchitecture
Entity
p35282
(dp35283
g11
(lp35284
sg13
S'com.google.common.hash.Funnels$LongFunnel'
p35285
sg15
(lp35286
sg17
(lp35287
sg19
(lp35288
sg21
I0
sba(iArchitecture
Entity
p35289
(dp35290
g11
(lp35291
sg13
S'com.google.common.hash.Funnels$SequentialFunnel'
p35292
sg15
(lp35293
sg17
(lp35294
sg19
(lp35295
sg21
I0
sba(iArchitecture
Entity
p35296
(dp35297
g11
(lp35298
sg13
S'com.google.common.hash.Funnels$SinkAsStream'
p35299
sg15
(lp35300
sg17
(lp35301
sg19
(lp35302
sg21
I0
sba(iArchitecture
Entity
p35303
(dp35304
g11
(lp35305
sg13
S'com.google.common.hash.Funnels$StringCharsetFunnel'
p35306
sg15
(lp35307
sg17
(lp35308
sg19
(lp35309
sg21
I0
sba(iArchitecture
Entity
p35310
(dp35311
g11
(lp35312
sg13
S'com.google.common.hash.Funnels$StringCharsetFunnel$SerializedForm'
p35313
sg15
(lp35314
sg17
(lp35315
sg19
(lp35316
sg21
I0
sba(iArchitecture
Entity
p35317
(dp35318
g11
(lp35319
sg13
S'com.google.common.hash.Funnels$UnencodedCharsFunnel'
p35320
sg15
(lp35321
sg17
(lp35322
sg19
(lp35323
sg21
I0
sba(iArchitecture
Entity
p35324
(dp35325
g11
(lp35326
sg13
S'com.google.common.hash.HashCode'
p35327
sg15
(lp35328
sg17
(lp35329
sg19
(lp35330
sg21
I0
sba(iArchitecture
Entity
p35331
(dp35332
g11
(lp35333
sg13
S'com.google.common.hash.HashCode$BytesHashCode'
p35334
sg15
(lp35335
sg17
(lp35336
sg19
(lp35337
sg21
I0
sba(iArchitecture
Entity
p35338
(dp35339
g11
(lp35340
sg13
S'com.google.common.hash.HashCode$IntHashCode'
p35341
sg15
(lp35342
sg17
(lp35343
sg19
(lp35344
sg21
I0
sba(iArchitecture
Entity
p35345
(dp35346
g11
(lp35347
sg13
S'com.google.common.hash.HashCode$LongHashCode'
p35348
sg15
(lp35349
sg17
(lp35350
sg19
(lp35351
sg21
I0
sba(iArchitecture
Entity
p35352
(dp35353
g11
(lp35354
sg13
S'com.google.common.hash.HashFunction'
p35355
sg15
(lp35356
sg17
(lp35357
sg19
(lp35358
sg21
I0
sba(iArchitecture
Entity
p35359
(dp35360
g11
(lp35361
sg13
S'com.google.common.hash.Hasher'
p35362
sg15
(lp35363
sg17
(lp35364
sg19
(lp35365
sg21
I0
sba(iArchitecture
Entity
p35366
(dp35367
g11
(lp35368
sg13
S'com.google.common.hash.Hashing'
p35369
sg15
(lp35370
sg17
(lp35371
sg19
(lp35372
sg21
I0
sba(iArchitecture
Entity
p35373
(dp35374
g11
(lp35375
sg13
S'com.google.common.hash.Hashing$1'
p35376
sg15
(lp35377
sg17
(lp35378
sg19
(lp35379
sg21
I0
sba(iArchitecture
Entity
p35380
(dp35381
g11
(lp35382
sg13
S'com.google.common.hash.Hashing$Adler32Holder'
p35383
sg15
(lp35384
sg17
(lp35385
sg19
(lp35386
sg21
I0
sba(iArchitecture
Entity
p35387
(dp35388
g11
(lp35389
sg13
S'com.google.common.hash.Hashing$ChecksumType'
p35390
sg15
(lp35391
sg17
(lp35392
sg19
(lp35393
sg21
I0
sba(iArchitecture
Entity
p35394
(dp35395
g11
(lp35396
sg13
S'com.google.common.hash.Hashing$ChecksumType$1'
p35397
sg15
(lp35398
sg17
(lp35399
sg19
(lp35400
sg21
I0
sba(iArchitecture
Entity
p35401
(dp35402
g11
(lp35403
sg13
S'com.google.common.hash.Hashing$ChecksumType$2'
p35404
sg15
(lp35405
sg17
(lp35406
sg19
(lp35407
sg21
I0
sba(iArchitecture
Entity
p35408
(dp35409
g11
(lp35410
sg13
S'com.google.common.hash.Hashing$ConcatenatedHashFunction'
p35411
sg15
(lp35412
sg17
(lp35413
sg19
(lp35414
sg21
I0
sba(iArchitecture
Entity
p35415
(dp35416
g11
(lp35417
sg13
S'com.google.common.hash.Hashing$Crc32Holder'
p35418
sg15
(lp35419
sg17
(lp35420
sg19
(lp35421
sg21
I0
sba(iArchitecture
Entity
p35422
(dp35423
g11
(lp35424
sg13
S'com.google.common.hash.Hashing$Crc32cHolder'
p35425
sg15
(lp35426
sg17
(lp35427
sg19
(lp35428
sg21
I0
sba(iArchitecture
Entity
p35429
(dp35430
g11
(lp35431
sg13
S'com.google.common.hash.Hashing$FarmHashFingerprint64Holder'
p35432
sg15
(lp35433
sg17
(lp35434
sg19
(lp35435
sg21
I0
sba(iArchitecture
Entity
p35436
(dp35437
g11
(lp35438
sg13
S'com.google.common.hash.Hashing$LinearCongruentialGenerator'
p35439
sg15
(lp35440
sg17
(lp35441
sg19
(lp35442
sg21
I0
sba(iArchitecture
Entity
p35443
(dp35444
g11
(lp35445
sg13
S'com.google.common.hash.Hashing$Md5Holder'
p35446
sg15
(lp35447
sg17
(lp35448
sg19
(lp35449
sg21
I0
sba(iArchitecture
Entity
p35450
(dp35451
g11
(lp35452
sg13
S'com.google.common.hash.Hashing$Murmur3_128Holder'
p35453
sg15
(lp35454
sg17
(lp35455
sg19
(lp35456
sg21
I0
sba(iArchitecture
Entity
p35457
(dp35458
g11
(lp35459
sg13
S'com.google.common.hash.Hashing$Murmur3_32Holder'
p35460
sg15
(lp35461
sg17
(lp35462
sg19
(lp35463
sg21
I0
sba(iArchitecture
Entity
p35464
(dp35465
g11
(lp35466
sg13
S'com.google.common.hash.Hashing$Sha1Holder'
p35467
sg15
(lp35468
sg17
(lp35469
sg19
(lp35470
sg21
I0
sba(iArchitecture
Entity
p35471
(dp35472
g11
(lp35473
sg13
S'com.google.common.hash.Hashing$Sha256Holder'
p35474
sg15
(lp35475
sg17
(lp35476
sg19
(lp35477
sg21
I0
sba(iArchitecture
Entity
p35478
(dp35479
g11
(lp35480
sg13
S'com.google.common.hash.Hashing$Sha384Holder'
p35481
sg15
(lp35482
sg17
(lp35483
sg19
(lp35484
sg21
I0
sba(iArchitecture
Entity
p35485
(dp35486
g11
(lp35487
sg13
S'com.google.common.hash.Hashing$Sha512Holder'
p35488
sg15
(lp35489
sg17
(lp35490
sg19
(lp35491
sg21
I0
sba(iArchitecture
Entity
p35492
(dp35493
g11
(lp35494
sg13
S'com.google.common.hash.Hashing$SipHash24Holder'
p35495
sg15
(lp35496
sg17
(lp35497
sg19
(lp35498
sg21
I0
sba(iArchitecture
Entity
p35499
(dp35500
g11
(lp35501
sg13
S'com.google.common.hash.LittleEndianByteArray'
p35502
sg15
(lp35503
sg17
(lp35504
sg19
(lp35505
sg21
I0
sba(iArchitecture
Entity
p35506
(dp35507
g11
(lp35508
sg13
S'com.google.common.hash.LittleEndianByteArray$1'
p35509
sg15
(lp35510
sg17
(lp35511
sg19
(lp35512
sg21
I0
sba(iArchitecture
Entity
p35513
(dp35514
g11
(lp35515
sg13
S'com.google.common.hash.LittleEndianByteArray$JavaLittleEndianBytes'
p35516
sg15
(lp35517
sg17
(lp35518
sg19
(lp35519
sg21
I0
sba(iArchitecture
Entity
p35520
(dp35521
g11
(lp35522
sg13
S'com.google.common.hash.LittleEndianByteArray$JavaLittleEndianBytes$1'
p35523
sg15
(lp35524
sg17
(lp35525
sg19
(lp35526
sg21
I0
sba(iArchitecture
Entity
p35527
(dp35528
g11
(lp35529
sg13
S'com.google.common.hash.LittleEndianByteArray$LittleEndianBytes'
p35530
sg15
(lp35531
sg17
(lp35532
sg19
(lp35533
sg21
I0
sba(iArchitecture
Entity
p35534
(dp35535
g11
(lp35536
sg13
S'com.google.common.hash.LittleEndianByteArray$UnsafeByteArray'
p35537
sg15
(lp35538
sg17
(lp35539
sg19
(lp35540
sg21
I0
sba(iArchitecture
Entity
p35541
(dp35542
g11
(lp35543
sg13
S'com.google.common.hash.LittleEndianByteArray$UnsafeByteArray$1'
p35544
sg15
(lp35545
sg17
(lp35546
sg19
(lp35547
sg21
I0
sba(iArchitecture
Entity
p35548
(dp35549
g11
(lp35550
sg13
S'com.google.common.hash.LittleEndianByteArray$UnsafeByteArray$2'
p35551
sg15
(lp35552
sg17
(lp35553
sg19
(lp35554
sg21
I0
sba(iArchitecture
Entity
p35555
(dp35556
g11
(lp35557
sg13
S'com.google.common.hash.LittleEndianByteArray$UnsafeByteArray$3'
p35558
sg15
(lp35559
sg17
(lp35560
sg19
(lp35561
sg21
I0
sba(iArchitecture
Entity
p35562
(dp35563
g11
(lp35564
sg13
S'com.google.common.hash.MacHashFunction'
p35565
sg15
(lp35566
sg17
(lp35567
sg19
(lp35568
sg21
I0
sba(iArchitecture
Entity
p35569
(dp35570
g11
(lp35571
sg13
S'com.google.common.hash.MacHashFunction$1'
p35572
sg15
(lp35573
sg17
(lp35574
sg19
(lp35575
sg21
I0
sba(iArchitecture
Entity
p35576
(dp35577
g11
(lp35578
sg13
S'com.google.common.hash.MacHashFunction$MacHasher'
p35579
sg15
(lp35580
sg17
(lp35581
sg19
(lp35582
sg21
I0
sba(iArchitecture
Entity
p35583
(dp35584
g11
(lp35585
sg13
S'com.google.common.hash.MessageDigestHashFunction'
p35586
sg15
(lp35587
sg17
(lp35588
sg19
(lp35589
sg21
I0
sba(iArchitecture
Entity
p35590
(dp35591
g11
(lp35592
sg13
S'com.google.common.hash.MessageDigestHashFunction$1'
p35593
sg15
(lp35594
sg17
(lp35595
sg19
(lp35596
sg21
I0
sba(iArchitecture
Entity
p35597
(dp35598
g11
(lp35599
sg13
S'com.google.common.hash.MessageDigestHashFunction$MessageDigestHasher'
p35600
sg15
(lp35601
sg17
(lp35602
sg19
(lp35603
sg21
I0
sba(iArchitecture
Entity
p35604
(dp35605
g11
(lp35606
sg13
S'com.google.common.hash.MessageDigestHashFunction$SerializedForm'
p35607
sg15
(lp35608
sg17
(lp35609
sg19
(lp35610
sg21
I0
sba(iArchitecture
Entity
p35611
(dp35612
g11
(lp35613
sg13
S'com.google.common.hash.Murmur3_128HashFunction'
p35614
sg15
(lp35615
sg17
(lp35616
sg19
(lp35617
sg21
I0
sba(iArchitecture
Entity
p35618
(dp35619
g11
(lp35620
sg13
S'com.google.common.hash.Murmur3_128HashFunction$Murmur3_128Hasher'
p35621
sg15
(lp35622
sg17
(lp35623
sg19
(lp35624
sg21
I0
sba(iArchitecture
Entity
p35625
(dp35626
g11
(lp35627
sg13
S'com.google.common.hash.Murmur3_32HashFunction'
p35628
sg15
(lp35629
sg17
(lp35630
sg19
(lp35631
sg21
I0
sba(iArchitecture
Entity
p35632
(dp35633
g11
(lp35634
sg13
S'com.google.common.hash.Murmur3_32HashFunction$Murmur3_32Hasher'
p35635
sg15
(lp35636
sg17
(lp35637
sg19
(lp35638
sg21
I0
sba(iArchitecture
Entity
p35639
(dp35640
g11
(lp35641
sg13
S'com.google.common.hash.PrimitiveSink'
p35642
sg15
(lp35643
sg17
(lp35644
sg19
(lp35645
sg21
I0
sba(iArchitecture
Entity
p35646
(dp35647
g11
(lp35648
sg13
S'com.google.common.hash.SipHashFunction'
p35649
sg15
(lp35650
sg17
(lp35651
sg19
(lp35652
sg21
I0
sba(iArchitecture
Entity
p35653
(dp35654
g11
(lp35655
sg13
S'com.google.common.hash.SipHashFunction$SipHasher'
p35656
sg15
(lp35657
sg17
(lp35658
sg19
(lp35659
sg21
I0
sba(iArchitecture
Entity
p35660
(dp35661
g11
(lp35662
sg13
S'sun.misc.Unsafe'
p35663
sg15
(lp35664
sg17
(lp35665
sg19
(lp35666
sg21
I0
sbasg1135
(lp35667
g35096
ag35103
ag35110
ag35117
ag35124
ag35131
ag35138
ag35145
ag35152
ag35159
ag35166
ag35173
ag35180
ag35187
ag35194
ag35201
ag35208
ag35215
ag35222
ag35229
ag35236
ag35243
ag35250
ag35257
ag35264
ag35271
ag35278
ag35285
ag35292
ag35299
ag35306
ag35313
ag35320
ag35327
ag35334
ag35341
ag35348
ag35355
ag35362
ag35369
ag35376
ag35383
ag35390
ag35397
ag35404
ag35411
ag35418
ag35425
ag35432
ag35439
ag35446
ag35453
ag35460
ag35467
ag35474
ag35481
ag35488
ag35495
ag35502
ag35509
ag35516
ag35523
ag35530
ag35537
ag35544
ag35551
ag35558
ag35565
ag35572
ag35579
ag35586
ag35593
ag35600
ag35607
ag35614
ag35621
ag35628
ag35635
ag35642
ag35649
ag35656
ag35663
asg1137
I0
sg21
I0
sg1138
S'com.google.common.hash.ss'
p35668
sba(iArchitecture
Cluster
p35669
(dp35670
g7
(lp35671
(iArchitecture
Entity
p35672
(dp35673
g11
(lp35674
sg13
S'com.google.common.io.AppendableWriter'
p35675
sg15
(lp35676
sg17
(lp35677
sg19
(lp35678
sg21
I0
sba(iArchitecture
Entity
p35679
(dp35680
g11
(lp35681
sg13
S'com.google.common.io.BaseEncoding'
p35682
sg15
(lp35683
sg17
(lp35684
sg19
(lp35685
sg21
I0
sba(iArchitecture
Entity
p35686
(dp35687
g11
(lp35688
sg13
S'com.google.common.io.BaseEncoding$1'
p35689
sg15
(lp35690
sg17
(lp35691
sg19
(lp35692
sg21
I0
sba(iArchitecture
Entity
p35693
(dp35694
g11
(lp35695
sg13
S'com.google.common.io.BaseEncoding$2'
p35696
sg15
(lp35697
sg17
(lp35698
sg19
(lp35699
sg21
I0
sba(iArchitecture
Entity
p35700
(dp35701
g11
(lp35702
sg13
S'com.google.common.io.BaseEncoding$3'
p35703
sg15
(lp35704
sg17
(lp35705
sg19
(lp35706
sg21
I0
sba(iArchitecture
Entity
p35707
(dp35708
g11
(lp35709
sg13
S'com.google.common.io.BaseEncoding$4'
p35710
sg15
(lp35711
sg17
(lp35712
sg19
(lp35713
sg21
I0
sba(iArchitecture
Entity
p35714
(dp35715
g11
(lp35716
sg13
S'com.google.common.io.BaseEncoding$5'
p35717
sg15
(lp35718
sg17
(lp35719
sg19
(lp35720
sg21
I0
sba(iArchitecture
Entity
p35721
(dp35722
g11
(lp35723
sg13
S'com.google.common.io.BaseEncoding$Alphabet'
p35724
sg15
(lp35725
sg17
(lp35726
sg19
(lp35727
sg21
I0
sba(iArchitecture
Entity
p35728
(dp35729
g11
(lp35730
sg13
S'com.google.common.io.BaseEncoding$Base16Encoding'
p35731
sg15
(lp35732
sg17
(lp35733
sg19
(lp35734
sg21
I0
sba(iArchitecture
Entity
p35735
(dp35736
g11
(lp35737
sg13
S'com.google.common.io.BaseEncoding$Base64Encoding'
p35738
sg15
(lp35739
sg17
(lp35740
sg19
(lp35741
sg21
I0
sba(iArchitecture
Entity
p35742
(dp35743
g11
(lp35744
sg13
S'com.google.common.io.BaseEncoding$DecodingException'
p35745
sg15
(lp35746
sg17
(lp35747
sg19
(lp35748
sg21
I0
sba(iArchitecture
Entity
p35749
(dp35750
g11
(lp35751
sg13
S'com.google.common.io.BaseEncoding$SeparatedBaseEncoding'
p35752
sg15
(lp35753
sg17
(lp35754
sg19
(lp35755
sg21
I0
sba(iArchitecture
Entity
p35756
(dp35757
g11
(lp35758
sg13
S'com.google.common.io.BaseEncoding$StandardBaseEncoding'
p35759
sg15
(lp35760
sg17
(lp35761
sg19
(lp35762
sg21
I0
sba(iArchitecture
Entity
p35763
(dp35764
g11
(lp35765
sg13
S'com.google.common.io.BaseEncoding$StandardBaseEncoding$1'
p35766
sg15
(lp35767
sg17
(lp35768
sg19
(lp35769
sg21
I0
sba(iArchitecture
Entity
p35770
(dp35771
g11
(lp35772
sg13
S'com.google.common.io.BaseEncoding$StandardBaseEncoding$2'
p35773
sg15
(lp35774
sg17
(lp35775
sg19
(lp35776
sg21
I0
sba(iArchitecture
Entity
p35777
(dp35778
g11
(lp35779
sg13
S'com.google.common.io.ByteArrayDataInput'
p35780
sg15
(lp35781
sg17
(lp35782
sg19
(lp35783
sg21
I0
sba(iArchitecture
Entity
p35784
(dp35785
g11
(lp35786
sg13
S'com.google.common.io.ByteArrayDataOutput'
p35787
sg15
(lp35788
sg17
(lp35789
sg19
(lp35790
sg21
I0
sba(iArchitecture
Entity
p35791
(dp35792
g11
(lp35793
sg13
S'com.google.common.io.ByteProcessor'
p35794
sg15
(lp35795
sg17
(lp35796
sg19
(lp35797
sg21
I0
sba(iArchitecture
Entity
p35798
(dp35799
g11
(lp35800
sg13
S'com.google.common.io.ByteSink'
p35801
sg15
(lp35802
sg17
(lp35803
sg19
(lp35804
sg21
I0
sba(iArchitecture
Entity
p35805
(dp35806
g11
(lp35807
sg13
S'com.google.common.io.ByteSink$1'
p35808
sg15
(lp35809
sg17
(lp35810
sg19
(lp35811
sg21
I0
sba(iArchitecture
Entity
p35812
(dp35813
g11
(lp35814
sg13
S'com.google.common.io.ByteSink$AsCharSink'
p35815
sg15
(lp35816
sg17
(lp35817
sg19
(lp35818
sg21
I0
sba(iArchitecture
Entity
p35819
(dp35820
g11
(lp35821
V2843
p35822
ag35822
asg13
S'com.google.common.io.ByteSource'
p35823
sg15
(lp35824
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35825
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35826
asg17
(lp35827
(lp35828
I0
aag35828
asg19
(lp35829
VOptimize {Byte,Char}Source.isEmpty() for known-non-empty sources
p35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35831
(dp35832
g11
(lp35833
g35822
ag35822
asg13
S'com.google.common.io.ByteSource$AsCharSource'
p35834
sg15
(lp35835
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35836
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35837
asg17
(lp35838
g35828
ag35828
asg19
(lp35839
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35840
(dp35841
g11
(lp35842
g35822
ag35822
asg13
S'com.google.common.io.ByteSource$ByteArrayByteSource'
p35843
sg15
(lp35844
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35845
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35846
asg17
(lp35847
g35828
ag35828
asg19
(lp35848
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35849
(dp35850
g11
(lp35851
g35822
ag35822
asg13
S'com.google.common.io.ByteSource$ConcatenatedByteSource'
p35852
sg15
(lp35853
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35854
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35855
asg17
(lp35856
g35828
ag35828
asg19
(lp35857
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35858
(dp35859
g11
(lp35860
g35822
ag35822
asg13
S'com.google.common.io.ByteSource$EmptyByteSource'
p35861
sg15
(lp35862
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35863
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35864
asg17
(lp35865
g35828
ag35828
asg19
(lp35866
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35867
(dp35868
g11
(lp35869
g35822
ag35822
asg13
S'com.google.common.io.ByteSource$SlicedByteSource'
p35870
sg15
(lp35871
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35872
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35873
asg17
(lp35874
g35828
ag35828
asg19
(lp35875
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35876
(dp35877
g11
(lp35878
sg13
S'com.google.common.io.ByteStreams'
p35879
sg15
(lp35880
sg17
(lp35881
sg19
(lp35882
sg21
I0
sba(iArchitecture
Entity
p35883
(dp35884
g11
(lp35885
sg13
S'com.google.common.io.ByteStreams$1'
p35886
sg15
(lp35887
sg17
(lp35888
sg19
(lp35889
sg21
I0
sba(iArchitecture
Entity
p35890
(dp35891
g11
(lp35892
sg13
S'com.google.common.io.ByteStreams$ByteArrayDataInputStream'
p35893
sg15
(lp35894
sg17
(lp35895
sg19
(lp35896
sg21
I0
sba(iArchitecture
Entity
p35897
(dp35898
g11
(lp35899
sg13
S'com.google.common.io.ByteStreams$ByteArrayDataOutputStream'
p35900
sg15
(lp35901
sg17
(lp35902
sg19
(lp35903
sg21
I0
sba(iArchitecture
Entity
p35904
(dp35905
g11
(lp35906
sg13
S'com.google.common.io.ByteStreams$FastByteArrayOutputStream'
p35907
sg15
(lp35908
sg17
(lp35909
sg19
(lp35910
sg21
I0
sba(iArchitecture
Entity
p35911
(dp35912
g11
(lp35913
sg13
S'com.google.common.io.ByteStreams$LimitedInputStream'
p35914
sg15
(lp35915
sg17
(lp35916
sg19
(lp35917
sg21
I0
sba(iArchitecture
Entity
p35918
(dp35919
g11
(lp35920
sg13
S'com.google.common.io.CharSequenceReader'
p35921
sg15
(lp35922
sg17
(lp35923
sg19
(lp35924
sg21
I0
sba(iArchitecture
Entity
p35925
(dp35926
g11
(lp35927
sg13
S'com.google.common.io.CharSink'
p35928
sg15
(lp35929
sg17
(lp35930
sg19
(lp35931
sg21
I0
sba(iArchitecture
Entity
p35932
(dp35933
g11
(lp35934
g35822
ag35822
asg13
S'com.google.common.io.CharSource'
p35935
sg15
(lp35936
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35937
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35938
asg17
(lp35939
g35828
ag35828
asg19
(lp35940
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35941
(dp35942
g11
(lp35943
g35822
ag35822
asg13
S'com.google.common.io.CharSource$AsByteSource'
p35944
sg15
(lp35945
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35946
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35947
asg17
(lp35948
g35828
ag35828
asg19
(lp35949
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35950
(dp35951
g11
(lp35952
g35822
ag35822
asg13
S'com.google.common.io.CharSource$CharSequenceCharSource'
p35953
sg15
(lp35954
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35955
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35956
asg17
(lp35957
g35828
ag35828
asg19
(lp35958
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35959
(dp35960
g11
(lp35961
g35822
ag35822
asg13
S'com.google.common.io.CharSource$CharSequenceCharSource$1'
p35962
sg15
(lp35963
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35964
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35965
asg17
(lp35966
g35828
ag35828
asg19
(lp35967
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35968
(dp35969
g11
(lp35970
g35822
ag35822
asg13
S'com.google.common.io.CharSource$ConcatenatedCharSource'
p35971
sg15
(lp35972
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35973
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35974
asg17
(lp35975
g35828
ag35828
asg19
(lp35976
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35977
(dp35978
g11
(lp35979
g35822
ag35822
asg13
S'com.google.common.io.CharSource$EmptyCharSource'
p35980
sg15
(lp35981
VThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35982
aVThe default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\u000a\u000aHere is what `ByteSource` does now:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\u000a    return true;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aI feel like it should do this instead:\u000a\u000a```java\u000apublic boolean isEmpty() throws IOException {\u000a  Optional<Long> sizeIfKnown = sizeIfKnown();\u000a  if (sizeIfKnown.isPresent()) {\u000a    return sizeIfKnown.get() == 0L;\u000a  }\u000a  // Fall back to reading a byte from the input stream...\u000a```\u000a\u000aThat way it avoids reading the input stream when the size is known to be non-zero.\u000a\u000aI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.
p35983
asg17
(lp35984
g35828
ag35828
asg19
(lp35985
g35830
ag35830
asg21
I0
sba(iArchitecture
Entity
p35986
(dp35987
g11
(lp35988
sg13
S'com.google.common.io.CharStreams'
p35989
sg15
(lp35990
sg17
(lp35991
sg19
(lp35992
sg21
I0
sba(iArchitecture
Entity
p35993
(dp35994
g11
(lp35995
sg13
S'com.google.common.io.CharStreams$NullWriter'
p35996
sg15
(lp35997
sg17
(lp35998
sg19
(lp35999
sg21
I0
sba(iArchitecture
Entity
p36000
(dp36001
g11
(lp36002
sg13
S'com.google.common.io.Closeables'
p36003
sg15
(lp36004
sg17
(lp36005
sg19
(lp36006
sg21
I0
sba(iArchitecture
Entity
p36007
(dp36008
g11
(lp36009
sg13
S'com.google.common.io.Closer'
p36010
sg15
(lp36011
sg17
(lp36012
sg19
(lp36013
sg21
I0
sba(iArchitecture
Entity
p36014
(dp36015
g11
(lp36016
sg13
S'com.google.common.io.Closer$LoggingSuppressor'
p36017
sg15
(lp36018
sg17
(lp36019
sg19
(lp36020
sg21
I0
sba(iArchitecture
Entity
p36021
(dp36022
g11
(lp36023
sg13
S'com.google.common.io.Closer$SuppressingSuppressor'
p36024
sg15
(lp36025
sg17
(lp36026
sg19
(lp36027
sg21
I0
sba(iArchitecture
Entity
p36028
(dp36029
g11
(lp36030
sg13
S'com.google.common.io.Closer$Suppressor'
p36031
sg15
(lp36032
sg17
(lp36033
sg19
(lp36034
sg21
I0
sba(iArchitecture
Entity
p36035
(dp36036
g11
(lp36037
sg13
S'com.google.common.io.FileBackedOutputStream'
p36038
sg15
(lp36039
sg17
(lp36040
sg19
(lp36041
sg21
I0
sba(iArchitecture
Entity
p36042
(dp36043
g11
(lp36044
sg13
S'com.google.common.io.FileBackedOutputStream$1'
p36045
sg15
(lp36046
sg17
(lp36047
sg19
(lp36048
sg21
I0
sba(iArchitecture
Entity
p36049
(dp36050
g11
(lp36051
sg13
S'com.google.common.io.FileBackedOutputStream$2'
p36052
sg15
(lp36053
sg17
(lp36054
sg19
(lp36055
sg21
I0
sba(iArchitecture
Entity
p36056
(dp36057
g11
(lp36058
sg13
S'com.google.common.io.FileBackedOutputStream$MemoryOutput'
p36059
sg15
(lp36060
sg17
(lp36061
sg19
(lp36062
sg21
I0
sba(iArchitecture
Entity
p36063
(dp36064
g11
(lp36065
sg13
S'com.google.common.io.FileWriteMode'
p36066
sg15
(lp36067
sg17
(lp36068
sg19
(lp36069
sg21
I0
sba(iArchitecture
Entity
p36070
(dp36071
g11
(lp36072
sg13
S'com.google.common.io.Files'
p36073
sg15
(lp36074
sg17
(lp36075
sg19
(lp36076
sg21
I0
sba(iArchitecture
Entity
p36077
(dp36078
g11
(lp36079
sg13
S'com.google.common.io.Files$1'
p36080
sg15
(lp36081
sg17
(lp36082
sg19
(lp36083
sg21
I0
sba(iArchitecture
Entity
p36084
(dp36085
g11
(lp36086
sg13
S'com.google.common.io.Files$2'
p36087
sg15
(lp36088
sg17
(lp36089
sg19
(lp36090
sg21
I0
sba(iArchitecture
Entity
p36091
(dp36092
g11
(lp36093
sg13
S'com.google.common.io.Files$FileByteSink'
p36094
sg15
(lp36095
sg17
(lp36096
sg19
(lp36097
sg21
I0
sba(iArchitecture
Entity
p36098
(dp36099
g11
(lp36100
sg13
S'com.google.common.io.Files$FileByteSource'
p36101
sg15
(lp36102
sg17
(lp36103
sg19
(lp36104
sg21
I0
sba(iArchitecture
Entity
p36105
(dp36106
g11
(lp36107
sg13
S'com.google.common.io.Files$FilePredicate'
p36108
sg15
(lp36109
sg17
(lp36110
sg19
(lp36111
sg21
I0
sba(iArchitecture
Entity
p36112
(dp36113
g11
(lp36114
sg13
S'com.google.common.io.Files$FilePredicate$1'
p36115
sg15
(lp36116
sg17
(lp36117
sg19
(lp36118
sg21
I0
sba(iArchitecture
Entity
p36119
(dp36120
g11
(lp36121
sg13
S'com.google.common.io.Files$FilePredicate$2'
p36122
sg15
(lp36123
sg17
(lp36124
sg19
(lp36125
sg21
I0
sba(iArchitecture
Entity
p36126
(dp36127
g11
(lp36128
sg13
S'com.google.common.io.InsecureRecursiveDeleteException'
p36129
sg15
(lp36130
sg17
(lp36131
sg19
(lp36132
sg21
I0
sba(iArchitecture
Entity
p36133
(dp36134
g11
(lp36135
sg13
S'com.google.common.io.LineBuffer'
p36136
sg15
(lp36137
sg17
(lp36138
sg19
(lp36139
sg21
I0
sba(iArchitecture
Entity
p36140
(dp36141
g11
(lp36142
sg13
S'com.google.common.io.LineProcessor'
p36143
sg15
(lp36144
sg17
(lp36145
sg19
(lp36146
sg21
I0
sba(iArchitecture
Entity
p36147
(dp36148
g11
(lp36149
sg13
S'com.google.common.io.LineReader'
p36150
sg15
(lp36151
sg17
(lp36152
sg19
(lp36153
sg21
I0
sba(iArchitecture
Entity
p36154
(dp36155
g11
(lp36156
sg13
S'com.google.common.io.LineReader$1'
p36157
sg15
(lp36158
sg17
(lp36159
sg19
(lp36160
sg21
I0
sba(iArchitecture
Entity
p36161
(dp36162
g11
(lp36163
sg13
S'com.google.common.io.MoreFiles'
p36164
sg15
(lp36165
sg17
(lp36166
sg19
(lp36167
sg21
I0
sba(iArchitecture
Entity
p36168
(dp36169
g11
(lp36170
sg13
S'com.google.common.io.MoreFiles$1'
p36171
sg15
(lp36172
sg17
(lp36173
sg19
(lp36174
sg21
I0
sba(iArchitecture
Entity
p36175
(dp36176
g11
(lp36177
sg13
S'com.google.common.io.MoreFiles$2'
p36178
sg15
(lp36179
sg17
(lp36180
sg19
(lp36181
sg21
I0
sba(iArchitecture
Entity
p36182
(dp36183
g11
(lp36184
sg13
S'com.google.common.io.MoreFiles$DirectoryTreeTraverser'
p36185
sg15
(lp36186
sg17
(lp36187
sg19
(lp36188
sg21
I0
sba(iArchitecture
Entity
p36189
(dp36190
g11
(lp36191
sg13
S'com.google.common.io.MoreFiles$PathByteSink'
p36192
sg15
(lp36193
sg17
(lp36194
sg19
(lp36195
sg21
I0
sba(iArchitecture
Entity
p36196
(dp36197
g11
(lp36198
sg13
S'com.google.common.io.MoreFiles$PathByteSource'
p36199
sg15
(lp36200
sg17
(lp36201
sg19
(lp36202
sg21
I0
sba(iArchitecture
Entity
p36203
(dp36204
g11
(lp36205
sg13
S'com.google.common.io.MoreFiles$PathByteSource$1'
p36206
sg15
(lp36207
sg17
(lp36208
sg19
(lp36209
sg21
I0
sba(iArchitecture
Entity
p36210
(dp36211
g11
(lp36212
V2996
p36213
ag36213
ag36213
ag36213
asg13
S'com.google.common.io.MultiInputStream'
p36214
sg15
(lp36215
VUsing `guava-23.0` (and earlier versions), `com.google.common.io.MultiInputStream` produces a stack overflow when it is given sufficiently many empty `ByteSource` instances.\u000a\u000aTest cases that reproduce the behavior:\u000a\u000a```java\u000aimport java.io.InputStream;\u000aimport java.util.List;\u000a\u000aimport org.junit.Before;\u000aimport org.junit.Test;\u000a\u000aimport com.google.common.collect.Lists;\u000aimport com.google.common.io.ByteSource;\u000a\u000apublic class MultiInputStreamTest {\u000a\u000a  /** Adjust this according to the thread stack size. */\u000a  private static final int LARGE_ENOUGH_FOR_CURRENT_STACK_SIZE = 1000000;\u000a\u000a  private ByteSource       concatenated;\u000a\u000a  public @Before void setup() throws Exception {\u000a    final List<ByteSource> emptySources = Lists.newArrayList();\u000a    for (int i = 0; i < LARGE_ENOUGH_FOR_CURRENT_STACK_SIZE; i++) {\u000a      emptySources.add(ByteSource.empty());\u000a    }\u000a    // produce a ConcatenatedByteSource which in turn produces\u000a    // a MultiInputStream\u000a    concatenated = ByteSource.concat(emptySources);\u000a  }\u000a\u000a  public @Test void stackOverflowErrorOnEmptySources1() throws Exception {\u000a    try (InputStream in = concatenated.openStream()) {\u000a      in.read();\u000a    }\u000a  }\u000a\u000a  public @Test void stackOverflowErrorOnEmptySources2() throws Exception {\u000a    try (InputStream in = concatenated.openStream()) {\u000a      in.read(new byte[1], 0, 1);\u000a    }\u000a  }\u000a\u000a}\u000a```\u000a\u000aThe condensed exception stack traces produced by the respective test case (which appear to be truncated):\u000a\u000a```\u000a$ uniq -c stack1\u000a   1 java.lang.StackOverflowError\u000a   1 	at com.google.common.io.ByteSource$ByteArrayByteSource.openStream(ByteSource.java:574)\u000a   1 	at com.google.common.io.MultiInputStream.advance(MultiInputStream.java:65)\u000a   1 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:89)\u000a1021 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:90)\u000a```\u000a\u000a```\u000a$ uniq -c stack2\u000a   1 java.lang.StackOverflowError\u000a   1 	at com.google.common.io.MultiInputStream.close(MultiInputStream.java:52)\u000a   1 	at com.google.common.io.MultiInputStream.advance(MultiInputStream.java:63)\u000a   1 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:102)\u000a1021 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:103)\u000a```
p36216
aVUsing `guava-23.0` (and earlier versions), `com.google.common.io.MultiInputStream` produces a stack overflow when it is given sufficiently many empty `ByteSource` instances.\u000a\u000aTest cases that reproduce the behavior:\u000a\u000a```java\u000aimport java.io.InputStream;\u000aimport java.util.List;\u000a\u000aimport org.junit.Before;\u000aimport org.junit.Test;\u000a\u000aimport com.google.common.collect.Lists;\u000aimport com.google.common.io.ByteSource;\u000a\u000apublic class MultiInputStreamTest {\u000a\u000a  /** Adjust this according to the thread stack size. */\u000a  private static final int LARGE_ENOUGH_FOR_CURRENT_STACK_SIZE = 1000000;\u000a\u000a  private ByteSource       concatenated;\u000a\u000a  public @Before void setup() throws Exception {\u000a    final List<ByteSource> emptySources = Lists.newArrayList();\u000a    for (int i = 0; i < LARGE_ENOUGH_FOR_CURRENT_STACK_SIZE; i++) {\u000a      emptySources.add(ByteSource.empty());\u000a    }\u000a    // produce a ConcatenatedByteSource which in turn produces\u000a    // a MultiInputStream\u000a    concatenated = ByteSource.concat(emptySources);\u000a  }\u000a\u000a  public @Test void stackOverflowErrorOnEmptySources1() throws Exception {\u000a    try (InputStream in = concatenated.openStream()) {\u000a      in.read();\u000a    }\u000a  }\u000a\u000a  public @Test void stackOverflowErrorOnEmptySources2() throws Exception {\u000a    try (InputStream in = concatenated.openStream()) {\u000a      in.read(new byte[1], 0, 1);\u000a    }\u000a  }\u000a\u000a}\u000a```\u000a\u000aThe condensed exception stack traces produced by the respective test case (which appear to be truncated):\u000a\u000a```\u000a$ uniq -c stack1\u000a   1 java.lang.StackOverflowError\u000a   1 	at com.google.common.io.ByteSource$ByteArrayByteSource.openStream(ByteSource.java:574)\u000a   1 	at com.google.common.io.MultiInputStream.advance(MultiInputStream.java:65)\u000a   1 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:89)\u000a1021 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:90)\u000a```\u000a\u000a```\u000a$ uniq -c stack2\u000a   1 java.lang.StackOverflowError\u000a   1 	at com.google.common.io.MultiInputStream.close(MultiInputStream.java:52)\u000a   1 	at com.google.common.io.MultiInputStream.advance(MultiInputStream.java:63)\u000a   1 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:102)\u000a1021 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:103)\u000a```
p36217
aVUsing `guava-23.0` (and earlier versions), `com.google.common.io.MultiInputStream` produces a stack overflow when it is given sufficiently many empty `ByteSource` instances.\u000a\u000aTest cases that reproduce the behavior:\u000a\u000a```java\u000aimport java.io.InputStream;\u000aimport java.util.List;\u000a\u000aimport org.junit.Before;\u000aimport org.junit.Test;\u000a\u000aimport com.google.common.collect.Lists;\u000aimport com.google.common.io.ByteSource;\u000a\u000apublic class MultiInputStreamTest {\u000a\u000a  /** Adjust this according to the thread stack size. */\u000a  private static final int LARGE_ENOUGH_FOR_CURRENT_STACK_SIZE = 1000000;\u000a\u000a  private ByteSource       concatenated;\u000a\u000a  public @Before void setup() throws Exception {\u000a    final List<ByteSource> emptySources = Lists.newArrayList();\u000a    for (int i = 0; i < LARGE_ENOUGH_FOR_CURRENT_STACK_SIZE; i++) {\u000a      emptySources.add(ByteSource.empty());\u000a    }\u000a    // produce a ConcatenatedByteSource which in turn produces\u000a    // a MultiInputStream\u000a    concatenated = ByteSource.concat(emptySources);\u000a  }\u000a\u000a  public @Test void stackOverflowErrorOnEmptySources1() throws Exception {\u000a    try (InputStream in = concatenated.openStream()) {\u000a      in.read();\u000a    }\u000a  }\u000a\u000a  public @Test void stackOverflowErrorOnEmptySources2() throws Exception {\u000a    try (InputStream in = concatenated.openStream()) {\u000a      in.read(new byte[1], 0, 1);\u000a    }\u000a  }\u000a\u000a}\u000a```\u000a\u000aThe condensed exception stack traces produced by the respective test case (which appear to be truncated):\u000a\u000a```\u000a$ uniq -c stack1\u000a   1 java.lang.StackOverflowError\u000a   1 	at com.google.common.io.ByteSource$ByteArrayByteSource.openStream(ByteSource.java:574)\u000a   1 	at com.google.common.io.MultiInputStream.advance(MultiInputStream.java:65)\u000a   1 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:89)\u000a1021 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:90)\u000a```\u000a\u000a```\u000a$ uniq -c stack2\u000a   1 java.lang.StackOverflowError\u000a   1 	at com.google.common.io.MultiInputStream.close(MultiInputStream.java:52)\u000a   1 	at com.google.common.io.MultiInputStream.advance(MultiInputStream.java:63)\u000a   1 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:102)\u000a1021 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:103)\u000a```
p36218
aVUsing `guava-23.0` (and earlier versions), `com.google.common.io.MultiInputStream` produces a stack overflow when it is given sufficiently many empty `ByteSource` instances.\u000a\u000aTest cases that reproduce the behavior:\u000a\u000a```java\u000aimport java.io.InputStream;\u000aimport java.util.List;\u000a\u000aimport org.junit.Before;\u000aimport org.junit.Test;\u000a\u000aimport com.google.common.collect.Lists;\u000aimport com.google.common.io.ByteSource;\u000a\u000apublic class MultiInputStreamTest {\u000a\u000a  /** Adjust this according to the thread stack size. */\u000a  private static final int LARGE_ENOUGH_FOR_CURRENT_STACK_SIZE = 1000000;\u000a\u000a  private ByteSource       concatenated;\u000a\u000a  public @Before void setup() throws Exception {\u000a    final List<ByteSource> emptySources = Lists.newArrayList();\u000a    for (int i = 0; i < LARGE_ENOUGH_FOR_CURRENT_STACK_SIZE; i++) {\u000a      emptySources.add(ByteSource.empty());\u000a    }\u000a    // produce a ConcatenatedByteSource which in turn produces\u000a    // a MultiInputStream\u000a    concatenated = ByteSource.concat(emptySources);\u000a  }\u000a\u000a  public @Test void stackOverflowErrorOnEmptySources1() throws Exception {\u000a    try (InputStream in = concatenated.openStream()) {\u000a      in.read();\u000a    }\u000a  }\u000a\u000a  public @Test void stackOverflowErrorOnEmptySources2() throws Exception {\u000a    try (InputStream in = concatenated.openStream()) {\u000a      in.read(new byte[1], 0, 1);\u000a    }\u000a  }\u000a\u000a}\u000a```\u000a\u000aThe condensed exception stack traces produced by the respective test case (which appear to be truncated):\u000a\u000a```\u000a$ uniq -c stack1\u000a   1 java.lang.StackOverflowError\u000a   1 	at com.google.common.io.ByteSource$ByteArrayByteSource.openStream(ByteSource.java:574)\u000a   1 	at com.google.common.io.MultiInputStream.advance(MultiInputStream.java:65)\u000a   1 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:89)\u000a1021 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:90)\u000a```\u000a\u000a```\u000a$ uniq -c stack2\u000a   1 java.lang.StackOverflowError\u000a   1 	at com.google.common.io.MultiInputStream.close(MultiInputStream.java:52)\u000a   1 	at com.google.common.io.MultiInputStream.advance(MultiInputStream.java:63)\u000a   1 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:102)\u000a1021 	at com.google.common.io.MultiInputStream.read(MultiInputStream.java:103)\u000a```
p36219
asg17
(lp36220
(lp36221
I7
aag36221
ag36221
ag36221
asg19
(lp36222
VMultiInputStream produces stack overflow
p36223
ag36223
ag36223
ag36223
asg21
I0
sba(iArchitecture
Entity
p36224
(dp36225
g11
(lp36226
sg13
S'com.google.common.io.MultiReader'
p36227
sg15
(lp36228
sg17
(lp36229
sg19
(lp36230
sg21
I0
sba(iArchitecture
Entity
p36231
(dp36232
g11
(lp36233
sg13
S'com.google.common.io.ReaderInputStream'
p36234
sg15
(lp36235
sg17
(lp36236
sg19
(lp36237
sg21
I0
sba(iArchitecture
Entity
p36238
(dp36239
g11
(lp36240
sg13
S'com.google.common.io.RecursiveDeleteOption'
p36241
sg15
(lp36242
sg17
(lp36243
sg19
(lp36244
sg21
I0
sba(iArchitecture
Entity
p36245
(dp36246
g11
(lp36247
sg13
S'com.google.common.io.Resources'
p36248
sg15
(lp36249
sg17
(lp36250
sg19
(lp36251
sg21
I0
sba(iArchitecture
Entity
p36252
(dp36253
g11
(lp36254
sg13
S'com.google.common.io.Resources$1'
p36255
sg15
(lp36256
sg17
(lp36257
sg19
(lp36258
sg21
I0
sba(iArchitecture
Entity
p36259
(dp36260
g11
(lp36261
sg13
S'com.google.common.io.Resources$UrlByteSource'
p36262
sg15
(lp36263
sg17
(lp36264
sg19
(lp36265
sg21
I0
sba(iArchitecture
Entity
p36266
(dp36267
g11
(lp36268
sg13
S'com.google.errorprone.annotations.MustBeClosed'
p36269
sg15
(lp36270
sg17
(lp36271
sg19
(lp36272
sg21
I0
sbasg1135
(lp36273
g35675
ag35682
ag35689
ag35696
ag35703
ag35710
ag35717
ag35724
ag35731
ag35738
ag35745
ag35752
ag35759
ag35766
ag35773
ag35780
ag35787
ag35794
ag35801
ag35808
ag35815
ag35823
ag35834
ag35843
ag35852
ag35861
ag35870
ag35879
ag35886
ag35893
ag35900
ag35907
ag35914
ag35921
ag35928
ag35935
ag35944
ag35953
ag35962
ag35971
ag35980
ag35989
ag35996
ag36003
ag36010
ag36017
ag36024
ag36031
ag36038
ag36045
ag36052
ag36059
ag36066
ag36073
ag36080
ag36087
ag36094
ag36101
ag36108
ag36115
ag36122
ag36129
ag36136
ag36143
ag36150
ag36157
ag36164
ag36171
ag36178
ag36185
ag36192
ag36199
ag36206
ag36214
ag36227
ag36234
ag36241
ag36248
ag36255
ag36262
ag36269
asg1137
I0
sg21
I0
sg1138
S'com.google.common.io.ss'
p36274
sba(iArchitecture
Cluster
p36275
(dp36276
g7
(lp36277
(iArchitecture
Entity
p36278
(dp36279
g11
(lp36280
sg13
S'com.google.common.math.BigIntegerMath'
p36281
sg15
(lp36282
sg17
(lp36283
sg19
(lp36284
sg21
I0
sba(iArchitecture
Entity
p36285
(dp36286
g11
(lp36287
sg13
S'com.google.common.math.BigIntegerMath$1'
p36288
sg15
(lp36289
sg17
(lp36290
sg19
(lp36291
sg21
I0
sba(iArchitecture
Entity
p36292
(dp36293
g11
(lp36294
sg13
S'com.google.common.math.DoubleMath'
p36295
sg15
(lp36296
sg17
(lp36297
sg19
(lp36298
sg21
I0
sba(iArchitecture
Entity
p36299
(dp36300
g11
(lp36301
sg13
S'com.google.common.math.DoubleMath$1'
p36302
sg15
(lp36303
sg17
(lp36304
sg19
(lp36305
sg21
I0
sba(iArchitecture
Entity
p36306
(dp36307
g11
(lp36308
sg13
S'com.google.common.math.DoubleUtils'
p36309
sg15
(lp36310
sg17
(lp36311
sg19
(lp36312
sg21
I0
sba(iArchitecture
Entity
p36313
(dp36314
g11
(lp36315
sg13
S'com.google.common.math.IntMath'
p36316
sg15
(lp36317
sg17
(lp36318
sg19
(lp36319
sg21
I0
sba(iArchitecture
Entity
p36320
(dp36321
g11
(lp36322
sg13
S'com.google.common.math.IntMath$1'
p36323
sg15
(lp36324
sg17
(lp36325
sg19
(lp36326
sg21
I0
sba(iArchitecture
Entity
p36327
(dp36328
g11
(lp36329
sg13
S'com.google.common.math.LinearTransformation'
p36330
sg15
(lp36331
sg17
(lp36332
sg19
(lp36333
sg21
I0
sba(iArchitecture
Entity
p36334
(dp36335
g11
(lp36336
sg13
S'com.google.common.math.LinearTransformation$1'
p36337
sg15
(lp36338
sg17
(lp36339
sg19
(lp36340
sg21
I0
sba(iArchitecture
Entity
p36341
(dp36342
g11
(lp36343
sg13
S'com.google.common.math.LinearTransformation$LinearTransformationBuilder'
p36344
sg15
(lp36345
sg17
(lp36346
sg19
(lp36347
sg21
I0
sba(iArchitecture
Entity
p36348
(dp36349
g11
(lp36350
sg13
S'com.google.common.math.LinearTransformation$NaNLinearTransformation'
p36351
sg15
(lp36352
sg17
(lp36353
sg19
(lp36354
sg21
I0
sba(iArchitecture
Entity
p36355
(dp36356
g11
(lp36357
sg13
S'com.google.common.math.LinearTransformation$RegularLinearTransformation'
p36358
sg15
(lp36359
sg17
(lp36360
sg19
(lp36361
sg21
I0
sba(iArchitecture
Entity
p36362
(dp36363
g11
(lp36364
sg13
S'com.google.common.math.LinearTransformation$VerticalLinearTransformation'
p36365
sg15
(lp36366
sg17
(lp36367
sg19
(lp36368
sg21
I0
sba(iArchitecture
Entity
p36369
(dp36370
g11
(lp36371
sg13
S'com.google.common.math.LongMath'
p36372
sg15
(lp36373
sg17
(lp36374
sg19
(lp36375
sg21
I0
sba(iArchitecture
Entity
p36376
(dp36377
g11
(lp36378
sg13
S'com.google.common.math.LongMath$1'
p36379
sg15
(lp36380
sg17
(lp36381
sg19
(lp36382
sg21
I0
sba(iArchitecture
Entity
p36383
(dp36384
g11
(lp36385
sg13
S'com.google.common.math.LongMath$MillerRabinTester'
p36386
sg15
(lp36387
sg17
(lp36388
sg19
(lp36389
sg21
I0
sba(iArchitecture
Entity
p36390
(dp36391
g11
(lp36392
sg13
S'com.google.common.math.LongMath$MillerRabinTester$1'
p36393
sg15
(lp36394
sg17
(lp36395
sg19
(lp36396
sg21
I0
sba(iArchitecture
Entity
p36397
(dp36398
g11
(lp36399
sg13
S'com.google.common.math.LongMath$MillerRabinTester$2'
p36400
sg15
(lp36401
sg17
(lp36402
sg19
(lp36403
sg21
I0
sba(iArchitecture
Entity
p36404
(dp36405
g11
(lp36406
sg13
S'com.google.common.math.MathPreconditions'
p36407
sg15
(lp36408
sg17
(lp36409
sg19
(lp36410
sg21
I0
sba(iArchitecture
Entity
p36411
(dp36412
g11
(lp36413
sg13
S'com.google.common.math.PairedStats'
p36414
sg15
(lp36415
sg17
(lp36416
sg19
(lp36417
sg21
I0
sba(iArchitecture
Entity
p36418
(dp36419
g11
(lp36420
sg13
S'com.google.common.math.PairedStatsAccumulator'
p36421
sg15
(lp36422
sg17
(lp36423
sg19
(lp36424
sg21
I0
sba(iArchitecture
Entity
p36425
(dp36426
g11
(lp36427
sg13
S'com.google.common.math.Quantiles'
p36428
sg15
(lp36429
sg17
(lp36430
sg19
(lp36431
sg21
I0
sba(iArchitecture
Entity
p36432
(dp36433
g11
(lp36434
sg13
S'com.google.common.math.Quantiles$1'
p36435
sg15
(lp36436
sg17
(lp36437
sg19
(lp36438
sg21
I0
sba(iArchitecture
Entity
p36439
(dp36440
g11
(lp36441
sg13
S'com.google.common.math.Quantiles$Scale'
p36442
sg15
(lp36443
sg17
(lp36444
sg19
(lp36445
sg21
I0
sba(iArchitecture
Entity
p36446
(dp36447
g11
(lp36448
sg13
S'com.google.common.math.Quantiles$ScaleAndIndex'
p36449
sg15
(lp36450
sg17
(lp36451
sg19
(lp36452
sg21
I0
sba(iArchitecture
Entity
p36453
(dp36454
g11
(lp36455
sg13
S'com.google.common.math.Quantiles$ScaleAndIndexes'
p36456
sg15
(lp36457
sg17
(lp36458
sg19
(lp36459
sg21
I0
sba(iArchitecture
Entity
p36460
(dp36461
g11
(lp36462
sg13
S'com.google.common.math.Stats'
p36463
sg15
(lp36464
sg17
(lp36465
sg19
(lp36466
sg21
I0
sba(iArchitecture
Entity
p36467
(dp36468
g11
(lp36469
sg13
S'com.google.common.math.StatsAccumulator'
p36470
sg15
(lp36471
sg17
(lp36472
sg19
(lp36473
sg21
I0
sbasg1135
(lp36474
g36281
ag36288
ag36295
ag36302
ag36309
ag36316
ag36323
ag36330
ag36337
ag36344
ag36351
ag36358
ag36365
ag36372
ag36379
ag36386
ag36393
ag36400
ag36407
ag36414
ag36421
ag36428
ag36435
ag36442
ag36449
ag36456
ag36463
ag36470
asg1137
I0
sg21
I0
sg1138
S'com.google.common.math.ss'
p36475
sba(iArchitecture
Cluster
p36476
(dp36477
g7
(lp36478
(iArchitecture
Entity
p36479
(dp36480
g11
(lp36481
sg13
S'com.google.common.base.Charsets'
p36482
sg15
(lp36483
sg17
(lp36484
sg19
(lp36485
sg21
I0
sba(iArchitecture
Entity
p36486
(dp36487
g11
(lp36488
sg13
S'com.google.common.base.Strings'
p36489
sg15
(lp36490
sg17
(lp36491
sg19
(lp36492
sg21
I0
sba(iArchitecture
Entity
p36493
(dp36494
g11
(lp36495
sg13
S'com.google.common.net.HostAndPort'
p36496
sg15
(lp36497
sg17
(lp36498
sg19
(lp36499
sg21
I0
sba(iArchitecture
Entity
p36500
(dp36501
g11
(lp36502
sg13
S'com.google.common.net.HostSpecifier'
p36503
sg15
(lp36504
sg17
(lp36505
sg19
(lp36506
sg21
I0
sba(iArchitecture
Entity
p36507
(dp36508
g11
(lp36509
sg13
S'com.google.common.net.InetAddresses'
p36510
sg15
(lp36511
sg17
(lp36512
sg19
(lp36513
sg21
I0
sba(iArchitecture
Entity
p36514
(dp36515
g11
(lp36516
sg13
S'com.google.common.net.InetAddresses$TeredoInfo'
p36517
sg15
(lp36518
sg17
(lp36519
sg19
(lp36520
sg21
I0
sba(iArchitecture
Entity
p36521
(dp36522
g11
(lp36523
sg13
S'com.google.common.net.InternetDomainName'
p36524
sg15
(lp36525
sg17
(lp36526
sg19
(lp36527
sg21
I0
sba(iArchitecture
Entity
p36528
(dp36529
g11
(lp36530
sg13
S'com.google.common.net.MediaType'
p36531
sg15
(lp36532
sg17
(lp36533
sg19
(lp36534
sg21
I0
sba(iArchitecture
Entity
p36535
(dp36536
g11
(lp36537
sg13
S'com.google.common.net.MediaType$1'
p36538
sg15
(lp36539
sg17
(lp36540
sg19
(lp36541
sg21
I0
sba(iArchitecture
Entity
p36542
(dp36543
g11
(lp36544
sg13
S'com.google.common.net.MediaType$2'
p36545
sg15
(lp36546
sg17
(lp36547
sg19
(lp36548
sg21
I0
sba(iArchitecture
Entity
p36549
(dp36550
g11
(lp36551
sg13
S'com.google.common.net.MediaType$Tokenizer'
p36552
sg15
(lp36553
sg17
(lp36554
sg19
(lp36555
sg21
I0
sba(iArchitecture
Entity
p36556
(dp36557
g11
(lp36558
sg13
S'com.google.common.net.PercentEscaper'
p36559
sg15
(lp36560
sg17
(lp36561
sg19
(lp36562
sg21
I0
sba(iArchitecture
Entity
p36563
(dp36564
g11
(lp36565
sg13
S'com.google.common.net.UrlEscapers'
p36566
sg15
(lp36567
sg17
(lp36568
sg19
(lp36569
sg21
I0
sbasg1135
(lp36570
g36482
ag36489
ag36496
ag36503
ag36510
ag36517
ag36524
ag36531
ag36538
ag36545
ag36552
ag36559
ag36566
asg1137
I0
sg21
I0
sg1138
S'com.google.common.net.ss'
p36571
sba(iArchitecture
Cluster
p36572
(dp36573
g7
(lp36574
(iArchitecture
Entity
p36575
(dp36576
g11
(lp36577
sg13
S'com.google.common.io.LittleEndianDataInputStream'
p36578
sg15
(lp36579
sg17
(lp36580
sg19
(lp36581
sg21
I0
sba(iArchitecture
Entity
p36582
(dp36583
g11
(lp36584
sg13
S'com.google.common.io.LittleEndianDataOutputStream'
p36585
sg15
(lp36586
sg17
(lp36587
sg19
(lp36588
sg21
I0
sba(iArchitecture
Entity
p36589
(dp36590
g11
(lp36591
sg13
S'com.google.common.primitives.Booleans'
p36592
sg15
(lp36593
sg17
(lp36594
sg19
(lp36595
sg21
I0
sba(iArchitecture
Entity
p36596
(dp36597
g11
(lp36598
sg13
S'com.google.common.primitives.Booleans$BooleanArrayAsList'
p36599
sg15
(lp36600
sg17
(lp36601
sg19
(lp36602
sg21
I0
sba(iArchitecture
Entity
p36603
(dp36604
g11
(lp36605
sg13
S'com.google.common.primitives.Booleans$BooleanComparator'
p36606
sg15
(lp36607
sg17
(lp36608
sg19
(lp36609
sg21
I0
sba(iArchitecture
Entity
p36610
(dp36611
g11
(lp36612
sg13
S'com.google.common.primitives.Booleans$LexicographicalComparator'
p36613
sg15
(lp36614
sg17
(lp36615
sg19
(lp36616
sg21
I0
sba(iArchitecture
Entity
p36617
(dp36618
g11
(lp36619
sg13
S'com.google.common.primitives.Bytes'
p36620
sg15
(lp36621
sg17
(lp36622
sg19
(lp36623
sg21
I0
sba(iArchitecture
Entity
p36624
(dp36625
g11
(lp36626
sg13
S'com.google.common.primitives.Bytes$ByteArrayAsList'
p36627
sg15
(lp36628
sg17
(lp36629
sg19
(lp36630
sg21
I0
sba(iArchitecture
Entity
p36631
(dp36632
g11
(lp36633
sg13
S'com.google.common.primitives.Chars'
p36634
sg15
(lp36635
sg17
(lp36636
sg19
(lp36637
sg21
I0
sba(iArchitecture
Entity
p36638
(dp36639
g11
(lp36640
sg13
S'com.google.common.primitives.Chars$CharArrayAsList'
p36641
sg15
(lp36642
sg17
(lp36643
sg19
(lp36644
sg21
I0
sba(iArchitecture
Entity
p36645
(dp36646
g11
(lp36647
sg13
S'com.google.common.primitives.Chars$LexicographicalComparator'
p36648
sg15
(lp36649
sg17
(lp36650
sg19
(lp36651
sg21
I0
sba(iArchitecture
Entity
p36652
(dp36653
g11
(lp36654
sg13
S'com.google.common.primitives.Doubles'
p36655
sg15
(lp36656
sg17
(lp36657
sg19
(lp36658
sg21
I0
sba(iArchitecture
Entity
p36659
(dp36660
g11
(lp36661
sg13
S'com.google.common.primitives.Doubles$DoubleArrayAsList'
p36662
sg15
(lp36663
sg17
(lp36664
sg19
(lp36665
sg21
I0
sba(iArchitecture
Entity
p36666
(dp36667
g11
(lp36668
sg13
S'com.google.common.primitives.Doubles$DoubleConverter'
p36669
sg15
(lp36670
sg17
(lp36671
sg19
(lp36672
sg21
I0
sba(iArchitecture
Entity
p36673
(dp36674
g11
(lp36675
sg13
S'com.google.common.primitives.Doubles$LexicographicalComparator'
p36676
sg15
(lp36677
sg17
(lp36678
sg19
(lp36679
sg21
I0
sba(iArchitecture
Entity
p36680
(dp36681
g11
(lp36682
sg13
S'com.google.common.primitives.Floats'
p36683
sg15
(lp36684
sg17
(lp36685
sg19
(lp36686
sg21
I0
sba(iArchitecture
Entity
p36687
(dp36688
g11
(lp36689
sg13
S'com.google.common.primitives.Floats$FloatArrayAsList'
p36690
sg15
(lp36691
sg17
(lp36692
sg19
(lp36693
sg21
I0
sba(iArchitecture
Entity
p36694
(dp36695
g11
(lp36696
sg13
S'com.google.common.primitives.Floats$FloatConverter'
p36697
sg15
(lp36698
sg17
(lp36699
sg19
(lp36700
sg21
I0
sba(iArchitecture
Entity
p36701
(dp36702
g11
(lp36703
sg13
S'com.google.common.primitives.Floats$LexicographicalComparator'
p36704
sg15
(lp36705
sg17
(lp36706
sg19
(lp36707
sg21
I0
sba(iArchitecture
Entity
p36708
(dp36709
g11
(lp36710
sg13
S'com.google.common.primitives.ImmutableDoubleArray'
p36711
sg15
(lp36712
sg17
(lp36713
sg19
(lp36714
sg21
I0
sba(iArchitecture
Entity
p36715
(dp36716
g11
(lp36717
sg13
S'com.google.common.primitives.ImmutableDoubleArray$1'
p36718
sg15
(lp36719
sg17
(lp36720
sg19
(lp36721
sg21
I0
sba(iArchitecture
Entity
p36722
(dp36723
g11
(lp36724
sg13
S'com.google.common.primitives.ImmutableDoubleArray$AsList'
p36725
sg15
(lp36726
sg17
(lp36727
sg19
(lp36728
sg21
I0
sba(iArchitecture
Entity
p36729
(dp36730
g11
(lp36731
sg13
S'com.google.common.primitives.ImmutableDoubleArray$Builder'
p36732
sg15
(lp36733
sg17
(lp36734
sg19
(lp36735
sg21
I0
sba(iArchitecture
Entity
p36736
(dp36737
g11
(lp36738
sg13
S'com.google.common.primitives.ImmutableIntArray'
p36739
sg15
(lp36740
sg17
(lp36741
sg19
(lp36742
sg21
I0
sba(iArchitecture
Entity
p36743
(dp36744
g11
(lp36745
sg13
S'com.google.common.primitives.ImmutableIntArray$1'
p36746
sg15
(lp36747
sg17
(lp36748
sg19
(lp36749
sg21
I0
sba(iArchitecture
Entity
p36750
(dp36751
g11
(lp36752
sg13
S'com.google.common.primitives.ImmutableIntArray$AsList'
p36753
sg15
(lp36754
sg17
(lp36755
sg19
(lp36756
sg21
I0
sba(iArchitecture
Entity
p36757
(dp36758
g11
(lp36759
sg13
S'com.google.common.primitives.ImmutableIntArray$Builder'
p36760
sg15
(lp36761
sg17
(lp36762
sg19
(lp36763
sg21
I0
sba(iArchitecture
Entity
p36764
(dp36765
g11
(lp36766
sg13
S'com.google.common.primitives.ImmutableLongArray'
p36767
sg15
(lp36768
sg17
(lp36769
sg19
(lp36770
sg21
I0
sba(iArchitecture
Entity
p36771
(dp36772
g11
(lp36773
sg13
S'com.google.common.primitives.ImmutableLongArray$1'
p36774
sg15
(lp36775
sg17
(lp36776
sg19
(lp36777
sg21
I0
sba(iArchitecture
Entity
p36778
(dp36779
g11
(lp36780
sg13
S'com.google.common.primitives.ImmutableLongArray$AsList'
p36781
sg15
(lp36782
sg17
(lp36783
sg19
(lp36784
sg21
I0
sba(iArchitecture
Entity
p36785
(dp36786
g11
(lp36787
sg13
S'com.google.common.primitives.ImmutableLongArray$Builder'
p36788
sg15
(lp36789
sg17
(lp36790
sg19
(lp36791
sg21
I0
sba(iArchitecture
Entity
p36792
(dp36793
g11
(lp36794
sg13
S'com.google.common.primitives.Ints'
p36795
sg15
(lp36796
sg17
(lp36797
sg19
(lp36798
sg21
I0
sba(iArchitecture
Entity
p36799
(dp36800
g11
(lp36801
sg13
S'com.google.common.primitives.Ints$IntArrayAsList'
p36802
sg15
(lp36803
sg17
(lp36804
sg19
(lp36805
sg21
I0
sba(iArchitecture
Entity
p36806
(dp36807
g11
(lp36808
sg13
S'com.google.common.primitives.Ints$IntConverter'
p36809
sg15
(lp36810
sg17
(lp36811
sg19
(lp36812
sg21
I0
sba(iArchitecture
Entity
p36813
(dp36814
g11
(lp36815
sg13
S'com.google.common.primitives.Ints$LexicographicalComparator'
p36816
sg15
(lp36817
sg17
(lp36818
sg19
(lp36819
sg21
I0
sba(iArchitecture
Entity
p36820
(dp36821
g11
(lp36822
sg13
S'com.google.common.primitives.Longs'
p36823
sg15
(lp36824
sg17
(lp36825
sg19
(lp36826
sg21
I0
sba(iArchitecture
Entity
p36827
(dp36828
g11
(lp36829
sg13
S'com.google.common.primitives.Longs$LexicographicalComparator'
p36830
sg15
(lp36831
sg17
(lp36832
sg19
(lp36833
sg21
I0
sba(iArchitecture
Entity
p36834
(dp36835
g11
(lp36836
sg13
S'com.google.common.primitives.Longs$LongArrayAsList'
p36837
sg15
(lp36838
sg17
(lp36839
sg19
(lp36840
sg21
I0
sba(iArchitecture
Entity
p36841
(dp36842
g11
(lp36843
sg13
S'com.google.common.primitives.Longs$LongConverter'
p36844
sg15
(lp36845
sg17
(lp36846
sg19
(lp36847
sg21
I0
sba(iArchitecture
Entity
p36848
(dp36849
g11
(lp36850
sg13
S'com.google.common.primitives.ParseRequest'
p36851
sg15
(lp36852
sg17
(lp36853
sg19
(lp36854
sg21
I0
sba(iArchitecture
Entity
p36855
(dp36856
g11
(lp36857
sg13
S'com.google.common.primitives.Shorts'
p36858
sg15
(lp36859
sg17
(lp36860
sg19
(lp36861
sg21
I0
sba(iArchitecture
Entity
p36862
(dp36863
g11
(lp36864
sg13
S'com.google.common.primitives.Shorts$LexicographicalComparator'
p36865
sg15
(lp36866
sg17
(lp36867
sg19
(lp36868
sg21
I0
sba(iArchitecture
Entity
p36869
(dp36870
g11
(lp36871
sg13
S'com.google.common.primitives.Shorts$ShortArrayAsList'
p36872
sg15
(lp36873
sg17
(lp36874
sg19
(lp36875
sg21
I0
sba(iArchitecture
Entity
p36876
(dp36877
g11
(lp36878
sg13
S'com.google.common.primitives.Shorts$ShortConverter'
p36879
sg15
(lp36880
sg17
(lp36881
sg19
(lp36882
sg21
I0
sba(iArchitecture
Entity
p36883
(dp36884
g11
(lp36885
sg13
S'com.google.common.primitives.SignedBytes'
p36886
sg15
(lp36887
sg17
(lp36888
sg19
(lp36889
sg21
I0
sba(iArchitecture
Entity
p36890
(dp36891
g11
(lp36892
sg13
S'com.google.common.primitives.SignedBytes$LexicographicalComparator'
p36893
sg15
(lp36894
sg17
(lp36895
sg19
(lp36896
sg21
I0
sba(iArchitecture
Entity
p36897
(dp36898
g11
(lp36899
sg13
S'com.google.common.primitives.UnsignedBytes'
p36900
sg15
(lp36901
sg17
(lp36902
sg19
(lp36903
sg21
I0
sba(iArchitecture
Entity
p36904
(dp36905
g11
(lp36906
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder'
p36907
sg15
(lp36908
sg17
(lp36909
sg19
(lp36910
sg21
I0
sba(iArchitecture
Entity
p36911
(dp36912
g11
(lp36913
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder$PureJavaComparator'
p36914
sg15
(lp36915
sg17
(lp36916
sg19
(lp36917
sg21
I0
sba(iArchitecture
Entity
p36918
(dp36919
g11
(lp36920
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator'
p36921
sg15
(lp36922
sg17
(lp36923
sg19
(lp36924
sg21
I0
sba(iArchitecture
Entity
p36925
(dp36926
g11
(lp36927
sg13
S'com.google.common.primitives.UnsignedBytes$LexicographicalComparatorHolder$UnsafeComparator$1'
p36928
sg15
(lp36929
sg17
(lp36930
sg19
(lp36931
sg21
I0
sba(iArchitecture
Entity
p36932
(dp36933
g11
(lp36934
sg13
S'com.google.common.primitives.UnsignedInts'
p36935
sg15
(lp36936
sg17
(lp36937
sg19
(lp36938
sg21
I0
sba(iArchitecture
Entity
p36939
(dp36940
g11
(lp36941
sg13
S'com.google.common.primitives.UnsignedInts$LexicographicalComparator'
p36942
sg15
(lp36943
sg17
(lp36944
sg19
(lp36945
sg21
I0
sba(iArchitecture
Entity
p36946
(dp36947
g11
(lp36948
sg13
S'com.google.common.primitives.UnsignedLong'
p36949
sg15
(lp36950
sg17
(lp36951
sg19
(lp36952
sg21
I0
sba(iArchitecture
Entity
p36953
(dp36954
g11
(lp36955
sg13
S'com.google.common.primitives.UnsignedLongs'
p36956
sg15
(lp36957
sg17
(lp36958
sg19
(lp36959
sg21
I0
sba(iArchitecture
Entity
p36960
(dp36961
g11
(lp36962
sg13
S'com.google.common.primitives.UnsignedLongs$LexicographicalComparator'
p36963
sg15
(lp36964
sg17
(lp36965
sg19
(lp36966
sg21
I0
sbasg1135
(lp36967
g36578
ag36585
ag36592
ag36599
ag36606
ag36613
ag36620
ag36627
ag36634
ag36641
ag36648
ag36655
ag36662
ag36669
ag36676
ag36683
ag36690
ag36697
ag36704
ag36711
ag36718
ag36725
ag36732
ag36739
ag36746
ag36753
ag36760
ag36767
ag36774
ag36781
ag36788
ag36795
ag36802
ag36809
ag36816
ag36823
ag36830
ag36837
ag36844
ag36851
ag36858
ag36865
ag36872
ag36879
ag36886
ag36893
ag36900
ag36907
ag36914
ag36921
ag36928
ag36935
ag36942
ag36949
ag36956
ag36963
asg1137
I0
sg21
I0
sg1138
S'com.google.common.primitives.ss'
p36968
sba(iArchitecture
Cluster
p36969
(dp36970
g7
(lp36971
(iArchitecture
Entity
p36972
(dp36973
g11
(lp36974
sg13
S'com.google.common.collect.ForwardingMapEntry'
p36975
sg15
(lp36976
sg17
(lp36977
sg19
(lp36978
sg21
I0
sba(iArchitecture
Entity
p36979
(dp36980
g11
(lp36981
sg13
S'com.google.common.collect.ImmutableSet$Builder'
p36982
sg15
(lp36983
sg17
(lp36984
sg19
(lp36985
sg21
I0
sba(iArchitecture
Entity
p36986
(dp36987
g11
(lp36988
sg13
S'com.google.common.primitives.Primitives'
p36989
sg15
(lp36990
sg17
(lp36991
sg19
(lp36992
sg21
I0
sba(iArchitecture
Entity
p36993
(dp36994
g11
(lp36995
sg13
S'com.google.common.reflect.ClassPath'
p36996
sg15
(lp36997
sg17
(lp36998
sg19
(lp36999
sg21
I0
sba(iArchitecture
Entity
p37000
(dp37001
g11
(lp37002
sg13
S'com.google.common.reflect.ClassPath$1'
p37003
sg15
(lp37004
sg17
(lp37005
sg19
(lp37006
sg21
I0
sba(iArchitecture
Entity
p37007
(dp37008
g11
(lp37009
sg13
S'com.google.common.reflect.ClassPath$ClassInfo'
p37010
sg15
(lp37011
sg17
(lp37012
sg19
(lp37013
sg21
I0
sba(iArchitecture
Entity
p37014
(dp37015
g11
(lp37016
sg13
S'com.google.common.reflect.ClassPath$DefaultScanner'
p37017
sg15
(lp37018
sg17
(lp37019
sg19
(lp37020
sg21
I0
sba(iArchitecture
Entity
p37021
(dp37022
g11
(lp37023
sg13
S'com.google.common.reflect.ClassPath$ResourceInfo'
p37024
sg15
(lp37025
sg17
(lp37026
sg19
(lp37027
sg21
I0
sba(iArchitecture
Entity
p37028
(dp37029
g11
(lp37030
sg13
S'com.google.common.reflect.ClassPath$Scanner'
p37031
sg15
(lp37032
sg17
(lp37033
sg19
(lp37034
sg21
I0
sba(iArchitecture
Entity
p37035
(dp37036
g11
(lp37037
sg13
S'com.google.common.reflect.Element'
p37038
sg15
(lp37039
sg17
(lp37040
sg19
(lp37041
sg21
I0
sba(iArchitecture
Entity
p37042
(dp37043
g11
(lp37044
sg13
S'com.google.common.reflect.ImmutableTypeToInstanceMap'
p37045
sg15
(lp37046
sg17
(lp37047
sg19
(lp37048
sg21
I0
sba(iArchitecture
Entity
p37049
(dp37050
g11
(lp37051
sg13
S'com.google.common.reflect.ImmutableTypeToInstanceMap$1'
p37052
sg15
(lp37053
sg17
(lp37054
sg19
(lp37055
sg21
I0
sba(iArchitecture
Entity
p37056
(dp37057
g11
(lp37058
sg13
S'com.google.common.reflect.ImmutableTypeToInstanceMap$Builder'
p37059
sg15
(lp37060
sg17
(lp37061
sg19
(lp37062
sg21
I0
sba(iArchitecture
Entity
p37063
(dp37064
g11
(lp37065
sg13
S'com.google.common.reflect.Invokable'
p37066
sg15
(lp37067
sg17
(lp37068
sg19
(lp37069
sg21
I0
sba(iArchitecture
Entity
p37070
(dp37071
g11
(lp37072
sg13
S'com.google.common.reflect.Invokable$ConstructorInvokable'
p37073
sg15
(lp37074
sg17
(lp37075
sg19
(lp37076
sg21
I0
sba(iArchitecture
Entity
p37077
(dp37078
g11
(lp37079
sg13
S'com.google.common.reflect.Invokable$MethodInvokable'
p37080
sg15
(lp37081
sg17
(lp37082
sg19
(lp37083
sg21
I0
sba(iArchitecture
Entity
p37084
(dp37085
g11
(lp37086
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap'
p37087
sg15
(lp37088
sg17
(lp37089
sg19
(lp37090
sg21
I0
sba(iArchitecture
Entity
p37091
(dp37092
g11
(lp37093
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$1'
p37094
sg15
(lp37095
sg17
(lp37096
sg19
(lp37097
sg21
I0
sba(iArchitecture
Entity
p37098
(dp37099
g11
(lp37100
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry'
p37101
sg15
(lp37102
sg17
(lp37103
sg19
(lp37104
sg21
I0
sba(iArchitecture
Entity
p37105
(dp37106
g11
(lp37107
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry$1'
p37108
sg15
(lp37109
sg17
(lp37110
sg19
(lp37111
sg21
I0
sba(iArchitecture
Entity
p37112
(dp37113
g11
(lp37114
sg13
S'com.google.common.reflect.MutableTypeToInstanceMap$UnmodifiableEntry$2'
p37115
sg15
(lp37116
sg17
(lp37117
sg19
(lp37118
sg21
I0
sba(iArchitecture
Entity
p37119
(dp37120
g11
(lp37121
sg13
S'com.google.common.reflect.Parameter'
p37122
sg15
(lp37123
sg17
(lp37124
sg19
(lp37125
sg21
I0
sba(iArchitecture
Entity
p37126
(dp37127
g11
(lp37128
sg13
S'com.google.common.reflect.Reflection'
p37129
sg15
(lp37130
sg17
(lp37131
sg19
(lp37132
sg21
I0
sba(iArchitecture
Entity
p37133
(dp37134
g11
(lp37135
sg13
S'com.google.common.reflect.TypeCapture'
p37136
sg15
(lp37137
sg17
(lp37138
sg19
(lp37139
sg21
I0
sba(iArchitecture
Entity
p37140
(dp37141
g11
(lp37142
sg13
S'com.google.common.reflect.TypeParameter'
p37143
sg15
(lp37144
sg17
(lp37145
sg19
(lp37146
sg21
I0
sba(iArchitecture
Entity
p37147
(dp37148
g11
(lp37149
sg13
S'com.google.common.reflect.TypeResolver'
p37150
sg15
(lp37151
sg17
(lp37152
sg19
(lp37153
sg21
I0
sba(iArchitecture
Entity
p37154
(dp37155
g11
(lp37156
sg13
S'com.google.common.reflect.TypeResolver$1'
p37157
sg15
(lp37158
sg17
(lp37159
sg19
(lp37160
sg21
I0
sba(iArchitecture
Entity
p37161
(dp37162
g11
(lp37163
sg13
S'com.google.common.reflect.TypeResolver$TypeMappingIntrospector'
p37164
sg15
(lp37165
sg17
(lp37166
sg19
(lp37167
sg21
I0
sba(iArchitecture
Entity
p37168
(dp37169
g11
(lp37170
sg13
S'com.google.common.reflect.TypeResolver$TypeTable'
p37171
sg15
(lp37172
sg17
(lp37173
sg19
(lp37174
sg21
I0
sba(iArchitecture
Entity
p37175
(dp37176
g11
(lp37177
sg13
S'com.google.common.reflect.TypeResolver$TypeTable$1'
p37178
sg15
(lp37179
sg17
(lp37180
sg19
(lp37181
sg21
I0
sba(iArchitecture
Entity
p37182
(dp37183
g11
(lp37184
sg13
S'com.google.common.reflect.TypeResolver$TypeVariableKey'
p37185
sg15
(lp37186
sg17
(lp37187
sg19
(lp37188
sg21
I0
sba(iArchitecture
Entity
p37189
(dp37190
g11
(lp37191
sg13
S'com.google.common.reflect.TypeResolver$WildcardCapturer'
p37192
sg15
(lp37193
sg17
(lp37194
sg19
(lp37195
sg21
I0
sba(iArchitecture
Entity
p37196
(dp37197
g11
(lp37198
sg13
S'com.google.common.reflect.TypeResolver$WildcardCapturer$1'
p37199
sg15
(lp37200
sg17
(lp37201
sg19
(lp37202
sg21
I0
sba(iArchitecture
Entity
p37203
(dp37204
g11
(lp37205
sg13
S'com.google.common.reflect.TypeToInstanceMap'
p37206
sg15
(lp37207
sg17
(lp37208
sg19
(lp37209
sg21
I0
sba(iArchitecture
Entity
p37210
(dp37211
g11
(lp37212
sg13
S'com.google.common.reflect.TypeToken'
p37213
sg15
(lp37214
sg17
(lp37215
sg19
(lp37216
sg21
I0
sba(iArchitecture
Entity
p37217
(dp37218
g11
(lp37219
sg13
S'com.google.common.reflect.TypeToken$1'
p37220
sg15
(lp37221
sg17
(lp37222
sg19
(lp37223
sg21
I0
sba(iArchitecture
Entity
p37224
(dp37225
g11
(lp37226
sg13
S'com.google.common.reflect.TypeToken$2'
p37227
sg15
(lp37228
sg17
(lp37229
sg19
(lp37230
sg21
I0
sba(iArchitecture
Entity
p37231
(dp37232
g11
(lp37233
sg13
S'com.google.common.reflect.TypeToken$3'
p37234
sg15
(lp37235
sg17
(lp37236
sg19
(lp37237
sg21
I0
sba(iArchitecture
Entity
p37238
(dp37239
g11
(lp37240
sg13
S'com.google.common.reflect.TypeToken$4'
p37241
sg15
(lp37242
sg17
(lp37243
sg19
(lp37244
sg21
I0
sba(iArchitecture
Entity
p37245
(dp37246
g11
(lp37247
sg13
S'com.google.common.reflect.TypeToken$Bounds'
p37248
sg15
(lp37249
sg17
(lp37250
sg19
(lp37251
sg21
I0
sba(iArchitecture
Entity
p37252
(dp37253
g11
(lp37254
sg13
S'com.google.common.reflect.TypeToken$InterfaceSet'
p37255
sg15
(lp37256
sg17
(lp37257
sg19
(lp37258
sg21
I0
sba(iArchitecture
Entity
p37259
(dp37260
g11
(lp37261
sg13
S'com.google.common.reflect.TypeToken$InterfaceSet$1'
p37262
sg15
(lp37263
sg17
(lp37264
sg19
(lp37265
sg21
I0
sba(iArchitecture
Entity
p37266
(dp37267
g11
(lp37268
sg13
S'com.google.common.reflect.TypeToken$SimpleTypeToken'
p37269
sg15
(lp37270
sg17
(lp37271
sg19
(lp37272
sg21
I0
sba(iArchitecture
Entity
p37273
(dp37274
g11
(lp37275
sg13
S'com.google.common.reflect.TypeToken$TypeCollector'
p37276
sg15
(lp37277
sg17
(lp37278
sg19
(lp37279
sg21
I0
sba(iArchitecture
Entity
p37280
(dp37281
g11
(lp37282
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$1'
p37283
sg15
(lp37284
sg17
(lp37285
sg19
(lp37286
sg21
I0
sba(iArchitecture
Entity
p37287
(dp37288
g11
(lp37289
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$2'
p37290
sg15
(lp37291
sg17
(lp37292
sg19
(lp37293
sg21
I0
sba(iArchitecture
Entity
p37294
(dp37295
g11
(lp37296
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$3'
p37297
sg15
(lp37298
sg17
(lp37299
sg19
(lp37300
sg21
I0
sba(iArchitecture
Entity
p37301
(dp37302
g11
(lp37303
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$4'
p37304
sg15
(lp37305
sg17
(lp37306
sg19
(lp37307
sg21
I0
sba(iArchitecture
Entity
p37308
(dp37309
g11
(lp37310
sg13
S'com.google.common.reflect.TypeToken$TypeCollector$ForwardingTypeCollector'
p37311
sg15
(lp37312
sg17
(lp37313
sg19
(lp37314
sg21
I0
sba(iArchitecture
Entity
p37315
(dp37316
g11
(lp37317
sg13
S'com.google.common.reflect.TypeToken$TypeFilter'
p37318
sg15
(lp37319
sg17
(lp37320
sg19
(lp37321
sg21
I0
sba(iArchitecture
Entity
p37322
(dp37323
g11
(lp37324
sg13
S'com.google.common.reflect.TypeToken$TypeFilter$1'
p37325
sg15
(lp37326
sg17
(lp37327
sg19
(lp37328
sg21
I0
sba(iArchitecture
Entity
p37329
(dp37330
g11
(lp37331
sg13
S'com.google.common.reflect.TypeToken$TypeFilter$2'
p37332
sg15
(lp37333
sg17
(lp37334
sg19
(lp37335
sg21
I0
sba(iArchitecture
Entity
p37336
(dp37337
g11
(lp37338
sg13
S'com.google.common.reflect.TypeVisitor'
p37339
sg15
(lp37340
sg17
(lp37341
sg19
(lp37342
sg21
I0
sba(iArchitecture
Entity
p37343
(dp37344
g11
(lp37345
sg13
S'com.google.common.reflect.Types'
p37346
sg15
(lp37347
sg17
(lp37348
sg19
(lp37349
sg21
I0
sba(iArchitecture
Entity
p37350
(dp37351
g11
(lp37352
sg13
S'com.google.common.reflect.Types$1'
p37353
sg15
(lp37354
sg17
(lp37355
sg19
(lp37356
sg21
I0
sba(iArchitecture
Entity
p37357
(dp37358
g11
(lp37359
sg13
S'com.google.common.reflect.Types$2'
p37360
sg15
(lp37361
sg17
(lp37362
sg19
(lp37363
sg21
I0
sba(iArchitecture
Entity
p37364
(dp37365
g11
(lp37366
sg13
S'com.google.common.reflect.Types$ClassOwnership'
p37367
sg15
(lp37368
sg17
(lp37369
sg19
(lp37370
sg21
I0
sba(iArchitecture
Entity
p37371
(dp37372
g11
(lp37373
sg13
S'com.google.common.reflect.Types$ClassOwnership$1'
p37374
sg15
(lp37375
sg17
(lp37376
sg19
(lp37377
sg21
I0
sba(iArchitecture
Entity
p37378
(dp37379
g11
(lp37380
sg13
S'com.google.common.reflect.Types$ClassOwnership$1LocalClass'
p37381
sg15
(lp37382
sg17
(lp37383
sg19
(lp37384
sg21
I0
sba(iArchitecture
Entity
p37385
(dp37386
g11
(lp37387
sg13
S'com.google.common.reflect.Types$ClassOwnership$2'
p37388
sg15
(lp37389
sg17
(lp37390
sg19
(lp37391
sg21
I0
sba(iArchitecture
Entity
p37392
(dp37393
g11
(lp37394
sg13
S'com.google.common.reflect.Types$ClassOwnership$3'
p37395
sg15
(lp37396
sg17
(lp37397
sg19
(lp37398
sg21
I0
sba(iArchitecture
Entity
p37399
(dp37400
g11
(lp37401
sg13
S'com.google.common.reflect.Types$GenericArrayTypeImpl'
p37402
sg15
(lp37403
sg17
(lp37404
sg19
(lp37405
sg21
I0
sba(iArchitecture
Entity
p37406
(dp37407
g11
(lp37408
sg13
S'com.google.common.reflect.Types$JavaVersion'
p37409
sg15
(lp37410
sg17
(lp37411
sg19
(lp37412
sg21
I0
sba(iArchitecture
Entity
p37413
(dp37414
g11
(lp37415
sg13
S'com.google.common.reflect.Types$JavaVersion$1'
p37416
sg15
(lp37417
sg17
(lp37418
sg19
(lp37419
sg21
I0
sba(iArchitecture
Entity
p37420
(dp37421
g11
(lp37422
sg13
S'com.google.common.reflect.Types$JavaVersion$2'
p37423
sg15
(lp37424
sg17
(lp37425
sg19
(lp37426
sg21
I0
sba(iArchitecture
Entity
p37427
(dp37428
g11
(lp37429
sg13
S'com.google.common.reflect.Types$JavaVersion$3'
p37430
sg15
(lp37431
sg17
(lp37432
sg19
(lp37433
sg21
I0
sba(iArchitecture
Entity
p37434
(dp37435
g11
(lp37436
sg13
S'com.google.common.reflect.Types$JavaVersion$4'
p37437
sg15
(lp37438
sg17
(lp37439
sg19
(lp37440
sg21
I0
sba(iArchitecture
Entity
p37441
(dp37442
g11
(lp37443
sg13
S'com.google.common.reflect.Types$NativeTypeVariableEquals'
p37444
sg15
(lp37445
sg17
(lp37446
sg19
(lp37447
sg21
I0
sba(iArchitecture
Entity
p37448
(dp37449
g11
(lp37450
sg13
S'com.google.common.reflect.Types$ParameterizedTypeImpl'
p37451
sg15
(lp37452
sg17
(lp37453
sg19
(lp37454
sg21
I0
sba(iArchitecture
Entity
p37455
(dp37456
g11
(lp37457
sg13
S'com.google.common.reflect.Types$TypeVariableImpl'
p37458
sg15
(lp37459
sg17
(lp37460
sg19
(lp37461
sg21
I0
sba(iArchitecture
Entity
p37462
(dp37463
g11
(lp37464
sg13
S'com.google.common.reflect.Types$TypeVariableInvocationHandler'
p37465
sg15
(lp37466
sg17
(lp37467
sg19
(lp37468
sg21
I0
sba(iArchitecture
Entity
p37469
(dp37470
g11
(lp37471
sg13
S'com.google.common.reflect.Types$WildcardTypeImpl'
p37472
sg15
(lp37473
sg17
(lp37474
sg19
(lp37475
sg21
I0
sbasg1135
(lp37476
g36975
ag36982
ag36989
ag36996
ag37003
ag37010
ag37017
ag37024
ag37031
ag37038
ag37045
ag37052
ag37059
ag37066
ag37073
ag37080
ag37087
ag37094
ag37101
ag37108
ag37115
ag37122
ag37129
ag37136
ag37143
ag37150
ag37157
ag37164
ag37171
ag37178
ag37185
ag37192
ag37199
ag37206
ag37213
ag37220
ag37227
ag37234
ag37241
ag37248
ag37255
ag37262
ag37269
ag37276
ag37283
ag37290
ag37297
ag37304
ag37311
ag37318
ag37325
ag37332
ag37339
ag37346
ag37353
ag37360
ag37367
ag37374
ag37381
ag37388
ag37395
ag37402
ag37409
ag37416
ag37423
ag37430
ag37437
ag37444
ag37451
ag37458
ag37465
ag37472
asg1137
I0
sg21
I0
sg1138
S'com.google.common.reflect.ss'
p37477
sba(iArchitecture
Cluster
p37478
(dp37479
g7
(lp37480
(iArchitecture
Entity
p37481
(dp37482
g11
(lp37483
sg13
S'com.google.common.collect.ForwardingObject'
p37484
sg15
(lp37485
sg17
(lp37486
sg19
(lp37487
sg21
I0
sba(iArchitecture
Entity
p37488
(dp37489
g11
(lp37490
sg13
S'com.google.common.collect.Queues'
p37491
sg15
(lp37492
sg17
(lp37493
sg19
(lp37494
sg21
I0
sba(iArchitecture
Entity
p37495
(dp37496
g11
(lp37497
sg13
S'com.google.common.util.concurrent.AbstractCatchingFuture'
p37498
sg15
(lp37499
sg17
(lp37500
sg19
(lp37501
sg21
I0
sba(iArchitecture
Entity
p37502
(dp37503
g11
(lp37504
sg13
S'com.google.common.util.concurrent.AbstractCatchingFuture$AsyncCatchingFuture'
p37505
sg15
(lp37506
sg17
(lp37507
sg19
(lp37508
sg21
I0
sba(iArchitecture
Entity
p37509
(dp37510
g11
(lp37511
sg13
S'com.google.common.util.concurrent.AbstractCatchingFuture$CatchingFuture'
p37512
sg15
(lp37513
sg17
(lp37514
sg19
(lp37515
sg21
I0
sba(iArchitecture
Entity
p37516
(dp37517
g11
(lp37518
sg13
S'com.google.common.util.concurrent.AbstractCheckedFuture'
p37519
sg15
(lp37520
sg17
(lp37521
sg19
(lp37522
sg21
I0
sba(iArchitecture
Entity
p37523
(dp37524
g11
(lp37525
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService'
p37526
sg15
(lp37527
sg17
(lp37528
sg19
(lp37529
sg21
I0
sba(iArchitecture
Entity
p37530
(dp37531
g11
(lp37532
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$1'
p37533
sg15
(lp37534
sg17
(lp37535
sg19
(lp37536
sg21
I0
sba(iArchitecture
Entity
p37537
(dp37538
g11
(lp37539
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$1$1'
p37540
sg15
(lp37541
sg17
(lp37542
sg19
(lp37543
sg21
I0
sba(iArchitecture
Entity
p37544
(dp37545
g11
(lp37546
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$1$2'
p37547
sg15
(lp37548
sg17
(lp37549
sg19
(lp37550
sg21
I0
sba(iArchitecture
Entity
p37551
(dp37552
g11
(lp37553
sg13
S'com.google.common.util.concurrent.AbstractExecutionThreadService$2'
p37554
sg15
(lp37555
sg17
(lp37556
sg19
(lp37557
sg21
I0
sba(iArchitecture
Entity
p37558
(dp37559
g11
(lp37560
sg13
S'com.google.common.util.concurrent.AbstractFuture'
p37561
sg15
(lp37562
sg17
(lp37563
sg19
(lp37564
sg21
I0
sba(iArchitecture
Entity
p37565
(dp37566
g11
(lp37567
sg13
S'com.google.common.util.concurrent.AbstractFuture$1'
p37568
sg15
(lp37569
sg17
(lp37570
sg19
(lp37571
sg21
I0
sba(iArchitecture
Entity
p37572
(dp37573
g11
(lp37574
sg13
S'com.google.common.util.concurrent.AbstractFuture$AtomicHelper'
p37575
sg15
(lp37576
sg17
(lp37577
sg19
(lp37578
sg21
I0
sba(iArchitecture
Entity
p37579
(dp37580
g11
(lp37581
sg13
S'com.google.common.util.concurrent.AbstractFuture$Cancellation'
p37582
sg15
(lp37583
sg17
(lp37584
sg19
(lp37585
sg21
I0
sba(iArchitecture
Entity
p37586
(dp37587
g11
(lp37588
sg13
S'com.google.common.util.concurrent.AbstractFuture$Failure'
p37589
sg15
(lp37590
sg17
(lp37591
sg19
(lp37592
sg21
I0
sba(iArchitecture
Entity
p37593
(dp37594
g11
(lp37595
sg13
S'com.google.common.util.concurrent.AbstractFuture$Failure$1'
p37596
sg15
(lp37597
sg17
(lp37598
sg19
(lp37599
sg21
I0
sba(iArchitecture
Entity
p37600
(dp37601
g11
(lp37602
sg13
S'com.google.common.util.concurrent.AbstractFuture$Listener'
p37603
sg15
(lp37604
sg17
(lp37605
sg19
(lp37606
sg21
I0
sba(iArchitecture
Entity
p37607
(dp37608
g11
(lp37609
sg13
S'com.google.common.util.concurrent.AbstractFuture$SafeAtomicHelper'
p37610
sg15
(lp37611
sg17
(lp37612
sg19
(lp37613
sg21
I0
sba(iArchitecture
Entity
p37614
(dp37615
g11
(lp37616
sg13
S'com.google.common.util.concurrent.AbstractFuture$SetFuture'
p37617
sg15
(lp37618
sg17
(lp37619
sg19
(lp37620
sg21
I0
sba(iArchitecture
Entity
p37621
(dp37622
g11
(lp37623
sg13
S'com.google.common.util.concurrent.AbstractFuture$SynchronizedHelper'
p37624
sg15
(lp37625
sg17
(lp37626
sg19
(lp37627
sg21
I0
sba(iArchitecture
Entity
p37628
(dp37629
g11
(lp37630
sg13
S'com.google.common.util.concurrent.AbstractFuture$TrustedFuture'
p37631
sg15
(lp37632
sg17
(lp37633
sg19
(lp37634
sg21
I0
sba(iArchitecture
Entity
p37635
(dp37636
g11
(lp37637
sg13
S'com.google.common.util.concurrent.AbstractFuture$UnsafeAtomicHelper'
p37638
sg15
(lp37639
sg17
(lp37640
sg19
(lp37641
sg21
I0
sba(iArchitecture
Entity
p37642
(dp37643
g11
(lp37644
sg13
S'com.google.common.util.concurrent.AbstractFuture$UnsafeAtomicHelper$1'
p37645
sg15
(lp37646
sg17
(lp37647
sg19
(lp37648
sg21
I0
sba(iArchitecture
Entity
p37649
(dp37650
g11
(lp37651
sg13
S'com.google.common.util.concurrent.AbstractFuture$Waiter'
p37652
sg15
(lp37653
sg17
(lp37654
sg19
(lp37655
sg21
I0
sba(iArchitecture
Entity
p37656
(dp37657
g11
(lp37658
sg13
S'com.google.common.util.concurrent.AbstractIdleService'
p37659
sg15
(lp37660
sg17
(lp37661
sg19
(lp37662
sg21
I0
sba(iArchitecture
Entity
p37663
(dp37664
g11
(lp37665
sg13
S'com.google.common.util.concurrent.AbstractIdleService$1'
p37666
sg15
(lp37667
sg17
(lp37668
sg19
(lp37669
sg21
I0
sba(iArchitecture
Entity
p37670
(dp37671
g11
(lp37672
sg13
S'com.google.common.util.concurrent.AbstractIdleService$DelegateService'
p37673
sg15
(lp37674
sg17
(lp37675
sg19
(lp37676
sg21
I0
sba(iArchitecture
Entity
p37677
(dp37678
g11
(lp37679
sg13
S'com.google.common.util.concurrent.AbstractIdleService$DelegateService$1'
p37680
sg15
(lp37681
sg17
(lp37682
sg19
(lp37683
sg21
I0
sba(iArchitecture
Entity
p37684
(dp37685
g11
(lp37686
sg13
S'com.google.common.util.concurrent.AbstractIdleService$DelegateService$2'
p37687
sg15
(lp37688
sg17
(lp37689
sg19
(lp37690
sg21
I0
sba(iArchitecture
Entity
p37691
(dp37692
g11
(lp37693
sg13
S'com.google.common.util.concurrent.AbstractIdleService$ThreadNameSupplier'
p37694
sg15
(lp37695
sg17
(lp37696
sg19
(lp37697
sg21
I0
sba(iArchitecture
Entity
p37698
(dp37699
g11
(lp37700
sg13
S'com.google.common.util.concurrent.AbstractListeningExecutorService'
p37701
sg15
(lp37702
sg17
(lp37703
sg19
(lp37704
sg21
I0
sba(iArchitecture
Entity
p37705
(dp37706
g11
(lp37707
sg13
S'com.google.common.util.concurrent.AbstractScheduledService'
p37708
sg15
(lp37709
sg17
(lp37710
sg19
(lp37711
sg21
I0
sba(iArchitecture
Entity
p37712
(dp37713
g11
(lp37714
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$1'
p37715
sg15
(lp37716
sg17
(lp37717
sg19
(lp37718
sg21
I0
sba(iArchitecture
Entity
p37719
(dp37720
g11
(lp37721
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$1ThreadFactoryImpl'
p37722
sg15
(lp37723
sg17
(lp37724
sg19
(lp37725
sg21
I0
sba(iArchitecture
Entity
p37726
(dp37727
g11
(lp37728
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$CustomScheduler'
p37729
sg15
(lp37730
sg17
(lp37731
sg19
(lp37732
sg21
I0
sba(iArchitecture
Entity
p37733
(dp37734
g11
(lp37735
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$CustomScheduler$ReschedulableCallable'
p37736
sg15
(lp37737
sg17
(lp37738
sg19
(lp37739
sg21
I0
sba(iArchitecture
Entity
p37740
(dp37741
g11
(lp37742
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$CustomScheduler$Schedule'
p37743
sg15
(lp37744
sg17
(lp37745
sg19
(lp37746
sg21
I0
sba(iArchitecture
Entity
p37747
(dp37748
g11
(lp37749
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$Scheduler'
p37750
sg15
(lp37751
sg17
(lp37752
sg19
(lp37753
sg21
I0
sba(iArchitecture
Entity
p37754
(dp37755
g11
(lp37756
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$Scheduler$1'
p37757
sg15
(lp37758
sg17
(lp37759
sg19
(lp37760
sg21
I0
sba(iArchitecture
Entity
p37761
(dp37762
g11
(lp37763
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$Scheduler$2'
p37764
sg15
(lp37765
sg17
(lp37766
sg19
(lp37767
sg21
I0
sba(iArchitecture
Entity
p37768
(dp37769
g11
(lp37770
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$ServiceDelegate'
p37771
sg15
(lp37772
sg17
(lp37773
sg19
(lp37774
sg21
I0
sba(iArchitecture
Entity
p37775
(dp37776
g11
(lp37777
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$ServiceDelegate$1'
p37778
sg15
(lp37779
sg17
(lp37780
sg19
(lp37781
sg21
I0
sba(iArchitecture
Entity
p37782
(dp37783
g11
(lp37784
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$ServiceDelegate$2'
p37785
sg15
(lp37786
sg17
(lp37787
sg19
(lp37788
sg21
I0
sba(iArchitecture
Entity
p37789
(dp37790
g11
(lp37791
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$ServiceDelegate$3'
p37792
sg15
(lp37793
sg17
(lp37794
sg19
(lp37795
sg21
I0
sba(iArchitecture
Entity
p37796
(dp37797
g11
(lp37798
sg13
S'com.google.common.util.concurrent.AbstractScheduledService$ServiceDelegate$Task'
p37799
sg15
(lp37800
sg17
(lp37801
sg19
(lp37802
sg21
I0
sba(iArchitecture
Entity
p37803
(dp37804
g11
(lp37805
sg13
S'com.google.common.util.concurrent.AbstractService'
p37806
sg15
(lp37807
sg17
(lp37808
sg19
(lp37809
sg21
I0
sba(iArchitecture
Entity
p37810
(dp37811
g11
(lp37812
sg13
S'com.google.common.util.concurrent.AbstractService$1'
p37813
sg15
(lp37814
sg17
(lp37815
sg19
(lp37816
sg21
I0
sba(iArchitecture
Entity
p37817
(dp37818
g11
(lp37819
sg13
S'com.google.common.util.concurrent.AbstractService$2'
p37820
sg15
(lp37821
sg17
(lp37822
sg19
(lp37823
sg21
I0
sba(iArchitecture
Entity
p37824
(dp37825
g11
(lp37826
sg13
S'com.google.common.util.concurrent.AbstractService$3'
p37827
sg15
(lp37828
sg17
(lp37829
sg19
(lp37830
sg21
I0
sba(iArchitecture
Entity
p37831
(dp37832
g11
(lp37833
sg13
S'com.google.common.util.concurrent.AbstractService$4'
p37834
sg15
(lp37835
sg17
(lp37836
sg19
(lp37837
sg21
I0
sba(iArchitecture
Entity
p37838
(dp37839
g11
(lp37840
sg13
S'com.google.common.util.concurrent.AbstractService$5'
p37841
sg15
(lp37842
sg17
(lp37843
sg19
(lp37844
sg21
I0
sba(iArchitecture
Entity
p37845
(dp37846
g11
(lp37847
sg13
S'com.google.common.util.concurrent.AbstractService$6'
p37848
sg15
(lp37849
sg17
(lp37850
sg19
(lp37851
sg21
I0
sba(iArchitecture
Entity
p37852
(dp37853
g11
(lp37854
sg13
S'com.google.common.util.concurrent.AbstractService$HasReachedRunningGuard'
p37855
sg15
(lp37856
sg17
(lp37857
sg19
(lp37858
sg21
I0
sba(iArchitecture
Entity
p37859
(dp37860
g11
(lp37861
sg13
S'com.google.common.util.concurrent.AbstractService$IsStartableGuard'
p37862
sg15
(lp37863
sg17
(lp37864
sg19
(lp37865
sg21
I0
sba(iArchitecture
Entity
p37866
(dp37867
g11
(lp37868
sg13
S'com.google.common.util.concurrent.AbstractService$IsStoppableGuard'
p37869
sg15
(lp37870
sg17
(lp37871
sg19
(lp37872
sg21
I0
sba(iArchitecture
Entity
p37873
(dp37874
g11
(lp37875
sg13
S'com.google.common.util.concurrent.AbstractService$IsStoppedGuard'
p37876
sg15
(lp37877
sg17
(lp37878
sg19
(lp37879
sg21
I0
sba(iArchitecture
Entity
p37880
(dp37881
g11
(lp37882
sg13
S'com.google.common.util.concurrent.AbstractService$StateSnapshot'
p37883
sg15
(lp37884
sg17
(lp37885
sg19
(lp37886
sg21
I0
sba(iArchitecture
Entity
p37887
(dp37888
g11
(lp37889
sg13
S'com.google.common.util.concurrent.AbstractTransformFuture'
p37890
sg15
(lp37891
sg17
(lp37892
sg19
(lp37893
sg21
I0
sba(iArchitecture
Entity
p37894
(dp37895
g11
(lp37896
sg13
S'com.google.common.util.concurrent.AbstractTransformFuture$AsyncTransformFuture'
p37897
sg15
(lp37898
sg17
(lp37899
sg19
(lp37900
sg21
I0
sba(iArchitecture
Entity
p37901
(dp37902
g11
(lp37903
sg13
S'com.google.common.util.concurrent.AbstractTransformFuture$TransformFuture'
p37904
sg15
(lp37905
sg17
(lp37906
sg19
(lp37907
sg21
I0
sba(iArchitecture
Entity
p37908
(dp37909
g11
(lp37910
sg13
S'com.google.common.util.concurrent.AggregateFuture'
p37911
sg15
(lp37912
sg17
(lp37913
sg19
(lp37914
sg21
I0
sba(iArchitecture
Entity
p37915
(dp37916
g11
(lp37917
sg13
S'com.google.common.util.concurrent.AggregateFuture$RunningState'
p37918
sg15
(lp37919
sg17
(lp37920
sg19
(lp37921
sg21
I0
sba(iArchitecture
Entity
p37922
(dp37923
g11
(lp37924
sg13
S'com.google.common.util.concurrent.AggregateFuture$RunningState$1'
p37925
sg15
(lp37926
sg17
(lp37927
sg19
(lp37928
sg21
I0
sba(iArchitecture
Entity
p37929
(dp37930
g11
(lp37931
sg13
S'com.google.common.util.concurrent.AggregateFutureState'
p37932
sg15
(lp37933
sg17
(lp37934
sg19
(lp37935
sg21
I0
sba(iArchitecture
Entity
p37936
(dp37937
g11
(lp37938
sg13
S'com.google.common.util.concurrent.AggregateFutureState$1'
p37939
sg15
(lp37940
sg17
(lp37941
sg19
(lp37942
sg21
I0
sba(iArchitecture
Entity
p37943
(dp37944
g11
(lp37945
sg13
S'com.google.common.util.concurrent.AggregateFutureState$AtomicHelper'
p37946
sg15
(lp37947
sg17
(lp37948
sg19
(lp37949
sg21
I0
sba(iArchitecture
Entity
p37950
(dp37951
g11
(lp37952
sg13
S'com.google.common.util.concurrent.AggregateFutureState$SafeAtomicHelper'
p37953
sg15
(lp37954
sg17
(lp37955
sg19
(lp37956
sg21
I0
sba(iArchitecture
Entity
p37957
(dp37958
g11
(lp37959
sg13
S'com.google.common.util.concurrent.AggregateFutureState$SynchronizedAtomicHelper'
p37960
sg15
(lp37961
sg17
(lp37962
sg19
(lp37963
sg21
I0
sba(iArchitecture
Entity
p37964
(dp37965
g11
(lp37966
sg13
S'com.google.common.util.concurrent.AsyncCallable'
p37967
sg15
(lp37968
sg17
(lp37969
sg19
(lp37970
sg21
I0
sba(iArchitecture
Entity
p37971
(dp37972
g11
(lp37973
sg13
S'com.google.common.util.concurrent.AsyncFunction'
p37974
sg15
(lp37975
sg17
(lp37976
sg19
(lp37977
sg21
I0
sba(iArchitecture
Entity
p37978
(dp37979
g11
(lp37980
sg13
S'com.google.common.util.concurrent.Callables'
p37981
sg15
(lp37982
sg17
(lp37983
sg19
(lp37984
sg21
I0
sba(iArchitecture
Entity
p37985
(dp37986
g11
(lp37987
sg13
S'com.google.common.util.concurrent.Callables$1'
p37988
sg15
(lp37989
sg17
(lp37990
sg19
(lp37991
sg21
I0
sba(iArchitecture
Entity
p37992
(dp37993
g11
(lp37994
sg13
S'com.google.common.util.concurrent.Callables$2'
p37995
sg15
(lp37996
sg17
(lp37997
sg19
(lp37998
sg21
I0
sba(iArchitecture
Entity
p37999
(dp38000
g11
(lp38001
sg13
S'com.google.common.util.concurrent.Callables$3'
p38002
sg15
(lp38003
sg17
(lp38004
sg19
(lp38005
sg21
I0
sba(iArchitecture
Entity
p38006
(dp38007
g11
(lp38008
sg13
S'com.google.common.util.concurrent.Callables$4'
p38009
sg15
(lp38010
sg17
(lp38011
sg19
(lp38012
sg21
I0
sba(iArchitecture
Entity
p38013
(dp38014
g11
(lp38015
sg13
S'com.google.common.util.concurrent.CheckedFuture'
p38016
sg15
(lp38017
sg17
(lp38018
sg19
(lp38019
sg21
I0
sba(iArchitecture
Entity
p38020
(dp38021
g11
(lp38022
sg13
S'com.google.common.util.concurrent.CollectionFuture'
p38023
sg15
(lp38024
sg17
(lp38025
sg19
(lp38026
sg21
I0
sba(iArchitecture
Entity
p38027
(dp38028
g11
(lp38029
sg13
S'com.google.common.util.concurrent.CollectionFuture$CollectionFutureRunningState'
p38030
sg15
(lp38031
sg17
(lp38032
sg19
(lp38033
sg21
I0
sba(iArchitecture
Entity
p38034
(dp38035
g11
(lp38036
sg13
S'com.google.common.util.concurrent.CollectionFuture$ListFuture'
p38037
sg15
(lp38038
sg17
(lp38039
sg19
(lp38040
sg21
I0
sba(iArchitecture
Entity
p38041
(dp38042
g11
(lp38043
sg13
S'com.google.common.util.concurrent.CollectionFuture$ListFuture$ListFutureRunningState'
p38044
sg15
(lp38045
sg17
(lp38046
sg19
(lp38047
sg21
I0
sba(iArchitecture
Entity
p38048
(dp38049
g11
(lp38050
sg13
S'com.google.common.util.concurrent.CombinedFuture'
p38051
sg15
(lp38052
sg17
(lp38053
sg19
(lp38054
sg21
I0
sba(iArchitecture
Entity
p38055
(dp38056
g11
(lp38057
sg13
S'com.google.common.util.concurrent.CombinedFuture$AsyncCallableInterruptibleTask'
p38058
sg15
(lp38059
sg17
(lp38060
sg19
(lp38061
sg21
I0
sba(iArchitecture
Entity
p38062
(dp38063
g11
(lp38064
sg13
S'com.google.common.util.concurrent.CombinedFuture$CallableInterruptibleTask'
p38065
sg15
(lp38066
sg17
(lp38067
sg19
(lp38068
sg21
I0
sba(iArchitecture
Entity
p38069
(dp38070
g11
(lp38071
sg13
S'com.google.common.util.concurrent.CombinedFuture$CombinedFutureInterruptibleTask'
p38072
sg15
(lp38073
sg17
(lp38074
sg19
(lp38075
sg21
I0
sba(iArchitecture
Entity
p38076
(dp38077
g11
(lp38078
sg13
S'com.google.common.util.concurrent.CombinedFuture$CombinedFutureRunningState'
p38079
sg15
(lp38080
sg17
(lp38081
sg19
(lp38082
sg21
I0
sba(iArchitecture
Entity
p38083
(dp38084
g11
(lp38085
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory'
p38086
sg15
(lp38087
sg17
(lp38088
sg19
(lp38089
sg21
I0
sba(iArchitecture
Entity
p38090
(dp38091
g11
(lp38092
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$1'
p38093
sg15
(lp38094
sg17
(lp38095
sg19
(lp38096
sg21
I0
sba(iArchitecture
Entity
p38097
(dp38098
g11
(lp38099
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingLock'
p38100
sg15
(lp38101
sg17
(lp38102
sg19
(lp38103
sg21
I0
sba(iArchitecture
Entity
p38104
(dp38105
g11
(lp38106
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantLock'
p38107
sg15
(lp38108
sg17
(lp38109
sg19
(lp38110
sg21
I0
sba(iArchitecture
Entity
p38111
(dp38112
g11
(lp38113
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantReadLock'
p38114
sg15
(lp38115
sg17
(lp38116
sg19
(lp38117
sg21
I0
sba(iArchitecture
Entity
p38118
(dp38119
g11
(lp38120
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantReadWriteLock'
p38121
sg15
(lp38122
sg17
(lp38123
sg19
(lp38124
sg21
I0
sba(iArchitecture
Entity
p38125
(dp38126
g11
(lp38127
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$CycleDetectingReentrantWriteLock'
p38128
sg15
(lp38129
sg17
(lp38130
sg19
(lp38131
sg21
I0
sba(iArchitecture
Entity
p38132
(dp38133
g11
(lp38134
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$ExampleStackTrace'
p38135
sg15
(lp38136
sg17
(lp38137
sg19
(lp38138
sg21
I0
sba(iArchitecture
Entity
p38139
(dp38140
g11
(lp38141
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$LockGraphNode'
p38142
sg15
(lp38143
sg17
(lp38144
sg19
(lp38145
sg21
I0
sba(iArchitecture
Entity
p38146
(dp38147
g11
(lp38148
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies'
p38149
sg15
(lp38150
sg17
(lp38151
sg19
(lp38152
sg21
I0
sba(iArchitecture
Entity
p38153
(dp38154
g11
(lp38155
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies$1'
p38156
sg15
(lp38157
sg17
(lp38158
sg19
(lp38159
sg21
I0
sba(iArchitecture
Entity
p38160
(dp38161
g11
(lp38162
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies$2'
p38163
sg15
(lp38164
sg17
(lp38165
sg19
(lp38166
sg21
I0
sba(iArchitecture
Entity
p38167
(dp38168
g11
(lp38169
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policies$3'
p38170
sg15
(lp38171
sg17
(lp38172
sg19
(lp38173
sg21
I0
sba(iArchitecture
Entity
p38174
(dp38175
g11
(lp38176
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$Policy'
p38177
sg15
(lp38178
sg17
(lp38179
sg19
(lp38180
sg21
I0
sba(iArchitecture
Entity
p38181
(dp38182
g11
(lp38183
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$PotentialDeadlockException'
p38184
sg15
(lp38185
sg17
(lp38186
sg19
(lp38187
sg21
I0
sba(iArchitecture
Entity
p38188
(dp38189
g11
(lp38190
sg13
S'com.google.common.util.concurrent.CycleDetectingLockFactory$WithExplicitOrdering'
p38191
sg15
(lp38192
sg17
(lp38193
sg19
(lp38194
sg21
I0
sba(iArchitecture
Entity
p38195
(dp38196
g11
(lp38197
sg13
S'com.google.common.util.concurrent.ExecutionError'
p38198
sg15
(lp38199
sg17
(lp38200
sg19
(lp38201
sg21
I0
sba(iArchitecture
Entity
p38202
(dp38203
g11
(lp38204
sg13
S'com.google.common.util.concurrent.ExecutionList'
p38205
sg15
(lp38206
sg17
(lp38207
sg19
(lp38208
sg21
I0
sba(iArchitecture
Entity
p38209
(dp38210
g11
(lp38211
sg13
S'com.google.common.util.concurrent.ExecutionList$RunnableExecutorPair'
p38212
sg15
(lp38213
sg17
(lp38214
sg19
(lp38215
sg21
I0
sba(iArchitecture
Entity
p38216
(dp38217
g11
(lp38218
sg13
S'com.google.common.util.concurrent.FakeTimeLimiter'
p38219
sg15
(lp38220
sg17
(lp38221
sg19
(lp38222
sg21
I0
sba(iArchitecture
Entity
p38223
(dp38224
g11
(lp38225
sg13
S'com.google.common.util.concurrent.ForwardingCheckedFuture'
p38226
sg15
(lp38227
sg17
(lp38228
sg19
(lp38229
sg21
I0
sba(iArchitecture
Entity
p38230
(dp38231
g11
(lp38232
sg13
S'com.google.common.util.concurrent.ForwardingCheckedFuture$SimpleForwardingCheckedFuture'
p38233
sg15
(lp38234
sg17
(lp38235
sg19
(lp38236
sg21
I0
sba(iArchitecture
Entity
p38237
(dp38238
g11
(lp38239
sg13
S'com.google.common.util.concurrent.ForwardingExecutorService'
p38240
sg15
(lp38241
sg17
(lp38242
sg19
(lp38243
sg21
I0
sba(iArchitecture
Entity
p38244
(dp38245
g11
(lp38246
sg13
S'com.google.common.util.concurrent.ForwardingFuture'
p38247
sg15
(lp38248
sg17
(lp38249
sg19
(lp38250
sg21
I0
sba(iArchitecture
Entity
p38251
(dp38252
g11
(lp38253
sg13
S'com.google.common.util.concurrent.ForwardingFuture$SimpleForwardingFuture'
p38254
sg15
(lp38255
sg17
(lp38256
sg19
(lp38257
sg21
I0
sba(iArchitecture
Entity
p38258
(dp38259
g11
(lp38260
sg13
S'com.google.common.util.concurrent.ForwardingListenableFuture'
p38261
sg15
(lp38262
sg17
(lp38263
sg19
(lp38264
sg21
I0
sba(iArchitecture
Entity
p38265
(dp38266
g11
(lp38267
sg13
S'com.google.common.util.concurrent.ForwardingListenableFuture$SimpleForwardingListenableFuture'
p38268
sg15
(lp38269
sg17
(lp38270
sg19
(lp38271
sg21
I0
sba(iArchitecture
Entity
p38272
(dp38273
g11
(lp38274
sg13
S'com.google.common.util.concurrent.ForwardingListeningExecutorService'
p38275
sg15
(lp38276
sg17
(lp38277
sg19
(lp38278
sg21
I0
sba(iArchitecture
Entity
p38279
(dp38280
g11
(lp38281
sg13
S'com.google.common.util.concurrent.FutureCallback'
p38282
sg15
(lp38283
sg17
(lp38284
sg19
(lp38285
sg21
I0
sba(iArchitecture
Entity
p38286
(dp38287
g11
(lp38288
sg13
S'com.google.common.util.concurrent.Futures'
p38289
sg15
(lp38290
sg17
(lp38291
sg19
(lp38292
sg21
I0
sba(iArchitecture
Entity
p38293
(dp38294
g11
(lp38295
sg13
S'com.google.common.util.concurrent.Futures$1'
p38296
sg15
(lp38297
sg17
(lp38298
sg19
(lp38299
sg21
I0
sba(iArchitecture
Entity
p38300
(dp38301
g11
(lp38302
sg13
S'com.google.common.util.concurrent.Futures$2'
p38303
sg15
(lp38304
sg17
(lp38305
sg19
(lp38306
sg21
I0
sba(iArchitecture
Entity
p38307
(dp38308
g11
(lp38309
sg13
S'com.google.common.util.concurrent.Futures$3'
p38310
sg15
(lp38311
sg17
(lp38312
sg19
(lp38313
sg21
I0
sba(iArchitecture
Entity
p38314
(dp38315
g11
(lp38316
sg13
S'com.google.common.util.concurrent.Futures$CallbackListener'
p38317
sg15
(lp38318
sg17
(lp38319
sg19
(lp38320
sg21
I0
sba(iArchitecture
Entity
p38321
(dp38322
g11
(lp38323
sg13
S'com.google.common.util.concurrent.Futures$FutureCombiner'
p38324
sg15
(lp38325
sg17
(lp38326
sg19
(lp38327
sg21
I0
sba(iArchitecture
Entity
p38328
(dp38329
g11
(lp38330
sg13
S'com.google.common.util.concurrent.Futures$MappingCheckedFuture'
p38331
sg15
(lp38332
sg17
(lp38333
sg19
(lp38334
sg21
I0
sba(iArchitecture
Entity
p38335
(dp38336
g11
(lp38337
sg13
S'com.google.common.util.concurrent.Futures$NonCancellationPropagatingFuture'
p38338
sg15
(lp38339
sg17
(lp38340
sg19
(lp38341
sg21
I0
sba(iArchitecture
Entity
p38342
(dp38343
g11
(lp38344
sg13
S'com.google.common.util.concurrent.Futures$NonCancellationPropagatingFuture$1'
p38345
sg15
(lp38346
sg17
(lp38347
sg19
(lp38348
sg21
I0
sba(iArchitecture
Entity
p38349
(dp38350
g11
(lp38351
sg13
S'com.google.common.util.concurrent.FuturesGetChecked'
p38352
sg15
(lp38353
sg17
(lp38354
sg19
(lp38355
sg21
I0
sba(iArchitecture
Entity
p38356
(dp38357
g11
(lp38358
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$1'
p38359
sg15
(lp38360
sg17
(lp38361
sg19
(lp38362
sg21
I0
sba(iArchitecture
Entity
p38363
(dp38364
g11
(lp38365
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidator'
p38366
sg15
(lp38367
sg17
(lp38368
sg19
(lp38369
sg21
I0
sba(iArchitecture
Entity
p38370
(dp38371
g11
(lp38372
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder'
p38373
sg15
(lp38374
sg17
(lp38375
sg19
(lp38376
sg21
I0
sba(iArchitecture
Entity
p38377
(dp38378
g11
(lp38379
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder$ClassValueValidator'
p38380
sg15
(lp38381
sg17
(lp38382
sg19
(lp38383
sg21
I0
sba(iArchitecture
Entity
p38384
(dp38385
g11
(lp38386
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder$ClassValueValidator$1'
p38387
sg15
(lp38388
sg17
(lp38389
sg19
(lp38390
sg21
I0
sba(iArchitecture
Entity
p38391
(dp38392
g11
(lp38393
sg13
S'com.google.common.util.concurrent.FuturesGetChecked$GetCheckedTypeValidatorHolder$WeakSetValidator'
p38394
sg15
(lp38395
sg17
(lp38396
sg19
(lp38397
sg21
I0
sba(iArchitecture
Entity
p38398
(dp38399
g11
(lp38400
sg13
S'com.google.common.util.concurrent.GwtFuturesCatchingSpecialization'
p38401
sg15
(lp38402
sg17
(lp38403
sg19
(lp38404
sg21
I0
sba(iArchitecture
Entity
p38405
(dp38406
g11
(lp38407
sg13
S'com.google.common.util.concurrent.ImmediateFuture'
p38408
sg15
(lp38409
sg17
(lp38410
sg19
(lp38411
sg21
I0
sba(iArchitecture
Entity
p38412
(dp38413
g11
(lp38414
sg13
S'com.google.common.util.concurrent.ImmediateFuture$ImmediateCancelledFuture'
p38415
sg15
(lp38416
sg17
(lp38417
sg19
(lp38418
sg21
I0
sba(iArchitecture
Entity
p38419
(dp38420
g11
(lp38421
sg13
S'com.google.common.util.concurrent.ImmediateFuture$ImmediateFailedCheckedFuture'
p38422
sg15
(lp38423
sg17
(lp38424
sg19
(lp38425
sg21
I0
sba(iArchitecture
Entity
p38426
(dp38427
g11
(lp38428
sg13
S'com.google.common.util.concurrent.ImmediateFuture$ImmediateFailedFuture'
p38429
sg15
(lp38430
sg17
(lp38431
sg19
(lp38432
sg21
I0
sba(iArchitecture
Entity
p38433
(dp38434
g11
(lp38435
sg13
S'com.google.common.util.concurrent.ImmediateFuture$ImmediateSuccessfulCheckedFuture'
p38436
sg15
(lp38437
sg17
(lp38438
sg19
(lp38439
sg21
I0
sba(iArchitecture
Entity
p38440
(dp38441
g11
(lp38442
sg13
S'com.google.common.util.concurrent.ImmediateFuture$ImmediateSuccessfulFuture'
p38443
sg15
(lp38444
sg17
(lp38445
sg19
(lp38446
sg21
I0
sba(iArchitecture
Entity
p38447
(dp38448
g11
(lp38449
sg13
S'com.google.common.util.concurrent.InterruptibleTask'
p38450
sg15
(lp38451
sg17
(lp38452
sg19
(lp38453
sg21
I0
sba(iArchitecture
Entity
p38454
(dp38455
g11
(lp38456
sg13
S'com.google.common.util.concurrent.InterruptibleTask$1'
p38457
sg15
(lp38458
sg17
(lp38459
sg19
(lp38460
sg21
I0
sba(iArchitecture
Entity
p38461
(dp38462
g11
(lp38463
sg13
S'com.google.common.util.concurrent.InterruptibleTask$AtomicHelper'
p38464
sg15
(lp38465
sg17
(lp38466
sg19
(lp38467
sg21
I0
sba(iArchitecture
Entity
p38468
(dp38469
g11
(lp38470
sg13
S'com.google.common.util.concurrent.InterruptibleTask$SafeAtomicHelper'
p38471
sg15
(lp38472
sg17
(lp38473
sg19
(lp38474
sg21
I0
sba(iArchitecture
Entity
p38475
(dp38476
g11
(lp38477
sg13
S'com.google.common.util.concurrent.InterruptibleTask$SynchronizedAtomicHelper'
p38478
sg15
(lp38479
sg17
(lp38480
sg19
(lp38481
sg21
I0
sba(iArchitecture
Entity
p38482
(dp38483
g11
(lp38484
sg13
S'com.google.common.util.concurrent.JdkFutureAdapters'
p38485
sg15
(lp38486
sg17
(lp38487
sg19
(lp38488
sg21
I0
sba(iArchitecture
Entity
p38489
(dp38490
g11
(lp38491
sg13
S'com.google.common.util.concurrent.JdkFutureAdapters$ListenableFutureAdapter'
p38492
sg15
(lp38493
sg17
(lp38494
sg19
(lp38495
sg21
I0
sba(iArchitecture
Entity
p38496
(dp38497
g11
(lp38498
sg13
S'com.google.common.util.concurrent.JdkFutureAdapters$ListenableFutureAdapter$1'
p38499
sg15
(lp38500
sg17
(lp38501
sg19
(lp38502
sg21
I0
sba(iArchitecture
Entity
p38503
(dp38504
g11
(lp38505
sg13
S'com.google.common.util.concurrent.ListenableFuture'
p38506
sg15
(lp38507
sg17
(lp38508
sg19
(lp38509
sg21
I0
sba(iArchitecture
Entity
p38510
(dp38511
g11
(lp38512
sg13
S'com.google.common.util.concurrent.ListenableScheduledFuture'
p38513
sg15
(lp38514
sg17
(lp38515
sg19
(lp38516
sg21
I0
sba(iArchitecture
Entity
p38517
(dp38518
g11
(lp38519
sg13
S'com.google.common.util.concurrent.ListenerCallQueue'
p38520
sg15
(lp38521
sg17
(lp38522
sg19
(lp38523
sg21
I0
sba(iArchitecture
Entity
p38524
(dp38525
g11
(lp38526
sg13
S'com.google.common.util.concurrent.ListenerCallQueue$Event'
p38527
sg15
(lp38528
sg17
(lp38529
sg19
(lp38530
sg21
I0
sba(iArchitecture
Entity
p38531
(dp38532
g11
(lp38533
sg13
S'com.google.common.util.concurrent.ListenerCallQueue$PerListenerQueue'
p38534
sg15
(lp38535
sg17
(lp38536
sg19
(lp38537
sg21
I0
sba(iArchitecture
Entity
p38538
(dp38539
g11
(lp38540
sg13
S'com.google.common.util.concurrent.ListeningExecutorService'
p38541
sg15
(lp38542
sg17
(lp38543
sg19
(lp38544
sg21
I0
sba(iArchitecture
Entity
p38545
(dp38546
g11
(lp38547
sg13
S'com.google.common.util.concurrent.ListeningScheduledExecutorService'
p38548
sg15
(lp38549
sg17
(lp38550
sg19
(lp38551
sg21
I0
sba(iArchitecture
Entity
p38552
(dp38553
g11
(lp38554
sg13
S'com.google.common.util.concurrent.Monitor'
p38555
sg15
(lp38556
sg17
(lp38557
sg19
(lp38558
sg21
I0
sba(iArchitecture
Entity
p38559
(dp38560
g11
(lp38561
sg13
S'com.google.common.util.concurrent.Monitor$1'
p38562
sg15
(lp38563
sg17
(lp38564
sg19
(lp38565
sg21
I0
sba(iArchitecture
Entity
p38566
(dp38567
g11
(lp38568
sg13
S'com.google.common.util.concurrent.Monitor$Guard'
p38569
sg15
(lp38570
sg17
(lp38571
sg19
(lp38572
sg21
I0
sba(iArchitecture
Entity
p38573
(dp38574
g11
(lp38575
sg13
S'com.google.common.util.concurrent.MoreExecutors'
p38576
sg15
(lp38577
sg17
(lp38578
sg19
(lp38579
sg21
I0
sba(iArchitecture
Entity
p38580
(dp38581
g11
(lp38582
sg13
S'com.google.common.util.concurrent.MoreExecutors$1'
p38583
sg15
(lp38584
sg17
(lp38585
sg19
(lp38586
sg21
I0
sba(iArchitecture
Entity
p38587
(dp38588
g11
(lp38589
sg13
S'com.google.common.util.concurrent.MoreExecutors$2'
p38590
sg15
(lp38591
sg17
(lp38592
sg19
(lp38593
sg21
I0
sba(iArchitecture
Entity
p38594
(dp38595
g11
(lp38596
sg13
S'com.google.common.util.concurrent.MoreExecutors$3'
p38597
sg15
(lp38598
sg17
(lp38599
sg19
(lp38600
sg21
I0
sba(iArchitecture
Entity
p38601
(dp38602
g11
(lp38603
sg13
S'com.google.common.util.concurrent.MoreExecutors$4'
p38604
sg15
(lp38605
sg17
(lp38606
sg19
(lp38607
sg21
I0
sba(iArchitecture
Entity
p38608
(dp38609
g11
(lp38610
sg13
S'com.google.common.util.concurrent.MoreExecutors$5'
p38611
sg15
(lp38612
sg17
(lp38613
sg19
(lp38614
sg21
I0
sba(iArchitecture
Entity
p38615
(dp38616
g11
(lp38617
sg13
S'com.google.common.util.concurrent.MoreExecutors$5$1'
p38618
sg15
(lp38619
sg17
(lp38620
sg19
(lp38621
sg21
I0
sba(iArchitecture
Entity
p38622
(dp38623
g11
(lp38624
sg13
S'com.google.common.util.concurrent.MoreExecutors$Application'
p38625
sg15
(lp38626
sg17
(lp38627
sg19
(lp38628
sg21
I0
sba(iArchitecture
Entity
p38629
(dp38630
g11
(lp38631
sg13
S'com.google.common.util.concurrent.MoreExecutors$Application$1'
p38632
sg15
(lp38633
sg17
(lp38634
sg19
(lp38635
sg21
I0
sba(iArchitecture
Entity
p38636
(dp38637
g11
(lp38638
sg13
S'com.google.common.util.concurrent.MoreExecutors$DirectExecutor'
p38639
sg15
(lp38640
sg17
(lp38641
sg19
(lp38642
sg21
I0
sba(iArchitecture
Entity
p38643
(dp38644
g11
(lp38645
sg13
S'com.google.common.util.concurrent.MoreExecutors$DirectExecutorService'
p38646
sg15
(lp38647
sg17
(lp38648
sg19
(lp38649
sg21
I0
sba(iArchitecture
Entity
p38650
(dp38651
g11
(lp38652
sg13
S'com.google.common.util.concurrent.MoreExecutors$ListeningDecorator'
p38653
sg15
(lp38654
sg17
(lp38655
sg19
(lp38656
sg21
I0
sba(iArchitecture
Entity
p38657
(dp38658
g11
(lp38659
sg13
S'com.google.common.util.concurrent.MoreExecutors$ScheduledListeningDecorator'
p38660
sg15
(lp38661
sg17
(lp38662
sg19
(lp38663
sg21
I0
sba(iArchitecture
Entity
p38664
(dp38665
g11
(lp38666
sg13
S'com.google.common.util.concurrent.MoreExecutors$ScheduledListeningDecorator$ListenableScheduledTask'
p38667
sg15
(lp38668
sg17
(lp38669
sg19
(lp38670
sg21
I0
sba(iArchitecture
Entity
p38671
(dp38672
g11
(lp38673
sg13
S'com.google.common.util.concurrent.MoreExecutors$ScheduledListeningDecorator$NeverSuccessfulListenableFutureTask'
p38674
sg15
(lp38675
sg17
(lp38676
sg19
(lp38677
sg21
I0
sba(iArchitecture
Entity
p38678
(dp38679
g11
(lp38680
sg13
S'com.google.common.util.concurrent.Partially'
p38681
sg15
(lp38682
sg17
(lp38683
sg19
(lp38684
sg21
I0
sba(iArchitecture
Entity
p38685
(dp38686
g11
(lp38687
sg13
S'com.google.common.util.concurrent.Partially$GwtIncompatible'
p38688
sg15
(lp38689
sg17
(lp38690
sg19
(lp38691
sg21
I0
sba(iArchitecture
Entity
p38692
(dp38693
g11
(lp38694
sg13
S'com.google.common.util.concurrent.Platform'
p38695
sg15
(lp38696
sg17
(lp38697
sg19
(lp38698
sg21
I0
sba(iArchitecture
Entity
p38699
(dp38700
g11
(lp38701
sg13
S'com.google.common.util.concurrent.RateLimiter'
p38702
sg15
(lp38703
sg17
(lp38704
sg19
(lp38705
sg21
I0
sba(iArchitecture
Entity
p38706
(dp38707
g11
(lp38708
sg13
S'com.google.common.util.concurrent.RateLimiter$SleepingStopwatch'
p38709
sg15
(lp38710
sg17
(lp38711
sg19
(lp38712
sg21
I0
sba(iArchitecture
Entity
p38713
(dp38714
g11
(lp38715
sg13
S'com.google.common.util.concurrent.RateLimiter$SleepingStopwatch$1'
p38716
sg15
(lp38717
sg17
(lp38718
sg19
(lp38719
sg21
I0
sba(iArchitecture
Entity
p38720
(dp38721
g11
(lp38722
sg13
S'com.google.common.util.concurrent.Runnables'
p38723
sg15
(lp38724
sg17
(lp38725
sg19
(lp38726
sg21
I0
sba(iArchitecture
Entity
p38727
(dp38728
g11
(lp38729
sg13
S'com.google.common.util.concurrent.Runnables$1'
p38730
sg15
(lp38731
sg17
(lp38732
sg19
(lp38733
sg21
I0
sba(iArchitecture
Entity
p38734
(dp38735
g11
(lp38736
sg13
S'com.google.common.util.concurrent.SerializingExecutor'
p38737
sg15
(lp38738
sg17
(lp38739
sg19
(lp38740
sg21
I0
sba(iArchitecture
Entity
p38741
(dp38742
g11
(lp38743
sg13
S'com.google.common.util.concurrent.SerializingExecutor$1'
p38744
sg15
(lp38745
sg17
(lp38746
sg19
(lp38747
sg21
I0
sba(iArchitecture
Entity
p38748
(dp38749
g11
(lp38750
sg13
S'com.google.common.util.concurrent.SerializingExecutor$QueueWorker'
p38751
sg15
(lp38752
sg17
(lp38753
sg19
(lp38754
sg21
I0
sba(iArchitecture
Entity
p38755
(dp38756
g11
(lp38757
sg13
S'com.google.common.util.concurrent.Service'
p38758
sg15
(lp38759
sg17
(lp38760
sg19
(lp38761
sg21
I0
sba(iArchitecture
Entity
p38762
(dp38763
g11
(lp38764
sg13
S'com.google.common.util.concurrent.Service$1'
p38765
sg15
(lp38766
sg17
(lp38767
sg19
(lp38768
sg21
I0
sba(iArchitecture
Entity
p38769
(dp38770
g11
(lp38771
sg13
S'com.google.common.util.concurrent.Service$Listener'
p38772
sg15
(lp38773
sg17
(lp38774
sg19
(lp38775
sg21
I0
sba(iArchitecture
Entity
p38776
(dp38777
g11
(lp38778
sg13
S'com.google.common.util.concurrent.Service$State'
p38779
sg15
(lp38780
sg17
(lp38781
sg19
(lp38782
sg21
I0
sba(iArchitecture
Entity
p38783
(dp38784
g11
(lp38785
sg13
S'com.google.common.util.concurrent.Service$State$1'
p38786
sg15
(lp38787
sg17
(lp38788
sg19
(lp38789
sg21
I0
sba(iArchitecture
Entity
p38790
(dp38791
g11
(lp38792
sg13
S'com.google.common.util.concurrent.Service$State$2'
p38793
sg15
(lp38794
sg17
(lp38795
sg19
(lp38796
sg21
I0
sba(iArchitecture
Entity
p38797
(dp38798
g11
(lp38799
sg13
S'com.google.common.util.concurrent.Service$State$3'
p38800
sg15
(lp38801
sg17
(lp38802
sg19
(lp38803
sg21
I0
sba(iArchitecture
Entity
p38804
(dp38805
g11
(lp38806
sg13
S'com.google.common.util.concurrent.Service$State$4'
p38807
sg15
(lp38808
sg17
(lp38809
sg19
(lp38810
sg21
I0
sba(iArchitecture
Entity
p38811
(dp38812
g11
(lp38813
sg13
S'com.google.common.util.concurrent.Service$State$5'
p38814
sg15
(lp38815
sg17
(lp38816
sg19
(lp38817
sg21
I0
sba(iArchitecture
Entity
p38818
(dp38819
g11
(lp38820
sg13
S'com.google.common.util.concurrent.Service$State$6'
p38821
sg15
(lp38822
sg17
(lp38823
sg19
(lp38824
sg21
I0
sba(iArchitecture
Entity
p38825
(dp38826
g11
(lp38827
sg13
S'com.google.common.util.concurrent.ServiceManager'
p38828
sg15
(lp38829
sg17
(lp38830
sg19
(lp38831
sg21
I0
sba(iArchitecture
Entity
p38832
(dp38833
g11
(lp38834
sg13
S'com.google.common.util.concurrent.ServiceManager$1'
p38835
sg15
(lp38836
sg17
(lp38837
sg19
(lp38838
sg21
I0
sba(iArchitecture
Entity
p38839
(dp38840
g11
(lp38841
sg13
S'com.google.common.util.concurrent.ServiceManager$2'
p38842
sg15
(lp38843
sg17
(lp38844
sg19
(lp38845
sg21
I0
sba(iArchitecture
Entity
p38846
(dp38847
g11
(lp38848
sg13
S'com.google.common.util.concurrent.ServiceManager$EmptyServiceManagerWarning'
p38849
sg15
(lp38850
sg17
(lp38851
sg19
(lp38852
sg21
I0
sba(iArchitecture
Entity
p38853
(dp38854
g11
(lp38855
sg13
S'com.google.common.util.concurrent.ServiceManager$Listener'
p38856
sg15
(lp38857
sg17
(lp38858
sg19
(lp38859
sg21
I0
sba(iArchitecture
Entity
p38860
(dp38861
g11
(lp38862
sg13
S'com.google.common.util.concurrent.ServiceManager$NoOpService'
p38863
sg15
(lp38864
sg17
(lp38865
sg19
(lp38866
sg21
I0
sba(iArchitecture
Entity
p38867
(dp38868
g11
(lp38869
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceListener'
p38870
sg15
(lp38871
sg17
(lp38872
sg19
(lp38873
sg21
I0
sba(iArchitecture
Entity
p38874
(dp38875
g11
(lp38876
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState'
p38877
sg15
(lp38878
sg17
(lp38879
sg19
(lp38880
sg21
I0
sba(iArchitecture
Entity
p38881
(dp38882
g11
(lp38883
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$1'
p38884
sg15
(lp38885
sg17
(lp38886
sg19
(lp38887
sg21
I0
sba(iArchitecture
Entity
p38888
(dp38889
g11
(lp38890
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$2'
p38891
sg15
(lp38892
sg17
(lp38893
sg19
(lp38894
sg21
I0
sba(iArchitecture
Entity
p38895
(dp38896
g11
(lp38897
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$AwaitHealthGuard'
p38898
sg15
(lp38899
sg17
(lp38900
sg19
(lp38901
sg21
I0
sba(iArchitecture
Entity
p38902
(dp38903
g11
(lp38904
sg13
S'com.google.common.util.concurrent.ServiceManager$ServiceManagerState$StoppedGuard'
p38905
sg15
(lp38906
sg17
(lp38907
sg19
(lp38908
sg21
I0
sba(iArchitecture
Entity
p38909
(dp38910
g11
(lp38911
sg13
S'com.google.common.util.concurrent.SettableFuture'
p38912
sg15
(lp38913
sg17
(lp38914
sg19
(lp38915
sg21
I0
sba(iArchitecture
Entity
p38916
(dp38917
g11
(lp38918
sg13
S'com.google.common.util.concurrent.SimpleTimeLimiter'
p38919
sg15
(lp38920
sg17
(lp38921
sg19
(lp38922
sg21
I0
sba(iArchitecture
Entity
p38923
(dp38924
g11
(lp38925
sg13
S'com.google.common.util.concurrent.SimpleTimeLimiter$1'
p38926
sg15
(lp38927
sg17
(lp38928
sg19
(lp38929
sg21
I0
sba(iArchitecture
Entity
p38930
(dp38931
g11
(lp38932
sg13
S'com.google.common.util.concurrent.SimpleTimeLimiter$1$1'
p38933
sg15
(lp38934
sg17
(lp38935
sg19
(lp38936
sg21
I0
sba(iArchitecture
Entity
p38937
(dp38938
g11
(lp38939
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter'
p38940
sg15
(lp38941
sg17
(lp38942
sg19
(lp38943
sg21
I0
sba(iArchitecture
Entity
p38944
(dp38945
g11
(lp38946
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter$1'
p38947
sg15
(lp38948
sg17
(lp38949
sg19
(lp38950
sg21
I0
sba(iArchitecture
Entity
p38951
(dp38952
g11
(lp38953
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter$SmoothBursty'
p38954
sg15
(lp38955
sg17
(lp38956
sg19
(lp38957
sg21
I0
sba(iArchitecture
Entity
p38958
(dp38959
g11
(lp38960
sg13
S'com.google.common.util.concurrent.SmoothRateLimiter$SmoothWarmingUp'
p38961
sg15
(lp38962
sg17
(lp38963
sg19
(lp38964
sg21
I0
sba(iArchitecture
Entity
p38965
(dp38966
g11
(lp38967
sg13
S'com.google.common.util.concurrent.Striped'
p38968
sg15
(lp38969
sg17
(lp38970
sg19
(lp38971
sg21
I0
sba(iArchitecture
Entity
p38972
(dp38973
g11
(lp38974
sg13
S'com.google.common.util.concurrent.Striped$1'
p38975
sg15
(lp38976
sg17
(lp38977
sg19
(lp38978
sg21
I0
sba(iArchitecture
Entity
p38979
(dp38980
g11
(lp38981
sg13
S'com.google.common.util.concurrent.Striped$2'
p38982
sg15
(lp38983
sg17
(lp38984
sg19
(lp38985
sg21
I0
sba(iArchitecture
Entity
p38986
(dp38987
g11
(lp38988
sg13
S'com.google.common.util.concurrent.Striped$3'
p38989
sg15
(lp38990
sg17
(lp38991
sg19
(lp38992
sg21
I0
sba(iArchitecture
Entity
p38993
(dp38994
g11
(lp38995
sg13
S'com.google.common.util.concurrent.Striped$4'
p38996
sg15
(lp38997
sg17
(lp38998
sg19
(lp38999
sg21
I0
sba(iArchitecture
Entity
p39000
(dp39001
g11
(lp39002
sg13
S'com.google.common.util.concurrent.Striped$5'
p39003
sg15
(lp39004
sg17
(lp39005
sg19
(lp39006
sg21
I0
sba(iArchitecture
Entity
p39007
(dp39008
g11
(lp39009
sg13
S'com.google.common.util.concurrent.Striped$CompactStriped'
p39010
sg15
(lp39011
sg17
(lp39012
sg19
(lp39013
sg21
I0
sba(iArchitecture
Entity
p39014
(dp39015
g11
(lp39016
sg13
S'com.google.common.util.concurrent.Striped$LargeLazyStriped'
p39017
sg15
(lp39018
sg17
(lp39019
sg19
(lp39020
sg21
I0
sba(iArchitecture
Entity
p39021
(dp39022
g11
(lp39023
sg13
S'com.google.common.util.concurrent.Striped$PaddedLock'
p39024
sg15
(lp39025
sg17
(lp39026
sg19
(lp39027
sg21
I0
sba(iArchitecture
Entity
p39028
(dp39029
g11
(lp39030
sg13
S'com.google.common.util.concurrent.Striped$PaddedSemaphore'
p39031
sg15
(lp39032
sg17
(lp39033
sg19
(lp39034
sg21
I0
sba(iArchitecture
Entity
p39035
(dp39036
g11
(lp39037
sg13
S'com.google.common.util.concurrent.Striped$PowerOfTwoStriped'
p39038
sg15
(lp39039
sg17
(lp39040
sg19
(lp39041
sg21
I0
sba(iArchitecture
Entity
p39042
(dp39043
g11
(lp39044
sg13
S'com.google.common.util.concurrent.Striped$SmallLazyStriped'
p39045
sg15
(lp39046
sg17
(lp39047
sg19
(lp39048
sg21
I0
sba(iArchitecture
Entity
p39049
(dp39050
g11
(lp39051
sg13
S'com.google.common.util.concurrent.Striped$SmallLazyStriped$ArrayReference'
p39052
sg15
(lp39053
sg17
(lp39054
sg19
(lp39055
sg21
I0
sba(iArchitecture
Entity
p39056
(dp39057
g11
(lp39058
sg13
S'com.google.common.util.concurrent.ThreadFactoryBuilder'
p39059
sg15
(lp39060
sg17
(lp39061
sg19
(lp39062
sg21
I0
sba(iArchitecture
Entity
p39063
(dp39064
g11
(lp39065
sg13
S'com.google.common.util.concurrent.ThreadFactoryBuilder$1'
p39066
sg15
(lp39067
sg17
(lp39068
sg19
(lp39069
sg21
I0
sba(iArchitecture
Entity
p39070
(dp39071
g11
(lp39072
sg13
S'com.google.common.util.concurrent.TimeLimiter'
p39073
sg15
(lp39074
sg17
(lp39075
sg19
(lp39076
sg21
I0
sba(iArchitecture
Entity
p39077
(dp39078
g11
(lp39079
sg13
S'com.google.common.util.concurrent.TimeoutFuture'
p39080
sg15
(lp39081
sg17
(lp39082
sg19
(lp39083
sg21
I0
sba(iArchitecture
Entity
p39084
(dp39085
g11
(lp39086
sg13
S'com.google.common.util.concurrent.TimeoutFuture$Fire'
p39087
sg15
(lp39088
sg17
(lp39089
sg19
(lp39090
sg21
I0
sba(iArchitecture
Entity
p39091
(dp39092
g11
(lp39093
sg13
S'com.google.common.util.concurrent.TrustedListenableFutureTask'
p39094
sg15
(lp39095
sg17
(lp39096
sg19
(lp39097
sg21
I0
sba(iArchitecture
Entity
p39098
(dp39099
g11
(lp39100
sg13
S'com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask'
p39101
sg15
(lp39102
sg17
(lp39103
sg19
(lp39104
sg21
I0
sba(iArchitecture
Entity
p39105
(dp39106
g11
(lp39107
sg13
S'com.google.common.util.concurrent.UncaughtExceptionHandlers'
p39108
sg15
(lp39109
sg17
(lp39110
sg19
(lp39111
sg21
I0
sba(iArchitecture
Entity
p39112
(dp39113
g11
(lp39114
sg13
S'com.google.common.util.concurrent.UncaughtExceptionHandlers$Exiter'
p39115
sg15
(lp39116
sg17
(lp39117
sg19
(lp39118
sg21
I0
sba(iArchitecture
Entity
p39119
(dp39120
g11
(lp39121
sg13
S'com.google.common.util.concurrent.UncheckedExecutionException'
p39122
sg15
(lp39123
sg17
(lp39124
sg19
(lp39125
sg21
I0
sba(iArchitecture
Entity
p39126
(dp39127
g11
(lp39128
sg13
S'com.google.common.util.concurrent.UncheckedTimeoutException'
p39129
sg15
(lp39130
sg17
(lp39131
sg19
(lp39132
sg21
I0
sba(iArchitecture
Entity
p39133
(dp39134
g11
(lp39135
sg13
S'com.google.common.util.concurrent.Uninterruptibles'
p39136
sg15
(lp39137
sg17
(lp39138
sg19
(lp39139
sg21
I0
sba(iArchitecture
Entity
p39140
(dp39141
g11
(lp39142
sg13
S'com.google.common.util.concurrent.WrappingExecutorService'
p39143
sg15
(lp39144
sg17
(lp39145
sg19
(lp39146
sg21
I0
sba(iArchitecture
Entity
p39147
(dp39148
g11
(lp39149
sg13
S'com.google.common.util.concurrent.WrappingExecutorService$1'
p39150
sg15
(lp39151
sg17
(lp39152
sg19
(lp39153
sg21
I0
sba(iArchitecture
Entity
p39154
(dp39155
g11
(lp39156
sg13
S'com.google.common.util.concurrent.WrappingScheduledExecutorService'
p39157
sg15
(lp39158
sg17
(lp39159
sg19
(lp39160
sg21
I0
sba(iArchitecture
Entity
p39161
(dp39162
g11
(lp39163
sg13
S'com.google.errorprone.annotations.DoNotMock'
p39164
sg15
(lp39165
sg17
(lp39166
sg19
(lp39167
sg21
I0
sba(iArchitecture
Entity
p39168
(dp39169
g11
(lp39170
sg13
S'com.google.errorprone.annotations.ForOverride'
p39171
sg15
(lp39172
sg17
(lp39173
sg19
(lp39174
sg21
I0
sba(iArchitecture
Entity
p39175
(dp39176
g11
(lp39177
sg13
S'com.google.j2objc.annotations.ReflectionSupport'
p39178
sg15
(lp39179
sg17
(lp39180
sg19
(lp39181
sg21
I0
sba(iArchitecture
Entity
p39182
(dp39183
g11
(lp39184
sg13
S'com.google.j2objc.annotations.ReflectionSupport$Level'
p39185
sg15
(lp39186
sg17
(lp39187
sg19
(lp39188
sg21
I0
sba(iArchitecture
Entity
p39189
(dp39190
g11
(lp39191
sg13
S'istFutureRunningState'
p39192
sg15
(lp39193
sg17
(lp39194
sg19
(lp39195
sg21
I0
sba(iArchitecture
Entity
p39196
(dp39197
g11
(lp39198
sg13
S'org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement'
p39199
sg15
(lp39200
sg17
(lp39201
sg19
(lp39202
sg21
I0
sbasg1135
(lp39203
g37484
ag37491
ag37498
ag37505
ag37512
ag37519
ag37526
ag37533
ag37540
ag37547
ag37554
ag37561
ag37568
ag37575
ag37582
ag37589
ag37596
ag37603
ag37610
ag37617
ag37624
ag37631
ag37638
ag37645
ag37652
ag37659
ag37666
ag37673
ag37680
ag37687
ag37694
ag37701
ag37708
ag37715
ag37722
ag37729
ag37736
ag37743
ag37750
ag37757
ag37764
ag37771
ag37778
ag37785
ag37792
ag37799
ag37806
ag37813
ag37820
ag37827
ag37834
ag37841
ag37848
ag37855
ag37862
ag37869
ag37876
ag37883
ag37890
ag37897
ag37904
ag37911
ag37918
ag37925
ag37932
ag37939
ag37946
ag37953
ag37960
ag37967
ag37974
ag37981
ag37988
ag37995
ag38002
ag38009
ag38016
ag38023
ag38030
ag38037
ag38044
ag38051
ag38058
ag38065
ag38072
ag38079
ag38086
ag38093
ag38100
ag38107
ag38114
ag38121
ag38128
ag38135
ag38142
ag38149
ag38156
ag38163
ag38170
ag38177
ag38184
ag38191
ag38198
ag38205
ag38212
ag38219
ag38226
ag38233
ag38240
ag38247
ag38254
ag38261
ag38268
ag38275
ag38282
ag38289
ag38296
ag38303
ag38310
ag38317
ag38324
ag38331
ag38338
ag38345
ag38352
ag38359
ag38366
ag38373
ag38380
ag38387
ag38394
ag38401
ag38408
ag38415
ag38422
ag38429
ag38436
ag38443
ag38450
ag38457
ag38464
ag38471
ag38478
ag38485
ag38492
ag38499
ag38506
ag38513
ag38520
ag38527
ag38534
ag38541
ag38548
ag38555
ag38562
ag38569
ag38576
ag38583
ag38590
ag38597
ag38604
ag38611
ag38618
ag38625
ag38632
ag38639
ag38646
ag38653
ag38660
ag38667
ag38674
ag38681
ag38688
ag38695
ag38702
ag38709
ag38716
ag38723
ag38730
ag38737
ag38744
ag38751
ag38758
ag38765
ag38772
ag38779
ag38786
ag38793
ag38800
ag38807
ag38814
ag38821
ag38828
ag38835
ag38842
ag38849
ag38856
ag38863
ag38870
ag38877
ag38884
ag38891
ag38898
ag38905
ag38912
ag38919
ag38926
ag38933
ag38940
ag38947
ag38954
ag38961
ag38968
ag38975
ag38982
ag38989
ag38996
ag39003
ag39010
ag39017
ag39024
ag39031
ag39038
ag39045
ag39052
ag39059
ag39066
ag39073
ag39080
ag39087
ag39094
ag39101
ag39108
ag39115
ag39122
ag39129
ag39136
ag39143
ag39150
ag39157
ag39164
ag39171
ag39178
ag39185
ag39192
ag39199
asg1137
I0
sg21
I0
sg1138
S'com.google.common.util.concurrent.ss'
p39204
sba(iArchitecture
Cluster
p39205
(dp39206
g7
(lp39207
(iArchitecture
Entity
p39208
(dp39209
g11
(lp39210
sg13
S'com.google.thirdparty.publicsuffix.PublicSuffixPatterns'
p39211
sg15
(lp39212
sg17
(lp39213
sg19
(lp39214
sg21
I0
sba(iArchitecture
Entity
p39215
(dp39216
g11
(lp39217
sg13
S'com.google.thirdparty.publicsuffix.PublicSuffixType'
p39218
sg15
(lp39219
sg17
(lp39220
sg19
(lp39221
sg21
I0
sba(iArchitecture
Entity
p39222
(dp39223
g11
(lp39224
sg13
S'com.google.thirdparty.publicsuffix.TrieParser'
p39225
sg15
(lp39226
sg17
(lp39227
sg19
(lp39228
sg21
I0
sbasg1135
(lp39229
g39211
ag39218
ag39225
asg1137
I0
sg21
I0
sg1138
S'com.google.thirdparty.publicsuffix.ss'
p39230
sbasg13265
g13266
sg1135
(lp39231
sg13268
I00
sg1138
S'22.0'
p39232
sba.