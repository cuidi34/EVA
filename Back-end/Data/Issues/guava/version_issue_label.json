{"v23.0": {"1746": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1746) created by **ddlatham** on 2014-05-06 at 11:24 PM_\n\n---\n\nFor my use case I want to iterate over all possible combinations of size k from a given Set.  Existing methods that satisfy similar use cases are Collections2.permutations and Sets.powerSet.  I would imagine it would take an input Collection&lt;E> and return a Collection&lt;Set&lt;E>>\n", "label": [5], "title": "Method to generate a collection of all possible combinations of size k"}, "2787": {"body": "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap doesn't mention MultimapBuilder anywhere.  It does mention Multimaps.newMultimap() as a means of getting a custom collection type but we should mention MultimapBuilder as well (if not instead of) newMultimap().", "label": [2], "title": "NewCollectionTypesExplained should reference MultimapBuilder"}, "2843": {"body": "The default implementations of `{Byte,Char}Source.isEmpty()` seem to do unnecessary work when the size is known to be non-zero.\r\n\r\nHere is what `ByteSource` does now:\r\n\r\n```java\r\npublic boolean isEmpty() throws IOException {\r\n  Optional<Long> sizeIfKnown = sizeIfKnown();\r\n  if (sizeIfKnown.isPresent() && sizeIfKnown.get() == 0L) {\r\n    return true;\r\n  }\r\n  // Fall back to reading a byte from the input stream...\r\n```\r\n\r\nI feel like it should do this instead:\r\n\r\n```java\r\npublic boolean isEmpty() throws IOException {\r\n  Optional<Long> sizeIfKnown = sizeIfKnown();\r\n  if (sizeIfKnown.isPresent()) {\r\n    return sizeIfKnown.get() == 0L;\r\n  }\r\n  // Fall back to reading a byte from the input stream...\r\n```\r\n\r\nThat way it avoids reading the input stream when the size is known to be non-zero.\r\n\r\nI see warnings in the javadocs that some sources report inaccurate sizes, but the example given is non-empty files that report a size of zero.  Are there empty files that falsely report a non-zero size?  If not, I think this change is safe.", "label": [0], "title": "Optimize {Byte,Char}Source.isEmpty() for known-non-empty sources"}, "2866": {"body": "Exception cause can be set by initCause method which can lead to a circular reference:\r\n```java\r\nException cause = new Exception();\r\nException exception = new Exception(cause);\r\ncause.initCause(exception);\r\n```\r\nCalling `Throwables.getCausalChain( exception )` or `Throwables.getRootCause( exception )` could lead to an infinitive loop.\r\n\r\nIt is good idea to use a `Set` to add cause exceptions to avoid iterating over a circular reference when `Set.add` method returns `false`. ", "label": [0], "title": "Make Throwables.getCausalChain and Throwables.getRootCause cyclic reference safe"}, "2885": {"body": "In the Guava 23.0 [release notes](https://github.com/google/guava/wiki/Release23), there was a mention of a class `GraphTraverser` which AFAICT isn't in the open source version of Guava. Is it a real class in Google-internal Guava? If so, are there any plans to eventually release it?", "label": [2], "title": "GraphTraverser?"}}, "v23.1": {"2146": {"body": "`ByteSource.asCharSource` is present, and very useful. But I'm finding several cases where it'd be nice to have a `ByteSource` view of a `CharSource` without first serializing out to `String` and then calling `String.getBytes(Charset)`. Additionally, having both `ByteSource.asCharSource` and `CharSource.asByteSource` would let us chain the two to transcode from a `ByteSource` in one charset to a `ByteSource` in another.\n", "label": [5], "title": "add CharSource.asByteSource"}, "2942": {"body": null, "label": [], "title": "Moe sync"}, "2948": {"body": "Java 8u144 (Mac 10.11.6)\r\nGuava 23.0\r\n\r\nExpected: Calling `parallelStream()` on an ImmutableMap-derived Set should lead to pipeline execution on multiple threads. Calling `spliterator()` on a ImmutableMap-derived Set should yield a splittable (`trySplit() != null`) spliterator.\r\n\r\nActual: Pipeline executes on main thread only. Spliterator is not splittable.\r\n\r\nDiagnosis:\r\nThe spliterator is ultimately constructed using an `IntStream#range` which is sequential. The `AbstractWrappingSpliterator` that results from the `mapToObj` checks the stream context and refuses to split if the stream is sequential (even though the underlying spliterator is splittable, see `trySplit:189, StreamSpliterators$AbstractWrappingSpliterator (java.util.stream)`). `RegularImmutableSet` and friends are constructed using `ArraySpliterator`, which don't have this problem.\r\n\r\n```\r\nrange:798, IntStream (java.util.stream)\r\nindexed:94, CollectSpliterators (com.google.common.collect)\r\nindexed:40, CollectSpliterators (com.google.common.collect)\r\nspliterator:386, ImmutableSet$Indexed (com.google.common.collect)\r\nparallelStream:602, Collection (java.util)\r\n```\r\n\r\n\r\n```\r\npublic class Problem {\r\n\r\n  public static void main(String[] args) {\r\n    Set<String> list = Stream.iterate(\"a\", str -> str + \"a\")\r\n        .limit(1000)\r\n        .collect(toImmutableMap(Function.identity(), Function.identity()))\r\n        .keySet();\r\n\r\n    Logger logger = Logger.getAnonymousLogger();\r\n    logger.info(\"Parallel stream is parallel: \" + list.parallelStream().isParallel());\r\n    logger.info(\"Parallel stream's spliterator can be split: \"\r\n        + (list.parallelStream().spliterator().trySplit() != null));\r\n\r\n    ThreadLocal<Boolean> invoked = ThreadLocal.withInitial(() -> false);\r\n\r\n    list.parallelStream()\r\n        .map(str -> {\r\n          if (invoked.get()) {\r\n            return str;\r\n          }\r\n          invoked.set(true);\r\n          logger.info(\"Parallel stream executed on thread \" + Thread.currentThread().getName());\r\n          return str;\r\n        })\r\n        .forEach(str -> {});\r\n  }\r\n\r\n}\r\n```\r\n\r\nExpected:\r\n```\r\nINFO: Parallel stream is parallel: true\r\nINFO: Parallel stream's spliterator can be split: true\r\nINFO: Parallel stream executed on thread main\r\nINFO: Parallel stream executed on thread ForkJoinPool.commonPool-worker-4\r\nINFO: Parallel stream executed on thread ForkJoinPool.commonPool-worker-2\r\n...\r\n```\r\n\r\nActual:\r\n```\r\nINFO: Parallel stream is parallel: true\r\nINFO: Parallel stream's spliterator can be split: false\r\nINFO: Parallel stream executed on thread main\r\n```", "label": [3], "title": "ImmutableMap's key set's spliterator is not splittable"}}, "v23.2": {"2936": {"body": "It's not actually easy to sort an `int[]` in reverse in Java.  The typical ways you'd sort an array in reverse don't work on primitives:\r\n\r\n     Arrays.sort(array, Collections.reverseOrder()); // no comparators for primitives\r\n\r\n     Arrays.sort(array);\r\n     Collections.reverse(Arrays.asList(array)); // view array as a List and reverse it, but Arrays.asList doesn't work for int[]\r\n\r\nThe shortest way I can think of is\r\n\r\n     Arrays.sort(array);\r\n     Collections.reverse(Ints.asList(array));\r\n\r\n...which boxes every element in the array.\r\n\r\nPerhaps we should consider e.g. `Ints.reverseSort` or the like.", "label": [5, 0], "title": "Add reverse sorting for primitives"}, "2024": {"body": "Someone asked, \"is the order of URL parameters fixed across JVM boundaries? In other words, is it e.g. alphabetical, rather than just hash order?\"\n\nAnswers:\n\"They are in insertion (creation) order, so that parse->serialize ordering is preserved.\"\n\"Yep, uses a LinkedListMultimap under the hood.\"\n\"It seems unsafe to depend on this though, because that detail is never promised in the Uri interface, at least as far as I can see (though, it's probably one of those things that is unlikely to ever change).\"\n\nSo... \"If we're willing to make the commitment, it would be nice to add that promise to the interface.\"\n", "label": [2], "title": "Document the ordering guarantees made by Uri"}, "2959": {"body": "Hello,\r\n\r\nThis is continue of #2152 the problem still exists, but this time on java 9.\r\n\r\n```log\r\njava version \"9\"\r\nJava(TM) SE Runtime Environment (build 9+181)\r\nJava HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode)\r\n```\r\nI've tested with 22.0, 23.0, 23.1\r\n\r\n", "label": [1], "title": "ClassPath.getTopLevelClasses() returns empty list (Again)"}, "2962": {"body": "When creating `ImmutableSortedMap` instances the documentation for methods `copyOf` and `copyOfSorted` state: \r\n\r\n> \"NullPointerException - if any key or value in map is null\"\r\n\r\nHowever this behavior is not consistent an it is possible to create a map with null values.\r\n\r\nGiven a `HashMap` of stings with `map:{a:null}` all the `copOf` methods throw as expected, with a `map:{a:null, b:two}` then none of the `copyOf` methods throw.\r\n\r\nGiven a `SortedMap` of strings with `map:{a:null}` and a natural order `copyOf` and `copyOfSorted` all throw as expected; with a `map:{a:null, b:two}` then `copyOf(Map)` and `copyOfSorted(SortedMap)` throw; `copyOf(Iterable)`, `copyOf(Iterable, Comparator)`, `copyOf(Map, Comparator)` do not throw; with a `map:{a:one, b:null}`\r\n`copyOf` and `copyOfSorted` all throw as expected.\r\n\r\nFrom what I can tell this behavior is only present for maps with two elements and only when the `null` is the first value of the first key. The `of` and `builder` methods are not effected an throw as expected.\r\n\r\n", "label": [1], "title": "Inconsistant null checks in ImmutableSortedMap"}}, "v23.3": {"2477": {"body": "We're seeing a behaviour of a Striped.lazyReadWriteLock that seem to break the documented behaviour that for the same key the same lock will be returned. Is there something obvious we're missing or misunderstood about the lazy Striped Locks? When using eager Locks, everything works as expected.\n\nThe following test reproduces the behaviour.\n\n```\npublic class MyTest {\n\n    private final Striped<ReadWriteLock> stripedLock = Striped.lazyWeakReadWriteLock(64);\n    private final AtomicBoolean writeLocked = new AtomicBoolean(false);\n    private final Set<String> someSet = new HashSet<>();\n    private final Random random = new Random();\n\n    private final String key = \"anyKey\";\n\n    @Test\n    public void test() throws Exception {\n        final ExecutorService executorService = Executors.newCachedThreadPool();\n        final AtomicBoolean testFailed = new AtomicBoolean(false);\n\n        for (int i = 0; i < 1000000; i++) {\n            someSet.add(\"\" + i);\n        }\n\n        for (int i = 0; i < 10; i++) {\n\n            executorService.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        while (!testFailed.get()) {\n                            if (random.nextBoolean()) {\n                                writeLockedMethod();\n                            } else {\n                                readLockedMethod();\n                            }\n                        }\n                    } catch (AssertionError e) {\n                        e.printStackTrace();\n                        testFailed.set(true);\n                    }\n                }\n            });\n        }\n\n        while (!testFailed.get()) {\n            Thread.sleep(1000);\n        }\n        fail();\n    }\n\n    private void readLockedMethod() {\n        final Lock readLock = stripedLock.get(key).readLock();\n        readLock.lock();\n        assertFalse(writeLocked.get());\n        try {\n            someSet.contains(\"\" + random.nextInt(1000000)); //Just do something.\n        } finally {\n            readLock.unlock();\n        }\n    }\n\n    private void writeLockedMethod() {\n        final Lock writeLock = stripedLock.get(key).writeLock();\n        writeLock.lock();\n        //Since the atomic boolean is set inside the write lock, for the same key, this should never be true.\n        assertFalse(Thread.currentThread().getName(),writeLocked.get());\n        writeLocked.getAndSet(true);\n        try {\n            someSet.contains(\"\" + random.nextInt(1000000)); //Just do something.\n        } finally {\n            writeLocked.getAndSet(false);\n            writeLock.unlock();\n        }\n    }\n}\n```\n", "label": [1], "title": "Locking Problem with Lazy Striped ReadWriteLocks"}, "2968": {"body": "I had the old location bookmarked, and I was wondering why it wasn't updating :) I figured it out, but it would be nice if we had a way to redirect the old, since links exist (though perhaps [not very many](https://www.google.com/search?q=%22google.github.io%2Fguava%2Freleases%2Fsnapshot%22+-inurl%3A%22google.github.io%2Fguava%22)).", "label": [2], "title": "Any way to redirect http://google.github.io/guava/releases/snapshot/api/docs/ to http://google.github.io/guava/releases/snapshot-jre/api/docs/?"}}, "v23.4": {"2965": {"body": "This might work: https://stackoverflow.com/a/37702441/28465", "label": [2], "title": "Fix Javadoc links to javadoc.io"}, "2967": {"body": "@cgdecker Please add a line item for https://github.com/google/guava/commit/f2be0be06ef49dee7c5dfcb3a0231c5ecaf5b621 in the https://github.com/google/guava/releases/tag/v23.2 release notes.", "label": [2], "title": "Mention Java 9 support in 23.2 release notes"}}, "v23.5": {"2816": {"body": "In `ImmutableDoubleArray`, documentation ([as of 22.0-rc1](http://google.github.io/guava/releases/22.0-rc1/api/docs/com/google/common/primitives/ImmutableDoubleArray.html)) of the behaviour of `equals(Object)`, `indexOf(double)` and `lastIndexOf(double)` is ambiguous as to the treatment of NaNs.\r\n\r\nSpecific examples:\r\n```java\r\nImmutableDoubleArray a = ImmutableDoubleArray.of(Double.NaN);\r\na.equals(a) == ? (hopefully true)\r\na.equals(ImmutableDoubleArray.of(Double.NaN)) == ?\r\na.indexOf(Double.NaN) == ?\r\na.lastIndexOf(Double.NaN) == ?\r\n```\r\n\r\nI suppose behaviour with the infinities and `-0.0` is unambiguous, but perhaps this should be documented too.", "label": [2], "title": "ImmutableDoubleArray should document behaviour re NaN"}, "1891": {"body": "Affected Files:796\nViolations: 4071\n\nGoogle Java Style guide (version of March 21, 2014): \nhttps://google-styleguide.googlecode.com/svn-history/r130/trunk/javaguide.html\n\nCheckstyle Maven plugin report for Guava 17.0:\nhttp://checkstyle.sourceforge.net/reports/google-style/guava/\nAll violations are thoroughly rechecked, but some very occasional false-positives could be present.\n\nDetailed report (match of each Google Java Style rule to Checkstyle):\nhttp://checkstyle.sourceforge.net/google_style.html\n\nHow to run (command line): \n\n```\n~ $ cd /var/tmp\n/var/tmp $ git clone https://code.google.com/p/guava-libraries/\n\n/var/tmp $ wget -O checkstyle-6.1-all.jar http://downloads.sourceforge.net/project/checkstyle/checkstyle/6.1/checkstyle-6.1-all.jar?r=&ts=1416082535&use_mirror=tcpdiag\n\n/var/tmp $ wget https://raw.githubusercontent.com/checkstyle/checkstyle/master/google_checks.xml\n\n/var/tmp $ time java -jar checkstyle-6.1-all.jar -c google_checks.xml -o checkstyle-report-guava.txt -r guava-libraries\n\nreal    2m55.599s\nuser    3m12.596s\nsys 0m1.056s\n```\n\nPS: all work was done during Google Summer of Code 2014\n", "label": [7], "title": "Guava library violates Google Java Style guide"}}, "v23.6": {"2859": {"body": "https://github.com/google/guava/wiki/IOExplained#sources-and-sinks\r\n\r\nFirst table is malformed. Should be a little more similar to\r\n\r\n|             | **Bytes**      | **Chars**\r\n| :---------- | :------------- | :-------------\r\n| **Reading** | [`ByteSource`] | [`CharSource`]\r\n| **Writing** | [`ByteSink`]   | [`CharSink`]\r\n", "label": [2], "title": "IOExplained / Sources and sinks [wiki]"}, "2980": {"body": "As of 23.3, `com.google.common.collect.TreeTraverser` is deprecated. Are `Files.fileTreeTraverser()` and `MoreFiles.directoryTreeTraverser()` deprecated too? Should users migrate to `java.nio.file.SimpleFileVisitor`?\r\n\r\nNote that `MoreFiles.directoryTreeTraverser()` appeared in 21.0 (Java 8), despite `SimpleFileVisitor` presence (Java 7).", "label": [6], "title": "No replacement for Files.fileTreeTraverser() and MoreFiles.directoryTreeTraverser()"}, "2996": {"body": "Using `guava-23.0` (and earlier versions), `com.google.common.io.MultiInputStream` produces a stack overflow when it is given sufficiently many empty `ByteSource` instances.\r\n\r\nTest cases that reproduce the behavior:\r\n\r\n```java\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\n\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\n\r\nimport com.google.common.collect.Lists;\r\nimport com.google.common.io.ByteSource;\r\n\r\npublic class MultiInputStreamTest {\r\n\r\n  /** Adjust this according to the thread stack size. */\r\n  private static final int LARGE_ENOUGH_FOR_CURRENT_STACK_SIZE = 1000000;\r\n\r\n  private ByteSource       concatenated;\r\n\r\n  public @Before void setup() throws Exception {\r\n    final List<ByteSource> emptySources = Lists.newArrayList();\r\n    for (int i = 0; i < LARGE_ENOUGH_FOR_CURRENT_STACK_SIZE; i++) {\r\n      emptySources.add(ByteSource.empty());\r\n    }\r\n    // produce a ConcatenatedByteSource which in turn produces\r\n    // a MultiInputStream\r\n    concatenated = ByteSource.concat(emptySources);\r\n  }\r\n\r\n  public @Test void stackOverflowErrorOnEmptySources1() throws Exception {\r\n    try (InputStream in = concatenated.openStream()) {\r\n      in.read();\r\n    }\r\n  }\r\n\r\n  public @Test void stackOverflowErrorOnEmptySources2() throws Exception {\r\n    try (InputStream in = concatenated.openStream()) {\r\n      in.read(new byte[1], 0, 1);\r\n    }\r\n  }\r\n\r\n}\r\n```\r\n\r\nThe condensed exception stack traces produced by the respective test case (which appear to be truncated):\r\n\r\n```\r\n$ uniq -c stack1\r\n   1 java.lang.StackOverflowError\r\n   1 \tat com.google.common.io.ByteSource$ByteArrayByteSource.openStream(ByteSource.java:574)\r\n   1 \tat com.google.common.io.MultiInputStream.advance(MultiInputStream.java:65)\r\n   1 \tat com.google.common.io.MultiInputStream.read(MultiInputStream.java:89)\r\n1021 \tat com.google.common.io.MultiInputStream.read(MultiInputStream.java:90)\r\n```\r\n\r\n```\r\n$ uniq -c stack2\r\n   1 java.lang.StackOverflowError\r\n   1 \tat com.google.common.io.MultiInputStream.close(MultiInputStream.java:52)\r\n   1 \tat com.google.common.io.MultiInputStream.advance(MultiInputStream.java:63)\r\n   1 \tat com.google.common.io.MultiInputStream.read(MultiInputStream.java:102)\r\n1021 \tat com.google.common.io.MultiInputStream.read(MultiInputStream.java:103)\r\n```", "label": [7], "title": "MultiInputStream produces stack overflow"}}, "v22.0": {"2749": {"body": "While AbstractTable defines a method valuesSpliterator(), that method does not get called. Instead, the default implementation from AbstractCollection is used.", "label": [6], "title": "AbstractTable.Values doesn't override spliterator() method"}, "2693": {"body": "Just like `java.nio.file.Files.lines()` and `java.io.BufferedReader.lines()`, for CharSource to have a `lines()` method returning a `Stream<String>` of lines.\r\n\r\nOf course this can be trivially accomplished by the caller with `charSource.openBufferedStream().lines()` and indeed a default implementation could trivially just be `return openBufferedStream().lines();`, it being the caller's responsibility to ensure the `Stream`, and thus the `Reader`, are closed; and that would be job-done for concrete implementations based on streaming sources like files, resources, URLs etc.\r\n\r\nBut a concrete `CharSource` implementation is best-placed to know if it could better override that with something more efficient than a `BufferedReader` wrapping whatever `Reader` is actually used to access the characters. For a case in point the `CharSource.CharSequenceCharSource` implementation already has a `private Iterable<String> lines()` method (which would need to be renamed, because the proposed new public method really ought to have that name, for consistency with other APIs, especially in JDK, but such a rename shouldn't have too great an impact being of a private method), which would easily be the basis of a `Stream<String> lines()` method. Say the existing private `lines()` method became `getLines()`, the implementation here would literally just be `return Streams.stream(getLines());`.\r\n\r\nFor reference my private library code that I'm hoping to replace chunks of with Guava, has a `StringLinesSpliterator` and a `CharSequenceLinesSpliterator` for these purposes, in order to get a `Stream<String>` and `Stream<CharSequence>` from such sources. The latter meaning that the subsequences aren't potentially wastefully converted to Strings; the caller can always do that themselves with `.map(String::valueOf)`. (There's also a `CharBuffer` based one, that advances the position as it goes, but honestly it doesn't get used!)\r\n\r\nAt the moment, the code that wants to get a stream of lines from the `CharSource` would have to know more than it should about the circumstances of that `CharSource`'s creation, to know if it would be least wasteful in terms of copying of character sequences of arbitrary length, or Readers wrapping Readers, to access it via `read()`, `readLines()` or `openBufferedStream()`. Instead they ought to be able to trust that the implementation of `CharSource` will do it the best way.\r\n\r\nPossibly the first in a series of missing `Stream` based conveniences, as Java8-only features are a relatively new thing in Guava. ;-)", "label": [5], "title": "Add Stream<String> lines() to CharSource"}, "2794": {"body": "Is it possible to support the use case here:\r\nhttp://stackoverflow.com/questions/11120985/guava-collections-limit-permutation-size\r\n\r\nOr alternatively, provide a static function like Sets#powerSet that returns instead of \"the set of all possible subsets..\" the set of all possible subsets of a given size?", "label": [5], "title": "Guava Collections : limit permutation size / or support a sizedSubsets iterable?"}}, "v21.0": {"2658": {"body": "A MinMaxPriorityQueue fails at removing the correct object after a series of operations. See output and code below.\r\n\r\n> [5.6, 6.0, 5.7, 5.9]\r\nTry to remove 5.7 :\r\n[5.6, 6.0, 5.7]\r\n\r\nObtained from :\r\n\r\n> MinMaxPriorityQueue<Double> values = MinMaxPriorityQueue.create();\r\n\t\t\tvalues.add(6.2);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.add(6.2);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.3);\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.1);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.5);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.2);\r\n\t\t\tvalues.add(6.3);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.5);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.5);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.2);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.remove(6.2);\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.3);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.add(6.4);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(6.4);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.remove(6.3);\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.remove(5.8);\r\n\t\t\tvalues.add(6.4);\r\n\t\t\tvalues.remove(6.0);\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.3);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(6.3);\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.5);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.4);\r\n\t\t\tvalues.remove(5.4);\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.remove(6.1);\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.add(5.4);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.remove(5.5);\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.8);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.remove(5.8);\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.remove(5.7);\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(5.9);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.remove(6.1);\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.add(6.0);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.remove(6.0);\r\n\t\t\tvalues.add(5.9);\r\n\t\t\tvalues.remove(6.0);\r\n\t\t\tvalues.add(5.7);\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tvalues.add(6.1);\r\n\t\t\tvalues.pollFirst();\r\n\t\t\tvalues.add(5.6);\r\n\t\t\tvalues.pollLast();\r\n\t\t\tSystem.out.println(values);\r\n\t\t\tSystem.out.println(\"Try to remove 5.7 :\");\r\n\t\t\tvalues.remove(5.7);\r\n\t\t\tSystem.out.println(values);", "label": [1], "title": "remove() in MinMaxPriorityQueue<Double> not removing the correct object"}, "2644": {"body": "I found a small typo here: https://github.com/google/guava/wiki/ReflectionExplained#is-the-first-parameter-of-the-method-annotated-with-nullable :\r\n\r\n`method.getParameterAnnotations[0]` should be `method.getParameterAnnotations()[0]`", "label": [2], "title": "Small typo on ReflectionExplained wiki page"}}, "Not Released": {"2887": {"body": "The mechanism which detects whether to fallback on the non-lazy stack trace implementation seems to be broken on AIX 5.3 with IBMs JDK `jdk-6.0.0.645-aix-powerpc`. When iterating through the list returned by the method on such a system I get the following exception + trace\r\n\r\n> Caused by: java.lang.UnsupportedOperationException: You cannot access stack trace depth this way in this implementation\r\n        at sun.misc.SharedSecrets$1.getStackTraceDepth(SharedSecrets.java:172)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)\r\n        at java.lang.reflect.Method.invoke(Method.java:611)\r\n        at com.google.common.base.Throwables.invokeAccessibleNonThrowingMethod(Throwables.java:292)\r\n        at com.google.common.base.Throwables.access$200(Throwables.java:48)\r\n        at com.google.common.base.Throwables$1.size(Throwables.java:284)\r\n        at java.util.AbstractList$SimpleListIterator.hasNext(AbstractList.java:51)\r\n        at com.google.common.collect.Iterators$PeekingImpl.hasNext(Iterators.java:1171)\r\n        at com.delphix.logger.Logger.getLogger(Logger.java:96)\r\n        at com.delphix.session.impl.common.SessionManager.<clinit>(SessionManager.java:23)\r\n        at java.lang.J9VMInternals.initializeImpl(Native Method)\r\n        at java.lang.J9VMInternals.initialize(J9VMInternals.java:199)\r\n        ... 21 more\r\n\r\nExplicitly using `new Throwable().getStackTrace` resolved the problem.", "label": [1], "title": "Throwables#lazyStackTrace throws UnsupportedOperationException on AIX 5.3"}, "3003": {"body": "`ConcurrentHashMultiset#createEntrySet()` has public visibility, although it seems like an internal method, not meant to be in public API. \r\n\r\nWhole `ConcurrentHashMultiset` is not in `@Beta`, so I'm not sure if simply changing visibility to package-private is what you really want, hence no PR from my side.", "label": [1], "title": "ConcurrentHashMultiset#createEntrySet() is public"}}, "v19.0": {"2196": {"body": "Let a < x < b:\n- [x].intersection([x]) should return [x], returns [],\n- [x].intersection([a..b]) should return [x], returns [],\n- [a..b].intersection([x]) should return [x], returns [],\n- [a..x].intersection([x..b]) should return [x], returns [].\n\nI'll create a PR in a minute.\n", "label": [1], "title": "ContiguousSet.intersection doesn't handle singleton results."}, "1781": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1781) created by **justatheory** on 2014-06-13 at 08:25 PM_\n\n---\n\nWas experimenting with JavaScript code when I noticed this.  If you call\n\n```\noptimalNumOfHashFunctions(319, 3072)\n```\n\nIt returns 6. A quick JavaScript version returned 7. The reason is because the division acts only on integers and returns an integer. In JavaScript everything is a float. That is, in Java, `3072 / 319`&nbsp;returns 9, but in JavaScript it returns 9.63. Maybe it was intentional to have an implicitly truncated value, but I'm guessing not. The fix would be something like:\n\n--- a/guava/src/com/google/common/hash/BloomFilter.java\n+++ b/guava/src/com/google/common/hash/BloomFilter.java\n@@ -363,7 +363,7 @@ public final class BloomFilter&lt;T> implements Predicate&lt;T>, Serializable {\n&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;@\ufeffVisibleForTesting\n&nbsp;&nbsp;&nbsp;static int optimalNumOfHashFunctions(long n, long m) {\n-    return Math.max(1, (int) Math.round(m / n \\* Math.log(2)));\n-    return Math.max(1, (int) Math.round((float)m / n \\* Math.log(2)));\n  &nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;/**\n", "label": [1], "title": "optimalNumOfHashFunctions() May not Return what you Expect"}, "2093": {"body": "In Guava 18.0, `EventBus.handleException()` incorrectly logs `exception.getCause()` instead of the underlying `exception`:\n\n```\n  logger.log(Level.SEVERE, \"Could not dispatch event: \" \n      + context.getSubscriber() + \" to \" + context.getSubscriberMethod(),\n      exception.getCause());\n```\n\nThis means any `@Subscribe` method which throws an exception fails to log the most important information of all: the actual exception thrown. (If the exception happened to be wrapping another exception, Guava will log the wrapped exception, but that's usually not the case.)\n\nI believe this should be:\n\n```\n  logger.log(Level.SEVERE, \"Could not dispatch event: \" \n      + context.getSubscriber() + \" to \" + context.getSubscriberMethod(),\n      exception);\n```\n\nTo reproduce, try the following. I would expect the log message to include `This message should appear in the logs`, but it doesn't.\n\n```\n% cat GuavaBug.java \nimport com.google.common.eventbus.EventBus;\nimport com.google.common.eventbus.Subscribe;\n\npublic class GuavaBug {\n  private static class Event { }\n\n  @Subscribe\n  public void handleEvent(Event event) {\n    throw new RuntimeException(\"This message should appear in the logs\");\n  }\n\n  public static void main(String[] args) {\n    EventBus eventBus = new EventBus();\n    GuavaBug guavaBug = new GuavaBug();\n    eventBus.register(guavaBug);\n    eventBus.post(new Event());\n  }\n}\n\n% javac -cp guava-18.0.jar GuavaBug.java\n% java -cp guava-18.0.jar:. GuavaBug\nJun 24, 2015 2:30:42 PM com.google.common.eventbus.EventBus$LoggingSubscriberExceptionHandler handleException\nSEVERE: Could not dispatch event: GuavaBug@7de26db8 to public void GuavaBug.handleEvent(GuavaBug$Event)\n```\n", "label": [1], "title": "EventBus.handleException() fails to log exception thrown"}, "1896": {"body": "As per I can see on the docs (https://code.google.com/p/guava-libraries/wiki/CommonObjectUtilitiesExplained), the documentation is still using _Objects_, when it should say _MoreObjects_ (Objects it's deprecated on the 1.8 version). How can I fix this minor issue?\nThanks!\n", "label": [2], "title": "Documentation issue: Object common methods it's still pointing to Objects."}, "1857": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1857) created by **matt.nathan** on 2014-09-26 at 08:47 AM_\n\n---\n\nFirstly, I have no idea if you want this type of feedback or not so sorry if not, and I hope this is the correct place to put this.\n\nI was reading through the recent changes to Guava and came across https://github.com/google/guava/commit/8061999c2ae5a914ae765c1bdc373b9cc4ee70d0\n\nThis pulls out a Lists.indexMap from a number of places in the code to reduce duplicates. I noticed, however, that the method in question isn't actually related to Lists; it takes Collection instead. As I've done this type of change a number of times I expect it used to accept List then was loosened to accept Collection.\n\nThere are a number of callers of this function that convert their arguments to Lists without need and I'd suggest moving the method to Collections2, though that change may be a little more controversial.\n\nAnyway, I just thought I'd let you know of what I saw in the off chance it had slipped through the normal review process.\n", "label": [6], "title": "Lists.indexMap actually doesn't reference List"}, "1738": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1738) created by **socram8888** on 2014-04-24 at 10:38 AM_\n\n---\n\nApparently Oracle has added a new abstract method to TypeVariable (getAnnotatedBounds) which is not implemented.\n", "label": [7], "title": "Unable to compile on Java 8"}, "1830": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1830) created by **leventov.ru** on 2014-08-11 at 06:42 AM_\n\n---\n\nGuava-testlib depends on truth:1.0-SNAPSHOT, which couldn't be downloaded from maven central.\n", "label": [1], "title": "18.0-rc1is unusable because Truth dep is SNAPSHOT"}, "1836": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1836) created by **Maaartinus** on 2014-08-21 at 09:50 PM_\n\n---\n\nThe documentation of CacheBuilder#ticker says\n\n\"The primary intent of this method is to facilitate testing of caches which have been configured with expireAfterWrite or expireAfterAccess.\"\n\nMentioning the two explicitly and omitting refreshAfterWrite seems to be confusing as a comment to\n\nhttp://stackoverflow.com/a/25418475/581205\n\nshows. Some general statement like \"the only timing source\" would be cleaner and more future-proof.\n", "label": [2], "title": "Documentation of CacheBuilder#ticker"}, "2133": {"body": "`MoreExecutors.java:541`\n\n``` java\n    @Override\n    public <V> ListenableScheduledFuture<V> schedule(\n        Callable<V> callable, long delay, TimeUnit unit) {\n      TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(callable);\n      ScheduledFuture<?> scheduled = delegate.schedule(task, delay, unit);\n      return new ListenableScheduledTask<V>(task, scheduled);\n    }\n```\n\n`delegate.schedule(Runnable...)` is invoked here instead of the (intended?) `delegate.schedule(Callable<V>...)`. As a result, the `ScheduledListeningDecorator` is unusable for `Callable<?>`.\n", "label": [2], "title": "BUG: ScheduledListeningDecorator schedule(Callable<V>....) delegates to schedule(Runnable"}, "1850": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1850) created by **wes...@cutterslade.ca** on 2014-09-19 at 05:00 PM_\n\n---\n\nThe class JavaDoc for CacheStats states: \"No stats are modified on a query to {@\ufefflink Cache#getIfPresent}.\"\n\nHowever, the LocalCache.getIfPresent() method clearly updates stats:\n\n&nbsp;&nbsp;@\ufeffNullable\n&nbsp;&nbsp;public V getIfPresent(Object key) {\n&nbsp;&nbsp;&nbsp;&nbsp;int hash = hash(checkNotNull(key));\n&nbsp;&nbsp;&nbsp;&nbsp;V value = segmentFor(hash).get(key, hash);\n&nbsp;&nbsp;&nbsp;&nbsp;if (value == null) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;globalStatsCounter.recordMisses(1);\n&nbsp;&nbsp;&nbsp;&nbsp;} else {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;globalStatsCounter.recordHits(1);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return value;\n&nbsp;&nbsp;}\n", "label": [2], "title": "Inconsistency between CacheStats documentation and behaviour"}, "1947": {"body": "When decoding Base64/32/16 data an exception is thrown if an invalid character is found:\n\nBaseEncoding.java:501:\n\n``` java\n    int decode(char ch) throws IOException {\n      if (ch > Ascii.MAX || decodabet[ch] == -1) {\n        throw new DecodingException(\"Unrecognized character: \" + ch);\n      }\n      return decodabet[ch];\n    }\n```\n\nThe exception message prints out the character itself, which isn't terribly helpful when that is a non-printable character.  Recommend that the hex value of the character be printed instead.\n", "label": [0], "title": "Improve invalid character exceptions from BaseEncoding"}, "1962": {"body": "", "label": [], "title": ".technology needs to be added under TLD"}, "1963": {"body": "Would be keen to use these in non-`@Beta`. Are there any plans?\n", "label": [0], "title": "De-@Beta Maps.asMap and toMap"}, "2037": {"body": "Uncorrect hashCode() implementation at com.google.common.base.Absent and com.google.common.base.Present - for example if hashCode() of reference at Present return 0 then it hashCode() equal Absent.\n\nexample: Optional.absent() has same hash code as Optional.of(0.0) or Optional.of(0)\n", "label": [0], "title": "Optional.hashCode()"}, "2173": {"body": "The following test case fails on jdk6u45 (trigger a jdk6 bug probably fixed in jdk7). It happens as soon as an annotation processor is present in the classpath (not only auto-value).\n\n``` java\npackage test;\nimport com.google.common.collect.ImmutableMultimap;\npublic final class Test {{\n    ImmutableMultimap.class.toString();\n}}\n```\n\n``` xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>guava-19rc2-regression</groupId>\n    <artifactId>immutablemultimap</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <dependencies>\n        <dependency>\n            <groupId>com.google.guava</groupId>\n            <artifactId>guava</artifactId>\n            <version>19.0-rc2</version>\n        </dependency>\n        <dependency>\n            <groupId>com.google.auto.value</groupId>\n            <artifactId>auto-value</artifactId>\n            <version>1.1</version>\n            <optional>true</optional>\n        </dependency>\n    </dependencies>\n    <build>\n        <pluginManagement>\n            <plugins>\n                <plugin>\n                    <groupId>org.apache.maven.plugins</groupId>\n                    <artifactId>maven-compiler-plugin</artifactId>\n                    <version>3.1</version>\n                    <configuration>\n                        <source>1.6</source>\n                        <target>1.6</target>\n                        <compilerArgs combine.self=\"append\">\n                            <arg>-verbose</arg>\n                        </compilerArgs>\n                    </configuration>\n                </plugin>\n            </plugins>\n        </pluginManagement>\n    </build>\n</project>\n```\n", "label": [1], "title": "19rc2 regression: Using ImmutableMutlimap and annotation processors fails compile on jdk6"}, "2019": {"body": "Guice depends on Cache, RemovalListener, RemovalNotification, etc....\n", "label": [6], "title": "Cache & Friends should have @Beta removed"}, "1747": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1747) created by **a.korzhevskiy** on 2014-05-07 at 09:40 AM_\n\n---\n\nguava has public ImmutableCollection.Builder\n\nguava-gwt has package private ImmutableCollection.Builder\n", "label": [0], "title": "Different visibility of ImmutableCollection.Builder in guava and guava-gwt"}, "2073": {"body": "Guava 18 uses Truth, but truth is not API stable, so using it in an intermediary library like Guava-testlib is problematic - it forces that fragility onto non-guava consumers of our testlibs.\n\nFor Guava 19, we should remove use of Truth within the testlib, since it's a convenience for us, but only marginally helpful to users of guava-testlib.\n\nFor Guava 18, it is broken for anyone who attempts to upgrade to a version of Truth past 0.24. We should consider rolling an 18.0.1 of guava-testlib to rectify this, so that existing users are not hampered.\n", "label": [1], "title": "Guava-testlib 18 uses Truth APIs that are deleted in 0.25+ releases of Truth"}, "2072": {"body": "(Source attached below which demonstrates the issue).\nI have an implementation of an AbstractScheduledService which overrides the scheduler() method and creates and returns a CustomScheduler.  This CustomScheduler's getNextSchedule() method sleeps for a period of time (which makes the deadlock more predicable) and then either returns a Schedule, or if the Service\u2019s state is STOPPING it throws an exception.  \nThe problem arises when it throws an exception.  After throwing the exception the service never actually terminates, and the shutDown() method is never called.  After a brief investigation, it looks as though there is a deadlock between notifyFailed() and stopAsync() in AbstractService class.  notifyFailed() (called from the catch block of reschedule() method in one of AbstractScheduledService inner classes) tries to enter the monitor field but is blocked as the monitor is currently held by stopAsync(), and stopAsync() hasn\u2019t released the monitor yet as it is blocked when calling this.doStop() (in case 3 of switch stmt).  The doStop() called is the impl in AbstractScheduledService, and this gets blocked on the first line waiting for this.runningTask.cancel(false) to return.\n\nI haven\u2019t had time to download the source code and build things myself to investigate it further, but hopefully there is enough here to go on.  Below is some source code which demonstrates the problem, and the log output showing that the service\u2019s shutDown() method is not called and the service and JVM hasn\u2019t terminated yet.\n\n``` java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Service service = new ScheduledServiceWithCustomBlockingScheduler(5000);\n        new ServiceStateMonitor().monitorServiceStateWithServiceListener(service);\n        System.out.println(\"starting service\");\n        service.startAsync();\n        Thread.sleep(6000); // wait just enough time for 2nd call of getNextSchedule() to start\n        System.out.println(\"Stopping service\");\n        service.stopAsync();\n        System.out.println(\"Bye\");\n      }\n}\n```\n\n``` java\npublic class ScheduledServiceWithCustomBlockingScheduler extends AbstractScheduledService {\n    private long blockTime;\n\n    public ScheduledServiceWithCustomBlockingScheduler(final long blockTime) {\n        this.blockTime = blockTime;\n    }\n\n    @Override\n    protected void runOneIteration() throws Exception {\n        System.out.println(\"runOneIteration()\");\n    }\n\n    @Override\n    protected Scheduler scheduler() {\n        return new CustomScheduler() {\n            @Override\n            protected Schedule getNextSchedule() throws Exception {\n                System.out.println(\"getNextSchedule()...\");\n                Thread.sleep(blockTime);\n                if (state() == State.STOPPING) {\n                    System.out.println(\"getNextSchedule() - not running anymore so don't return scheduler\");\n                    throw new Exception(\"not running anymore so don't return scheduler\");\n                }\n                System.out.println(\"...getNextSchedule()\");\n                return new Schedule(0, TimeUnit.NANOSECONDS);\n            }\n        };\n    }\n\n    @Override\n    protected void startUp() throws Exception {\n        System.out.println(\"startUp()\");\n    }\n\n    @Override\n    protected void shutDown() throws Exception {\n        System.out.println(\"shutDown()\");\n    }\n}\n```\n\n``` java\npublic class ServiceStateMonitor {\n    public void monitorServiceStateWithServiceListener(final Service serviceToMonitor) {\n        serviceToMonitor.addListener(new PrintOutNewStateServiceListener(), MoreExecutors.directExecutor());\n    }\n\n    private class PrintOutNewStateServiceListener extends Service.Listener {\n        @Override\n        public void starting() {\n            System.out.println(\"SERVICE LISTENER : Starting\");\n        }\n\n        @Override\n        public void running() {\n            System.out.println(\"SERVICE LISTENER : Running\");\n        }\n\n        @Override\n        public void stopping(final Service.State from) {\n            System.out.println(\"SERVICE LISTENER : Stopping\");\n        }\n\n        @Override\n        public void terminated(final Service.State from) {\n            System.out.println(\"SERVICE LISTENER : Terminated\");\n        }\n\n        @Override\n        public void failed(final Service.State from, final Throwable failure) {\n            System.out.println(\"SERVICE LISTENER : Failed\");\n        }\n    }\n}\n```\n\nThe Standard Ouput from running the main()\n\n```\nstarting service\nSERVICE LISTENER : Starting\nstartUp()\ngetNextSchedule()...\n...getNextSchedule()\nSERVICE LISTENER : Running\nrunOneIteration()\ngetNextSchedule()...\nStopping service\ngetNextSchedule() - not running anymore so don't return scheduler\n```\n\nnotice that there is no \"shutDown()\" or \"Bye\" output line.\n", "label": [1], "title": "Deadlock when stopping an AbstractScheduledService and Exception thrown from CustomScheduler.getNextSchedule()"}, "2178": {"body": "As a novice of using Cache I think its statistic activation should be documented in the API of stats().\n\nFirst: recordStats() is to be isssued.\nSecond: stats() can not be instantiated because it is a factory for a final statistic.\n", "label": [2], "title": "Cache.stats usage should be documented better"}, "2016": {"body": "Please fix the `ImmutableSortedMultiset::naturalOrder` generic type so that classes that are subclasses of classes implementing `Comparable` can be used.\n\nHere is a snippet showing the issue:\n\n```\npublic class ImmutableSortedCollectionsComparison {\n  public static void main(String[] args) {\n    ImmutableSortedSet     <MySubComparable> sortedSet      = ImmutableSortedSet     .<MySubComparable>naturalOrder().build();\n    ImmutableSortedMultiset<MySubComparable> sortedMultiset = ImmutableSortedMultiset.<MySubComparable>naturalOrder().build();\n  }\n}\nclass MyComparable implements Comparable<MyComparable> {\n  @Override public int compareTo(MyComparable o) { return 1; }\n}\nclass MySubComparable extends MyComparable { }\n```\n\nThe line of the `ImmutableSortedSet` will compile nicely, but the one of the `ImmutableSortedMultiset` won't.\n\nHere's the faulty signature of `ImmutableSortedMultiset::naturalOrder`:\n\n```\npublic static <E extends Comparable<E>> ImmutableSortedMultiset.Builder<E> naturalOrder()\n```\n\nAnd here is the expected signature:\n\n```\npublic static <E extends Comparable<?>> ImmutableSortedMultiset.Builder<E> naturalOrder()\n```\n\nWhich will then be similar to the working `ImmutableSortedSet::naturalOrder`:\n\n```\npublic static <E extends Comparable<?>> ImmutableSortedSet.Builder<E> naturalOrder()\n```\n", "label": [1], "title": "ImmutableSortedMultiset::naturalOrder has wrong generic type"}, "2158": {"body": "The visitClass implementation in TypeResolver.populateTypeMappings has the following body:\n\n```\n  @Override void visitClass(Class<?> fromClass) {\n    // Can't map from a raw class to anything other than itself.\n    // You can't say \"assuming String is Integer\".\n    // And we don't support \"assuming String is T\"; user has to say \"assuming T is String\". \n    throw new IllegalArgumentException(\"No type mapping from \" + fromClass);\n  }\n```\n\nIt would be great if the IllegalArgumentException message reported the type it's trying to convert to, as well as the one its converting from, for easier debugging should this exception be thrown.\n", "label": [0], "title": "TypeVisitor.visitClass in TypeResolver.populateTypeMappings should report the to type as well as the from type"}, "2039": {"body": "Hello, I was reading through the set of tests at https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StopwatchTest.java , and I noticed there are two tests that appear to do the same thing - testElapsed_millis() and testElapsedMillis(). Is this expected? Could one test perhaps be an old test under a different naming convention? From the history it looks like they were added independently.\n\nThe contribution guide recommends creating an issue as the first step, so I thought I would ask.\n\nGitHub suggests that both functions are only called from guava-gwt/test/com/google/common/base/StopwatchTest_gwt.java . Would it be appropriate to create a pull request to remove one of the tests? (Or of course, feel free to simply remove one yourself if the workflow is easier; I just wanted to ask)\n\nCheers!\n", "label": [6], "title": "Possible duplicate tests? - testElapsed_millis() and testElapsedMillis()"}, "1798": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1798) created by **xavier.fournet** on 2014-07-07 at 01:39 PM_\n\n---\n\nIn the pom.xml the dependency on javax.inject has been removed, but in the &lt;Import-Package> of the maven bundle plugin configuration there is still a reference to javax.inject:\njavax.inject;resolution:=optional,\nthat should be removed too.\n", "label": [7], "title": "Remove the Import-Package of javax.inject"}, "1790": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1790) created by **tgyurci** on 2014-06-25 at 10:19 AM_\n\n---\n\nIn ImmutableCollection.toArray() the result of size() is stored in a local variable and then the size() method is invoked again.\n", "label": [0], "title": "ImmutableCollection.toArray() calls size() twice"}, "1796": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1796) created by **kapoorvinny** on 2014-07-04 at 12:22 PM_\n\n---\n\nGuava's InternetDomainName API gives exception while computing \"topPrivateDomain\" from websites like \"gov.uk'. It works fine for \"nhs.uk\".\n\nI guess it needs to add \"gov.uk\" in excluded set.\n", "label": [0], "title": "Guava's InternetDomainName API exception"}, "2187": {"body": "The `IndexOutOfBoundsException` is not in its correct column (4th row, `checkElementIndex(int index, int size)`)\n\nhttps://github.com/google/guava/wiki/PreconditionsExplained\n\nThe table is correctly formatted in the [old google wiki](https://code.google.com/p/guava-libraries/wiki/PreconditionsExplained).\n", "label": [2], "title": "Formatting error in PreconditionsExplained table"}, "1888": {"body": "Migrating this old internal issue report:\n- \"Async\" suffix: CompletableFuture transformation methods come in three varieties, those equivalent to directExecutor(), those equivalent to passing ForkJoinPool.commonPool(), and those that accept an executor. The first of these is named with no suffix; the latter two are named with an \"Async\" suffix. None of our Futures methods have an \"Async\" suffix. In CompletableFuture terms, they correspond to the no-suffix version and the \"Async\"-suffix version _with_ executor.\n- \"transform\" is \"apply.\" This name works better in the fluent style -- getResult(...).thenApply(...) -- than it does as a static method. Also, com.google.common.collect still sets the transform() precedent, though, in an ideal world, we might standardize on JDK8's \"apply\" there, too. (Or maybe those methods will go away entirely?)\n- Overloads+lambdas=problems. Our transform() method has Function and AsyncFunction overloads. This may work poorly with lambda type inference.\n\nhttps://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\n", "label": [8], "title": "Consider Futures method names in light of JDK8/CompletableFuture"}, "1869": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1869) created by **anth...@whitford.com** on 2014-10-22 at 01:01 AM_\n\n---\n\nThe constructor suggests that outputsteam may be null:\n\npublic CountingOutputStream(@\ufeffNullable OutputStream out)\n\nBut then any write/close operation will NPE:\n\n@\ufeffOverride public void write(byte[] b, int off, int len) throws IOException {\n&nbsp;&nbsp;&nbsp;&nbsp;out.write(b, off, len);\n&nbsp;&nbsp;&nbsp;&nbsp;count += len;\n}\n\nEither the @\ufeffNullable annotation should be removed, or the write/close methods should only pass-through when out is non-null.\n", "label": [1], "title": "CountingOutputStream allegedly declares @Nullable out (wrapped), but will NPE"}, "1885": {"body": "MapMaker javadoc advertises \"on-demand computation of values for keys not already present\" but this doesn't appear to actually be possible.\n", "label": [2], "title": "Javadoc error in MapMaker"}, "2008": {"body": "I ran into a situation where I was using recursion and lazy iteration to emulate the in-order traversal path of a binary tree, but wasn't able to use `Iterators.concat` due to its non gc friendly implementation.\n\n(Note: the amount of memory that should be needed to run this is `O(maxDepth)` or `O(log N)`)\n\nHere's code to trigger the issue, and a potential solution: https://gist.github.com/devinrsmith/121d9a5ebd460c3bbaa0\n", "label": [1], "title": "Iterators.concat is not gc friendly"}, "1770": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1770) created by **matt.nathan** on 2014-06-02 at 02:04 PM_\n\n---\n\nRelated to Issue 1669 except there isn't a psf field in ByteSource, there is a zero-arg factory method though... :)\n\nAs with the linked issue this isn't a high priority, it is annoying though.\n", "label": [0], "title": "Provide default instance for ByteSource in NullPointerTester (et al)"}, "2120": {"body": "would it be possible to ensure `InternetDomainName` rolls out w/ the latest version of the PSL (or as close to it as you can get) before release?\n\ni don't know when the official release is slated for, but according to this site, https://iwantmyname.com/domains/new-gtld-launch-dates, there are new tlds on the horizon and depending on how quickly mozilla updates, it'd be nice to see as many of these included in the next release.\n\nit'd also be great to see something happen w/ #1123 /  #475 \n", "label": [6], "title": "possible for one final update of InternetDomainName (psl) before 19.0 release"}, "1761": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1761) created by **DanGLow** on 2014-05-22 at 05:18 PM_\n\n---\n\nHi,\n\nThis bug was originally discovered here: https://github.com/elasticsearch/elasticsearch/issues/6268, but I have traced it down into an issue with an overflowing int and long comparison in LocalCache.java eviction logic. The following is the eviction code at https://github.com/google/guava/blob/master/guava/src/com/google/common/cache/LocalCache.java#L2665\n\n@\ufeffGuardedBy(\"Segment.this\")\nvoid evictEntries() {\n&nbsp;&nbsp;if (!map.evictsBySize()) {\n&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;drainRecencyQueue();\n&nbsp;&nbsp;while (totalWeight > maxSegmentWeight) {\n&nbsp;&nbsp;&nbsp;&nbsp;ReferenceEntry&lt;K, V> e = getNextEvictable();\n&nbsp;&nbsp;&nbsp;&nbsp;if (!removeEntry(e, e.getHash(), RemovalCause.SIZE)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new AssertionError();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n}\n\n'totalWeight' is defined as an int, while 'maxSegmentWeight' is a long. If 'maxSegmentWeight' is set to any value int.MAX_VALUE or greater, then this check\n\n&nbsp;&nbsp;while (totalWeight > maxSegmentWeight) {\n\nwill never be true, since 'totalWeight' will overflow, and the eviction code will never run.\n", "label": [1], "title": "LocalCache weight eviction does not work when maxSegmentWeight is >= int.MAX_VALUE"}, "1801": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1801) created by **leventov.ru** on 2014-07-13 at 11:53 PM_\n\n---\n\ndiff --git a/guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java\nindex f54596a..c8390f0 100644\n--- a/guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java\n+++ b/guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java\n@@ -106,7 +106,7 @@ public class MapTestSuiteBuilder&lt;K, V>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.createTestSuite());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n-    derivedSuites.add(SetTestSuiteBuilder.using(\n-    derivedSuites.add(createDerivedEntrySetSuite(\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new MapEntrySetGenerator&lt;K, V>(parentBuilder.getSubjectGenerator()))\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.withFeatures(computeEntrySetFeatures(parentBuilder.getFeatures()))\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.named(parentBuilder.getName() + \" entrySet\")\n  @@ -120,7 +120,7 @@ public class MapTestSuiteBuilder&lt;K, V>\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.suppressing(parentBuilder.getSuppressedTests())\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.createTestSuite());\n-    derivedSuites.add(CollectionTestSuiteBuilder.using(\n-    derivedSuites.add(createDerivedValueCollectionSuite(\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new MapValueCollectionGenerator&lt;K, V>(\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parentBuilder.getSubjectGenerator()))\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.named(parentBuilder.getName() + \" values\")\n  @@ -132,10 +132,20 @@ public class MapTestSuiteBuilder&lt;K, V>\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return derivedSuites;\n  &nbsp;&nbsp;&nbsp;}\n-  protected SetTestSuiteBuilder&lt;Map.Entry&lt;K, V>> createDerivedEntrySetSuite(\n-      TestSetGenerator&lt;Map.Entry&lt;K, V>> entrySetGenerator) {\n-    return SetTestSuiteBuilder.using(entrySetGenerator);\n-  }\n  +\n  &nbsp;&nbsp;&nbsp;protected SetTestSuiteBuilder&lt;K> createDerivedKeySetSuite(TestSetGenerator&lt;K> keySetGenerator) {\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return SetTestSuiteBuilder.using(keySetGenerator);\n  &nbsp;&nbsp;&nbsp;}\n-  protected CollectionTestSuiteBuilder&lt;V> createDerivedValueCollectionSuite(\n-      TestCollectionGenerator&lt;V> valueCollectionGenerator) {\n-    return CollectionTestSuiteBuilder.using(valueCollectionGenerator);\n-  }\n  +\n  &nbsp;&nbsp;&nbsp;private static Set&lt;Feature<?>> computeReserializedMapFeatures(\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;Feature<?>> mapFeatures) {\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;Feature<?>> derivedFeatures = Helpers.copyToSet(mapFeatures);\n", "label": [5], "title": "Small refactoring of MapTestSuiteBuilder which would ease extension"}, "2127": {"body": "An algorithm similar to `java.lang.Math.addExact()` should be used to compute `offset + length`  and fallback to `Integer.MAX_VALUE` or `Long.MAX_VALUE` in case of overflow. \nThere is 3 occurrences of this possibly overflowing addition in `ByteSource.java`.\n\nI found this bug because I regularly slice bytesources with a length equals to Long.MAX_VALUE.\n", "label": [1], "title": "19rc1 regression in sliced bytesource: offset + length may overflow for large length values"}, "2082": {"body": "I'm a [Spoon](https://github.com/INRIA/spoon) contributor, an open source project to analyse and transform Java source code. This project have a dependency to [JDT](https://eclipse.org/jdt/) to compile target source code. Recently, I tried to analyse Guava with Spoon but JDT can't compile our project.\n\nWhat is the problem?\n\nIn [`ImmutableMap`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableMap.java) class, we have these methods:\n\n``` java\n// If the map is an EnumMap, it must have key type K for some <K extends Enum<K>>.\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nprivate static <K, V> ImmutableMap<K, V> copyOfEnumMapUnsafe(Map<? extends K, ? extends V> map) {\n    return copyOfEnumMap((EnumMap) map);\n}\n\nprivate static <K extends Enum<K>, V> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\n    EnumMap<K, V> copy = new EnumMap<K, V>(original);\n    for (Map.Entry<?, ?> entry : copy.entrySet()) {\n        checkEntryNotNull(entry.getKey(), entry.getValue());\n    }\n    return ImmutableEnumMap.asImmutable(copy);\n}\n```\n\nThis code is valid but there is an error from JDT:\n\n> Type mismatch: cannot convert from `<Enum<Enum<K>>>` to `<K>`\n\nBefore the creation of this issue, I reported the bug in the bugtracker of JDT (issue [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404)). In 2 words, the conclusion was that: \"Yes, JDT don't support this usage of Java but there is a better practice\". This better practice is explained [here](https://bugs.eclipse.org/bugs/show_bug.cgi?id=469404#c3):\n\n``` java\nprivate static <K extends Enum<K>> ImmutableMap<K, V> copyOfEnumMap(EnumMap<K, ? extends V> original) {\n    return copyOfEnumMap((EnumMap<K,?>) map);\n}\n```\n\nI tried some tricky solutions but, unfortunately, this solution can't be applied in your project. So I come to notify you that your project can't be compiled by JDT.\n", "label": [], "title": "Guava can't be compiled by JDT"}, "1842": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1842) created by **cpovirk@google.com** on 2014-09-04 at 02:34 PM_\n\n---\n\nhttp://stackoverflow.com/q/25646191/28465\n", "label": [2], "title": "Guarantee RangeMap iteration order"}, "2080": {"body": "Can you please confirm that .design will be added as a public suffix in Guava 19.0\n", "label": [6], "title": ".design needs to be added as a public suffix"}, "1826": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1826) created by **argaul** on 2014-08-04 at 06:13 PM_\n\n---\n\nIt would be nice if Guava included a CRC32C implementation.  Google offers one of these to help interface with Google cloud services although not as part of Guava:\n\nhttps://github.com/GoogleCloudPlatform/crc32c-java\n", "label": [5], "title": "CRC32C as a Hasher implementation"}, "2150": {"body": "https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained#Why?\nThere is an analysis in this section, however, this report is protected from normal users, why? Could you open this benchmark report?\n", "label": [2], "title": "Benchmark report on memory performance of Immutable Collection is blocked from normal users."}, "1977": {"body": "ImmutableList contains following code since version 15.0\n\n private static final ImmutableList<Object> EMPTY =\n      new RegularImmutableList<Object>(ObjectArrays.EMPTY_ARRAY);\n", "label": [1], "title": "Possible deadlock in ImmutableList "}, "1768": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1768) created by **stalkingtiger** on 2014-05-29 at 05:19 AM_\n\n---\n\nIt appears that the filtered NavigableMap implementation no longer overrides isEmpty(). Instead, it uses java.lang.AbstractMap's implementation, which calls size(). That is O(n) for a filtered map.\n\nIt looks like this landed in Guava 15:\n\nhttps://code.google.com/p/guava-libraries/source/diff?spec=svn155728d070ac6f2d2ca22644f5c5affea72d7feb&r=155728d070ac6f2d2ca22644f5c5affea72d7feb&format=side&path=/guava/src/com/google/common/collect/Maps.java\n", "label": [3], "title": "Regression: isEmpty() for Maps.<NavigableMap<K,V>>filterXXX is O(n)"}, "2108": {"body": "My multithreaded thrashing tests failed with Guava due to `size()` returning a negative value. The size is used for verifying that the `toArray()` methods are threadsafe (this was a common bug until JDK6 rewrote AbstractCollection's to be tolerant to races). The lines in question are,\n\n``` java\n(cache, key) -> cache.asMap().keySet().toArray(new Object[cache.asMap().size()]),\n(cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),\n(cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),\n```\n\nThis results in a `NegativeArraySizeException` unless worked around using `Math.max(0, cache.asMap().size())` which is now done in the guava fixture. I'm not sure why this occurs, and only happened after tweaking some JVM args. Regardless this failure was reproducible and is simple to fix.\n\n```\njava.lang.NegativeArraySizeException\nat com.github.benmanes.caffeine.cache.MultiThreadedTest.lambda$new$280(MultiThreadedTest.java:142)\nat com.github.benmanes.caffeine.cache.MultiThreadedTest$$Lambda$29/584234975.accept(Unknown Source)\nat com.github.benmanes.caffeine.testing.Threads$Thrasher.run(Threads.java:149)\nat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\nat com.github.benmanes.caffeine.testing.ConcurrentTestHarness.lambda$timeTasks$344(ConcurrentTestHarness.java:100)\nat com.github.benmanes.caffeine.testing.ConcurrentTestHarness$$Lambda$61/1027825150.run(Unknown Source)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\nat java.lang.Thread.run(Thread.java:745)\n```\n", "label": [1], "title": "Cache.asMap().size() may return a negative value"}, "1748": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1748) created by **xaerxess** on 2014-05-08 at 11:24 AM_\n\n---\n\nOn PrimitivesExplained wiki page (https://code.google.com/p/guava-libraries/wiki/PrimitivesExplained#Wrapper) there's info about API removed in 15.0:\n- \"UnsignedPrim add(UnsignedPrim), subtract, multiply, divide, remainder\" should be \"UnsignedPrim plus(UnsignedPrim), minus, times, dividedBy\",\n- \"UnsignedPrim asUnsigned(prim value)\" should be \"UnsignedPrim fromIntBits(prim value)\" (weird method name BTW).\n", "label": [8], "title": "PrimitivesExplained wiki page is out-of-date"}, "1751": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1751) created by **cpovirk@google.com** on 2014-05-12 at 06:30 PM_\n\n---\n\nI saw this failure once at internal CL 66812931 (test ID 6c02838a-8b9d-4ff3-ab06-89ecb4a8f01b -- this is a non-mint client, but the only change (to RateLimiterTest) ought to have affected only another test suite). For all I know, there's some bug in the JVM or java.util.concurrent, but I could believe that there's a race in ListenerCallQueue or another Guava class that we missed.\n\njunit.framework.AssertionFailedError\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.Assert.fail(Assert.java:48)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.Assert.assertTrue(Assert.java:20)\n&nbsp;&nbsp;&nbsp;&nbsp;at junit.framework.Assert.assertTrue(Assert.java:27)\n&nbsp;&nbsp;&nbsp;&nbsp;at com.google.common.util.concurrent.AbstractScheduledServiceTest.testDefaultExecutorIsShutdownWhenServiceFails(AbstractScheduledServiceTest.java:217)\n", "label": [1], "title": "Impossible-looking race in AbstractScheduledServiceTest.testDefaultExecutorIsShutdownWhenServiceFails"}, "2004": {"body": "https://code.google.com/p/guava-libraries/wiki/CachesExplained#Interruption\n\n\"(wrapped in an ExceptionException)\"\nshould probably be\n\"(wrapped in an ExecutionException)\"\n", "label": [7], "title": "Documentation Error in CachesExplained, section \"Interruption\""}, "1824": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1824) created by **jens.nehlmeier** on 2014-08-01 at 06:18 PM_\n\n---\n\nThe summary pretty much sums it up. \n\nActually Booleans does only use BitSet in JavaDoc @\ufefflink references and not in code, however the import is enough for GWT to fail during compilation. Using full qualified @\ufefflink references should probably fix the problem.\n\n[java]    [ERROR] Errors in 'jar:file:/..../guava-gwt.jar!/com/google/common/primitives/Booleans.java'\n[java]    [ERROR] Line 29: The import java.util.BitSet cannot be resolved\n[java]    [ERROR] Aborting compile due to errors in some input files\n", "label": [1], "title": "Booleans is marked as @GwtCompatible but imports java.util.BitSet which is not emulated by GWT"}, "1744": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1744) created by **justatheory** on 2014-05-05 at 10:49 PM_\n\n---\n\nI recently ported BloomFilter.java to Objective-C, where the default encoding is UTF-8. Took quite a while before I figured out why I got different false positives than the Java version did! This patch adds a test that specifically tests for false positives using a string funnel with Charsets.UTF_8, mostly to ensure that we do, in fact get the same results.\n", "label": [5], "title": "PATCH: Test BloomFilter for Known False Positives with UTF-8 Encoding"}, "2101": {"body": "When the cache is being cleared, either through `Cache.invalidateAll()` or `asMap().clear()`, the removal cause is always `EXPLICIT`. However the map may contain expired or GC'd entries that would be removed on the next maintenance cycle. The removal cause should indicate the actual state of the entry, not merely the action that triggered the eventual removal.\n\nDue to weak and soft references the key or value may be null. A listener should only expect to receive a null key or value if the cause is `COLLECTED`, as indicated by `RemovalNotification`:\n\n> The key and/or value may be null if they were already garbage collected.\n\nTherefore a listener might decide to inspect the properties without a null guard, leading to an NPE.\n\n``` java\n@Test\npublic void clear_expireAfterAccess() {\n  FakeTicker ticker = new FakeTicker();\n  RemovalListener<Integer, Integer> listener = Mockito.mock(RemovalListener.class);\n  ArgumentCaptor<RemovalNotification<Integer, Integer>> captor =\n      ArgumentCaptor.forClass(RemovalNotification.class);\n  Cache<Integer, Integer> cache = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.MINUTES)\n      .removalListener(listener)\n      .ticker(ticker)\n      .build();\n  cache.put(1, 1);\n  ticker.advance(10, TimeUnit.MINUTES);\n  cache.invalidateAll();\n\n  verify(listener).onRemoval(captor.capture());\n  assertThat(captor.getValue().getCause(), is(RemovalCause.EXPIRED));\n}\n```\n\nThe fix is to change `LocalCache$Segment#clear()` to inspect the key, value, and expiration status when determining the cause. \n\nUnfortunately this race condition is more widespread due to `enqueueNotification` not being tolerant to a garbage collection nulling out the key/value. Prior to constructing the notification, the method must take a strong reference to the key and value, check if either was collected, and if so publish a `COLLECTED` instead of the caller's cause.\n", "label": [1], "title": "Wrong RemovalCause published on cache.invaldateAll()"}, "1765": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1765) created by **d...@iq80.com** on 2014-05-24 at 07:50 PM_\n\n---\n\nExample in Discrete Domains section has:\n\n&nbsp;&nbsp;ContigousSet.create\n\nBut should be\n\n&nbsp;&nbsp;ContiguousSet.create\n", "label": [7], "title": "Typo on RangesExplained wiki page"}, "2219": {"body": "https://github.com/google/guava/wiki/PreconditionsExplained\n\nThe first link seems broken:\n([How to do this easily in Eclipse.](http://piotrjagielski.com/blog/working-with-static-imports-in-eclipse/)) \n", "label": [2], "title": "Preconditions links is dead"}, "1926": {"body": "Now that the JDK8 compilation issue is fixed, one test appears to be failing (at least under Oracle JDK 1.8.0_05). The failing test is `ClassPathTest.testGetResources`. It's throwing a NPE at the `assertNotNull(resource.url())` line for two particular resources, because the `ClassLoader` for those resources returns `null` when asked for the resource's URL.\n\nThe resources in question are `source_tips` and `version.rc`, both loaded by `sun.misc.Launcher$ExtClassLoader`, which loads from jars in `jre/lib/ext/`.\n\n`source_tips` appears to be a file that's in the root of multiple jars in `ext`: `sunec.jar`, `sunjce_provider.jar` and `sunpkcs11.jar`. I'm actually not clear on how (if at all) the class loader is supposed to distinguish between the multiple files with the same name that are in different jars (on second thought, I guess this is just the first or maybe last wins thing that causes issues with multiple jars defining some of the same classes on the classpath, but it doesn't seem like something that should cause the ClassLoader to just refuse to return a URL for the name).\n\n`version.rc`, on the other hand, only seems to appear in one jar: `jfxrt.jar`.\n\nThis may be some kind of bug or oddity with the `ClassLoader` implementation itself, I'm not sure. I couldn't trace down into exactly what's going on in there with a debugger.\n", "label": [1], "title": "Test failure in ClassPathTest under JDK8"}, "2104": {"body": "https://github.com/google/guava/wiki/ImmutableCollectionsExplained#why refers to https://code.google.com/p/memory-measurer/wiki/ElementCostInDataStructures (link text: analysis), which doen't exist anymore.\n\nThe old equivalent https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained#Why? also points to that same broken link.\n", "label": [1, 2], "title": "Documentation: Broken link"}}, "v20.0": {"2457": {"body": "", "label": [0], "title": "Emulate Throwables in GWT"}, "2430": {"body": "As they are [common headers](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Common_non-standard_request_fields) (at least the `X-Forwarded-Host`) it would be nice if they are defined in the class `HttpHeaders`. The `X-Forwared-Port` is used for example in [AWS](http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/x-forwarded-headers.html).\n", "label": [5], "title": "Add a constant for X-Forwarded-Host and X-Forwarded-Port to HttpHeaders"}, "1819": {"body": "_[Original issue](https://code.google.com/p/guava-libraries/issues/detail?id=1819) created by **ogregoire** on 2014-07-29 at 03:35 PM_\n\n---\n\nWhen I call the following, the test case fails (see full test case in attachment).\n\n&nbsp;&nbsp;new ClassSanityTester().testNulls(MyObject.class);\n\nI get the following error: No exception thrown for parameter at index 0 from MyObjectTest$MyObject.public boolean MyObjectTest$MyObject.equals(java.lang.Object)[null] for class MyObjectTest$MyObject\n\nClearly, this indicates that it expects a call to \"equals(Object)\" to throw a NullPointerException. That method should never throw an exception but rather return true or false. The test seems to skip this assertion and I'm surprised this hasn't been reported earlier. \n\nPlease make it so ClassSanityTester#testNulls(Class) doesn't fail when equals is behaving correctly (see the test case where testEquals(MyObject.class succeeds).\n\nOn a side note, the text returned should be adapted as it mentions three times MyObjectTest$MyObject. That's 2 too many, and it renders the whole error message nearly not understandable.\n", "label": [1], "title": "NullPointerTester should not require @Nullable on the param of an equals() override"}, "2096": {"body": "https://google.github.io/guava/releases/18.0/api/docs/package-list should be available so that we can Javadoc link to it.  I see that the file exists at `gh-pages/_releases/18.0/api/docs/package-list`, but for some reason it doesn't make it to the website.\n", "label": [8], "title": "Include package-list in browsable API docs"}, "2525": {"body": "The [snapshot Javadoc of Ordering#explicit(java.util.List)](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/Ordering.html#explicit%28java.util.List%29)  contains the sentnece:\n\n> The returned comparator throws **an ClassCastException** when it receives an input parameter that isn't among the provided values.\n\ninstead of\n\n> The returned comparator throws **a ClassCastException** when it receives an input parameter that isn't among the provided values.\n", "label": [2], "title": "Typo in the javadoc of Ordering's explicit(List<T>) method"}, "2132": {"body": "Missed several video MimeTypes in MediaType class:\n\n```\nvideo/x-flv\nvideo/3gpp\nvideo/3gpp2\n```\n\nand some audio types:\n\n```\naudio/basic\naudio/L24\naudio/aac\naudio/vorbis\naudio/x-ms-wma\naudio/x-ms-wax\naudio/vnd.rn-realaudio\naudio/vnd.wave\n```\n", "label": [5], "title": "Add video MediaTypes"}, "2228": {"body": "If I want to load a resource I have found by classpath scanning with `ClassPath`, I need to use `Resources.asByteSource(resourceInfo.url())`. This is only little code, but hard to discover because it uses a third class `Resources` which is neither related to what I have (`ResourceInfo`) nor what I want (`ByteSource`). I also need to remember that I should go via the URL and that I cannot use `ResourceInfo.getResourceName()`.\n\nA direct method to get a `ByteSource` from a `ResourceInfo` would make this easier. Alternatively, this should be documented at least.\n", "label": [5], "title": "Add ClassPath.ResourceInfo.asByteSource()"}, "2522": {"body": "The snapshot API has the following typos:\n\n`com.google.common.math.StatsAccumulator`: `public final double populationVariance()` and\n`com.google.common.math.Stats`: `public double populationVariance()` say\n\n> This is guaranteed to return zero if **the the** dataset contains only exactly one finite value.\n\nInstead of\n\n> This is guaranteed to return zero if **the** dataset contains only exactly one finite value.\n", "label": [2], "title": "Typo in the javadoc of StatsAccumulator's and Stats's populationVariance() method"}, "1942": {"body": "Please see https://github.com/google/guava/blob/master/guava/src/com/google/common/primitives/Booleans.java#L235.\n\nIsn't Java 6 available?\nIf it is, should that comment be removed?\nShould the method be removed? (It is private and only used in a single place).\n", "label": [7], "title": "Line comment on requiring Java 6"}, "2349": {"body": "The [javadoc for TestContainerGenerator.order](https://github.com/google/guava/blob/master/guava-testlib/src/com/google/common/collect/testing/TestContainerGenerator.java#L66) states:\n\n> This method runs only when CollectionFeature#KNOWN_ORDER is specified when creating the test suite. It should never run when testing containers such as HashSet, which have a non-deterministic iteration order.\n\nHowever, 74 tests (out of 450) fail with the code below which (as described by the documentation) expects TestContainerGenerator.order not to be called and throws an UnsupportedOperationException for it:\n\n``` java\npublic final class JavaUtilCollectionsTests {\n  public static Test suite() {\n    TestSuite suite = new TestSuite(\"HashSet\");\n    suite.addTest(SetTestSuiteBuilder.<Integer>using(new TestSetGenerator<Integer>() {\n      @Override\n      public SampleElements<Integer> samples() {\n        return new SampleElements<Integer>(-7, 0, Integer.MIN_VALUE, 42, Integer.MAX_VALUE);\n      }\n\n      @Override\n      public Integer[] createArray(int length) {\n        return new Integer[length];\n      }\n\n      @Override\n      public Iterable<Integer> order(List<Integer> insertionOrder) {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public Set<Integer> create(Object... elements) {\n        List<Integer> values =\n            Arrays.stream(elements).map(o -> (Integer) o).collect(Collectors.toList());\n        return new HashSet<>(values);\n      }\n    }).named(\"HashSet\")\n        .withFeatures(CollectionSize.ANY, CollectionFeature.GENERAL_PURPOSE,\n            CollectionFeature.ALLOWS_NULL_VALUES, CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS)\n        .createTestSuite());\n    return suite;\n  }\n}\n```\n\nThe expected result would be for all the tests to pass.\n", "label": [1], "title": "Test suites incorrectly call TestSetGenerator.order"}, "1961": {"body": "On the theory that most things should be a `TrustedFuture` :)\n\nWe would probably skip `immediateFuture` because there's little to optimize there: We'd basically be replacing one field access with another.\n\nBut why not do `immediateFuture` anyway? `TrustedFuture` is a bit larger than `immediateFuture`, since it stores listeners and waiters (\"would increase the size of the immediateFuture implementations by a least 8 bytes a piece (+ padding),\" per Luke).\n\nWe care about that less with failed and cancelled futures, since they have large `Exception` objects associated with them already.\n\nAlternatively, we could special-case `ImmediateFuture` in the same way that we special-case `TrustedFuture` -- either with a separate `instanceof` branch or with an interface. Then we could do all the whole `immediate*Future` family with no cost... unless the branch/interface has a performance cost.\n", "label": [0], "title": "Make immediateFailedFuture and immediateCancelledFuture return a TrustedFuture?"}, "2509": {"body": "**Failure cases:**\n_1) Positive_\nValues rounded incorrectly: `0.99999999999999984` to `0.99999999999999994`\nRounding modes: CEILING or UP\nExpected: `1`\nActual: `2`\n\n_2) Negative_\nValues rounded incorrectly:`-0.99999999999999984` to `-0.99999999999999994`\nRounding modes: FLOOR or UP\nExpected: `-1`\nActual: `-2`\n\n**Remarks:**\nThe reason is that values between 0 and 1 have higher fraction precision than values between 1 and 2. The code adds 1.0 to the value x, and double arithmetic uses HALF_EVEN rounding by default. This leads to unexpected results for edge cases when HALF_EVEN triggers rounding UP to 2.\n\n**Proposed FIX:**\nThe FIX is to cast the double value `x` to a long before the addition of `1.0`:\nCurrent:`x + 1.0`\nFixed: `(long)x + 1.0`\n\n**Pull Request:**\nSee pull request [#2511](https://github.com/google/guava/pull/2511)\n", "label": [1], "title": "DoubleMath incorrectly rounds 0.99999999999999994 to 2 with rounding mode UP or CEILING"}, "2507": {"body": "Specifically [here](https://github.com/google/guava/wiki/ListenableFutureExplained#application).\n\nFor the method that accepts an `AsyncFunction`, it should be renamed from `transform` to `transformAsync` instead. I would contribute but I'm not sure how to access the wiki as an intern.\n\n:smiley: \n", "label": [2], "title": "Small update for Listenable Futures Explained docs"}, "2365": {"body": "Not a high priority. I just feel a little bad that users there would get something like \"com.google.common.base.Stopwatch@0xdeadbeef\".\n", "label": [1], "title": "Implement Stopwatch.toString() under GWT"}, "2240": {"body": "[UseGuavaInYourBuild](https://github.com/google/guava/wiki/UseGuavaInYourBuild) is out-of-date as it refers to old versions of guava, specifically 12.0 and 10.0.1 as opposed to the latest release 18.0.\n\nAs the latest releases are documented in the [README](https://github.com/google/guava/blob/master/README.md) file this wiki-page does not really serve a purpose, and can probably be removed.\n", "label": [2], "title": "UseGuavaInYourBuild wiki-page out of date"}, "2463": {"body": "We already do in `AbstractFuture`.\n", "label": [1], "title": "Work around Samsung 5.0.x Atomic*FieldUpdater bug in AggregateFutureState and InterruptibleTask"}, "2124": {"body": "The next GWT release will probably have emulations for `Charset` built in. Internal CL 99622756 will be removing our custom emulations, but I think we can go further, changing calls to methods like `getBytes` to use the `Charset` versions.\n\nThis assumes that we require the new GWT version for the post-19 Guava release. This was not the plan on #1999 but might be reasonable. Otherwise, we need a workaround. We'd need to figure out if our emulations would interfere with the GWT versions for users who _are_ using the new GWT.\n", "label": [0], "title": "Use String.getBytes(Charset) and other Charset utilities once GWT supports them"}, "2555": {"body": "As detailed in issue #2554 there was a bug in com.google.common.collect.testing.Helpers#isEmpty when passed an Iterable that is not a Collection.\n\nAdded a test that fails before the patch, succeeds after.\n", "label": [1], "title": "Fix Issue #2554, Helpers#isEmpty"}, "1999": {"body": "- @lowasser internal CL 88242480 wants to use `SimpleImmutableEntry`.\n- Internal CL 86210805 can be rolled back to use `AssertionError(String, Throwable)`.\n- @kak internal CL 83767705 wanted to use `Arrays.copyOf`.\n- My internal CL 59647656 wants to remove `AbstractIteratorTester` workarounds for bugs in `java.util` classes fixed in new releases of GWT.\n\nGWT 2.7.0 was released in November. But note that we had bug reports from users of GWT 2.5.1 as late as October 2014, 9 months after the release of 2.6.0. We should get some idea of how quickly external users update the version of GWT they use.\n", "label": [7], "title": "Release a Guava that supports+requires GWT 2.8.0 upon GWT release"}, "2363": {"body": "So it would seem that most of the Cassandra java drivers out there are using guava CacheBuilder.  I have tried Astayanx and at runtime I get:\n\n```\nCaused by: java.lang.NoSuchMethodError: com.google.common.cache.CacheBuilder.build()Lcom/google/common/cache/Cache;\n    at com.netflix.astyanax.thrift.ThriftKeyspaceImpl.<init>(ThriftKeyspaceImpl.java:116)\n    at com.netflix.astyanax.thrift.ThriftFamilyFactory.createKeyspace(ThriftFamilyFactory.java:41)\n    at com.netflix.astyanax.AstyanaxContext$Builder.buildKeyspace(AstyanaxContext.java:146)\n    at com.disney.tss.auth.backend.persistence.CassandraClient.<init>(CassandraClient.java:28)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)\n    at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:147)\n    ... 25 more\n```\n\nI have tried the datastax driver and get a similar error in the same class CacheBuilder:\n\n```\nCaused by: java.lang.NoSuchMethodError: com.google.common.cache.CacheBuilder.maximumWeight(J)Lcom/google/common/cache/CacheBuilder;\n    at com.datastax.driver.core.CodecRegistry.defaultCacheBuilder(CodecRegistry.java:305)\n    at com.datastax.driver.core.CodecRegistry.<init>(CodecRegistry.java:297)\n    at com.datastax.driver.core.CodecRegistry.<clinit>(CodecRegistry.java:172)\n    at com.datastax.driver.core.Configuration$Builder.build(Configuration.java:276)\n    at com.datastax.driver.core.Cluster$Builder.getConfiguration(Cluster.java:1221)\n    at com.datastax.driver.core.Cluster.<init>(Cluster.java:116)\n    at com.datastax.driver.core.Cluster.buildFrom(Cluster.java:181)\n    at com.datastax.driver.core.Cluster$Builder.build(Cluster.java:1238)\n    at com.disney.tss.auth.backend.persistence.CassandraClient.<init>(CassandraClient.java:31)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)\n    at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:147)\n    ... 25 more\n```\n\nWhen I check my maven includes and look for the \"missing\" methods, they are there.  But evidently google is doing something weird with class loaders or something.  More than one product that depends on this class fails inexplicably.\n", "label": [7], "title": "VERY strange runtime errors with com.google.common.cache.CacheBuilder"}, "2410": {"body": "The second sentence of the JavaDoc for `CharMatcher.matchesNoneOf` is not correct: \"The default implementation iterates over the sequence, invoking matches(char) for each character, until this returns false or the end is reached.\"  This should be \"until this returns true or the end is reached\".  It appears the incorrect line may have been copied from `CharMatcher.matchesAllOf`\n\nSimilarly, the \"returns\" section currently says: \"true if this matcher matches every character in the sequence, including when the sequence is empty\" (same as `matchesAllOf`). It should say something like \"true if this matches matches no character in the sequence, including when the sequence is empty\".\n", "label": [2], "title": "CharMatcher.matchesNoneOf JavaDoc is incorrect"}, "2415": {"body": "In the last line under the heading : **Tuples for n>=2**, there is a link to AutoValue, which points to : \nhttps://docs.google.com/document/d/1THRUCIzIPRqFSHb67pHV8KMbo55HphSXqlQcIx9oUiI/edit#heading=h.7ojt6jg2vdwc\n\nwhich leads the user to a google doc asking to update whatever url lead them there to https://github.com/google/auto/tree/master/value\n", "label": [2], "title": "Wrong url for AutoValue on the IdeaGraveyard wiki page"}, "2379": {"body": "Previously we at least showed [the `@GwtIncompatible` reason in the Javadoc](http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html#catching%28com.google.common.util.concurrent.ListenableFuture, java.lang.Class, com.google.common.base.Function%29). But this will be going away in 20.0 with the removal of `@GwtIncompatible` reasons.\n\nFurthermore, even _with_ the reason, I saw multiple people who were confused.\n\nThere are various directions we could go here, including removing `@GwtIncompatible` (by adding a manual emulation to `Futures.java` ). But I'm wondering if, whichever direction we go, we pretty much need to start the Javadoc with **This is available under GWT, but you need to pass `Throwable.class` specifically.**\n", "label": [2], "title": "Better documentation of Futures.catching GWT availability"}, "2258": {"body": "Mutable operations on `ImmutableRangeSet` (`add`, `remove`, `clear`, etc) should be marked as unsupported and deprecated and javadoc modified appropriately, in a similar way to mutable operations on the other immutable collections.\n", "label": [2], "title": "Mutable operations on ImmutableRangeSet should be deprecated"}, "2418": {"body": "See a unit test demonstrating the issue here: https://github.com/gpanther/fastutil-guava-tests/blob/master/src/test/java/net/greypanther/guava/tests/tests/CustomToStringTest.java\n\nIt shows a HashMap subclass which overrides toString and as a result fails tests, even if CollectionFeature.NON_STANDARD_TOSTRING passed to MapTestSuiteBuilder.\n\nI believe that methods like https://github.com/google/guava/blob/2cd4d629a2b6f1a462643b248e0972f44c5133b7/guava-testlib/src/com/google/common/collect/testing/testers/MapToStringTester.java#L45 should be marked with `@CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)`.\n", "label": [1], "title": "Map tests assert on .toString even when CollectionFeature.NON_STANDARD_TOSTRING is specified"}, "2376": {"body": "`Range.toString()` returns `U+2025` which is not supported by the default terminal under Windows, and most IDEs unless you explicitly change the font. If you read through https://issues.apache.org/jira/browse/SUREFIRE-1220 you will understand the insane hoops that developers have to jump through to get this to work.\n\nConsider replacing this unicode character by `..` or `-` or `,` ASCII characters.\n", "label": [1], "title": "Consider replacing unicode character in Range.toString()"}, "2254": {"body": "Hey!\nI found that the following test will fail with a TimeoutException (the Future hangs indefinitely): \n\n``` java\n  static final int REPS = 10000;\n  @Test\n  public void hangs() throws InterruptedException, TimeoutException {\n    SettableFuture<Integer> settableFuture = SettableFuture.create();\n    ListenableFuture<Integer> chained = settableFuture;\n    for (int i = 0; i < REPS; ++i) {\n      chained = Futures.transform(chained, Functions.<Integer>identity());\n    }\n    settableFuture.set(0);\n\n    Futures.get(chained, 10, TimeUnit.SECONDS, TimeoutException.class);\n  }\n```\n\nBut if I change REPS to be something smaller, like 1000 (this will depend on the size of the stack) then the test passes. I think the root cause is is that the exception can't 'surface' to the final `chained` Future due to a StackOverflowError caused by repeated DirectExecutor.execute application.\n\nMy logging config may be screwed up, but I didn't see a log for this or anything, which made finding this a bit of a chore. I checked that this happens with Guava 18 and 19. Apologies if this is a KP or already filed (I tried searching Issues, but nothing related pops up).\n", "label": [1], "title": "Nesting Futures.transform() eats StackOverflowError and causes the Future to hang forever"}, "2372": {"body": "The code site wiki had a hidden comment just before the CharMatcher section in StringsExplained, and when the docs were migrated to github it got un-commented. Also, there's a missing line that's messing up the formatting of CharMatcher: https://github.com/google/guava/wiki/StringsExplained#charmatcher\n\nRe-commenting the comment and adding a blank line before the table at the beginning of CharMatcher fixes the formatting.\n\nApparently pull requests against wikis aren't a thing, so here's the fix:\n\n```\ndiff --git a/StringsExplained.md b/StringsExplained.md\nindex beaf585..225ed92 100644\n--- a/StringsExplained.md\n+++ b/StringsExplained.md\n@@ -60,16 +60,19 @@ If you wish to get a `List`, just use `Lists.newArrayList(splitter.split(string)\n\n **Warning:** splitter instances are always immutable.  The splitter configuration methods will always return a new `Splitter`, which you must use to get the desired semantics.  This makes any `Splitter` thread safe, and usable as a `static final` constant.\n\n+<!--\n <a href='Hidden comment:\n = Escaper =\n Escaping strings correctly -- converting them into a format safe for inclusion in e.g. an XML document or a Java source file -- can be a tricky business, and critical for security reasons.  Guava provides a flexible API for escaping text, and a number of built-in escapers, in the com.google.common.escape package.\n\n All escapers in Guava extend the [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/escape/Escaper.html Escaper] abstract class, and support the method String escape(String).  Built-in Escaper instances can be found in several classes, depending on your needs: [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/html/HtmlEscapers.html HtmlEscapers], [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/xml/XmlEscapers.html XmlEscapers], [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/escape/SourceCodeEscapers.html SourceCodeEscapers], [http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/net/UriEscapers.html UriEscapers], or you can build your own with [http://google.github.io/guava/releases/snapshot/api/docs/ an Escapers.Builder].  To inspect an Escaper, you can use Escapers.computeReplacement to find the replacement string for a given character.\n '></a>\n+-->\n\n # CharMatcher\n In olden times, our `StringUtil` class grew unchecked, and had\n many methods like these:\n+\n | `allAscii` | `collapse` | `collapseControlChars` | `collapseWhitespace` | `indexOfChars` |\n |:-----------|:-----------|:-----------------------|:---------------------|:---------------|\n | `lastIndexNotOf` | `numSharedChars` | `removeChars`          | `removeCrLf`         | `replaceChars` |\n```\n", "label": [2], "title": "CharMatcher docs are mangled"}}}